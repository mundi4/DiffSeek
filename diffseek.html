<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiffSeek</title>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	font-size: 16px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

#topbar {
	grid-column: span 2;
	display: flex;
	align-items: center;
	padding: 5px 10px;
	background: #444;
	color: white;
	align-items: center;
	justify-content: space-between;
}

.buttons {
	display: flex;
	gap: 10px;
	margin-left: auto;
}

button.toggle {
	background: none;
	border: 2px solid transparent;
	cursor: pointer;
	padding: 2px 4px;
	transition: all 0.2s ease-in-out;
	opacity: 0.3;
	font-size: 14px;
	outline: none;
}

button.toggle[aria-pressed="true"] {
	opacity: 1;
	transform: scale(1.2);
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr 250px;
	height: 100vh;
	overflow: hidden;
	gap: 0 8px;
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: 20px;
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: "ë‹ì›€ì²´", monospace;
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	white-space: pre-wrap;
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background-color: hsl(0 0% 80% / 0.3);
	z-index: -1;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: rgba(0, 0, 0, 0.1);
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	pointer-events: auto;
	position: static;
	color: inherit;
	background-color: transparent;
	cursor: text;
	caret-color: white; /* ì»¤ì„œ ìœ ì§€ */
	/* cursor: default; */
}

.edit .mirror {
	height: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
	color: inherit;
}
mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-blockìœ¼ë¡œ ì•ˆí•´ë‘ë©´ ë†’ì´ 1pxì´ ëª¨ìë¥´ê²Œ ëœë‹¤. ë¬»ì§€ë§ˆ... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	right: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
ê³µê°„ì„ ì „í˜€ ì°¨ì§€í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ visualì´ ìˆì–´ì•¼í•¨
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

/*
ì¤„ë§ì¶¤ ìš© marker element
*/

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror {
	color: #fff;
	background-color: #000;
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
ì¤„(div)ì•ˆì— ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë„£ì–´ì„œ ê°•ì œë¡œ ì¤„ë°”ê¿ˆ íš¨ê³¼ë¥¼ ì£¼ì—ˆì„ ë•Œ
diffê°€ ì—†ëŠ” ê°€ìƒì˜ ì¤„ë„ diffê°€ ìˆëŠ” ì¤„ì²˜ëŸ¼ í‘œì‹œë˜ëŠ” ë¬¸ì œ.
ë‹¹ì—°í•œê±°ê¸´ í•œë°... ì‰¬ìš´ í•´ê²°ë°©ë²•ì´ ë– ì˜¤ë¥´ì§ˆ ì•ŠëŠ”ë‹¤!
ê³ ë¯¼í•´ ë³¼ í•„ìš”ê°€ ì™•ì™• ìˆë‹¤.
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

.aligned #main {
	/* overflow-y: scroll; */
}

.aligned .editor-wrapper {
	/* overflow: visible;
	padding-right: 7px; */
}

.aligned .editor-wrapper:last-child {
	/* margin-left: 8px; */
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "ğŸ‘¬";
	font-size: 128px;
	font-weight: bold;
	font-family: 'Consolas', Courier, monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "ğŸ’­";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: "Consolas", "Courier New", monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "â—€ï¸"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "â–¶ï¸" !important; */
}

.edit hr {
	height: 0 !important;
}

/* ì˜ë¯¸ì—†ë‹¤
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

</style>
<script id='constants.js'>
// DIFF ìƒ‰(HUE). 0(ë¹¨)ì€ DIFF ë°°ê²½ìƒ‰ìœ¼ë¡œ ì“°ì´ë‹ˆ íŒ¨ìŠ¤
// ì™„ì „í•œ ìƒ‰ìƒ ì½”ë“œë³´ë‹¤ HUEë§Œ ì‚¬ìš©í•˜ë©´ ìš©ë„ì— ë”°ë¼ ìƒ‰ì„ ì¡°ì ˆí•˜ê¸° ì‰¬ì›€.
// ì¸ì ‘í•œ ìƒ‰ìƒê³¼ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šë„ë¡ ì•„ì£¼ CAREFULí•˜ê²Œ ê³ ë¥¸ ìˆœì„œ. ê³¼í•™ì´ë‹¤.
const DIFF_COLOR_HUES = [
	30, // ì£¼í™©?
	180, // cyan
	300, // í•‘í¬?
	120, // ì´ˆë¡
	240, // íŒŒë‘
	60, // ë…¸ë‘
	270, // ë³´ë¼?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;

const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;

// ì–´ì°¨í”¼ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬ë˜ê³  ê¸°ì¡´ ì‘ì—…ì´ ì·¨ì†Œì‹œí‚¨ í›„ì— ì‹œì‘ë˜ë‹ˆ ë„ˆë¬´ í¬ê²Œ ì¡ì„ í•„ìš”ëŠ” ì—†ì„ ë“¯
const COMPUTE_DEBOUNCE_TIME = 100; // ms

// ë¬¸ì¥ë¶€í˜¸ë‚˜ íŠ¹ìˆ˜ë¬¸ìë¥¼ ì •ê·œí™” í•˜ê¸° ìœ„í•´ì„œ...
// ë”°ì˜´í‘œ, ì¤‘ê°„ì  ë“±ë“±ë“± ë¬¸ìì½”ë“œëŠ” ë‹¤ë¥´ì§€ë§Œ ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼ ë  ë¬¸ìë“¤ì´ ë§ìŒ.
// length===1ì¸ ë¬¸ìëŠ” ê·¸ëƒ¥ ë¬¸ì
// ìˆ«ìëŠ” charCode
// &ë¡œ ì‹œì‘í•˜ë©´ html ì—”í‹°í‹°
// TODO: ê°ì¢… í™”ì‚´í‘œ íŠ¹ìˆ˜ë¬¸ìë“¤...
const NORMALIZE_CHARS = [
	['"', "â€œ", "â€"],
	["'", "â€˜", "â€™"],
	["-", "â€“", "â€”"],
	[".", "â€¤"],
	["â‹…", "Â·", "â€¢"], // &middot;ê³¼ &bullet;(&bull;)ì€ ë‹¤ë¥¸ ê±¸ë¡œ ì—¬ê²¨ì•¼í•˜ì§€ ì•Šì„ê¹Œ? middotëŒ€ì‹  bulletì„ ì“°ë©´ ì ì´ ë„ˆë¬´ ì™•ì ì´ë¼ ë³´ê¸° í‰í•œë°...
	["â€¦", "â‹¯"],
	["(", "ï¼ˆ"], // ì´ëŸ° ê±¸ êµ³ì´ íŠ¹ìˆ˜ë¬¸ìë¡œ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì´ ìˆë‹¤ê³ ?? ë¯¿ê¸° í˜ë“¤ì§€ë§Œ ìˆë”ë¼...
	[")", "ï¼‰"],
	["[", "ï¼»"],
	["]", "ï¼½"],
	["{", "ï½›"],
	["}", "ï½"],
	["<", "ï¼œ"],
	[">", "ï¼"],
	["-", "ï¼"], // ì™œ êµ³ì´... ì´ëŸ° ë¬¸ìë¥¼...? ìˆ˜ì‹í¸ì§‘ê¸° ê°™ì€ ê²ƒì—ì„œ ì´ëŸ° ë¬¸ìë¥¼ ë±‰ì–´ë‚´ëŠ” ê±´ê°€...?
	["=", "ï¼"],
	["+", "ï¼‹"],
	["*", "ï¼Š", "âœ±", "x"], // xì™€ *ì„ ê°™ì€ ë¬¸ìë¡œ ì·¨ê¸‰í•˜ëŠ” ê±´ ì¡°ê¸ˆ ìœ„í—˜í•˜ì§€ë§Œ ê°™ì€ ìœ„ì¹˜ì— ì´ ë¬¸ìê°€ ê°ê° ì‚¬ìš©ëœë‹¤ë©´ ê³±ì…ˆ ê¸°í˜¸ë¡œ ì‚¬ìš©í•˜ë ¤ëŠ” ì˜ë„ëŠ” ë»”í•˜ì§€ ì•Šì€ê°€?
	["/", "ï¼", "Ã·"], // ë§ˆì°¬ê°€ì§€
	["\\", "ï¼¼", "â‚©"], // ì—­ì‹œ ë§ˆì°¬ê°€ì§€. ê³ ì •í­ì´ ì•„ë‹Œ ëŒ€ë¶€ë¶„ì˜ í•œê¸€ í°íŠ¸ì—ì„œëŠ” ì›í™” ë§ˆí¬ë¡œ í‘œì‹œë˜ê³  ì•„ë§ˆ ë¬¸ì„œì—ì„œë„ ê·¸ ì˜ë„ë¡œ ì‚¬ìš©ëì„ ê²ƒì„!
	["&", "ï¼†"],
	["#", "ï¼ƒ"],
	["@", "ï¼ "],
	["$", "ï¼„"],
	["%", "ï¼…"],
	["^", "ï¼¾"],
	["~", "ï½"],
	["`", "ï½€"],
	["|", "ï½œ"],
];

const PROCESSING_MESSAGES = [
	"í•œë•€í•œë•€ ë¹„êµ ì¤‘...",
	"ì¸ë‚´ì‹¬ í…ŒìŠ¤íŠ¸ ì¤‘...",
	"ìƒê° ì¤‘...",
	"ì¬ë¶€íŒ… ì¤€ë¹„ ì¤‘...",
	"ë¬´í•œ ë£¨í”„ ì¤‘...",
	"ë¨¸ë¦¬ ê¸ëŠ” ì¤‘...",
	"DIFFSEEKING...",
	"COME ON, TARS!",
	"3... 2... 1...",
	"99... 98... 97...",
	"í‡´ê·¼ ì¤€ë¹„ ì¤‘...",
];

</script>
<script id='textrun.js'>
"use strict";

function getTextRuns(textKey, text, diffs, anchors) {
	let pos = 0;
	let textLen = text.length;
	let nextDiffPos = null;
	let nextDiffEndPos = null;
	let nextDiff = null;
	let nextAnchorPos = null;
	let nextAnchor = null;
	let nextNewLinePos = null;
	let nextNewLineIsEndOfString = false;
	let diffIndex = -1;
	let anchorIndex = -1;
	const textruns = [];

	// let counter = 0;
	// pos < textLen ì¡°ê±´ì„ ì“°ë©´ textì˜ ëì— ìœ„ì¹˜í•œ ì´ë²¤íŠ¸ê°€ ë¬´ì‹œë  ìˆ˜ ìˆìŒ.
	while (true) {
		// if (counter++ > 100000) {
		// 	console.error("Infinite loop detected", {
		// 		textruns,
		// 		pos: pos,
		// 		textLen: textLen,
		// 		nextDiffPos: nextDiffPos,
		// 		nextDiffEndPos: nextDiffEndPos,
		// 		nextAnchorPos: nextAnchorPos,
		// 		nextNewLinePos: nextNewLinePos,
		// 		diffIndex: diffIndex,
		// 		anchorIndex: anchorIndex,
		// 		nextDiff: nextDiff,
		// 		nextAnchor: nextAnchor,
		// 		diffs,
		// 		anchors,
		// 	});
		// 	throw new Error("Infinite loop detected");
		// }
		let nextEventPos = textLen;

		if (nextAnchorPos === null) {
			anchorIndex++;
			if (anchorIndex < anchors.length) {
				nextAnchor = anchors[anchorIndex];
				nextAnchorPos = nextAnchor[textKey];
				if (nextAnchorPos < pos) {
					// skipped anchor. this should not happen.
					console.warn("Skipped anchor", { anchor: nextAnchor, anchorIndex: anchorIndex, pos: pos, anchorPos: nextAnchorPos });
					nextAnchorPos = nextAnchor = null;
					continue;
				}
			} else {
				nextAnchorPos = Number.MAX_SAFE_INTEGER;
			}
		}
		if (nextAnchorPos < nextEventPos) {
			nextEventPos = nextAnchorPos;
		}

		if (nextDiffEndPos === null) {
			diffIndex++;
			if (diffIndex < diffs.length) {
				nextDiff = diffs[diffIndex][textKey];
				nextDiffPos = nextDiff.pos;
				nextDiffEndPos = nextDiff.pos + nextDiff.len;
				if (nextDiffPos < pos) {
					console.warn("Skipped diff", { diff: nextDiff, diffIndex: diffIndex, pos: pos, diffPos: nextDiffPos });
					nextDiffPos = nextDiffEndPos = nextDiff = null;
				}
			} else {
				nextDiffPos = Number.MAX_SAFE_INTEGER;
				nextDiffEndPos = Number.MAX_SAFE_INTEGER;
			}
		}

		if (nextDiffPos < nextEventPos) {
			nextEventPos = nextDiffPos;
		} else if (nextDiffEndPos < nextEventPos) {
			nextEventPos = nextDiffEndPos;
		}

		if (nextNewLinePos === null) {
			nextNewLinePos = text.indexOf("\n", pos);
			if (nextNewLinePos === -1) {
				nextNewLinePos = textLen;
				nextNewLineIsEndOfString = true;
			}
		}
		if (nextNewLinePos < nextEventPos) {
			nextEventPos = nextNewLinePos;
		}

		if (pos < nextEventPos) {
			// chars
			textruns.push({
				type: "CHARS",
				pos: pos,
				len: nextEventPos - pos,
			});
			pos = nextEventPos;
		}

		// ì´ë²¤íŠ¸ ì²˜ë¦¬ í›„ ë°˜ë“œì‹œ continueë¡œ ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ë„˜ì–´ê°€ì•¼ í•¨. (í˜¹ì€ else if else if else if...)
		if (nextEventPos === nextAnchorPos && nextAnchor.type === "before") {
			textruns.push({
				type: "ANCHOR",
				pos: nextAnchorPos,
				len: 0,
				diffIndex: diffIndex,
				anchorIndex: anchorIndex,
			});
			nextAnchorPos = nextAnchor = null;
			continue;
		}

		if (nextEventPos === nextDiffPos) {
			textruns.push({
				type: "DIFF",
				pos: nextDiffPos,
				len: 0,
				diffIndex: diffIndex,
			});
			nextDiffPos = Number.MAX_SAFE_INTEGER;
			continue;
		}

		if (nextEventPos === nextDiffEndPos) {
			// diff end
			textruns.push({
				type: "DIFF_END",
				pos: nextDiffEndPos,
				len: 0,
				diffIndex: diffIndex,
			});
			nextDiffPos = nextDiffEndPos = nextDiff = null;
			continue;
		}

		if (nextEventPos === nextAnchorPos && nextAnchor.type === "after") {
			textruns.push({
				type: "ANCHOR",
				pos: nextAnchorPos,
				len: 0,
				diffIndex: diffIndex,
				anchorIndex: anchorIndex,
			});
			nextAnchorPos = null;
			continue;
		}

		if (nextEventPos === nextNewLinePos) {
			if (nextNewLineIsEndOfString) {
				break;
			} else {
				textruns.push({
					type: "LINEBREAK",
					pos: nextNewLinePos,
					len: 1,
				});
				pos = nextEventPos + 1;
				nextNewLinePos = null;
				continue;
			}
		}
	}
    
    textruns.push({
        type: "END_OF_STRING",
        pos: textLen,
        len: 0,
    });

	return textruns;
}

</script>
<script id='editor.js'>
"use strict";

function createEditor(container, name, callbacks) {
	const { onDiffVisibilityChanged, onTextChanged, onMirrorUpdated } = callbacks;
	const _lineElements = [];
	const _diffElements = [];
	const _anchorElements = [];
	const _visibleAnchors = new Set();
	const _visibleDiffIndices = new Set();
	let _text = "";
	let _savedCaret = null;
	let _observingAnchors = false;
	let _editMode = false;

	const wrapper = document.createElement("div");
	wrapper.id = name + "EditorWrapper";
	wrapper.classList.add("editor-wrapper");

	const mirror = document.createElement("div");
	mirror.id = name + "Mirror";
	mirror.classList.add("mirror");
	mirror.spellcheck = false;


	const editor = document.createElement("div");
 	editor.id = name + "Editor";
	editor.classList.add("editor");
	editor.contentEditable = "plaintext-only";
	editor.spellcheck = false;
 
	editor.appendChild(document.createTextNode(""));

	wrapper.appendChild(mirror);
	wrapper.appendChild(editor);
	container.appendChild(wrapper);

	function updateText() {
		_text = editor.textContent;
		// let p = _text.length - 1;
		// let endsWithNewline = false;
		// while (p >= 0) {
		// 	if (!/\s/.test(_text[p])) {
		// 		break;
		// 	}
		// 	if (_text[p] === "\n") {
		// 		endsWithNewline = true;
		// 		break;
		// 	}
		// 	p--;
		// }
		// if (!endsWithNewline) {
		// }
		_text += "\n";
		onTextChanged(_text);
	}

	editor.addEventListener("input", updateText);

	const intersectionObserver = new IntersectionObserver(
		(entries) => {
			for (const entry of entries) {
				if (entry.isIntersecting) {
					if (entry.target.nodeName === ANCHOR_TAG) {
						_visibleAnchors.add(entry.target);
					} else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
						const diffIndex = Number(entry.target.dataset.diff);
						_visibleDiffIndices.add(diffIndex);
						onDiffVisibilityChanged(diffIndex, true);
					}
				} else {
					if (entry.target.nodeName === ANCHOR_TAG) {
						_visibleAnchors.delete(entry.target);
					} else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
						const diffIndex = Number(entry.target.dataset.diff);
						_visibleDiffIndices.delete(diffIndex);
						onDiffVisibilityChanged(diffIndex, false);
					}
				}
			}
		},

		{ threshold: 1, root: wrapper }
	);

	function saveCaret() {
		const sel = window.getSelection();
		if (sel.rangeCount > 0) {
			const range = sel.getRangeAt(0);
			if (editor.contains(range.commonAncestorContainer)) {
				_savedCaret = range.cloneRange();
			}
		}
	}

	function restoreCaret() {
		if (_savedCaret && editor.contains(_savedCaret.commonAncestorContainer)) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(_savedCaret);
		}
		_savedCaret = null;
	}

	function getVisibleAnchors() {
		return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
	}

	let mouseX;
	let mouseY;
	document.addEventListener("mousemove", (event) => {
		mouseX = event.clientX;
		mouseY = event.clientY;
	});

	function getNearestAnchorToCaret() {
		const selection = window.getSelection();
		if (!selection || selection.rangeCount === 0) {
			return null;
		}

		let range = selection.getRangeAt(0);
		if (!editor.contains(range.startContainer)) {
			return null;
		}

		let rect = range.getBoundingClientRect();
		let y;
		if (rect.left === 0 && rect.top === 0) {
			y = EDITOR_PADDING + TOPBAR_HEIGHT;
		} else {
			y = rect.top;
		}

		let nearestAnchor = null;
		let minDistance = Number.MAX_SAFE_INTEGER;
		for (const anchor of _visibleAnchors) {
			const rect = anchor.getBoundingClientRect();
			const distance = Math.abs(rect.top - y);
			if (distance < minDistance) {
				minDistance = distance;
				nearestAnchor = anchor;
			}
		}
		return nearestAnchor;
	}

	function getFirstVisibleLineElement() {
		const lineEls = _lineElements;
		let low = 0;
		let high = lineEls.length - 1;
		let mid;
		let lineEl = null;
		let distance = null;
		while (low <= high) {
			mid = (low + high) >>> 1;
			const thisDistance = lineEls[mid].getBoundingClientRect().top - TOPBAR_HEIGHT;
			if (thisDistance >= -LINE_HEIGHT) {
				lineEl = lineEls[mid];
				distance = thisDistance;
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return [lineEl, distance];
	}

	function scrollToDiff(diffIndex) {
		const offsetTop = _diffElements[diffIndex][0].offsetTop - wrapper.clientTop;
		wrapper.scrollTop = offsetTop - SCROLL_MARGIN;
	}

	// ë‚´ê°€ ë¨¸ë¦¬ê°€ ë‚˜ì˜ë‹¤ëŠ” ê±¸ í™•ì‹¤í•˜ê²Œ ì•Œê²Œ í•´ì£¼ëŠ” í•¨ìˆ˜
	function scrollToLine(lineNum, distance = 0) {
		const lineEl = _lineElements[lineNum - 1];
		if (lineEl) {
			const scrollTop = lineEl.offsetTop - distance;
			wrapper.scrollTop = scrollTop;
		}
	}

	// generator í•¨ìˆ˜ë¡œ ë§Œë“¤ê³  requestIdleCallbackìœ¼ë¡œ ì ì¦ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ í• ê¹Œ?
	// => ê·¸ë¦¬ ë¬´ê²ê³  ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…ì´ ì•„ë‹ˆë‹¤.
	// ì–‘ìª½ì— 3000ì¤„, ëŒ€ëµ diffê°€ 20ê°œì •ë„ ìˆëŠ” ìƒí™©ì—ì„œ 20ms ì •ë„. íšŒì‚¬ë˜¥ì»´ì—ì„œëŠ” ë” ì˜¤ë˜ ê±¸ë¦¬ê² ì§€ë§Œ
	// ê·¸ë ‡ê²Œ í° ë¬¸ì„œëŠ” ë“œë¬¼ê³  requestIdleCallback ìì²´ì˜ ì˜¤ë²„í—¤ë“œë„ ìƒê°í•´ì•¼ë˜ë‹ˆ ì¼ë‹¨ ë³´ë¥˜.
	function update({ diffs, anchors }) {
		if (!diffs) {
			return;
		}
		// const startTime = performance.now();
		// console.debug("update");

		_lineElements.length = 0;
		_diffElements.length = 0;
		_anchorElements.length = 0;
		untrackIntersections();

		const textruns = getTextRuns(name, _text, diffs, anchors);

		// editor.style.removeProperty("min-height");
		// mirror.style.removeProperty("min-height");
		// wrapper.style.removeProperty("min-height");

		const text = _text;
		const view = mirror;
		let lineEl = null;
		let inlineNode = null;
		let currentDiffIndex = null;
		let lineNum = 1;
		let unwrittenDiff = false;
		let _pos = 0;

		function appendAnchor(pos, anchorIndex, diffIndex = null) {
			const anchor = anchors[anchorIndex];
			if (inlineNode === null || inlineNode.nodeName !== ANCHOR_TAG) {
				const el = document.createElement(ANCHOR_TAG);
				el.contentEditable = false;
				lineEl.insertBefore(el, inlineNode);
				inlineNode = el;
			}
			inlineNode.id = `${name}Anchor${anchorIndex}`;
			inlineNode.dataset.anchor = anchorIndex;
			inlineNode.dataset.type = anchor.type;
			inlineNode.dataset.pos = pos;
			if (diffIndex !== null) {
				inlineNode.dataset.diff = diffIndex;
			} else {
				delete inlineNode.dataset.diff;
			}
			_anchorElements.push(inlineNode);
			inlineNode = inlineNode.nextSibling;
		}

		function appendChars(chars) {
			if (currentDiffIndex !== null) {
				//const diff = diffs[currentDiffIndex];
				if (inlineNode === null || inlineNode.nodeName !== DIFF_ELEMENT_NAME) {
					const el = document.createElement(DIFF_ELEMENT_NAME);
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
				inlineNode.dataset.diff = currentDiffIndex;
				inlineNode.className = "diff-color" + ((currentDiffIndex % NUM_DIFF_COLORS) + 1);
				//inlineNode.classList.toggle("block", diff.align && diff[name].empty);
				_diffElements[currentDiffIndex] = _diffElements[currentDiffIndex] || [];
				_diffElements[currentDiffIndex].push(inlineNode);
				unwrittenDiff = false;
			} else {
				if (inlineNode === null || inlineNode.nodeName !== "SPAN") {
					//console.log("new text node");
					const el = document.createElement("SPAN");
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
			}
			inlineNode = inlineNode.nextSibling;
		}

		lineEl = view.firstElementChild;
		if (lineEl === null) {
			lineEl = document.createElement(LINE_TAG);
			view.appendChild(lineEl);
			lineEl.dataset.lineNum = lineNum;
			lineEl.dataset.pos = _pos;
			lineNum++;
		}
		_lineElements.push(lineEl);
		inlineNode = lineEl.firstChild;

		for (const textrun of textruns) {
			// if (name === "right") {
			// 	console.log(lineNum, textrun);
			// }
			if (textrun.type === "CHARS") {
				const { pos, len } = textrun;
				appendChars(text.substring(pos, pos + len));
			} else if (textrun.type === "ANCHOR") {
				const { pos, anchorIndex } = textrun;
				appendAnchor(pos, anchorIndex, currentDiffIndex);
				unwrittenDiff = false;
			} else if (textrun.type === "DIFF") {
				currentDiffIndex = textrun.diffIndex;
				unwrittenDiff = true;
			} else if (textrun.type === "DIFF_END") {
				if (unwrittenDiff) {
					appendChars("");
				}
				currentDiffIndex = null;
			} else if (textrun.type === "LINEBREAK" || textrun.type === "END_OF_STRING") {
				if (unwrittenDiff) {
					appendChars("");
				}
				if (inlineNode === null || inlineNode.nodeType !== 3 || inlineNode.nodeValue !== "\n") {
					lineEl.insertBefore(document.createTextNode("\n"), inlineNode);
				}

				while (inlineNode) {
					const nextInlineNode = inlineNode.nextSibling;
					inlineNode.remove();
					inlineNode = nextInlineNode;
				}
				lineEl = lineEl.nextElementSibling;
				if (textrun.type === "LINEBREAK") {
					lineNum++;
					_pos = textrun.pos + textrun.len;
					if (lineEl === null) {
						lineEl = document.createElement(LINE_TAG);
						view.appendChild(lineEl);
					}
					lineEl.dataset.lineNum = lineNum;
					lineEl.dataset.pos = _pos;
					_lineElements.push(lineEl);
					inlineNode = lineEl.firstChild;

					if (currentDiffIndex !== null) {
						unwrittenDiff = true;
					}
				} else {
					_lineElements.length = lineNum;
					while (lineEl) {
						const nextLineEl = lineEl.nextElementSibling;
						lineEl.remove();
						lineEl = nextLineEl;
					}
					break;
				}
			}
		}

		trackIntersections();
		onMirrorUpdated();

		// const endTime = performance.now();
		// const elapsedTime = endTime - startTime;
		// console.debug(`update took ${elapsedTime} ms`);
	}

	function trackIntersections() {
		if (!_observingAnchors) {
			for (const anchor of _anchorElements) {
				intersectionObserver.observe(anchor);
			}
			for (const diff of _diffElements.flat()) {
				intersectionObserver.observe(diff);
			}
			_observingAnchors = true;
		}
	}

	function untrackIntersections() {
		_observingAnchors = false;
		_visibleAnchors.clear();
		_visibleDiffIndices.clear();
		intersectionObserver.disconnect();
	}

	function getFirstVisibleAnchor() {
		let firstAnchor = null;
		let firstPos = null;
		for (const anchor of _visibleAnchors) {
			if (firstAnchor === null) {
				firstAnchor = anchor;
				firstPos = Number(anchor.dataset.pos);
			} else {
				const pos = Number(anchor.dataset.pos);
				if (pos < firstPos) {
					firstAnchor = anchor;
					firstPos = pos;
				}
			}
		}
		return firstAnchor;
	}

	function setEditMode(editMode) {
		_editMode = !!editMode;
	}

	function getTextOffsetFromRoot(root, textNode, textNodeOffset) {
		let offset = 0;
		const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
		while (walker.nextNode()) {
			if (walker.currentNode === textNode) {
				return offset + textNodeOffset;
			}
			offset += walker.currentNode.nodeValue.length;
		}
		return null;
	}

	function findLineIndexByPos(pos, low = 0, high = _lineElements.length - 1) {
		let mid;
		while (low <= high) {
			mid = (low + high) >>> 1;
			const lineEl = _lineElements[mid];
			const linePos = Number(lineEl.dataset.pos);
			if (linePos === pos) {
				return mid;
			}
			if (linePos > pos) {
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return high;
	}

	window.findLineIndexByPos = findLineIndexByPos;

	function selectTextRange(startOffset, endOffset) {
		const range = document.createRange();
		let startSet = false;
		let endSet = false;
		if (_editMode) {
			const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
			let currentNode;
			let pos = 0;
			while (!endSet && (currentNode = walker.nextNode())) {
				if (!startSet && pos + currentNode.nodeValue.length >= startOffset) {
					range.setStart(currentNode, startOffset - pos);
					startSet = true;
				}
				if (!endSet && pos + currentNode.nodeValue.length >= endOffset) {
					range.setEnd(currentNode, endOffset - pos);
					endSet = true;
				}
				pos += currentNode.nodeValue.length;
			}
		} else {
			// binary search in _lineElements for startOffset
			let startLineIndex = findLineIndexByPos(startOffset);
			let endLineIndex = findLineIndexByPos(endOffset, startLineIndex);

			let currentNode;
			let walker = document.createTreeWalker(_lineElements[startLineIndex], NodeFilter.SHOW_TEXT, null, false);
			let pos = Number(_lineElements[startLineIndex].dataset.pos);
			while ((currentNode = walker.nextNode())) {
				const nodeLen = currentNode.nodeValue.length;
				if (pos + nodeLen >= startOffset) {
					range.setStart(currentNode, startOffset - pos);
					startSet = true;
					break;
				}
				pos += nodeLen;
			}

			walker = document.createTreeWalker(_lineElements[endLineIndex], NodeFilter.SHOW_TEXT, null, false);
			pos = Number(_lineElements[endLineIndex].dataset.pos);
			while ((currentNode = walker.nextNode())) {
				const nodeLen = currentNode.nodeValue.length;
				if (pos + nodeLen >= endOffset) {
					range.setEnd(currentNode, endOffset - pos);
					endSet = true;
					break;
				}
				pos += nodeLen;
			}
		}

		if (startSet && endSet) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(range);
		}
	}

	function getTextSelectionRange() {
		const selection = window.getSelection();
		if (!selection.rangeCount) {
			return null;
		}

		const range = selection.getRangeAt(0);
		if (!wrapper.contains(range.commonAncestorContainer)) {
			return null;
		}

		let startOffset = Number.NaN;
		let endOffset = Number.NaN;
		if (_editMode) {
			const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
			let currentNode;
			let pos = 0;
			while ((currentNode = walker.nextNode())) {
				if (currentNode === range.startContainer) {
					startOffset = pos + range.startOffset;
				}
				if (currentNode === range.endContainer) {
					endOffset = pos + range.endOffset;
					break;
				}
				pos += currentNode.textContent.length;
			}
		} else {
			// ì´ ê²½ìš° ì¡°ê¸ˆ ìµœì í™”ê°€ ê°€ëŠ¥. ì‹¤ì œë¡œ ì´ê²Œ ì–¼ë§ˆë‚˜ íš¨ìœ¨ì ì¸ì§€ëŠ” í…ŒìŠ¤íŠ¸í•´ ë³¼ í•„ìš”ê°€ ìˆê² ì§€ë§Œ...
			// ëª‡ì²œ ë¼ì¸ì˜ í…ìŠ¤íŠ¸ê³  diff, anchorê°€ ë§ì€ ê²½ìš° ë‹¹ì—°íˆ ì‹œì‘ì¤„, ëì¤„ì„ ë¨¼ì € ì°¾ê³  ê·¸ ì¤„ì— ëŒ€í•´ì„œë§Œ
			// offsetì„ ê³„ì‚°í•˜ëŠ” ê²ƒì´ ë” ë¹ ë¥´ê² ì§€!

			// ì£¼ì˜: startContainer, endContainerê°€ textë…¸ë“œê°€ ì•„ë‹ ìˆ˜ë„ ìˆìŒ.
			let startLineEl = range.startContainer;
			if (startLineEl.nodeType === 3) {
				startLineEl = startLineEl.parentElement.closest("div[data-pos]");
			} else {
				startOffset = Number(startLineEl.dataset.pos);
			}
			let endLineEl = range.endContainer;
			if (endLineEl.nodeType === 3) {
				endLineEl = endLineEl.parentElement.closest("div[data-pos]");
			} else {
				endOffset = Number(endLineEl.dataset.pos) + endLineEl.textContent.length;
			}

			if (isNaN(startOffset) || isNaN(endOffset)) {
				if (startLineEl && endLineEl) {
					if (isNaN(startOffset)) {
						startOffset = getTextOffsetFromRoot(startLineEl, range.startContainer, range.startOffset) + Number(startLineEl.dataset.pos);
					}
					if (isNaN(endOffset)) {
						endOffset = getTextOffsetFromRoot(endLineEl, range.endContainer, range.endOffset) + Number(endLineEl.dataset.pos);
					}
				} else {
					const walker = document.createTreeWalker(mirror, NodeFilter.SHOW_TEXT, null, false);
					let currentNode;
					let pos = 0;
					while (isNaN(startOffset) && isNaN(endOffset) && (currentNode = walker.nextNode())) {
						if (currentNode === range.startContainer && isNaN(startOffset)) {
							startOffset = pos + range.startOffset;
						}
						if (currentNode === range.endContainer && isNaN(endOffset)) {
							endOffset = pos + range.endOffset;
							break;
						}
						pos += currentNode.textContent.length;
					}
				}
			}
		}

		if (isNaN(startOffset) || isNaN(endOffset)) {
			return null;
		}

		// ì›ë³¸í…ìŠ¤íŠ¸ì˜ ëì— í•˜ë‚˜ì˜ "\n"ì´ ë” ë¶™ì–´ìˆìœ¼ë‹ˆ ì›ë³¸í…ìŠ¤íŠ¸ í¬ê¸°ë³´ë‹¤ offsetì´ ë” ì»¤ì§ˆ ìˆ˜ ìˆìŒ!!
		if (startOffset >= _text.length) {
			startOffset = _text.length - 1;
		}
		if (endOffset >= _text.length) {
			endOffset = _text.length - 1;
		}

		return {
			startOffset,
			endOffset,
		};
	}

	//updateText();

	return {
		name: name,
		wrapper,
		editor,
		mirror,
		updateText,
		update,
		scrollToDiff,
		saveCaret,
		restoreCaret,
		getVisibleAnchors,
		trackVisibleAnchors: trackIntersections,
		untrackVisibleAnchors: untrackIntersections,
		getFirstVisibleAnchor,
		scrollToLine,
		getFirstVisibleLineElement,
		getNearestAnchorToCaret,
		setEditMode,
		getTextSelectionRange,
		selectTextRange,
		get text() {
			return _text;
		},
		get lineElements() {
			return _lineElements;
		},
		get diffElements() {
			return _diffElements;
		},
		get visibleAnchors() {
			return _visibleAnchors;
		},
		get anchorElements() {
			return _anchorElements;
		},
		get visibleDiffIndices() {
			return _visibleDiffIndices;
		},
	};
}

</script>
<script id='worker.js'>
"use strict";

const DIFF_BY_CHAR = 1;
const DIFF_BY_WORD = 2;
const DIFF_BY_LINE = 3;
const TOKEN_CACHE_SIZE = 2;

// token flags
const FIRST_OF_LINE = 1;
const LAST_OF_LINE = 2;
const WILD_CARD = 16;
const NORMALIZE = 32; // &middot;, ë”°ì˜´í‘œ -, ë§ë¨¸ë¦¬ë¬¸ì ë“±ë“± ì‹¤ì œë¡œ ë¬¸ì ì½”ë“œëŠ” ë‹¤ë¥´ì§€ë§Œ ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼ í•  ë¬¸ìë“¤ì´ ìˆë‹¤.

const SPACE_CHARS = {
	" ": true,
	"\t": true,
	"\n": true,
	"\r": true, // ê¸€ì„...
	"\f": true, // ì´ê²ƒë“¤ì€...
	"\v": true, // ë³¼ì¼ì´ ì—†ì„ê²ƒ...
};

const normalizeChars = {};

//let greedyMatch = false;

function insertNormalizeChar(chars) {
	const norm = chars[0];
	normalizeChars[norm] = norm;
	for (let i = 1; i < chars.length; i++) {
		normalizeChars[chars[i]] = norm;
	}
}

// const decoder = new TextDecoder();
let _nextWork = null;
let _currentWork = null;

const tokenCache = {
	[DIFF_BY_CHAR]: [],
	[DIFF_BY_WORD]: [],
	[DIFF_BY_LINE]: [],
};

function createTrieNode() {
	const children = {};
	function next(char) {
		return char === " " ? this : children[char] || null;
	}

	function addChild(char) {
		if (!children[char]) {
			children[char] = createTrieNode();
		}
		return children[char];
	}
	return { next, addChild, word: null, flags: null };
}

function createTrie() {
	const root = createTrieNode();

	function insert(word, flags = 0) {
		let node = root;
		for (const char of word) {
			node = node.addChild(char);
		}
		node.word = word;
		node.flags = flags;
	}

	return { insert, root };
}

// wildcards.
// ì´ê±¸ ì–´ë–»ê²Œ êµ¬í˜„í•´ì•¼í• ì§€ ê°ì´ ì•ˆì˜¤ì§€ë§Œ ì§€ê¸ˆìœ¼ë¡œì¨ëŠ” ì–˜ë„¤ë“¤ì„ atomicí•˜ê²Œ ì·¨ê¸‰(ì‚¬ì´ì— ê³µë°±ì´ ìˆì–´ë„ í•˜ë‚˜ì˜ í† í°ìœ¼ë¡œ ë§Œë“¬. '(í˜„í–‰ê³¼ ê°™ìŒ)'ì—ì„œ ì¼ë¶€ë¶„ë§Œ ë§¤ì¹˜ë˜ëŠ” ê²ƒì„ ë°©ì§€)
// ì™€ì¼ë“œì¹´ë“œdiffì¸ ê²½ìš° ë‹¤ë¥¸ diffì™€ ë³‘í•©ë˜ì§€ ì•Šìœ¼ë©´ ì¢‹ì§€ë§Œ ì™€ì¼ë“œì¹´ë“œê°€ ì–¼ë§ˆë‚˜ greedyí•˜ê²Œ ë°˜ëŒ€ìª½ í…ìŠ¤íŠ¸ë¥¼ ì¡ì•„ë¨¹ì–´ì•¼ í• ì§€
// ì–‘ìª½ì— wildcardê°€ ë™ì‹œì— ë‚˜ì˜¤ëŠ” ê²½ìš° ê²½ê³„ë¥¼ ì–´ë””ì„œ ì–´ë–»ê²Œ ì§¤ë¼ì•¼í• ì§€ ì‰½ì§€ ì•ŠìŒ.
// ë˜í•œ wildcardë¥¼ ê°•ì œë¡œ ë‹¤ë¥¸ diffì™€ ë¶„ë¦¬í•˜ëŠ” ê²½ìš° diffê°€ ê°™ì€ ìœ„ì¹˜ì— ë‘ ê°œ ì´ìƒ ìƒê¸°ê²Œ ë˜ëŠ” ìˆ˜ê°€ ìˆë‹¤. (wildcardì™€ wildcardê°€ ì•„ë‹Œ ê²ƒ)
// ì´ ê²½ìš° ì •í™•íˆ ê°™ì€ ìœ„ì¹˜ì— ë‘ê°œì˜ diffë¥¼ ë Œë”ë§í•´ì•¼í•˜ê³  ê²°êµ­ ë‘ê°œê°€ ê²¹ì³ë³´ì´ê²Œ ë˜ëŠ”ë° ë¶„ê°„ì´ ì˜ ì•ˆëœë‹¤.
const Trie = createTrie();
Trie.insert("(ì¶”ê°€)", WILD_CARD);
Trie.insert("(ì‚­ì œ)", WILD_CARD);
Trie.insert("(ì‹ ì„¤)", WILD_CARD);
Trie.insert("(ìƒëµ)", WILD_CARD);
Trie.insert("(í˜„í–‰ê³¼ê°™ìŒ)", WILD_CARD);

const TrieRoot = Trie.root;
const WildcardNode = Trie.root.next("(");

self.onmessage = (e) => {
	if (e.data.type === "diff") {
		const work = {
			reqId: e.data.reqId,
			leftText: e.data.left,
			rightText: e.data.right,
			...e.data.options,
			cancel: false,
		};
		if (_currentWork) {
			_currentWork.cancel = true;
			_nextWork = work;
			return;
		}
		runDiff(work);
	} else if (e.data.type === "normalizeChars") {
		insertNormalizeChar(e.data.chars);
		// } else if (e.data.type === "option") {
		// 	if (e.data.key === "greedyMatch") {
		// 		greedyMatch = e.data.value;
		// 	}
	}
};

async function runDiff(work) {
	_currentWork = work;
	// const leftText = decoder.decode(work.left);
	// const rightText = decoder.decode(work.right);
	// const leftText = work.left;
	// const rightText = work.right;
	try {
		work.lastYield = work.start = performance.now();
		self.postMessage({
			reqId: work.reqId,
			type: "start",
			start: work.start,
		});
		const results = await computeDiff({
			...work,
			ctx: work,
		});
		work.finish = performance.now();
		//console.log("Elapsed time:", work.finish - work.start);
		_currentWork = null;
		if (results) {
			self.postMessage({
				reqId: work.reqId,
				type: "diffs",
				diffs: results.diffs,
				anchors: results.anchors,
			});
		} else {
			// console.debug("Diff canceled");
		}
	} catch (e) {
		if (e.message === "cancelled") {
			// console.debug("Diff canceled");
		} else {
			console.error(e);
		}
	}
	[work, _nextWork] = [_nextWork, null];
	if (work) {
		return await runDiff(work);
	}
}

function checkIfFirstOfLine(input, pos) {
	pos--;
	while (pos >= 0) {
		if (input[pos] === "\n") {
			break;
		} else if (!SPACE_CHARS[input[pos]]) {
			return false;
		}
		pos--;
	}
	return true;
}

function tokenizeByChar(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let lineCount = 0;
	let flags = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (!SPACE_CHARS[char]) {
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}
			flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
			tokens.push({
				text: char,
				pos: i,
				len: 1,
				lineNum: baseLineNum + lineCount,
				flags,
			});
			flags = 0;
		}
		if (char === "\n") {
			lineCount++;
			flags = FIRST_OF_LINE;
			if (tokens.length > 0) {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
			}
		}
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByChar", tokens);
	return tokens;
}

function normalize(text) {
	let result = "";
	for (let i = 0; i < text.length; i++) {
		const char = text[i];
		result += normalizeChars[char] || char;
	}
	return result;
}

function tokenizeByWord(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let currentStart = -1;
	let lineCount = 0;
	let flags = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		let char = input[i];
		// ë¬¸ì¥ë¶€í˜¸ë¥¼ ë³„ê°œë¡œ ë‹¨ì–´ë¡œ ë¶„ë¦¬í•˜ëŠ” ë°©ë²•ë„ ìƒê°í•´ë³¼ í•„ìš”ê°€ ìˆìŒ.
		// ë¬¸ì œëŠ” (hello)ì™€ (world)ì—ì„œ '('ë§Œ ë§¤ì¹˜ë˜ë©´ ëˆˆì´ í”¼ê³¤í•´ì§„ë‹¤. ê´„í˜¸ì•ˆì˜ ë¬¸ìë“¤ì´ ì—¬ëŸ¬ì¤„ì´ë©´ ë”ë”ìš±..
		if (SPACE_CHARS[char]) {
			if (currentStart !== -1) {
				flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
				tokens.push({
					text: flags & NORMALIZE ? normalize(input.substring(currentStart, i)) : input.substring(currentStart, i),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags,
				});
				flags = 0;
				currentStart = -1;
			}
			if (char === "\n") {
				lineCount++;
				flags = FIRST_OF_LINE;
				if (tokens.length > 0) {
					tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				}
			}
		} else {
			if (normalizeChars[char]) {
				flags |= NORMALIZE;
				char = normalizeChars[char];
			}
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					if (currentStart !== -1) {
						flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
						tokens.push({
							text: input.substring(currentStart, i),
							pos: currentStart,
							len: i - currentStart,
							lineNum: baseLineNum + lineCount,
							flags,
						});
						flags = 0;
						currentStart = -1;
					}

					flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}

			if (currentStart === -1) {
				currentStart = i;
			}
		}
	}

	if (currentStart !== -1) {
		flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
		tokens.push({
			text: flags & NORMALIZE ? normalize(input.substring(currentStart)) : input.substring(currentStart),
			pos: currentStart,
			len: inputEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: flags,
		});
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByWord", tokens);
	return tokens;
}

function tokenizeByLine(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let currentStart = -1;
	let currentEnd = -1;
	let lineCount = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (char !== "\n") {
			if (!SPACE_CHARS[char]) {
				if (currentStart === -1) {
					currentStart = i;
				}
				currentEnd = i + 1;
			}
		} else {
			if (currentStart !== -1) {
				tokens.push({
					text: input.substring(currentStart, currentEnd).trim(),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags: FIRST_OF_LINE | LAST_OF_LINE,
				});
				currentStart = currentEnd = -1;
			}
			lineCount++;
		}
	}

	if (currentStart !== -1) {
		tokens.push({
			text: input.substring(currentStart, currentEnd).trim(),
			pos: currentStart,
			len: currentEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: FIRST_OF_LINE | LAST_OF_LINE,
		});
	}

	return tokens;
}

function tokenize(input, method, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	let cacheArr;
	if ((inputPos === undefined || inputPos === 0) && (inputEnd === undefined || inputEnd === input.length)) {
		cacheArr = tokenCache[method];
		if (cacheArr) {
			for (let i = 0; i < cacheArr.length; i++) {
				const token = cacheArr[i];
				if (token.text === input) {
					if (i !== cacheArr.length - 1) {
						cacheArr.splice(i, 1);
						cacheArr.push(token);
					}
					return token.tokens;
				}
			}
		}
	}

	const tokens =
		method === DIFF_BY_CHAR
			? tokenizeByChar(input, inputPos, inputEnd, baseLineNum)
			: method === DIFF_BY_LINE
			? tokenizeByLine(input, inputPos, inputEnd, baseLineNum)
			: tokenizeByWord(input, inputPos, inputEnd, baseLineNum);

	// tokens.push({
	// 	text: "",
	// 	pos: input.length,
	// 	len: 0,
	// 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
	// 	flags: FIRST_OF_LINE | LAST_OF_LINE,
	// });

	if (cacheArr) {
		if (cacheArr.length >= TOKEN_CACHE_SIZE) {
			cacheArr.shift();
		}
		cacheArr.push({ text: input, tokens });
	}
	return tokens;
}

async function computeLCS(leftTokens, rightTokens, ctx) {
	const m = leftTokens.length;
	const n = rightTokens.length;

	const dp = new Array(m + 1);
	for (let i = 0; i <= m; i++) {
		dp[i] = new Array(n + 1).fill(0);
	}

	// í…ìŠ¤íŠ¸ê°€ ê¸¸ì–´ì§€ëŠ” ê²½ìš°(í† í°ì´ ë§ì€ ê²½ìš°) ë”ì°í•˜ê²Œ ë§ì€ ë°˜ë³µì„ ìˆ˜í–‰í•˜ê²Œëœë‹¤.
	for (let i = 1; i <= m; i++) {
		const leftText = leftTokens[i - 1].text;
		for (let j = 1; j <= n; j++) {
			// ì£¼ê¸°ì ìœ¼ë¡œ yield í•´ì„œ ì·¨ì†Œìš”ì²­ì„ ë°›ì•„ì•¼í•¨.
			// performance.now()ëŠ” ë¯¸ì¹œê²Œ ì•„ë‹Œê°€ ì‹¶ì„ ì •ë„ë¡œ ë¬´ê±°ìš´ í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— ë˜ë„ë¡ ìì œ.
			// await new Promise(...) ì—­ì‹œ ìì£¼ ì‚¬ìš©í•˜ë©´ ì•ˆë¨
			// (i+j) % 0x4000 === 0 ì¼ ë•Œë§Œ ì‚¬ìš©í•˜ê¸°ë¡œ. ë¸Œë¼ìš°ì € jsì—”ì§„ì˜ ë¹„íŠ¸ì—°ì‚° ì†ë„ë¥¼ ë¯¿ì–´ë³¸ë‹¤ ã…‹
			if (ctx && ((i + j) & 16383) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}

			if (leftText === rightTokens[j - 1].text) {
				dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
			}
		}
	}

	let i = m;
	let j = n;
	const lcsIndices = [];
	while (i > 0 && j > 0) {
		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
			lcsIndices.push({
				leftIndex: i - 1,
				rightIndex: j - 1,
			});
			i--;
			j--;
		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
			i--;
		} else {
			j--;
		}
	}
	lcsIndices.reverse();
	return lcsIndices;
}

async function computeDiff({
	leftText,
	rightText,
	leftInputPos = undefined,
	leftInputEnd = undefined,
	rightInputPos = undefined,
	rightInputEnd = undefined,
	// leftTokens = undefined,
	// rightTokens = undefined,
	method = DIFF_BY_WORD,
	greedyMatch = false,
	useFallback = false,
	ctx,
}) {
	//console.log("computeDiff", { leftText, rightText, leftInputPos, leftInputEnd, rightInputPos, rightInputEnd, method, greedyMatch, useFallback });

	// ì•µì»¤ë¼ëŠ” ì´ë¦„ë„ êµ¬í˜„ ë°©ì‹ë„ ì‚¬ì‹¤ ì¢€ ë§ˆìŒì— ì•ˆë“¤ì§€ë§Œ
	// ì–‘ìª½ í…ìŠ¤íŠ¸ì—ì„œ ê³µí†µ ë¶€ë¶„(diffê°€ ì•„ë‹Œ ë¶€ë¶„)ì„ ì„œë¡œ ëŒ€ì‘ì‹œí‚¬ ë§Œí•œ ë”±íˆ ì¢‹ì€ ìˆ˜ê°€ ì—†ìŒ
	const diffs = [],
		anchors = [];

	if (leftInputPos === undefined) {
		leftInputPos = 0;
	}
	if (leftInputEnd === undefined) {
		leftInputEnd = leftText.length;
	}
	if (rightInputPos === undefined) {
		rightInputPos = 0;
	}
	if (rightInputEnd === undefined) {
		rightInputEnd = rightText.length;
	}

	const leftTokens = tokenize(leftText, method, leftInputPos, leftInputEnd);
	const rightTokens = tokenize(rightText, method, rightInputPos, rightInputEnd);

	if (leftText === rightText) {
		for (let i = 0; i < leftTokens.length; i++) {
			const token = leftTokens[i];
			if (token.flags & FIRST_OF_LINE) {
				let anchorPos = token.pos;
				while (anchorPos > 0 && leftText[anchorPos - 1] !== "\n") {
					anchorPos--;
				}
				addAnchor("before", anchorPos, anchorPos);
			}
		}
		return { diffs, anchors };
	}

	// console.log("tokens:", { leftTokens, rightTokens });

	const lcs = await computeLCS(leftTokens, rightTokens, ctx);
	const lcsLength = lcs.length;
	const leftTokensLength = leftTokens.length;
	const rightTokensLength = rightTokens.length;

	// ì•µì»¤ ì¶”ê°€ëŠ” ë‚˜ì¤‘ì— í•œë²ˆì— ì²˜ë¦¬í•˜ê³  ì‹¶ì€ë°
	// common sequenceì¸ ê²½ìš° ëŒ€ì‘í•˜ëŠ” ë°˜ëŒ€ìª½ í† í°ì— ëŒ€í•œ ì •ë³´ê°€ í•„ìš”í•˜ë¯€ë¡œ ì‰½ì§€ ì•ŠìŒ.
	// ê²°êµ­ ì„œë¡œ ëŒ€ì‘í•˜ëŠ” í† í° ìŒì„ ì €ì¥í•´ë†”ì•¼í•˜ëŠ”ë° ê·¸ëŸ¬ë©´ ì•µì»¤ë¥¼ ë‚˜ì¤‘ì— ì¶”ê°€í•˜ëŠ”ê²Œ ë¬´ìŠ¨ ì˜ë¯¸?
	function addAnchor(type, leftPos, rightPos, diffIndex = null) {
		if (leftPos === undefined || rightPos === undefined) {
			console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
		}
		if (anchors.length > 0) {
			let lastAnchor = anchors[anchors.length - 1];
			if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
				return;
			}
			if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
				if (type === lastAnchor.type || type === "before") {
					return;
				}
			}
		}
		anchors.push({ type, diffIndex, left: leftPos, right: rightPos });
	}

	if (leftTokensLength === 0 && rightTokensLength === 0) {
		// ë”±íˆ í•  ìˆ˜ ìˆëŠ”ê²Œ ì—†ë‹¤.
	} else if (leftTokensLength === 0) {
		diffs.push({
			left: {
				pos: leftInputPos,
				len: 0,
				empty: true,
			},
			right: {
				pos: rightTokens[0].pos,
				len: rightTokens[rightTokensLength - 1].pos + rightTokens[rightTokensLength - 1].len - rightTokens[0].pos,
				line: rightTokens[0].lineNum,
			},
		});
	} else if (rightTokensLength === 0) {
		diffs.push({
			left: {
				pos: leftTokens[0].pos,
				len: leftTokens[leftTokensLength - 1].pos + leftTokens[leftTokensLength - 1].len - leftTokens[0].pos,
			},
			right: {
				pos: rightInputPos,
				len: 0,
				empty: true,
			},
		});
	} else {
		let i = 0;
		let j = 0;
		let lcsIndex = 0;
		let iteration = 0;

		while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
			if (ctx && (iteration & 1023) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}
			if (
				lcsIndex < lcsLength &&
				((greedyMatch &&
					leftTokens[i].text === leftTokens[lcs[lcsIndex].leftIndex].text &&
					rightTokens[j].text === rightTokens[lcs[lcsIndex].rightIndex].text) ||
					(i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))
			) {
				const leftToken = leftTokens[i];
				const rightToken = rightTokens[j];
				if ((leftToken.flags & rightToken.flags & FIRST_OF_LINE) === FIRST_OF_LINE) {
					let leftAnchorPos = leftToken.pos;
					let rightAnchorPos = rightToken.pos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
					addAnchor("before", leftAnchorPos, rightAnchorPos);
				}
				i++;
				j++;
				lcsIndex++;
				continue;
			}

			const lcsEntry = lcs[lcsIndex];
			let leftIndex = i;
			let leftCount = 0;
			let rightIndex = j;
			let rightCount = 0;

			// greedyMatchì¸ ê²½ìš° ìµœëŒ€í•œ ê³µí†µë¶€ë¶„ì„ ì¼ì°/ë§ì´ ì¡ì•„ë¨¹ì–´ì•¼í•˜ë¯€ë¡œ
			// diffëŠ” ìµœëŒ€í•œ ì ê²Œ ì¡ì•„ë¨¹ì–´ì•¼í•¨. ë§...ì§€..?

			while (
				i < leftTokensLength && // ìœ íš¨í•œ í† í° index
				(!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
					(!greedyMatch && i < lcsEntry.leftIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
					leftTokens[i].text !== leftTokens[lcsEntry.leftIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
			) {
				leftCount++;
				i++;
			}

			while (
				j < rightTokensLength && // ìœ íš¨í•œ í† í° index
				(!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
					(!greedyMatch && j < lcsEntry.rightIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
					rightTokens[j].text !== rightTokens[lcsEntry.rightIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
			) {
				rightCount++;
				j++;
			}

			if (leftCount > 0 && rightCount > 0) {
				if (useFallback && method > DIFF_BY_WORD) {
					const result = await computeDiff({
						leftText,
						rightText,
						leftInputPos: leftTokens[leftIndex].pos,
						leftInputEnd: leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len,
						rightInputPos: rightTokens[rightIndex].pos,
						rightInputEnd: rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len,
						method: DIFF_BY_WORD,
						greedyMatch,
						useFallback: useFallback,
						ctx,
					});
					for (const anchor of result.anchors) {
						if (anchor.diffIndex !== null) {
							anchor.diffIndex += diffs.length;
						}
						addAnchor(anchor.type, anchor.left, anchor.right, diffs.length);
					}
					for (const diff of result.diffs) {
						diffs.push(diff);
					}
					continue;
				} else if (method > DIFF_BY_CHAR) {
					// ë‹¨ì–´ ì‚¬ì´ì—ì„œ ì˜ˆê¸°ì¹˜ ì•Šì€ ê³µë°±ì´ ë‚˜ì˜¤ëŠ” ê²½ìš°ê°€ ì™•ì™• ìˆë‹¤.
					// ê²Œë‹¤ê°€ ìš°ë¦¬ë§ì€ ë„ì–´ì“°ê¸°ë¥¼ í•´ë„ ë§ê³  ì•ˆí•´ë„ ë§ëŠ” ê²ƒ ê°™ì€ ëŠë‚Œì ì¸ ëŠë‚Œì˜ ëŠë‚Œì´ ëŠê»´ì§€ëŠ” ê²½ìš°ê°€ ë§ì€ ëŠë‚Œì´ë‹¤!!!
					// FALLBACKìœ¼ë¡œ ê¸€ìë‹¨ìœ„ ë¹„êµë¥¼ í•˜ê³  ê·¸ ê²°ê³¼ë¥¼ ìµœì¢…ê²°ê³¼ì— ë„£ì–´ë²„ë¦¬ëŠ” ë°©ë²•ì„ ì¨ë„ ë˜ì§€ë§Œ
					// ê¸€ìë‹¨ìœ„ DIFFëŠ” ì˜¤íˆë ¤ ì‚¬ëŒì˜ ëˆˆì—ëŠ” ë” ë¶ˆí¸í•¨.

					// ë¬¸ì œ: [diff0] abc [diff1] vs [diff0] a bc [diff1] ê°™ì€ ê²½ìš° "abc" vs "a bc"ë„ diffë¡œ ì²˜ë¦¬ë¨.
					// > diff0ì—ì„œë¶€í„° diff1 ë²”ìœ„ê¹Œì§€ë¥¼ ëª½ë•… diff ë²”ìœ„ë¡œ ë¬¶ì–´ë²„ë ¸ê¸° ë•Œë¬¸ì— abc vs a bcë¥¼ ë³„ê°œë¡œ ë¹„êµí•˜ì§€ ëª»í•¨.
					// > ê·¸ë ‡ë‹¤ê³  í† í° í•˜ë‚˜ì”© ë”°ë¡œë”°ë¡œ ì²˜ë¦¬ë¥¼ í•˜ë©´ ì‹œì‘ë¶€ë¶„ë¶€í„° "ab cd" vs "abcd" ê°™ì€ê±¸ ì²˜ë¦¬í•˜ì§€ ëª»í•¨(ab vs abcd ë¹„êµë¥¼ í•˜ê²Œë˜ê¸° ë•Œë¬¸ì—)
					// ê·¸ë˜ë„ diffë¥¼ diffê°€ ì•„ë‹Œ ê±¸ë¡œ í‘œì‹œí•˜ëŠ” ê²Œ ì•„ë‹ˆë¼ë¼ diffê°€ ì•„ë‹Œ ê±¸ diffë¡œ í‘œì‹œí•˜ëŠ” ê±°ë‹ˆê¹Œ í° ë¬¸ì œê°€ ë˜ì§€ëŠ” ì•Šì„ ê²ƒ...
					const result = await computeDiff({
						leftText,
						rightText,
						leftInputPos: leftTokens[leftIndex].pos,
						leftInputEnd: leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len,
						rightInputPos: rightTokens[rightIndex].pos,
						rightInputEnd: rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len,
						method: DIFF_BY_CHAR,
						useFallback: false,
						ctx,
					});

					if (result.diffs.length === 0) {
						continue;
					}

					// ê¸€ìë‹¨ìœ„ë¡œ í‘œì‹œí•˜ë©´ ì˜¤íˆë ¤ ëˆˆê¹” ë¹ ì§„ë‹¤.
					// ê³µë°±ë¬´ì‹œ ê¸€ìë‹¨ìœ„ë¡œ ë¹„êµì—ì„œë„ ë‘ ë¬¸ìì—´ì´ ê°™ì§€ ì•Šë‹¤ëŠ” ê²ƒì€ ì•Œì•˜ìœ¼ë‹ˆ ê¸°ì¡´ í† í°ì„ ê¸°ì¤€ìœ¼ë¡œ diffë¥¼ ë§Œë“ ë‹¤.
				}
			}

			// ì¡°ê¸ˆì”© ìˆ˜ì •í•˜ë‹¤ê°€ ë‚œì¥íŒì´ ëœ ë¶€ë¶„ì¸ë° ì„£ë¶ˆë¦¬ ì†ëŒ€ê³  ì‹¶ì§€ ì•Šë‹¤... ã…‹

			let leftPos, leftLen, rightPos, rightLen;
			let leftEmpty;
			let rightEmpty;
			let leftAnchorPos = null;
			let rightAnchorPos = null;

			let anchorBefore = false,
				anchorAfter = false;

			if (leftCount > 0 && rightCount > 0) {
				leftPos = leftTokens[leftIndex].pos;
				leftLen = leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len - leftPos;
				leftEmpty = false;
				rightPos = rightTokens[rightIndex].pos;
				rightLen = rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len - rightPos;
				rightEmpty = false;
				anchorBefore = !!(leftTokens[leftIndex].flags & rightTokens[rightIndex].flags & FIRST_OF_LINE);
				anchorAfter = !!(leftTokens[leftIndex + leftCount - 1].flags & rightTokens[rightIndex + rightCount - 1].flags & LAST_OF_LINE);

				if (anchorBefore) {
					leftAnchorPos = leftPos;
					rightAnchorPos = rightPos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
				}

				if ((leftTokens[leftIndex].flags | rightTokens[rightIndex].flags) & FIRST_OF_LINE) {
					leftAnchorPos = leftPos;
					rightAnchorPos = rightPos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
					addAnchor("before", leftAnchorPos, rightAnchorPos);
					if (leftTokens[leftIndex].flags & rightTokens[rightIndex].flags & FIRST_OF_LINE) {
						if (leftTokens[leftIndex + leftCount - 1].flags & rightTokens[rightIndex + rightCount - 1].flags & LAST_OF_LINE) {
							leftAnchorPos = leftPos + leftLen;
							rightAnchorPos = rightPos + rightLen;
							// ì¤„ë°”ê¿ˆ ë¬¸ì ìœ„ì¹˜ê¹Œì§€ ìŠ¤í‚µ

							if (leftText[leftAnchorPos] !== "\n") {
								do {
									leftAnchorPos++;
								} while (leftAnchorPos < leftText.length && leftText[leftAnchorPos] !== "\n");
							}
							if (rightText[rightAnchorPos] !== "\n") {
								do {
									rightAnchorPos++;
								} while (rightAnchorPos < rightText.length && rightText[rightAnchorPos] !== "\n");
							}

							// while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
							// 	leftAnchorPos++;
							// }
							// while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
							// 	rightAnchorPos++;
							// }
							addAnchor("after", leftAnchorPos, rightAnchorPos);
						}
					}
				}
			} else if (leftCount > 0 || rightCount > 0) {
				// ì´ë ‡ê²Œê¹Œì§€ ì¥í™©í•˜ê²Œ ë§Œë“¤ì–´ì•¼ë˜ë‚˜ ì‹¶ì€ë° ë”ì´ìƒì€ ì†ëŒ€ê¸° ì‹«ì€ ë¶€ë¶„...

				let longSideText, shortSideText;
				let longSideIndex, longSideCount, longSideTokens;
				let shortSideIndex, shortSideCount, shortSideTokens;
				let longSidePos, longSideLen;
				let shortSidePos, shortSideLen;
				let longSideStartPos, shortSideStart;
				let longSideEndPos, shortSideEnd;
				let longSideAnchorPos, shortSideAnchorPos;

				if (leftCount > 0) {
					longSideText = leftText;
					longSideTokens = leftTokens;
					longSideIndex = leftIndex;
					longSideCount = leftCount;
					shortSideText = rightText;
					shortSideTokens = rightTokens;
					shortSideIndex = rightIndex;
					shortSideCount = rightCount;
					longSideStartPos = leftInputPos;
					shortSideStart = rightInputPos;
					longSideEndPos = leftInputEnd;
					shortSideEnd = rightInputEnd;
				} else {
					longSideText = rightText;
					longSideTokens = rightTokens;
					longSideIndex = rightIndex;
					longSideCount = rightCount;
					shortSideText = leftText;
					shortSideTokens = leftTokens;
					shortSideIndex = leftIndex;
					shortSideCount = leftCount;
					longSideStartPos = rightInputPos;
					shortSideStart = leftInputPos;
					longSideEndPos = rightInputEnd;
					shortSideEnd = leftInputEnd;
				}

				longSidePos = longSideTokens[longSideIndex].pos;
				longSideLen = longSideTokens[longSideIndex + longSideCount - 1].pos + longSideTokens[longSideIndex + longSideCount - 1].len - longSidePos;
				shortSideLen = 0;
				const longSideIsFirstWord = longSideTokens[longSideIndex].flags & FIRST_OF_LINE;
				const longSideIsLastWord = longSideTokens[longSideIndex + longSideCount - 1].flags & LAST_OF_LINE;
				const shortSideIsOnLineEdge =
					shortSideTokens.length === 0 ||
					(shortSideIndex > 0 && shortSideTokens[shortSideIndex - 1].flags & FIRST_OF_LINE) ||
					(shortSideIndex < shortSideTokens.length && shortSideTokens[shortSideIndex].flags & FIRST_OF_LINE);
				anchorBefore = longSideIsFirstWord && shortSideIsOnLineEdge;
				anchorAfter = longSideIsLastWord && shortSideIsOnLineEdge;

				// base posëŠ” ë˜ë„ë¡ì´ë©´ ì•ìª½ìœ¼ë¡œ ì¡ì. ë‚œë°ì—†ì´ ë¹ˆì¤„ 10ê°œ ìŠ¤í‚µí•˜ê³  diffê°€ ì‹œì‘ë˜ë©´ ì´ìƒí•˜ìë‚˜.
				shortSidePos = shortSideIndex > 0 ? shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len : shortSideStart;

				// ì°¸ê³ :
				// ë§Œì•½ shortSidePosê°€ ì¤„ì˜ ì‹œì‘ ìœ„ì¹˜ë¡œ ì •í•´ì§„ë‹¤ë©´(\n ìœ„ì¹˜ì˜ +1) shortSideAnchorPosë„ ê°™ì€ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
				// ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” ì•ìª½ ê³µë°±ì„ ë‹¤ ìŠ¤í‚µí•´ì„œ shortSideAnchorPosë¥¼ ì°¾ì•„ì•¼ í•œë‹¤.
				if (shortSideIsOnLineEdge) {
					if (longSideIsFirstWord) {
						// longsideëŠ” ë¸”ëŸ­ diffë‹¤. shortsideë„ ê°€ëŠ¥í•˜ë‹¤ë©´ ë¹ˆì¤„ì„ ì°¾ì•„ì„œ ì°¾ì•„ì„œ ë…ì‹í•˜ì.
						// í˜„ì¬ shortsideposëŠ” ì´ì „ ë¸”ëŸ­ì˜ ëì´ë¯€ë¡œ ì´í›„ì— ì¤„ë°”ê¿ˆì´ ë‘ê°œ ë‚˜ì˜¤ë©´ ëœë‹¤

						if (shortSideIndex > 0 && shortSideIndex < shortSideTokens.length) {
							// ì´ì „ í† í°ê³¼ ë‹¤ìŒ í† í° ì‚¬ì´ì— ìˆìœ¼ë¯€ë¡œ lineNumì„ í™•ì¸í•˜ë©´ ëœë‹¤.
							if (shortSideTokens[shortSideIndex].lineNum > shortSideTokens[shortSideIndex - 1].lineNum) {
								// ì´ì „ í† í°ê³¼ ë‹¤ìŒ í† í° ì‚¬ì´ì— ë¹ˆì¤„ì´ ìˆë‹¤.
								while (shortSideText[shortSidePos++] !== "\n") {}
								shortSideAnchorPos = shortSidePos;
							} else {
								// do not even try
							}
						} else if (shortSideIndex > 0) {
							// í˜„ì¬ posëŠ” ì´ì „ í† í°ì˜ ëì´ë¯€ë¡œ ê·¸ ì´í›„ ì²«ë²ˆì§¸ ì¤„ë°”ê¿ˆ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ +1í•œ ìë¦¬ë¡œ.
							// ë§ˆì§€ë§‰ í† í° ì´í›„ì—ë„ ì¤„ë°”ê¿ˆì€ ë¬´ì¡°ê±´ í•˜ë‚˜ ì´ìƒ ìˆë‹¤. ë‚´ê°€ í…ìŠ¤íŠ¸ë¥¼ ê°•ì œë¡œ ê·¸ë ‡ê²Œ ë§Œë“¤ê±°ë‹ˆê¹Œ.
							while (shortSideText[shortSidePos++] !== "\n") {}
						} else {
							// ì´ì „ í† í°ì€ ì—†ì§€ë§Œ ì´ê²Œ í…ìŠ¤íŠ¸ì˜ ì‹œì‘ì€ ì•„ë‹ ìˆ˜ë„ ìˆë‹¤. - í…ìŠ¤íŠ¸ ì¤‘ê°„ ë¶€ë¶„ì—ì„œ diffë¥¼ êµ¬í•˜ëŠ” ê²½ìš°.
							// ì¼ë‹¨ í˜„ì¬ posì´ì „ì— ì²«ë²ˆì§¸ ì¤„ë°”ê¿ˆì„ ì°¾ë˜ ë„ì¤‘ì— ê³µë°±ì´ ì•„ë‹Œ ë¬¸ìë¥¼ ë§Œë‚˜ë©´ í¬ê¸°
							// ì²«ë²ˆì§¸ ì¤„ë°”ê¿ˆì—ì„œ ëë‚´ì§€ë§ê³ ê³  ê³„ì† ì°¾ì•„ì„œ ìµœëŒ€í•œ ìœ„ë¡œ ëŒì–´ì˜¬ë¦¬ê¸°.
							if (shortSidePos === 0) {
								shortSideAnchorPos = shortSidePos;
							} else {
								let p = shortSidePos;
								let success = false;
								while (p > 0) {
									const ch = shortSideText[p - 1];
									if (ch === "\n") {
										shortSidePos = shortSideAnchorPos = p;
										success = true;
									} else if (!SPACE_CHARS[ch]) {
										break;
									}
									p--;
								}
								if (p === 0) {
									shortSidePos = shortSideAnchorPos = 0;
									success = true;
								}
								if (!success) {
									p = shortSidePos;
									while (p < shortSideText.length) {
										if (shortSideText[p] === "\n") {
											shortSidePos = p + 1;
											shortSideAnchorPos = shortSidePos;
											break;
										}
										if (!SPACE_CHARS[shortSideText[p++]]) {
											break;
										}
									}
								}
							}
						}
					}
				}

				if (longSideIsFirstWord) {
					if (shortSideAnchorPos !== undefined) {
						shortSideAnchorPos = shortSidePos;
						while (shortSideAnchorPos > 0 && shortSideText[shortSideAnchorPos - 1] !== "\n") {
							shortSideAnchorPos--;
						}

						longSideAnchorPos = longSidePos;
						while (longSideAnchorPos > 0 && longSideText[longSideAnchorPos - 1] !== "\n") {
							longSideAnchorPos--;
						}

						if (leftCount > 0) {
							[leftAnchorPos, rightAnchorPos] = [longSideAnchorPos, shortSideAnchorPos];
						} else {
							[leftAnchorPos, rightAnchorPos] = [shortSideAnchorPos, longSideAnchorPos];
						}
						addAnchor("before", leftAnchorPos, rightAnchorPos);

						if (longSideIsLastWord && shortSideIsOnLineEdge) {
							longSideAnchorPos = longSidePos + longSideLen;
							while (longSideAnchorPos < longSideEndPos && longSideText[longSideAnchorPos] !== "\n") {
								longSideAnchorPos++;
							}
							shortSideAnchorPos = shortSidePos + shortSideLen;
							// ì´í›„ ì´ì–´ì§€ëŠ” ê³µë°± ë¬¸ì ì¤‘ ë§ˆì§€ë§‰ ê³µë°± ë¬¸ì ìë¦¬ì—ì„œ AFTER ì•µì»¤

							while (shortSideAnchorPos < shortSideEnd) {
								if (shortSideText[shortSideAnchorPos] === "\n") {
									break;
								}
								if (!SPACE_CHARS[shortSideText[shortSideAnchorPos]]) {
									break;
								}
								shortSideAnchorPos++;
							}
							if (leftCount > 0) {
								[leftAnchorPos, rightAnchorPos] = [longSideAnchorPos, shortSideAnchorPos];
							} else {
								[leftAnchorPos, rightAnchorPos] = [shortSideAnchorPos, longSideAnchorPos];
							}
							addAnchor("after", leftAnchorPos, rightAnchorPos);
						}
					}
				}
				if (leftCount > 0) {
					leftPos = longSidePos;
					leftLen = longSideLen;
					leftEmpty = false;
					rightPos = shortSidePos;
					rightLen = shortSideLen;
					rightEmpty = true;
				} else {
					leftPos = shortSidePos;
					leftLen = shortSideLen;
					leftEmpty = true;
					rightPos = longSidePos;
					rightLen = longSideLen;
					rightEmpty = false;
				}
			} else {
				throw new Error("WTF just happened?");
			}

			// ë¹ˆ diffì¼ ê²½ìš°ì—ë„ í•˜ë‚˜ ì´ìƒì˜ ê³µë°±(ì¤„ë°”ê¿ˆ) ìœ„ì¹˜ë¥¼ ì°¨ì§€í•  ìˆ˜ ìˆê²Œ í•˜ë ¤ê³  empty ì†ì„±ì„ ì¶”ê°€í–ˆëŠ”ë°
			// ì“°ì§€ë„ ì•ŠëŠ”ë‹¤. ê·¸ë¦¬ê³  ì ì ˆí•œ ê³µë°±ì„ í• ë‹¹ì‹œì¼œ ì£¼ëŠ” ì½”ë“œê°€ ì •ë§ ì§€ë„ê°™ìŒ.
			diffs.push({
				left: {
					pos: leftPos,
					len: leftLen,
					empty: leftEmpty,
				},
				right: {
					pos: rightPos,
					len: rightLen,
					empty: rightEmpty,
				},
			});
		}
	}

	// console.debug("computeDiff done", { diffs, anchors });
	return { diffs, anchors };
}

</script>
    <style id="highlightStyle">
    </style>
</head>

<body>
    <div class="container">
        <!-- <div id="topbar">
            <div class="">

            </div>
            <div class="buttons">
                <button id="alignedModeToggle" class="toggle">ğŸ“–</button>
                <button id="syncScrollToggle" class="toggle" data-target="strike">ğŸ”—</button>
            </div>
        </div> -->
        <main id="main">
            <!-- <div id="left"></div>
            <div id="right"></div> -->

            <div id="scrollSyncIndicator">ğŸ”—</div>
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>

    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT}px;\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script id='main.js'>
"use strict";

// ë„ˆë¬´ë‚˜ë„ ì„¼ìŠ¤ ë„˜ì³ë²„ë¦¬ëŠ” ì´ë¦„
const DiffSeek = (function () {
	let _diffs = [];
	let _anchors = [];
	let _alignedMode = false;
	let _alignedDirty = false;
	let _activeEditor = null;
	let _lastFocusedEditor = null;
	let _lastScrolledEditor = null;
	let _preventScrollSync = false;
	let _mousedOverEditor = null;
	let _currentDiffIndex = -1;
	let _syncEditor = false;
	let _currentlyScrollingEditor = null;
	let _resetCurrentlyScrollingEditorId = null;

	const _diffOptions = {
		method: 2,
		greedyMatch: true,
		useFallback: true,
	};

	const useEditableMirror = false;
	const container = document.getElementById("main");
	const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
	const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
	leftEditor.wrapper.tabIndex = 100;
	rightEditor.wrapper.tabIndex = 101;
	const diffList = document.getElementById("diffList");

	const resizeObserver = new ResizeObserver((entries) => {
		_alignedDirty = true;
		if (_alignedMode) {
			recalculateAlignmentPaddingAndPositionsDebounced();
		} else if (_syncEditor) {
			// ì–´ëŠ ì—ë””í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‹±í¬ë¥¼ í•˜ëƒ?
			// ê¸°ì¤€ì´ ë‹¨ìˆœí•˜ê³  ëª…í™•í•˜ì§€ ì•Šìœ¼ë©´ ì˜¤íˆë ¤ ë” í˜¼ë€ìŠ¤ëŸ¬ì›€.
			// 1. í¬ì»¤ìŠ¤ë¥¼ ê°€ì§„ ì—ë””í„°?...
			// 2. ë§ˆìš°ìŠ¤ì»¤ì„œê°€ ì˜¬ë ¤ì§„ ì—ë””í„°?...
			// 3. ìµœê·¼ì— ìŠ¤í¬ë¡¤ëœ ì—ë””í„°?...
		}
	});

	const recalculateAlignmentPaddingAndPositionsDebounced = debounce(recalculateAlignmentPaddingAndPositions, 200);

	function getEditorCallbacks(editorName) {
		const pendingDiffVisibilities = new Map();
		let updateDiffVisilitiesPending = false;

		return {
			onTextChanged: function () {
				_diffs = null;
				_anchors = null;
				_currentDiffIndex = -1;
				_alignedDirty = true;
				computeDiff();
			},

			onMirrorUpdated: function () {
				_alignedDirty = true;
				if (_alignedMode) {
					recalculateAlignmentPaddingAndPositions();
				}
			},

			// í˜„ì¬ í™”ë©´ ìƒì— ë³´ì´ëŠ” diff ì•„ì´í…œë“¤.
			onDiffVisibilityChanged: (diffIndex, visible) => {
				pendingDiffVisibilities.set(diffIndex, visible);
				if (!updateDiffVisilitiesPending) {
					updateDiffVisilitiesPending = true;
					requestAnimationFrame(() => {
						updateDiffVisilitiesPending = false;
						for (const [diffIndex, visible] of pendingDiffVisibilities) {
							const listItem = diffList.children[diffIndex];
							if (listItem) {
								const button = listItem.firstElementChild;
								button.classList.toggle(editorName + "-visible", visible);
							}
						}
						pendingDiffVisibilities.clear();
					});
				}
			},
		};
	}

	const { computeDiff } = (function () {
		// íšŒì‚¬pc ë³´ì•ˆ ì„¤ì • ìƒ new Worker("worker.js")ëŠ” ì‹¤í–‰ ì•ˆë¨.
		let workerURL;
		const workerCode = document.getElementById("worker.js").textContent;
		if (workerCode.trim().length === 0) {
			workerURL = "worker.js";
		} else {
			const blob = new Blob([workerCode], { type: "application/javascript" });
			workerURL = URL.createObjectURL(blob);
		}
		const worker = new Worker(workerURL);
		// ì¸ì½”ë” ì“¸ í•„ìš” ìˆì„ê¹Œ?? ì•ˆì“°ëŠ” ìª½ì´ ë©”ì¸ì“°ë ˆë“œ ë¶€ë‹´ì´ ì‘ì„ ê²ƒ ê°™ì€ë°...?
		// const encoder = new TextEncoder();

		function htmlEntityToChar(entity) {
			const doc = new DOMParser().parseFromString(entity, "text/html");
			const char = doc.body.textContent;
			if (char.length !== 1) {
				throw new Error("htmlEntityToChar: not a single character entity: " + entity);
			}
			return char;
		}

		for (var entry of NORMALIZE_CHARS) {
			// entry[0] = encoder.encode(entry[0]);
			let chars = "";
			for (var i = 0; i < entry.length; i++) {
				const char = entry[i];
				if (char.length === 1) {
					chars += char;
				} else if (typeof char === "number") {
					chars += String.fromCharCode(char);
				} else if (char[0] === "&") {
					chars += htmlEntityToChar(char);
				} else {
					throw new Error("normalizeChars: not a single character: " + char);
				}
			}
			worker.postMessage({
				type: "normalizeChars",
				chars: chars,
			});
		}

		let reqId = 0;
		let computeDiffTimeoutId = null;
		function computeDiff() {
			if (computeDiffTimeoutId) {
				clearTimeout(computeDiffTimeoutId);
			}

			computeDiffTimeoutId = setTimeout(() => {
				progress.textContent = "...";
				document.querySelector("body").classList.toggle("identical", leftEditor.text === rightEditor.text);
				document.querySelector("body").classList.add("computing");
				if (reqId === Number.MAX_SAFE_INTEGER) {
					reqId = 1;
				} else {
					reqId++;
				}
				worker.postMessage({
					type: "diff",
					reqId: reqId,
					left: leftEditor.text,
					right: rightEditor.text,
					// left: encoder.encode(leftEditor.text),
					// right: encoder.encode(rightEditor.text),
					// method: _diffMethod,
					// useFallback: _useFallback,
					// greedyMatch: _greedyMatch,
					options: _diffOptions,
				});
			}, COMPUTE_DEBOUNCE_TIME);
		}

		worker.onmessage = function (e) {
			const data = e.data;
			if (data.type === "diffs") {
				if (data.reqId === reqId) {
					document.querySelector("body").classList.remove("computing");
					onDiffComputed(data);
				}
			} else if (data.type === "start") {
				progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
			}
		};

		function onDiffComputed({ diffs, anchors }) {
			//console.debug("diffs computed", diffs, anchors);
			_diffs = diffs;
			_anchors = anchors;
			_alignedDirty = true;
			leftEditor.update({ diffs, anchors });
			rightEditor.update({ diffs, anchors });
			updateDiffList();
		}

		return { computeDiff };
	})();

	function enableAlignedMode() {
		// ìŠ¤í¬ë¡¤ ìœ„ì¹˜ëŠ” ì–´ë””ìª½ ì—ë””í„°ì— ë§ì¶”ë‚˜?
		// ì—­ì‹œ ëª…í™•í•œ ê¸°ì¤€ì´ í•„ìš”.

		if (!_alignedMode) {
			const currentSelectionRange = getSelectionRange();
			const currentEditor = _activeEditor || _mousedOverEditor || _lastFocusedEditor || rightEditor;
			// let firstVisibleLine, firstVisibleLineTop;
			// if (currentEditor) {
			// 	[firstVisibleLine, firstVisibleLineTop] = currentEditor.getFirstVisibleLineElement();
			// }

			_alignedMode = true;
			leftEditor.mirror.tabIndex = 100;
			rightEditor.mirror.tabIndex = 101;
			if (useEditableMirror) {
				leftEditor.mirror.contentEditable = "plaintext-only";
				rightEditor.mirror.contentEditable = "plaintext-only";
			}
			updateButtons();
			leftEditor.setEditMode(false);
			rightEditor.setEditMode(false);
			const body = document.querySelector("body");
			body.classList.remove("edit");
			body.classList.add("aligned");
			recalculateAlignmentPaddingAndPositions();

			if (currentSelectionRange) {
				restoreSelectionRange(currentSelectionRange);
			}

			//if (firstVisibleLine) {
			// const top = firstVisibleLine.offsetTop + TOPBAR_HEIGHT;
			requestAnimationFrame(() => {
				const theOtherEditor = currentEditor === leftEditor ? rightEditor : leftEditor;
				theOtherEditor.wrapper.scrollTop = currentEditor.wrapper.scrollTop;
				// container.scrollTop = top;
			});
			//}
		}
	}

	function disableAlignedMode() {
		const currentSelectionRange = getSelectionRange();

		// ì¼ë‹¨ editmodeë¡œ ê°€ê¸° ì „ì— ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¥¼ ë³µì›í•  ìˆ˜ ìˆê²Œ í™”ë©´ ìƒ ì²«ì¤„ì„ ë³´ì¡´í•´ë‘ê³ ...
		const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElement();
		const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElement();

		const activeEditor = _activeEditor;

		_alignedMode = false;
		leftEditor.setEditMode(true);
		rightEditor.setEditMode(true);
		const body = document.querySelector("body");
		leftEditor.mirror.removeAttribute("tabindex");
		rightEditor.mirror.removeAttribute("tabindex");
		leftEditor.mirror.contentEditable = false;
		rightEditor.mirror.contentEditable = false;
		body.classList.remove("aligned");
		body.classList.add("edit");
		updateButtons();

		_preventScrollSync = true;
		requestAnimationFrame(() => {
			if (leftFirstLine) {
				leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
			}
			if (rightFirstLine) {
				rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
			}
			_preventScrollSync = false;
		});

		if (currentSelectionRange) {
			restoreSelectionRange(currentSelectionRange);
		}
	}

	// ìµœì í™”ì˜ ì—¬ì§€ê°€ ìˆë‹¤.
	// ì—˜ëŸ¬ë¨¼íŠ¸ ë³„ë¡œ ìŠ¤íƒ€ì¼ê³¼ í´ë˜ìŠ¤ë¥¼ ì§€ì •í•  ê²Œ ì•„ë‹ˆë¼ cssí…ìŠ¤íŠ¸(ì˜ˆ: #leftAnchor17 { height: 60px; } ...)ë¥¼ ë§Œë“¤ì–´ì„œ styleìš”ì†Œì—ë‹¤ í•œë²ˆì— ì§‘ì–´ë„£ì–´ë²„ë¦¬ë©´
	// resetì´ ê°„ë‹¨í•˜ê³  ë¸Œë¼ìš°ì €ë„ í•œë²ˆë§Œ ì¼ì„ í•˜ë©´ ë˜ë‹ˆ ë” ë‚«ì§€ ì•Šì„ê¹Œ...? offsetHeight ê°™ì€ ì†ì„±ì„ ì‚¬ìš©í•˜ë©´ ë¸Œë¼ìš°ì €ê°€ ë§¤ë²ˆ ê³„ì‚°ì„ ë‹¤ì‹œ í•´ì•¼í•œë‹¤.
	// ìœ„ì—ì„œë¶€í„° ì™¼ìª½/ì˜¤ë¥¸ìª½ ëˆ„ì  íŒ¨ë”©ì„ ê³„ì‚°í•˜ë©´ì„œ ë‚´ë ¤ì˜¤ë©´ ë  ê²ƒ ê°™ì€ë°...?
	function recalculateAlignmentPaddingAndPositions() {
		if (!_alignedDirty) {
			return;
		}
		const anchors = _anchors;
		if (!anchors) {
			return;
		}

		for (let i = 0; i < leftEditor.anchorElements.length; i++) {
			const anchor = leftEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}
		for (let i = 0; i < rightEditor.anchorElements.length; i++) {
			const anchor = rightEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}

		for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
			const anchor = anchors[anchorIndex];
			const leftAnchor = leftEditor.anchorElements[anchorIndex];
			const rightAnchor = rightEditor.anchorElements[anchorIndex];
			if (!leftAnchor || !rightAnchor) {
				console.warn("anchor not found", anchorIndex, leftAnchor, rightAnchor);
			}

			if (leftAnchor && rightAnchor) {
				alignAnchor(leftAnchor, rightAnchor, anchor.type);
			}
		}

		_alignedDirty = false;
		requestAnimationFrame(() => {
			const height = leftEditor.wrapper.scrollHeight;//Math.max(leftEditor.mirror.offsetHeight, rightEditor.mirror.offsetHeight);
			// console.log("height", {
			// 	left: leftEditor.mirror.offsetHeight,
			// 	right: rightEditor.mirror.offsetHeight,
			// 	height: height,
			// 	leftScrollHeight: leftEditor.wrapper.scrollHeight,
			// 	rightScrollHeight: rightEditor.wrapper.scrollHeight,
			// });
			leftEditor.mirror.style.height = `${height}px`;
			rightEditor.mirror.style.height = `${height}px`;
		});
	}

	function alignAnchor(leftAnchor, rightAnchor, type) {
		if (type === "before") {
			const leftTop = leftAnchor.offsetTop;
			const rightTop = rightAnchor.offsetTop;
			let topDiff = leftTop - rightTop;
			let shortSide, longSide;
			if (topDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				topDiff = -topDiff;
			} else if (topDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${topDiff}px`;
				shortSide.className = "expanded";
			}
		} else {
			const leftBottom = leftAnchor.offsetTop + leftAnchor.offsetHeight;
			const rightBottom = rightAnchor.offsetTop + rightAnchor.offsetHeight;
			let bottomDiff = leftBottom - rightBottom;
			let shortSide, longSide;
			if (bottomDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				bottomDiff = -bottomDiff;
			} else if (bottomDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${bottomDiff}px`;
				shortSide.className = "expanded";
			}
		}
	}

	function restoreSelectionRange({ editor, startOffset, endOffset }) {
		if (editor) {
			editor.selectTextRange(startOffset, endOffset);
		}
	}

	function getSelectionRange() {
		let editor;
		let range = leftEditor.getTextSelectionRange();
		if (range !== null) {
			editor = leftEditor;
		} else {
			range = rightEditor.getTextSelectionRange();
			if (range !== null) {
				editor = rightEditor;
			}
		}

		if (editor) {
			return {
				editor,
				startOffset: range.startOffset,
				endOffset: range.endOffset,
			};
		} else {
			return null;
		}
	}

	function syncScrollPosition(sourceEditor) {
		if (_preventScrollSync) {
			return;
		}

		if (!sourceEditor) {
			sourceEditor = _currentlyScrollingEditor || _activeEditor || _mousedOverEditor || _lastFocusedEditor;
			if (!sourceEditor) {
				return;
			}
		}

		if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
			return;
		}

		_preventScrollSync = true;
		const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
		let sourceAnchor = null;
		let targetAnchor = null;

		sourceAnchor = sourceEditor.getNearestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
		if (sourceAnchor) {
			const anchorIndex = Number(sourceAnchor.dataset.anchor);
			targetAnchor = targetEditor.anchorElements[anchorIndex];
		}

		if (sourceAnchor && targetAnchor) {
			const prevLastScrolledEditor = _lastScrolledEditor;
			const sourceWrapper = sourceEditor.wrapper;
			const targetWrapper = targetEditor.wrapper;
			targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
			_lastScrolledEditor = prevLastScrolledEditor;
		}
		requestAnimationFrame(() => {
			_preventScrollSync = false;
		});
	}

	function highlightDiff(diff) {
		highlightStyle.textContent = `mark[data-diff="${diff}"], mark[data-diff="${diff}"]::after { 
box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
animation: highlightAnimation 0.3s linear 3; 
}`;
	}

	document.addEventListener("mouseover", (e) => {
		if (e.target.dataset.diff !== undefined) {
			const diff = Number(e.target.dataset.diff);
			highlightDiff(diff);
		}
	});

	document.addEventListener("mouseout", (e) => {
		if (e.target.dataset.diff !== undefined) {
			highlightStyle.textContent = "";
		}
	});

	// syncScrollToggle.addEventListener("click", () => {
	// 	toggleSyncScroll();
	// });

	// alignedModeToggle.addEventListener("click", () => {
	// 	if (_alignedMode) {
	// 		disableAlignedMode();
	// 	} else {
	// 		enableAlignedMode();
	// 	}
	// });

	function toggleSyncScroll() {
		_syncEditor = !_syncEditor;
		updateButtons();
	}

	function updateButtons() {
		//syncScrollToggle.setAttribute("aria-pressed", _syncEditor);
		// alignedModeToggle.setAttribute("aria-pressed", _alignedMode);
		if (_syncEditor && !_alignedMode) {
			scrollSyncIndicator.style.display = "block";
		} else {
			scrollSyncIndicator.style.display = "none";
		}
	}

	function updateDiffList() {
		if (!_diffs) {
			return;
		}

		const leftWholeText = leftEditor.text;
		const rightWholeText = rightEditor.text;
		const fragment = document.createDocumentFragment();

		for (let i = 0; i < _diffs.length; i++) {
			const diff = _diffs[i];
			const li = document.createElement("LI");
			const button = document.createElement("MARK");
			button.dataset.diff = i;
			button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
			li.appendChild(button);

			const leftText = leftWholeText.substring(diff.left.pos, diff.left.pos + diff.left.len);
			const leftSpan = document.createElement("SPAN");
			leftSpan.textContent = leftText;
			leftSpan.classList.add("left");
			button.appendChild(leftSpan);

			const rightText = rightWholeText.substring(diff.right.pos, diff.right.pos + diff.right.len);
			const rightSpan = document.createElement("SPAN");
			rightSpan.textContent = rightText;
			rightSpan.classList.add("right");
			button.appendChild(rightSpan);

			fragment.appendChild(li);
		}

		diffList.innerHTML = "";
		diffList.appendChild(fragment);
	}

	document.addEventListener("keydown", (e) => {
		// ì–´ëŠ ë‹¨ì¶•í‚¤ë¥¼ ì¨ì•¼ ì˜ì¼ë‹¤ê³  ì†Œë¬¸ë‚˜ëƒ?
		if (e.key === "F2" || e.key === "Escape") {
			e.preventDefault();

			if (e.shiftKey) {
				toggleSyncScroll();
				return;
			}

			if (_alignedMode) {
				disableAlignedMode();
			} else {
				enableAlignedMode();
			}
			return;
		}

		// ì£¼ì˜ ìš”ë§
		// aligned ëª¨ë“œì—ì„œ í›„ë”± ë‹¨ì–´ í•˜ë‚˜ ì‚­ì œí•˜ê³  ì‹¶ì„ ë•Œ ë‹¨ì–´ ë”ë¸”í´ë¦­í•˜ê³  ì‚­ì œ
		if ((_alignedMode && !e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
			disableAlignedMode();
			return;
		}

		// diff cycling
		if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
			e.preventDefault();
			if (!_diffs || _diffs.length === 0) {
				return;
			}

			_currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
			if (_currentDiffIndex < 0) {
				_currentDiffIndex = _diffs.length - 1;
			}
			if (_currentDiffIndex >= _diffs.length) {
				_currentDiffIndex = 0;
			}
			_preventScrollSync = true;
			leftEditor.scrollToDiff(_currentDiffIndex);
			rightEditor.scrollToDiff(_currentDiffIndex);
			highlightDiff(_currentDiffIndex);
			requestAnimationFrame(() => {
				_preventScrollSync = false;
			});
			return;
		}
	});

	diffList.addEventListener("click", (e) => {
		const diffIndex = Number(e.target.dataset.diff);
		if (!isNaN(diffIndex)) {
			_preventScrollSync = true;
			leftEditor.scrollToDiff(diffIndex);
			rightEditor.scrollToDiff(diffIndex);
			requestAnimationFrame(() => {
				_preventScrollSync = false;
			});
		}
	});

	for (const editor of [leftEditor, rightEditor]) {
		editor.wrapper.addEventListener("scroll", (e) => {
			if (_currentlyScrollingEditor !== null || _preventScrollSync) {
				return;
			}

			_lastScrolledEditor = _currentlyScrollingEditor = editor;
			if (_alignedMode) {
				// aligned modeì¼ ë•ŒëŠ” ì–‘ìª½ ì—ë””í„°ì˜ ë†’ì´ê°€ ê°™ê²Œ ìœ ì§€ë˜ë‹ˆ ë‘˜ ë‹¤ overflow:visibleë¡œ í•´ë‘ê³ 
				// ë¶€ëª¨ì—ì„œ ìŠ¤í¬ë¡¤í•˜ë©´ ë‘˜ ë‹¤ ìŠ¤í¬ë¡¤ì´ ë˜ì§€ë§Œ ìŠ¤í¬ë¡¤ë°”ê°€ í•˜ë‚˜ë§Œ ë³´ì´ëŠ”ê²Œ ìƒê°ë³´ë‹¤ ì–´ìƒ‰í•˜ê³  ë¶ˆí¸í•˜ë‹¤.
				// ê·¸ë˜ì„œ ê·¸ëƒ¥ ê°•ì œë¡œ ìŠ¤í¬ë¡¤ ë™ê¸°í™” ì‹œí‚´.
				if (editor === leftEditor) {
					rightEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
				} else {
					leftEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
				}
			} else if (_syncEditor) {
				syncScrollPosition(editor);
			}

			if (_resetCurrentlyScrollingEditorId) {
				cancelAnimationFrame(_resetCurrentlyScrollingEditorId);
			}
			_resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
				_currentlyScrollingEditor = null;
			});
		});

		editor.wrapper.addEventListener("mouseenter", () => {
			_mousedOverEditor = editor;
		});

		editor.wrapper.addEventListener("mouseleave", () => {
			_mousedOverEditor = null;
		});

		function onFocus() {
			_activeEditor = _lastFocusedEditor = editor;
		}

		function onBlur() {
			_activeEditor = null;
		}
		editor.editor.addEventListener("focus", onFocus);
		editor.mirror.addEventListener("focus", onFocus);
		editor.editor.addEventListener("blur", onBlur);
		editor.mirror.addEventListener("blur", onBlur);

		editor.editor.addEventListener("keydown", (e) => {
			if (e.key === " " && e.ctrlKey) {
				syncScrollPosition(editor);
			} else if (e.ctrlKey && e.key === "ArrowUp") {
				editor.wrapper.scrollTop -= LINE_HEIGHT * 2;
				e.preventDefault();
			} else if (e.ctrlKey && e.key === "ArrowDown") {
				editor.wrapper.scrollTop += LINE_HEIGHT * 2;
				e.preventDefault();
			}
		});

		// editor.editor.addEventListener("click", (e) => {
		// 	if (e.ctrlKey) {
		// 		enableAlignedMode(true);
		// 	}
		// });

		editor.mirror.addEventListener("click", (e) => {
			if (e.ctrlKey) {
				disableAlignedMode();
			}
		});

		if (useEditableMirror) {
			editor.mirror.addEventListener("paste", (e) => {
				disableAlignedMode();
			});

			editor.mirror.addEventListener("drop", (e) => {
				e.preventDefault();
			});

			editor.mirror.addEventListener("cut", (e) => {
				disableAlignedMode();
			});

			// aligned modeì—ì„œë„ í…ìŠ¤íŠ¸ ì»¤ì„œê°€ ê¹œë¹¡ì´ë©´ì„œ ë³´ì˜€ìœ¼ë©´ ì¢‹ê² ê³  ë‹¨ìˆœí•œ í¸ì§‘ì€ ëª¨ë“œ í† ê¸€ ì—†ì´ ë°”ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ?
			// ìˆ˜ì •ì„ ì‹œë„í•˜ëŠ” ìˆœê°„:
			// 1. editorë¡œ í¬ì»¤ìŠ¤ë¥¼ ì˜®ê¸°ê³ 
			// 2. mirrorì˜ ì»¤ì„œìœ„ì¹˜ì™€ í…ìŠ¤íŠ¸ì„ íƒ ë²”ìœ„ë¡¤ editorì—ì„œ ë³µì›
			// 3. ë‚˜ë¨¸ì§€ëŠ” ë¸Œë¼ìš°ì €ê°€ í•˜ê²Œ ë‚´ë¹„ë‘”ë‹¤.
			// ë¶ˆì•ˆí•˜ì§€ë§Œ ì¼ë‹¨ ì¨ë³´ë©´ì„œ ë¬¸ì œê°€ ìˆìœ¼ë©´ ì§€ì›Œë²„ë¦¬ì§€ ë­
			// => ê²°ë¡ : ì“°ì§€ë§ˆ. í•œê¸€ì„ ì…ë ¥í•  ë•Œ ê°€ë”ì”© ì•„ë¬´ ì¡°ê±´ì—ë„ ì•ˆê±¸ë¦¬ê³  ëš«ë ¤ì„œ ì…ë ¥ì´ ëœë‹¤. ã…‹ã…‹
			// editor.mirror.addEventListener("keydown", (e) => {
			// 	if (
			// 		_alignedMode &&
			// 		!e.ctrlKey &&
			// 		//e.key.length === 1 ||
			// 		(e.key === "Backspace" || e.key === "Delete" || e.key === "Enter")
			// 	) {
			// 		disableAlignedMode();
			// 		return;
			// 	}
			// 	e.preventDefault();
			// });
		}

		resizeObserver.observe(editor.wrapper);
	}

	disableAlignedMode();

	leftEditor.updateText();
	rightEditor.updateText();

	return {
		get alignedMode() {
			return _alignedMode;
		},

		set alignedMode(value) {
			if (!!value) {
				enableAlignedMode();
			} else {
				disableAlignedMode();
			}
		},
		get dump() {
			return {
				diffs: _diffs,
				anchors: _anchors,
				leftEditor,
				rightEditor,
			};
		},

		compute: computeDiff,

		diffOptions: {
			get greedyMatch() {
				return _diffOptions.greedyMatch;
			},
			set greedyMatch(value) {
				value = !!value;
				if (_diffOptions.greedyMatch === value) {
					return;
				}
				_diffOptions.greedyMatch = value;
				computeDiff();
			},
			get useFallback() {
				return _diffOptions.useFallback;
			},
			set useFallback(value) {
				value = !!value;
				if (_diffOptions.useFallback === value) {
					return;
				}
				_diffOptions.useFallback = value;
				computeDiff();
			},
			get method() {
				return _diffOptions.method;
			},
			set method(value) {
				value = Number(value);
				if (_diffOptions.method === value) {
					return;
				}
				_diffOptions.method = value;
				computeDiff();
			},
		},
	};
})();

function debounce(func, delay) {
	let timeoutId;
	return function (...args) {
		const context = this;
		clearTimeout(timeoutId);
		timeoutId = setTimeout(function () {
			func.apply(context, args);
		}, delay);
	};
}

</script>
</body>

</html>

