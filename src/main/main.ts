// Ïù¥Í≤ÉÏ†ÄÍ≤É Ïù¥Ïñ¥Î∂ôÏù¥Îäî ÏΩîÎìú ÏßëÌï©
const DiffSeek = (function () {
	let _alignedMode = false;
	let _alignedDirty = false;
	let _activeEditor: Editor | null = null;
	let _lastFocusedEditor: Editor | null = null;
	let _lastScrolledEditor: Editor | null = null;
	let _currentlyScrollingEditor: Editor | null = null;
	let _preventScrollSync = false;
	let _currentDiffIndex = -1;
	let _syncEditor = false;
	let _resetCurrentlyScrollingEditorId: number | null = null;
	// let _diffResult: DiffResponse | null = null;
	let _diffContext: DiffContext = { done: false, reqId: 0 } as DiffContext;
	let _outputOptions: OutputOptions = {
		// Ïñ¥Ï∞®Ìîº ÎÇòÎßå Ïì∞Îäî Í∏∞Îä•ÏùºÌÖåÎãà
		leftLabel: "ÎåÄÎπÑÌëú",
		rightLabel: "Ï†ÑÎ¨∏",
		htmlFormat: "div",
		textFormat: 0,
	};
	let _copyMode: CopyMode = "raw";
	let _lastNonRawCopyMode: Exclude<CopyMode, "raw"> = "compare";
	let _diffListItemElements: HTMLElement[] = [];

	// Ï†ïÎßê ÏßÄÏ†ÄÎ∂ÑÌïú ÏΩîÎìú ÏãúÏûë
	const _diffOptions = (function (defaultValues: DiffOptions) {
		let _diffOptions = { ...defaultValues };

		function setValue<K extends keyof DiffOptions>(key: K, value: DiffOptions[K]) {
			if (_diffOptions[key] !== value) {
				_diffOptions[key] = value;
				computeDiff();
			}
		}

		return {
			get algorithm() {
				return _diffOptions.algorithm;
			},
			set algorithm(value: DiffAlgorithm) {
				if (value !== "histogram" && value !== "lcs") {
					throw new Error("Invalid algorithm: " + value);
				}
				setValue("algorithm", value);
			},

			get tokenization() {
				return _diffOptions.tokenization;
			},
			set tokenization(value: TokenizationMode) {
				if (value !== "char" && value !== "word" && value !== "line") {
					throw new Error("Invalid tokenization: " + value);
				}
				setValue("tokenization", value);
			},

			get whitespace() {
				return _diffOptions.whitespace;
			},
			set whitespace(value: WhitespaceHandling) {
				if (value !== "ignore" && value !== "normalize") {
					throw new Error("Invalid whitespace handling: " + value);
				}
				setValue("whitespace", value);
			},

			get greedyMatch() {
				return !!_diffOptions.greedyMatch;
			},
			set greedyMatch(value: boolean) {
				if (value !== true && value !== false) {
					throw new Error("Invalid greedyMatch: " + value);
				}
				setValue("greedyMatch", !!value);
			},

			get useLengthBias() {
				return !!_diffOptions.useLengthBias;
			},
			set useLengthBias(value: boolean) {
				if (value !== true && value !== false) {
					throw new Error("Invalid useLengthBias: " + value);
				}
				setValue("useLengthBias", !!value);
			},

			get maxGram() {
				return _diffOptions.maxGram;
			},
			set maxGram(value: number) {
				if (value < 1) {
					throw new Error("Invalid maxGram: " + value);
				}
				setValue("maxGram", value);
			},

			get lengthBiasFactor() {
				return _diffOptions.lengthBiasFactor;
			},
			set lengthBiasFactor(value: number) {
				if (value <= 0) {
					throw new Error("Invalid lengthBiasFactor: " + value);
				}
				setValue("lengthBiasFactor", value);
			},
			get sectionHeadingMultiplier() {
				return _diffOptions.sectionHeadingMultiplier;
			},
			set sectionHeadingMultiplier(value: number) {
				if (value <= 0) {
					throw new Error("Invalid sectionHeadingMultiplier: " + value);
				}
				setValue("sectionHeadingMultiplier", value);
			},
			get lineStartMultiplier() {
				return _diffOptions.lineStartMultiplier;
			},
			set lineStartMultiplier(value: number) {
				if (value <= 0) {
					throw new Error("Invalid lineStartMultiplier: " + value);
				}
				setValue("lineStartMultiplier", value);
			},
			get lineEndMultiplier() {
				return _diffOptions.lineEndMultiplier;
			},
			set lineEndMultiplier(value: number) {
				if (value <= 0) {
					throw new Error("Invalid lineEndMultiplier: " + value);
				}
				setValue("lineEndMultiplier", value);
			},
			get uniqueMultiplier() {
				return _diffOptions.uniqueMultiplier;
			},
			set uniqueMultiplier(value: number) {
				if (value <= 0) {
					throw new Error("Invalid uniqueMultiplier: " + value);
				}
				setValue("uniqueMultiplier", value);
			},
		};
	})({
		algorithm: "histogram",
		tokenization: "word",
		whitespace: "ignore",
		greedyMatch: false,
		useLengthBias: true,
		maxGram: 4,
		lengthBiasFactor: 0.7,
		sectionHeadingMultiplier: 1 / 0.75,
		lineStartMultiplier: 1 / 0.85,
		lineEndMultiplier: 1 / 0.9,
		uniqueMultiplier: 1 / 0.6667,
	});

	const container = document.getElementById("main") as HTMLElement;
	const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
	const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
	leftEditor.wrapper.tabIndex = 100;
	rightEditor.wrapper.tabIndex = 101;

	// ÏßÄÏ†ÄÎ∂ÑÏùò ÎÅù
	const statusBar = InitializeStatusBar([
		{
			side: "center",
			key: "mode",
			label: "",
			get: () => (_alignedMode ? "üìñ" : "‚úèÔ∏è"),
			toggle: () => {
				if (_alignedMode) {
					disableAlignedMode();
				} else {
					enableAlignedMode();
				}
			},
		},
		{
			//üìã
			side: "center",
			key: "copyMode",
			//label: "üìã",
			label: "",
			get: () => (_copyMode === "raw" ? "üìÑ" : _copyMode === "formatted" ? "üñçÔ∏è" : "‚ÜîÔ∏è"),
			toggle: () => {
				if (_copyMode === "raw") {
					_copyMode = "formatted";
				} else if (_copyMode === "formatted") {
					_copyMode = "compare";
				} else {
					_copyMode = "raw";
				}
				updateButtons();
			},
		},
		{
			side: "left",
			key: "tokenization",
			label: "Îã®ÏúÑ",
			get: () => _diffOptions.tokenization,
			set: (value: TokenizationMode) => (_diffOptions.tokenization = value),
			options: [
				{ label: "Í∏ÄÏûê", value: "char" },
				{ label: "Îã®Ïñ¥", value: "word" },
				{ label: "Ï§Ñ", value: "line" },
			],
		},
		// {
		// 	side: "left",
		// 	key: "algorithm",
		// 	label: "ÏïåÍ≥†Î¶¨Ï¶ò",
		// 	get: () => _diffOptions.algorithm,
		// 	set: (value: DiffAlgorithm) => (_diffOptions.algorithm = value),
		// 	options: [
		// 		{ label: "Histogram", value: "histogram" },
		// 		{ label: "‚ö†Ô∏è Myers ‚ùå", value: "myers" },
		// 		{ label: "LCS DP", value: "lcs" },
		// 	],
		// },
		{
			side: "left",
			key: "whitespace",
			label: "Í≥µÎ∞±",
			get: () => _diffOptions.whitespace,
			set: (value: WhitespaceHandling) => (_diffOptions.whitespace = value),
			visible: () => _diffOptions.algorithm === "histogram" && _diffOptions.tokenization === "word",
			options: [
				{ label: "Ï†ïÍ∑úÌôî", value: "normalize" },
				{ label: "Î¨¥Ïãú", value: "ignore" },
			],
		},
		// {
		// 	side: "right",
		// 	key: "greedyMatch",
		// 	label: "Greedy Match",
		// 	get: () => _diffOptions.greedyMatch,
		// 	set: (value: boolean) => (_diffOptions.greedyMatch = value),
		// 	disabled: () => _diffOptions.algorithm === "lcs",
		// 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
		// },
		// {
		// 	side: "right",
		// 	key: "useLengthBias",
		// 	label: "Length Bias",
		// 	get: () => _diffOptions.useLengthBias,
		// 	set: (value: boolean) => (_diffOptions.useLengthBias = value),
		// 	disabled: () => _diffOptions.algorithm === "histogram",
		// 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
		// },
		// {
		// 	side: "right",
		// 	key: "maxGram",
		// 	label: "Max Gram",
		// 	get: () => _diffOptions.maxGram,
		// 	set: (value: number) => (_diffOptions.maxGram = value),
		// 	disabled: () => _diffOptions.algorithm === "histogram",
		// 	options: [1, 2, 3, 4, 5, 6, 7].reverse().map((v) => ({ label: v.toString(), value: v })),
		// },
		{
			side: "right",
			key: "diffs",
			label: "‚â†",
			get: () => {
				if (!_diffContext.done) {
					return "...";
				}
				return `${_diffContext.diffs!.length}`;
			},
		},
		{
			side: "right",
			key: "tokenCount",
			label: "#",
			get: () => {
				if (!_diffContext.leftTokens || !_diffContext.rightTokens) {
					return "...";
				}
				return `${_diffContext.leftTokens.length} / ${_diffContext.rightTokens.length}`;
			},
		},
		{
			side: "right",
			key: "processTime",
			label: "‚è±",
			get: () => {
				if (!_diffContext.done) {
					return "...";
				}
				return `${Math.ceil(_diffContext.processTime!)}ms`;
			},
		},
	]);
	const body = document.querySelector("body") as HTMLBodyElement;
	const diffList = document.getElementById("diffList") as HTMLUListElement;
	const highlightStyle = document.getElementById("highlightStyle") as HTMLStyleElement;
	const progress = document.getElementById("progress") as HTMLElement;
	const scrollSyncIndicator = document.getElementById("scrollSyncIndicator") as HTMLElement;
	const alignmentStyleElement = document.createElement("style");
	document.head.appendChild(alignmentStyleElement);

	const resizeObserver = new ResizeObserver(() => {
		_alignedDirty = true;
		if (_alignedMode) {
			recalculateAlignmentPaddingAndPositionsDebounced();
		} else if (_syncEditor) {
			// Ïñ¥Îäê ÏóêÎîîÌÑ∞Î•º Í∏∞Ï§ÄÏúºÎ°ú Ïã±ÌÅ¨Î•º ÌïòÎÉê?
			// Í∏∞Ï§ÄÏù¥ Îã®ÏàúÌïòÍ≥† Î™ÖÌôïÌïòÏßÄ ÏïäÏúºÎ©¥ Ïò§ÌûàÎ†§ Îçî ÌòºÎûÄÏä§Îü¨ÏõÄ.
			// 1. Ìè¨Ïª§Ïä§Î•º Í∞ÄÏßÑ ÏóêÎîîÌÑ∞?...
			// 2. ÎßàÏö∞Ïä§Ïª§ÏÑúÍ∞Ä Ïò¨Î†§ÏßÑ ÏóêÎîîÌÑ∞?...
			// 3. ÏµúÍ∑ºÏóê Ïä§ÌÅ¨Î°§Îêú ÏóêÎîîÌÑ∞?...
			// 4. Í∑ÄÏ∞ÆÎã§.
		}
	});
	resizeObserver.observe(container);

	const recalculateAlignmentPaddingAndPositionsDebounced = debounce(recalculateAlignmentPaddingAndPositions, 200);

	function getEditorCallbacks(editorName: EditorName) {
		const pendingDiffVisibilities = new Map();
		let updateDiffVisilitiesPending = false;

		return {
			onTextChanged: function () {
				computeDiff();
			},

			onMirrorUpdated: function () {
				_alignedDirty = true;
				if (_alignedMode) {
					recalculateAlignmentPaddingAndPositions();
				}
			},

			// ÌòÑÏû¨ ÌôîÎ©¥ ÏÉÅÏóê Î≥¥Ïù¥Îäî diff ÏïÑÏù¥ÌÖúÎì§.
			onDiffVisibilityChanged: (diffIndex: number, visible: boolean) => {
				pendingDiffVisibilities.set(diffIndex, visible);
				if (!updateDiffVisilitiesPending) {
					updateDiffVisilitiesPending = true;
					requestAnimationFrame(() => {
						updateDiffVisilitiesPending = false;
						for (const [diffIndex, visible] of pendingDiffVisibilities) {
							const listItem = _diffListItemElements[diffIndex];
							if (listItem) {
								const button = listItem.firstElementChild as HTMLElement;
								button.classList.toggle(editorName + "-visible", visible);
							}
						}
						pendingDiffVisibilities.clear();
					});
				}
			},
		};
	}

	function createWorker() {
		// Î≥¥Ïïà ÏÉÅ new Worker("worker.js")Îäî Ïã§Ìñâ ÏïàÎê®.
		let workerURL;
		const scriptElement = document.getElementById("worker.js") as HTMLScriptElement;
		const workerCode = scriptElement.textContent;
		if (workerCode!.length < 10) {
			workerURL = scriptElement.src; // "./dist/worker.js";
		} else {
			const blob = new Blob([workerCode!], { type: "application/javascript" });
			workerURL = URL.createObjectURL(blob);
		}
		const worker = new Worker(workerURL);

		return worker;
	}

	const { computeDiff } = (function () {
		const worker = createWorker();
		let _reqId = 0;
		let computeDiffTimeoutId: number | null = null;

		function* computeDiffGenerator(ctx: DiffContext) {
			let idleDeadline: IdleDeadline = yield ctx;
			ctx.leftTokens = tokenize(ctx.leftText, _diffOptions.tokenization);
			if (idleDeadline.timeRemaining() <= 1) {
				idleDeadline = yield;
			}

			ctx.rightTokens = tokenize(ctx.rightText, _diffOptions.tokenization);
			if (idleDeadline.timeRemaining() <= 1) {
				idleDeadline = yield;
			}

			const request: DiffRequest = {
				type: "diff",
				reqId: ctx.reqId,
				options: ctx.diffOptions,
				leftTokens: ctx.leftTokens!,
				rightTokens: ctx.rightTokens!,
			};

			worker.postMessage(request);
			updateButtons();
		}

		function computeDiff() {
			if (computeDiffTimeoutId) {
				cancelIdleCallback(computeDiffTimeoutId);
				//clearTimeout(computeDiffTimeoutId);
			}

			_currentDiffIndex = -1;
			_alignedDirty = true;

			const leftText = leftEditor.text;
			const rightText = rightEditor.text;

			body.classList.add("computing");
			body.classList.toggle("identical", leftText === rightText);
			progress.textContent = "...";

			const ctx = (_diffContext = {
				reqId: ++_reqId, //overflow ÎêòÎäî ÏàúÍ∞Ñ ÏßÄÍµ¨ Î©∏Îßù
				leftText: leftText,
				rightText: rightText,
				diffOptions: { ..._diffOptions },
				done: false,
				processTime: 0,
			});

			const generator = computeDiffGenerator(ctx);
			
			const step = (idleDeadline: IdleDeadline) => {
				computeDiffTimeoutId = null;
				const { done } = generator.next(idleDeadline);
				if (!done && ctx === _diffContext) {
					computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
				}
			};
			computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
		}

		worker.onmessage = function (e) {
			const data = e.data;
			if (data.type === "diff") {
				if (data.reqId === _reqId) {
					console.debug("diff response:", data);
					body.classList.remove("computing");
					_diffContext.rawEntries = data.diffs;
					postProcess(_diffContext);
					_diffContext.done = true;
					_diffContext.processTime = data.processTime;
					onDiffComputed(_diffContext);
				}
			} else if (data.type === "start") {
				progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
			}
		};

		function onDiffComputed(diffContext: DiffContext) {
			leftEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
			rightEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
			updateDiffList();
			updateButtons();
		}

		return { computeDiff };
	})();

	// ÏÜê Î≥º Ïó¨ÏßÄÍ∞Ä ÎßéÏùÄÎç∞... Ïúº...
	// Ïä§ÌÅ¨Î°§ ÏúÑÏπò Í≥ÑÏÇ∞ÌïòÎäîÍ≤å Ï¢Ä.. Ïùå...
	function enableAlignedMode() {
		// Ïä§ÌÅ¨Î°§ ÏúÑÏπòÎäî Ïñ¥ÎîîÏ™Ω ÏóêÎîîÌÑ∞Ïóê ÎßûÏ∂îÎÇò?
		// Ïó≠Ïãú Î™ÖÌôïÌïú Í∏∞Ï§ÄÏù¥ ÌïÑÏöî.

		if (!_alignedMode) {
			const currentSelectionRange = getSelectionRange();
			const currentEditor = _activeEditor || _lastFocusedEditor || rightEditor;
			const [firstVisibleLineEl, firstVisibleLineDistance] = currentEditor.getFirstVisibleLineElement();

			_alignedMode = true;
			leftEditor.mirror.tabIndex = 100;
			rightEditor.mirror.tabIndex = 101;
			leftEditor.setEditMode(false);
			rightEditor.setEditMode(false);
			body.classList.toggle("aligned", true);
			body.classList.toggle("edit", false);
			recalculateAlignmentPaddingAndPositions();

			if (currentSelectionRange) {
				restoreSelectionRange(currentSelectionRange);
			}

			updateButtons();

			requestAnimationFrame(() => {
				// Î†àÏù¥ÏïÑÏõÉÏù¥ ÎÅùÎÇú ÌõÑ ÎØ∏Î¶¨ Ï∞æÏïÑÎíÄÎçò Ï§Ñ ÏúÑÏπòÎ°ú Ïä§ÌÅ¨Î°§.
				let lineNum = Number(firstVisibleLineEl?.dataset?.lineNum) || 1;
				let distance = firstVisibleLineDistance || 0;
				currentEditor.scrollToLine(lineNum, distance);
				const theOtherEditor = currentEditor === leftEditor ? rightEditor : leftEditor;
				theOtherEditor.wrapper.scrollTop = currentEditor.wrapper.scrollTop;

				// Ìè¨Ïª§Ïä§Î•º Í∞ÄÏ†∏Ïïº aligned mode ÏßÑÏûÖ ÌõÑ Î∞îÎ°ú ÌÇ§Î≥¥ÎìúÎ°ú Ïä§ÌÅ¨Î°§ Ìï† Ïàò ÏûàÏùå.
				// Ïä§ÌÅ¨Î°§Ïù¥ ÎèôÍ∏∞ÌôîÎêòÎãà ÏÇ¨Ïã§ Ïñ¥ÎäêÏ™ΩÏù¥ Ìè¨Ïª§Ïä§Î•º Í∞ÄÏßÄÎì† ÏÉÅÍ¥Ä Î¨¥.
				currentEditor.mirror.focus();
			});
		}
	}

	function disableAlignedMode() {
		const currentSelectionRange = getSelectionRange();
		// console.log("currentSelectionRange", currentSelectionRange);

		// ÏùºÎã® editmodeÎ°ú Í∞ÄÍ∏∞ Ï†ÑÏóê ÌòÑÏû¨ ÌôîÎ©¥ ÏÉÅ Ï≤´Ï§ÑÏùÑ Î≥¥Ï°¥
		const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElement();
		const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElement();

		_alignedMode = false;
		leftEditor.setEditMode(true);
		rightEditor.setEditMode(true);
		leftEditor.mirror.removeAttribute("tabindex");
		rightEditor.mirror.removeAttribute("tabindex");
		leftEditor.mirror.contentEditable = "false";
		rightEditor.mirror.contentEditable = "false";
		body.classList.toggle("aligned", false);
		body.classList.toggle("edit", true);
		updateButtons();

		_preventScrollSync = true;
		requestAnimationFrame(() => {
			if (leftFirstLine) {
				leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
			}
			if (rightFirstLine) {
				rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
			}
			requestAnimationFrame(() => {
				_preventScrollSync = false;
			});
		});

		if (currentSelectionRange) {
			restoreSelectionRange(currentSelectionRange);
		}
	}

	function recalculateAlignmentPaddingAndPositions() {
		if (!_alignedDirty) {
			return;
		}
		if (!_diffContext.done) {
			return;
		}
		const anchors = _diffContext.anchors!,
			lhsTokens = _diffContext.leftTokens!,
			rhsTokens = _diffContext.rightTokens!,
			lhsLines = leftEditor.lineElements,
			rhsLines = rightEditor.lineElements,
			lhsLineHints = leftEditor.lineHints,
			rhsLineHints = rightEditor.lineHints;

		// ÏñòÎÑ§Îì§ÏùÄ ÏïåÏïÑÏÑú Ïä§Ïä§Î°ú Ïë•Ïë• ÏûêÎùºÍ≤å autoÎ°ú
		leftEditor.mirror.style.height = "auto";
		rightEditor.mirror.style.height = "auto";

		// Í∏∞Ï°¥ Ïä§ÌÉÄÏùº ÌïúÎ≤àÏóê ÎÇ†Î†§Î≤ÑÎ¶¨Í∏∞
		alignmentStyleElement.textContent = "";

		const leftAnchorEls = leftEditor.anchorElements,
			rightAnchorEls = rightEditor.anchorElements;

		let styleText = "";
		let leftDelta = 0,
			rightDelta = 0;

		for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
			const anchor = anchors[anchorIndex];
			const leftAnchorEl = leftAnchorEls[anchorIndex],
				rightAnchorEl = rightAnchorEls[anchorIndex];
			if (!leftAnchorEl || !rightAnchorEl) {
				continue;
			}
			const leftTop = leftAnchorEl.offsetTop,
				rightTop = rightAnchorEl.offsetTop;

			const leftY = leftTop + leftDelta,
				rightY = rightTop + rightDelta;

			let delta;
			if (anchor.type === "before") {
				delta = leftY - rightY;
				if (delta > LINE_HEIGHT) {
					const anchorLineIndex = anchor.leftLine - 1;
					// const anchorLineIndex = findIndexByPos(lhsLineHints, anchor.left);
					if (anchorLineIndex > 0) {
						const lastBlankLineIndex = anchorLineIndex - 1;
						const hint = lhsLineHints[lastBlankLineIndex];
						const collapseLimit = hint.numConsecutiveBlankLines - 1;

						let collapsedLines = 0;
						while (collapsedLines < collapseLimit) {
							const lineIndex = lastBlankLineIndex - collapsedLines;
							const lineEl = lhsLines[lineIndex];
							const lineHeight = lineEl.offsetHeight;

							if (lineHeight > delta) break;

							delta -= lineHeight;
							rightDelta += lineHeight;
							collapsedLines++;

							const lineNum = lineIndex + 1;
							styleText += `.aligned #leftMirror div[data-line-num="${lineNum}"] { display:none; }\n`;
						}
					}
				} else if (delta < -LINE_HEIGHT) {
					const anchorLineIndex = anchor.rightLine - 1;
					if (anchorLineIndex > 0) {
						const lastBlankLineIndex = anchorLineIndex - 1;
						const hint = rhsLineHints[lastBlankLineIndex];
						const collapseLimit = hint.numConsecutiveBlankLines - 1;

						let collapsedLines = 0;
						while (collapsedLines < collapseLimit) {
							const lineIndex = lastBlankLineIndex - collapsedLines;
							const lineEl = rhsLines[lineIndex];
							const lineHeight = lineEl.offsetHeight;

							if (-delta < lineHeight) break;

							delta += lineHeight;
							leftDelta += lineHeight;
							collapsedLines++;

							const lineNum = lineIndex + 1;
							styleText += `.aligned #rightMirror div[data-line-num="${lineNum}"] { display:none; }\n`;
						}
					}
				}
			} else if (anchor.type === "after") {
				const leftHeight = leftAnchorEl.offsetHeight,
					rightHeight = rightAnchorEl.offsetHeight;

				const leftB = leftY + leftHeight,
					rightB = rightY + rightHeight;
				delta = leftB - rightB;
			} else {
				console.warn("unknown anchor type", anchor.type);
				continue;
			}

			if (delta > 0) {
				styleText += `.aligned #rightAnchor${anchorIndex} { display:block; height:${delta}px; }\n`;
				rightDelta += delta;
			} else {
				styleText += `.aligned #leftAnchor${anchorIndex} { display:block; height:${-delta}px; }\n`;
				leftDelta += -delta;
			}
		}

		alignmentStyleElement.textContent = styleText;
		_alignedDirty = false;

		requestAnimationFrame(() => {
			// Î†àÏù¥ÏïÑÏõÉÏù¥ ÎÅùÎÇú ÌõÑ mirror ÎÜíÏù¥ Ï°∞Ï†ï
			const height = Math.max(leftEditor.mirror.offsetHeight, rightEditor.mirror.offsetHeight);
			leftEditor.mirror.style.height = `${height}px`;
			rightEditor.mirror.style.height = `${height}px`;
		});
	}

	function restoreSelectionRange({ editor, startOffset, endOffset }: { editor: Editor; startOffset: number; endOffset: number }) {
		if (editor) {
			editor.selectTextRange(startOffset, endOffset);
		}
	}

	function getSelectionRange(): { editor: Editor; startOffset: number; endOffset: number } | null {
		let editor: Editor | null = null;
		let [startOffset, endOffset] = leftEditor.getTextSelectionRange();
		if (startOffset !== null) {
			editor = leftEditor;
		} else {
			[startOffset, endOffset] = rightEditor.getTextSelectionRange();
			if (startOffset !== null) {
				editor = rightEditor;
			}
		}

		if (editor) {
			return {
				editor,
				startOffset: startOffset!,
				endOffset: endOffset!,
			};
		} else {
			return null;
		}
	}

	function syncScrollPosition(sourceEditor: Editor | null) {
		if (_preventScrollSync) {
			return;
		}

		if (!sourceEditor) {
			sourceEditor = _currentlyScrollingEditor || _activeEditor || _lastFocusedEditor;
			if (!sourceEditor) {
				return;
			}
		}

		if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
			return;
		}

		_preventScrollSync = true;
		const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
		let sourceAnchor = null;
		let targetAnchor = null;

		sourceAnchor = sourceEditor.getClosestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
		if (sourceAnchor) {
			const anchorIndex = Number(sourceAnchor.dataset.anchor);
			targetAnchor = targetEditor.anchorElements[anchorIndex];
		}

		if (sourceAnchor && targetAnchor) {
			const prevLastScrolledEditor = _lastScrolledEditor;
			const sourceWrapper = sourceEditor.wrapper;
			const targetWrapper = targetEditor.wrapper;
			targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
			_lastScrolledEditor = prevLastScrolledEditor;
		}
		requestAnimationFrame(() => {
			_preventScrollSync = false;
		});
	}

	let resetHighlightId: number | null = null;
	function highlightDiff(diffIndex: number) {
		if (resetHighlightId !== null) {
			clearTimeout(resetHighlightId);
		}
		highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
	box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
	animation: highlightAnimation 0.3s linear 3; 
	}`;
		resetHighlightId = setTimeout(() => {
			highlightStyle.textContent = "";
		}, 3000);
	}

	function highlightHeading(headingIndex: number) {
		if (resetHighlightId !== null) {
			clearTimeout(resetHighlightId);
		}
		highlightStyle.textContent = `[data-heading="${headingIndex}"] { 
	text-decoration-line: underline !important;
	}`;
		resetHighlightId = setTimeout(() => {
			highlightStyle.textContent = "";
		}, 2000);
	}

	document.addEventListener("mouseover", (e) => {
		if ((e.target as HTMLElement).dataset.diff !== undefined) {
			const diff = Number((e.target as HTMLElement).dataset.diff);
			highlightDiff(diff);
			return;
		}
		if ((e.target as HTMLElement).dataset.heading !== undefined) {
			const heading = Number((e.target as HTMLElement).dataset.heading);
			highlightHeading(heading);
		}
	});

	document.addEventListener("mouseout", (e) => {
		if ((e.target as HTMLElement).dataset.diff !== undefined) {
			highlightStyle.textContent = "";
			return;
		}
		if ((e.target as HTMLElement).dataset.heading !== undefined) {
			highlightStyle.textContent = "";
			if (resetHighlightId !== null) {
				clearTimeout(resetHighlightId);
			}
		}
	});

	// syncScrollToggle.addEventListener("click", () => {
	// 	toggleSyncScroll();
	// });

	// alignedModeToggle.addEventListener("click", () => {
	// 	if (_alignedMode) {
	// 		disableAlignedMode();
	// 	} else {
	// 		enableAlignedMode();
	// 	}
	// });

	function toggleSyncScroll() {
		_syncEditor = !_syncEditor;
		updateButtons();
	}

	function updateButtons() {
		if (_syncEditor && !_alignedMode) {
			scrollSyncIndicator.style.display = "block";
		} else {
			scrollSyncIndicator.style.display = "none";
		}
		statusBar.update();
	}

	function updateDiffList() {
		if (!_diffContext.done) {
			return;
		}

		const diffs = _diffContext.diffs!;
		const headings = _diffContext.headings ?? [];
		_diffListItemElements.length = 0;

		const leftWholeText = leftEditor.text;
		const rightWholeText = rightEditor.text;
		const fragment = document.createDocumentFragment();
		let headingIndex = 0;
		let leftPos = 0;
		for (let i = 0; i < diffs.length; i++) {
			const diff = diffs[i];
			const thisLeftPos = diff.left.pos;
			// Í∑ÄÏ∞ÆÏùåÏùò Ï†ïÏ†ê. ÎåÄÏ∂© ÎèåÏïÑÍ∞ÄÍ≤åÎßå... Îî± Í±∞Í∏∞ÍπåÏßÄÎßå...
			for (let j = leftPos; j < thisLeftPos; j++) {
				for (; headingIndex < headings.length; headingIndex++) {
					const heading = headings[headingIndex];
					if (heading.left.pos > thisLeftPos) {
						break;
					}
					const li = document.createElement("LI");
					const hd = document.createElement("A");
					hd.className = "heading";
					hd.dataset.heading = headingIndex.toString();
					hd.textContent = heading.ordinalText + " " + heading.title;
					li.appendChild(hd);
					fragment.appendChild(li);
				}
			}
			const li = document.createElement("LI");
			const button = document.createElement("MARK");
			button.draggable = true;
			button.dataset.diff = i.toString();
			button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
			li.appendChild(button);

			const leftText = leftWholeText.slice(diff.left.pos, diff.left.pos + diff.left.len);
			const leftSpan = document.createElement("SPAN");
			leftSpan.textContent = leftText;
			leftSpan.classList.add("left");
			button.appendChild(leftSpan);

			const rightText = rightWholeText.slice(diff.right.pos, diff.right.pos + diff.right.len);
			const rightSpan = document.createElement("SPAN");
			rightSpan.textContent = rightText;
			rightSpan.classList.add("right");
			button.appendChild(rightSpan);

			fragment.appendChild(li);
			_diffListItemElements[i] = li;
			leftPos = thisLeftPos;
		}

		for (; headingIndex < headings.length; headingIndex++) {
			const heading = headings[headingIndex];
			const li = document.createElement("LI");
			const hd = document.createElement("A");
			hd.className = "heading";
			hd.dataset.heading = headingIndex.toString();
			hd.textContent = heading.ordinalText + " " + heading.title;
			li.appendChild(hd);
			fragment.appendChild(li);
		}

		diffList.innerHTML = "";
		diffList.appendChild(fragment);
	}

	document.addEventListener("copy", (e) => {
		if (_diffContext.done === false) {
			return;
		}

		const selection = window.getSelection();
		if (!selection || selection.isCollapsed) return;

		const range = selection.getRangeAt(0);
		const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
			? leftEditor
			: rightEditor.wrapper.contains(range.commonAncestorContainer)
			? rightEditor
			: null;
		if (editor === null) {
			return;
		}

		const [startOffset, endOffset] = editor.getTextSelectionRange();
		if (startOffset === null || endOffset === null) return;
		if (_copyMode === "raw" && !_alignedMode) {
			return;
		}

		e.preventDefault();

		const text = editor.text;
		const tokens = editor === leftEditor ? _diffContext.leftTokens! : _diffContext.rightTokens!;
		const otherTokens = editor === leftEditor ? _diffContext.rightTokens! : _diffContext.leftTokens!;
		const rawEntries = _diffContext.rawEntries!;
		const sideKey = editor === leftEditor ? "left" : "right";
		const otherSideKey = sideKey === "left" ? "right" : "left";
		const diffs = _diffContext.diffs!;

		if (_copyMode === "raw") {
			const plain = editor.text.slice(startOffset, endOffset);
			e.clipboardData?.setData("text/plain", plain);
		} else if (_copyMode === "compare") {
			const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
			const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
			const startToken = tokens[startIndex];
			const endToken = tokens[endIndex - 1];
			const otherStartToken = otherTokens[mappedStartIndex];
			const otherEndToken = otherTokens[mappedEndIndex - 1];

			const startPos = startToken?.pos ?? 0;
			const endPos = endToken ? endToken.pos + endToken.len : startPos;
			const otherStartPos = otherStartToken?.pos ?? 0;
			const otherEndPos = otherEndToken ? otherEndToken.pos + otherEndToken.len : otherStartPos;

			const leftRuns = getTextRuns(
				"left",
				leftEditor.text,
				{ diffs },
				sideKey === "left" ? startPos : otherStartPos,
				sideKey === "left" ? endPos : otherEndPos
			);
			const rightRuns = getTextRuns(
				"right",
				rightEditor.text,
				{ diffs },
				sideKey === "right" ? startPos : otherStartPos,
				sideKey === "right" ? endPos : otherEndPos
			);

			const html = buildOutputHTML(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
			const plain = buildOutputPlainText(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);

			e.clipboardData?.setData("text/html", html);
			e.clipboardData?.setData("text/plain", plain);
		} else {
			const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
			const startToken = tokens[startIndex];
			const endToken = tokens[endIndex - 1];
			const startPos = startToken?.pos ?? 0;
			const endPos = endToken ? endToken.pos + endToken.len : startPos;
			const textRuns = getTextRuns(sideKey, leftEditor.text, { diffs }, startPos, endPos);

			const html = buildOutputHTMLFromRuns(text, textRuns, _outputOptions);
			const plain = buildOutputPlainTextFromRuns(text, textRuns, _outputOptions);
			e.clipboardData?.setData("text/html", html);
			e.clipboardData?.setData("text/plain", plain);
		}
	});

	document.addEventListener("keydown", (e) => {
		// Ïñ¥Îäê Îã®Ï∂ïÌÇ§Î•º Ïç®Ïïº ÏûòÏçºÎã§Í≥† ÏÜåÎ¨∏ÎÇòÎÉê?
		if (e.key === "F2") {
			e.preventDefault();

			if (e.shiftKey) {
				toggleSyncScroll();
				return;
			}

			if (_alignedMode) {
				disableAlignedMode();
			} else {
				enableAlignedMode();
			}

			return;
		}

		if (e.key === "F4") {
			e.preventDefault();

			if (_copyMode === "raw") {
				_copyMode = _lastNonRawCopyMode;
			} else {
				_lastNonRawCopyMode = _copyMode;
				_copyMode = "raw";
			}
			updateButtons();
			return;
		}

		if (e.key === "F8") {
			_diffOptions.whitespace = _diffOptions.whitespace === "ignore" ? "normalize" : "ignore";
		}

		// Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Î∏åÎùºÏö∞Ï†ÄÏùò Ï≤´Î≤àÏß∏ ÌÉ≠, ÎëêÎ≤àÏß∏ ÌÉ≠ÏùÑ ÏÑ†ÌÉùÌïòÎäî Îã®Ï∂ïÌÇ§Ïù∏Îç∞...
		// Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎäî Îã®Ï∂ïÌÇ§Î•º ÎçÆÏñ¥Ïì∞Îäî Í±¥ Ï†ïÎßê Î™ªÎêú ÏßìÏù¥Í∏¥ ÌïúÎç∞...
		// ÏÇ¨Ïö©ÏûêÏùò ÏùòÎèÑÎ•º Î¨¥ÏãúÌï¥Î≤ÑÎ¶¥ Ïàò ÏûàÎäî ÏïÑÏ£º ÎÇòÏÅú Îã®Ï∂ïÌÇ§ÏßÄÎßå... Ïù∏ÌÑ∞ÎÑ∑ÎèÑ ÏïàÎêòÎäî Ïª¥ÏóêÏÑú ÎàÑÍ∞Ä Ïó£ÏßÄÏóê ÌÉ≠ÏùÑ Ïó¨Îü¨Í∞ú Ïó¥Ïñ¥ÎÜìÍ≥† Ïì∏Íπå Ïã∂Îã§.
		if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
			e.preventDefault();
			if (_alignedMode) {
				disableAlignedMode();
			}
			const editor = e.key === "1" ? leftEditor : rightEditor;
			editor.editor.focus();
			return;
		}

		// mirrorÎ°ú Ïù¥Î≤§Ìä∏Ìï∏Îì§Îü¨ ÏòÆÍπÄ. ÌÖåÏä§Ìä∏ Ìï¥Î¥êÏïºÌï®Ìï®
		// if ((_alignedMode && !e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
		// 	disableAlignedMode();
		// 	return;
		// }

		// diff cycling
		if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
			e.preventDefault();
			if (_diffContext.done) {
				const diffs = _diffContext.diffs!;
				if (!diffs || diffs.length === 0) {
					return;
				}

				_currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
				if (_currentDiffIndex < 0) {
					_currentDiffIndex = diffs.length - 1;
				}
				if (_currentDiffIndex >= diffs.length) {
					_currentDiffIndex = 0;
				}
				scrollToDiff(_currentDiffIndex);
				highlightDiff(_currentDiffIndex);
			}
		}
	});

	diffList.addEventListener("click", (e) => {
		const diffIndex = Number((e.target as HTMLElement).dataset.diff);
		if (!isNaN(diffIndex)) {
			_currentDiffIndex = diffIndex;
			scrollToDiff(diffIndex);
			return;
		}
		const headingIndex = Number((e.target as HTMLElement).dataset.heading);
		if (!isNaN(headingIndex)) {
			scrollToHeading(headingIndex);
			return;
		}
	});

	function scrollToDiff(diffIndex: number) {
		_preventScrollSync = true;
		leftEditor.scrollToDiff(diffIndex);
		rightEditor.scrollToDiff(diffIndex);
		requestAnimationFrame(() => {
			_preventScrollSync = false;
		});
	}

	function scrollToHeading(headingIndex: number) {
		_preventScrollSync = true;
		leftEditor.scrollToHeading(headingIndex);
		rightEditor.scrollToHeading(headingIndex);
		requestAnimationFrame(() => {
			_preventScrollSync = false;
		});
	}

	for (const editor of [leftEditor, rightEditor]) {
		editor.wrapper.addEventListener("scroll", (e) => {
			if (_currentlyScrollingEditor !== null || _preventScrollSync) {
				return;
			}

			_lastScrolledEditor = _currentlyScrollingEditor = editor;
			if (_alignedMode) {
				// aligned modeÏùº ÎïåÎäî ÏñëÏ™Ω ÏóêÎîîÌÑ∞Ïùò ÎÜíÏù¥Í∞Ä Í∞ôÍ≤å Ïú†ÏßÄÎêòÎãà Îëò Îã§ overflow:visibleÎ°ú Ìï¥ÎëêÍ≥†
				// Î∂ÄÎ™®Í∞Ä Ïä§ÌÅ¨Î°§ÌïòÍ≤å ÌïòÎ©¥ Îëò Îã§ Í∞ôÏù¥ Ïä§ÌÅ¨Î°§Ïù¥ ÎêòÏßÄÎßå(ÎîúÎ†àÏù¥ Ï†ÑÌòÄ ÏóÜÏù¥ ÏôÑÏ†Ñ ÏûêÏó∞Ïä§ÎüΩÍ≤å!) Í∑∏Î†áÍ≤å ÎßåÎì§Î©¥ Ïä§ÌÅ¨Î°§Î∞îÍ∞Ä ÌïòÎÇòÎßå Î≥¥Ïù¥ÎäîÍ≤å ÏÉùÍ∞ÅÎ≥¥Îã§ Ïñ¥ÏÉâÌïòÍ≥† Î∂àÌé∏ÌïòÎã§.
				// Í∑∏ÎûòÏÑú Í∑∏ÎÉ• Í∞ïÏ†úÎ°ú Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞Ìôî ÏãúÌÇ¥.
				if (editor === leftEditor) {
					rightEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
				} else {
					leftEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
				}
			} else if (_syncEditor) {
				syncScrollPosition(editor);
			}

			if (_resetCurrentlyScrollingEditorId) {
				cancelAnimationFrame(_resetCurrentlyScrollingEditorId);
			}
			_resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
				_currentlyScrollingEditor = null;
			});
		});

		function onFocus() {
			_activeEditor = _lastFocusedEditor = editor;
		}

		function onBlur() {
			_activeEditor = null;
		}
		editor.editor.addEventListener("focus", onFocus);
		editor.mirror.addEventListener("focus", onFocus);
		editor.editor.addEventListener("blur", onBlur);
		editor.mirror.addEventListener("blur", onBlur);

		editor.editor.addEventListener("keydown", (e) => {
			if (e.key === " " && e.ctrlKey) {
				// ÏóêÎîîÌÑ∞ÏóêÏÑú Ìé∏Ïßë Ï§ë Î∞òÎåÄÏ™Ω ÏóêÎîîÌÑ∞Ïùò Ïä§ÌÅ¨Î°§ ÏúÑÏπòÎ•º ÌòÑÏû¨ ÏóêÎîîÌÑ∞Ïùò ÎÇ¥Ïö©Ïóê ÎßûÏ∂î...Î†§Í≥† ÏãúÎèÑÎßå Ìï¥ Î¥Ñ.
				syncScrollPosition(editor);
				return;
			}

			if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
				// Ïù¥Ï†ïÎèÑ Ïä§ÌÅ¨Î°§ÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎêòÏñ¥ÎêòÎäîÍ±∞ ÏïÑÎãàÏïº?? Ïù¥ Í∏∞Îä• ÎÇòÎßå Ïì∞ÎÇò?
				// Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ Î∞ñÏùò Îî± ÌïúÎëêÏ§Ñ! Îî± Í∑∏Ï†ïÎèÑÎßå Î≥¥Î©¥ ÎêúÎã§ Ïã∂ÏùÑ Îïå?
				// ÌÖçÏä§Ìä∏Ïª§ÏÑúÍ∞Ä Ï§ëÏïô Î∂ÄÎ∂ÑÏóê ÏúÑÏπòÌïòÏßÄ ÏïäÏúºÎ©¥ ÎßàÏùåÏù¥ ÎÜìÏù¥ÏßÄ ÏïäÏïÑÏÑú ÏßÄÍ∏à ÎãπÏû• ÏúÑÏïÑÎûòÎ°ú Ï°∞Í∏à Ïä§ÌÅ¨Î°§ Ìï¥ÏïºÎßå Ìï† Îïå!!!!
				const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2;
				editor.wrapper.scrollTop += delta;
				e.preventDefault();
			}
		});

		editor.mirror.addEventListener("paste", (e) => {
			disableAlignedMode();
		});

		editor.mirror.addEventListener("cut", (e) => {
			disableAlignedMode();
		});

		editor.mirror.addEventListener("keydown", (e) => {
			// aligned Î™®ÎìúÏóêÏÑú Í∞ÑÎã®Ìïú Ìé∏ÏßëÏùÑ ÏãúÎèÑÌï† Îïå ÏûΩÏã∏Í≤å aligned Î™®ÎìúÏóêÏÑú ÎÇòÍ∞ÄÍ∏∞!
			// aligned Î™®ÎìúÏóêÏÑú ÎÇòÍ∞àÎïå mirrorÏóêÏÑú ÏÑ†ÌÉùÎêòÏñ¥ÏûàÎçò ÌÖçÏä§Ìä∏ ÏòÅÏó≠Ïù¥ contenteditable ÎÇ¥ÏóêÏÑú Î≥µÏõêÏù¥ ÎêòÎØÄÎ°ú
			// Í∑∏ Ïù¥ÌõÑÎäî Î≥µÏõêÎêú ÌÖçÏä§Ìä∏ ÏòÅÏó≠ÏùÑ Î∏åÎùºÏö∞Ï†ÄÍ∞Ä keyÏóê ÎßûÍ≤å Ï≤òÎ¶¨Ìï¥Ï§å. Ï°∞Í∏à ÏñçÏÇΩ?
			if ((!e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
				disableAlignedMode();
				return;
			}

			// mirrorÏóêÏÑú Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù ÏãúÏóê Ï∞Ω Ï†ÑÏ≤¥Ïùò ÌÖçÏä§Ìä∏Í∞Ä ÏïÑÎãå ÌòÑÏû¨ ÏóêÎîîÌÑ∞Ïùò ÌÖçÏä§Ìä∏Îßå ÏÑ†ÌÉùÎêòÎèÑÎ°ù.
			if (e.ctrlKey && (e.key === "A" || e.key === "a")) {
				e.preventDefault();
				editor.selectTextRange(0, editor.text.length);
				return;
			}
		});

		// editor.editor.addEventListener("click", (e) => {
		// 	if (e.ctrlKey) {
		// 		enableAlignedMode(true);
		// 	}
		// });

		function onClick(e: MouseEvent) {
			if (e.ctrlKey && _alignedMode) {
				_activeEditor = editor;
				disableAlignedMode();
				return;
			}
			if (e.altKey) {
				const [start, end] = editor.getTextSelectionRange();
				if (start !== null && end !== null && start === end) {
					_activeEditor = editor;
					disableAlignedMode();
					setTimeout(() => {
						//syncScrollPosition(editor);
						document.execCommand("insertText", false, " " + MANUAL_ANCHOR1 + " ");
						requestAnimationFrame(() => {
							editor.updateText();
						});
					}, 0);
					return;
				}
			}
		}

		editor.editor.addEventListener("click", onClick);
		editor.mirror.addEventListener("click", onClick);
	}

	// Î¨¥ÏãùÌïòÍ≤å ÌÅ∞ Ìï®Ïàò
	// Ï∞ùÏ∞ùÌïúÎç∞... Ïû¨ÎØ∏ ÏóÜÎäî Î∂ÄÎ∂ÑÏù¥Îùº...
	function postProcess(diffContext: DiffContext) {
		let prevEntry: DiffEntry | null = null;
		const leftText = diffContext.leftText!;
		const rightText = diffContext.rightText!;
		const leftTokens = diffContext.leftTokens!;
		const rightTokens = diffContext.rightTokens!;
		const rawEntries = diffContext.rawEntries!;

		const diffs: DiffEntry[] = [];
		const anchors: Anchor[] = [];
		const sectionHeadings: SectionHeading[] = [];
		const MAX_ANCHOR_SKIP = 5;
		let anchorSkipCount = 0;

		for (let i = 0; i < rawEntries.length; i++) {
			const entry = rawEntries[i];
			if (entry.type) {
				if (prevEntry) {
					console.assert(prevEntry.left.pos + prevEntry.left.len === entry.left.pos, prevEntry, entry);
					console.assert(prevEntry.right.pos + prevEntry.right.len === entry.right.pos, prevEntry, entry);
					prevEntry.type |= entry.type;
					prevEntry.left.len += entry.left.len;
					prevEntry.right.len += entry.right.len;
				} else {
					prevEntry = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
					//prevEntry = entry;
				}
			} else {
				if (prevEntry) {
					addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
					// mappings.push(prevEntry);
				}
				prevEntry = null;

				const leftToken = leftTokens[entry.left.pos];
				const rightToken = rightTokens[entry.right.pos];
				if (leftToken.flags & rightToken.flags & FIRST_OF_LINE) {
					// ÏïµÏª§ Ï∂îÍ∞Ä
					addAnchor("before", leftToken.pos, leftToken.lineNum, rightToken.pos, rightToken.lineNum, null);

					if (leftToken.flags & rightToken.flags & SECTION_HEADING) {
						addHeading(i);
					}
				}
				// mappings.push(entry);
			}
		}
		addAnchor("before", leftText.length, -1, rightText.length, -1, null);

		if (prevEntry) {
			addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
			// mappings.push(prevEntry);
		}

		function addHeading(entryIndex: number) {
			const entry = rawEntries[entryIndex];
			const leftToken = leftTokens[entry.left.pos];
			const rightToken = rightTokens[entry.right.pos];

			if (leftToken.flags & SECTION_HEADING && rightToken.flags & SECTION_HEADING) {
				const ordinalText = leftToken.text;

				// Ìó§Îî© ÎÅù Ï∞æÍ∏∞
				let leftEndPos = entry.left.pos + entry.left.len;
				let rightEndPos = entry.right.pos + entry.right.len;
				for (let j = entryIndex; j < rawEntries.length; j++) {
					const entry2 = rawEntries[j];
					if (entry2.type !== 0) {
						return;
					}
					const leftLastToken = leftTokens[entry2.left.pos + entry2.left.len - 1];
					if (leftLastToken.flags & LAST_OF_LINE) {
						leftEndPos = entry2.left.pos + entry2.left.len;
						rightEndPos = entry2.right.pos + entry2.right.len;
						break;
					}
				}

				if (leftEndPos - entry.left.pos <= 1) {
					return; // ÎÇ¥Ïö© ÏóÜÏúºÎ©¥ Î¨¥Ïãú
				}

				const headingText = leftText.substring(leftTokens[entry.left.pos].pos, leftTokens[leftEndPos - 1].pos + leftTokens[leftEndPos - 1].len);

				const title = headingText.slice(ordinalText.length).trim();

				sectionHeadings.push({
					ordinalText,
					title,
					left: {
						pos: leftTokens[entry.left.pos].pos,
						len: leftTokens[leftEndPos - 1].pos + leftTokens[leftEndPos - 1].len - leftTokens[entry.left.pos].pos,
					},
					right: {
						pos: rightTokens[entry.right.pos].pos,
						len: rightTokens[rightEndPos - 1].pos + rightTokens[rightEndPos - 1].len - rightTokens[entry.right.pos].pos,
					},
				});
			}
		}

		function addAnchor(type: "before" | "after", leftPos: number, leftLine: number, rightPos: number, rightLine: number, diffIndex: number | null) {
			if (leftPos === undefined || rightPos === undefined) {
				console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
			}

			//ÏïµÏª§Í∞Ä ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎäî Í±∏ Î∞©ÏßÄ! section headingÏù∏ Í≤ΩÏö∞ Ïä§ÌÇµÌïòÎ©¥ ÏïàÎêòÍ≥† Í∑∏Í±∏ ÌåêÎã®ÌïòÎ†§Î©¥ tokenÏù¥ ÌïÑÏöîÌï®... Í∑ÄÏ∞ÆÏïÑ
			// if (diffIndex === null && anchorSkipCount < MAX_ANCHOR_SKIP && anchors.length > 0) {
			// 	const lastAnchor = anchors[anchors.length - 1];
			// 	if (lastAnchor.type === type && lastAnchor.diffIndex === null && leftLine - lastAnchor.leftLine <= 1 && rightLine - lastAnchor.rightLine <= 1) {
			// 		anchorSkipCount++;
			// 		return;
			// 	}
			// }
			// anchorSkipCount = 0;

			if (type === "before") {
				// before ÏïµÏª§Îäî Ìï≠ÏÉÅ Ï§ÑÏùò ÏãúÏûëÏúÑÏπòÏùº ÎïåÎßå Ï∂îÍ∞ÄÌïòÎØÄÎ°ú Ï§ÑÎ∞îÍøà Î¨∏ÏûêÎßå ÌôïÏù∏ÌïòÎ©¥ ÎêúÎã§!
				while (leftPos > 0 && leftText[leftPos - 1] !== "\n") {
					leftPos--;
				}
				while (rightPos > 0 && rightText[rightPos - 1] !== "\n") {
					rightPos--;
				}
			} else if (type === "after") {
				// empty diffÏùò afterÏïµÏª§Îäî Ïù¥ÌõÑÏóê Îã§Î•∏ ÌÜ†ÌÅ∞Ïù¥ Ï°¥Ïû¨Ìï† Ïàò ÏûàÏùå.
				// Í≥µÎ∞±Ïù¥ ÏïÑÎãå Î¨∏ÏûêÍ∞Ä ÎÇòÏò§Î©¥ Î©àÏ∂îÍ≥† Í∏∞Î≥∏ ÏúÑÏπò ÏÇ¨Ïö©.
				let p;
				p = leftPos;
				while (p < leftText.length) {
					const ch = leftText[p++];
					if (ch === "\n") {
						leftPos = p - 1;
						break;
					} else if (!SPACE_CHARS[ch]) {
						break;
					}
				}
				p = rightPos;
				while (p < rightText.length) {
					const ch = rightText[p++];
					if (ch === "\n") {
						rightPos = p - 1;
						break;
					} else if (!SPACE_CHARS[ch]) {
						break;
					}
				}
			}

			if (anchors.length > 0) {
				let lastAnchor = anchors[anchors.length - 1];
				if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
					return;
				}
				if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
					if (type === lastAnchor.type || type === "before") {
						return;
					}
				}
			}

			anchors.push({ type, left: leftPos, leftLine, right: rightPos, rightLine, diffIndex });
		}

		function addDiff(leftIndex: number, leftCount: number, rightIndex: number, rightCount: number) {
			let leftPos, leftLen, rightPos, rightLen;
			let leftBeforeAnchorPos,
				leftBeforeAnchorLine,
				rightBeforeAnchorPos,
				rightBeforeAnchorLine,
				leftAfterAnchorPos,
				leftAfterAnchorLine,
				rightAfterAnchorPos,
				rightAfterAnchorLine;
			let leftEmpty, rightEmpty;
			let type: DiffType;
			let asBlock = false;

			// ÏñëÏ™ΩÏóê ÎåÄÏùëÌïòÎäî ÌÜ†ÌÅ∞Ïù¥ Î™®Îëê Ï°¥Ïû¨ÌïòÎäî Í≤ΩÏö∞. Ïâ¨Ïö¥ ÏºÄÏù¥Ïä§
			if (leftCount > 0 && rightCount > 0) {
				type = 3;
				let leftTokenStart = leftTokens[leftIndex];
				let leftTokenEnd = leftTokens[leftIndex + leftCount - 1];
				let rightTokenEnd = rightTokens[rightIndex + rightCount - 1];
				let rightTokenStart = rightTokens[rightIndex];

				leftPos = leftTokenStart.pos;
				leftLen = leftTokenEnd.pos + leftTokenEnd.len - leftPos;
				leftEmpty = false;
				rightPos = rightTokenStart.pos;
				rightLen = rightTokenEnd.pos + rightTokenEnd.len - rightPos;
				rightEmpty = false;

				// ÏÉùÍ∞Å: ÌïúÏ™ΩÎßå Ï§ÑÏùò Ï≤´ ÌÜ†ÌÅ∞Ïùº ÎïåÏóêÎèÑ ÏïµÏª§Î•º ÎÑ£ÏùÑÍπå? ÏïµÏª§Ïóê display:blockÏùÑ Ï§òÏÑú Í∞ïÏ†úÎ°ú Ï§ÑÎ∞îÍøà ÏãúÌÇ® ÌõÑÏóêÏóê
				// Ï¢åÏö∞ Ï†ïÎ†¨ÏùÑ Ìï† Ïàò ÏûàÏùÑ Í≤É Í∞ôÍ∏∞ÎèÑ ÌïúÎç∞...
				if (leftTokenStart.flags & rightTokenStart.flags & FIRST_OF_LINE) {
					leftBeforeAnchorPos = leftPos;
					rightBeforeAnchorPos = rightPos;

					while (leftBeforeAnchorPos > 0 && leftText[leftBeforeAnchorPos - 1] !== "\n") {
						leftBeforeAnchorPos--;
					}

					while (rightBeforeAnchorPos > 0 && rightText[rightBeforeAnchorPos - 1] !== "\n") {
						rightBeforeAnchorPos--;
					}
					// addAnchor("before", leftAnchorPos, rightAnchorPos, null);

					if (leftTokenEnd.flags & rightTokenEnd.flags & LAST_OF_LINE) {
						asBlock = true;
						leftAfterAnchorPos = leftPos + leftLen;
						rightAfterAnchorPos = rightPos + rightLen;
						if (leftText[leftAfterAnchorPos] !== "\n") {
							do {
								leftAfterAnchorPos++;
							} while (leftAfterAnchorPos < leftText.length && leftText[leftAfterAnchorPos] !== "\n");
						}
						if (rightText[rightAfterAnchorPos] !== "\n") {
							do {
								rightAfterAnchorPos++;
							} while (rightAfterAnchorPos < rightText.length && rightText[rightAfterAnchorPos] !== "\n");
						}

						// while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
						// 	leftAnchorPos++;
						// }
						// while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
						// 	rightAnchorPos++;
						// }
						// addAnchor("after", leftBeforeAnchorPos, rightBeforeAnchorPos, null);
					}
				}
			} else {
				// ÌïúÏ™ΩÏù¥ ÎπÑÏñ¥ÏûàÏùå.
				// Îã®ÏàúÌïòÍ≤å ÌÜ†ÌÅ∞ ÏÇ¨Ïù¥Ïóê ÏúÑÏπòÏãúÏºúÎèÑ ÎêòÏßÄÎßå ÎêòÎèÑÎ°ùÏù¥Î©¥ ÎåÄÏùëÌïòÎäî Ï™ΩÍ≥º Ïú†ÏÇ¨Ìïú ÏúÑÏπò(Ï§ÑÏãúÏûë/Ï§ÑÎÅù)Ïóê ÏúÑÏπòÏãúÌÇ§Í∏∞ ÏúÑÌï¥...
				// ÏûêÍæ∏ Ïù¥Îü∞Ï†ÄÎü∞ ÏãúÎèÑÎ•º ÌïòÎã§Î≥¥Îãà ÎÇúÏû•ÌåêÏù∏Îç∞ ÎßåÏßÄÍ∏∞ Ïã´Ïùå...
				let longSideText, shortSideText;
				let longSideIndex, longSideCount, longSideTokens;
				let shortSideIndex, shortSideTokens;
				let longSidePos, longSideLen;
				let shortSidePos, shortSideLen;
				let longSideBeforeAnchorPos, shortSideBeforeAnchorPos, longSideBeforeAnchorLine, shortSideBeforeAnchorLine;
				let longSideAfterAnchorPos, shortSideAfterAnchorPos, longSideAfterAnchorLine, shortSideAfterAnchorLine;
				let longSideTokenStart, longSideTokenEnd;
				let shortSideBeforeToken, shortSideAfterToken;

				if (leftCount > 0) {
					type = 1; // 1: left
					longSideText = leftText;
					longSideTokens = leftTokens;
					longSideIndex = leftIndex;
					longSideCount = leftCount;
					shortSideText = rightText;
					shortSideTokens = rightTokens;
					shortSideIndex = rightIndex;
					leftEmpty = false;
					rightEmpty = true;
				} else {
					type = 2; // 2: right
					longSideText = rightText;
					longSideTokens = rightTokens;
					longSideIndex = rightIndex;
					longSideCount = rightCount;
					shortSideText = leftText;
					shortSideTokens = leftTokens;
					shortSideIndex = leftIndex;
					leftEmpty = true;
					rightEmpty = false;
				}
				longSideTokenStart = longSideTokens[longSideIndex];
				longSideTokenEnd = longSideTokens[longSideIndex + longSideCount - 1];
				shortSideBeforeToken = shortSideTokens[shortSideIndex - 1];
				shortSideAfterToken = shortSideTokens[shortSideIndex];

				longSidePos = longSideTokenStart.pos;
				longSideLen = longSideTokenEnd.pos + longSideTokenEnd.len - longSidePos;
				shortSidePos = shortSideBeforeToken ? shortSideBeforeToken.pos + shortSideBeforeToken.len : 0;
				shortSideLen = 0;

				const longSideIsFirstWord = longSideTokenStart.flags & FIRST_OF_LINE;
				const longSideIsLastWord = longSideTokenEnd.flags & LAST_OF_LINE;
				const shortSideIsOnLineEdge =
					shortSideTokens.length === 0 ||
					(shortSideBeforeToken && shortSideBeforeToken.flags & LAST_OF_LINE) ||
					(shortSideAfterToken && shortSideAfterToken.flags & FIRST_OF_LINE);

				let shortSidePushedToNextLine = false;
				// base posÎäî ÎêòÎèÑÎ°ùÏù¥Î©¥ ÏïûÏ™ΩÏúºÎ°ú Ïû°Ïûê. ÎÇúÎç∞ÏóÜÏù¥ ÎπàÏ§Ñ 10Í∞ú Ïä§ÌÇµÌïòÍ≥† diffÍ∞Ä ÏãúÏûëÎêòÎ©¥ Ïù¥ÏÉÅÌïòÏûêÎÇò.
				if (shortSideIsOnLineEdge) {
					// Ï§ÑÏùò Í≤ΩÍ≥ÑÏóê empty diffÎ•º ÌëúÏãúÌïòÎäî Í≤ΩÏö∞ ÌòÑÏû¨ Ï§ÑÏùò ÎÅùÏù¥ÎÇò Îã§Ïùå Ï§ÑÏùò ÏãúÏûë Ï§ë "Ï†ÅÏ†àÌïòÍ≤å" ÏÑ†ÌÉù. ÌòÑÏû¨ Ï§ÑÏùò ÎÅù(Ïù¥Ï†Ñ ÌÜ†ÌÅ∞Ïùò Îí§)Ïóê ÏúÑÏπò Ï§ëÏûÑ.
					if (longSideIsFirstWord) {
						if (shortSidePos !== 0) {
							// posÍ∞Ä 0Ïù¥ ÏïÑÎãå Í≤ΩÏö∞Îäî Ïù¥Ï†Ñ ÌÜ†ÌÅ∞Ïùò Îí§Î°ú ÏúÑÏπòÎ•º Ïû°ÏùÄ Í≤ΩÏö∞ÎãàÍπå Îã§Ïùå Ï§ÑÎ∞îÍøàÏùÑ Ï∞æÏïÑÏÑú Í∑∏ Ï§ÑÎ∞îÍøà Îí§Î°ú Î∞ÄÏñ¥Ï§å
							// Ï£ºÏùò: ÌòÑÏû¨ ÏúÑÏπò Ïù¥ÌõÑÏóê Ï§ÑÎ∞îÍøàÏù¥ ÏûàÎäîÏßÄ ÏóÜÎäîÏßÄ ÌôïÏù∏ÌïòÍ∏∞Î≥¥Îã§Îäî ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Ïùò ÎßàÏßÄÎßâÏóê Ï§ÑÎ∞îÍøàÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Í∞ïÏ†úÎ°ú Ï§ÑÎ∞îÍøàÏùÑ Î∂ôÏó¨Ï£ºÎäîÍ≤å Ìé∏Ìï®.
							// ÏûäÏßÄÎßêÍ≥† Íº≠ ÏõêÎ≥∏ÌÖçÏä§Ìä∏Ïùò ÎÅùÏóê Ï§ÑÎ∞îÍøà ÌïòÎÇò Î∂ôÏùº Í≤É.
							// const maxPos = shortSideAfterToken ? shortSideAfterToken.pos - 1 : shortSideText.length - 1;
							// while (shortSidePos < maxPos && shortSideText[shortSidePos++] !== "\n");
							while (shortSideText[shortSidePos++] !== "\n");
							shortSidePushedToNextLine = true;
						}

						// ÏñëÏ™Ω Î™®Îëê Ï§ÑÏùò ÏãúÏûë Î∂ÄÎ∂ÑÏóê ÏúÑÏπòÌïòÎØÄÎ°ú ÏïµÏª§ Ï∂îÍ∞Ä.
						// Îπà diffÍ∞Ä Ï§Ñ ÏãúÏûëÏù¥ÎÇò Ï§Ñ ÎÅù ÏúÑÏπòÏóê ÏûàÎã§Î©¥ ÌïòÎÇòÏùò Ï§ÑÎ°ú ÌëúÏãúÎêòÍ≤å Ìï† Ïàò ÏûàÏùå(css ÏÇ¨Ïö©)
						longSideBeforeAnchorPos = longSidePos;
						longSideBeforeAnchorLine = longSideTokenStart.lineNum;
						shortSideBeforeAnchorPos = shortSidePos;
						shortSideBeforeAnchorLine = (shortSideBeforeToken ? shortSideBeforeToken.lineNum : 1) + (shortSidePushedToNextLine ? 1 : 0);
						if (
							longSideIsLastWord
							// && !shortSideAfterToken || (shortSideBeforeToken && shortSideAfterToken.lineNum - shortSideBeforeToken.lineNum > 1)
						) {
							asBlock = true;
							longSideAfterAnchorPos = longSidePos + longSideLen;
							longSideAfterAnchorLine = longSideTokenEnd.lineNum;
							shortSideAfterAnchorPos = shortSidePos;
							shortSideAfterAnchorLine = shortSideBeforeAnchorLine;
						}
					}
				}

				if (leftCount > 0) {
					leftPos = longSidePos;
					leftLen = longSideLen;
					leftEmpty = false;
					leftBeforeAnchorPos = longSideBeforeAnchorPos;
					leftBeforeAnchorLine = longSideBeforeAnchorLine;
					leftAfterAnchorPos = longSideAfterAnchorPos;
					leftAfterAnchorLine = longSideAfterAnchorLine;
					rightPos = shortSidePos;
					rightLen = shortSideLen;
					rightEmpty = true;
					rightBeforeAnchorPos = shortSideBeforeAnchorPos;
					rightBeforeAnchorLine = shortSideBeforeAnchorLine;
					rightAfterAnchorPos = shortSideAfterAnchorPos;
					rightAfterAnchorLine = shortSideAfterAnchorLine;
				} else {
					leftPos = shortSidePos;
					leftLen = shortSideLen;
					leftEmpty = true;
					leftBeforeAnchorPos = shortSideBeforeAnchorPos;
					leftAfterAnchorPos = shortSideAfterAnchorPos;
					rightPos = longSidePos;
					rightLen = longSideLen;
					rightEmpty = false;
					rightBeforeAnchorPos = longSideBeforeAnchorPos;
					rightBeforeAnchorLine = longSideBeforeAnchorLine;
					rightAfterAnchorPos = longSideAfterAnchorPos;
					rightAfterAnchorLine = longSideAfterAnchorLine;
				}
			}

			if (leftBeforeAnchorPos !== undefined && rightBeforeAnchorPos !== undefined) {
				addAnchor("before", leftBeforeAnchorPos, leftBeforeAnchorLine!, rightBeforeAnchorPos, rightBeforeAnchorLine!, diffs.length);
			}
			if (leftAfterAnchorPos !== undefined && rightAfterAnchorPos !== undefined) {
				addAnchor("after", leftAfterAnchorPos, leftAfterAnchorLine!, rightAfterAnchorPos, rightAfterAnchorLine!, diffs.length);
			}

			const newEntry: DiffEntry = {
				type: type,
				left: {
					pos: leftPos,
					len: leftLen,
					// empty: leftEmpty,
				},
				right: {
					pos: rightPos,
					len: rightLen,
					// empty: rightEmpty,
				},
				asBlock,
			};
			diffs.push(newEntry);
		}

		diffContext.diffs = diffs;
		diffContext.anchors = anchors;
		diffContext.headings = sectionHeadings;
		// return { diffs, anchors, leftTokenCount: leftTokens.length, rightTokenCount: rightTokens.length, sectionHeadings };
	}

	disableAlignedMode();
	leftEditor.updateText();
	rightEditor.updateText();
	_diffContext = {
		reqId: 0,
		leftText: leftEditor.text,
		rightText: rightEditor.text,
		diffOptions: { ..._diffOptions },
		done: false,
	};
	computeDiff();

	return {
		get alignedMode() {
			return _alignedMode;
		},

		set alignedMode(value) {
			if (!!value) {
				enableAlignedMode();
			} else {
				disableAlignedMode();
			}
		},
		get dump() {
			// ÎîîÎ≤ÑÍπÖ Ìï† Îïå...
			return {
				_diffContext: _diffContext,
				// diffs: _diffResult?.diffs,
				// anchors: _diffResult?.anchors,
				diffOptions: _diffOptions,
				leftEditor,
				rightEditor,
				activeEditor: _activeEditor,
			};
		},

		compute: computeDiff,

		diffOptions: _diffOptions,

		get outputOptions() {
			return _outputOptions;
		},
	};
})();
