<!DOCTYPE html>
<!--
# DiffSeek 

### 개요
- 정말 센스만점 이름. 중국산 DeepSeek 아님. diff를 seek함.
- 한글자 한글자 눈으로 비교하는건 죽어도 못하겠고 죽어도 하기 싫어서.
- 공백 무시. 공백을 완전히 무시하는건 완전히 의도된 것임. **업무매뉴얼의 줄바꿈 위치는 절대로 문장의 끝 혹은 단락의 끝과 일치하지 않음!** 공백을 전혀 무시하지 않거나 정규화(여러개의 연속된 공백을 하나로 인식)해서 비교하는 코드를 짜는게 100만배 쉽고 계산속도도 훨씬 빠름. (토글 가능: `DiffSeek.diffOptions.whitespace = "ignore" | "normalize"`)
- 단어 단위 diff가 기본. 글자 단위 diff는 성능도 성능이지만 사람의 눈에 오히려 더 피곤하기만 함. 줄 단위의 경우도 문서마다 줄바꿈의 위치가 지멋대로라 비효율적임. (토글 가능: `DiffSeek.diffOptions.tokenization = "char" | "word" | "line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

### 구현 의도? 참고사항?
- 양쪽에 텍스트 붙여넣고 실행버튼 딱~ 누르면 diff들이 표시되.... 
    *왜???? 버튼을 뭐하러 눌러?*
    **diff는 텍스트 변경시 실시간으로, 입력한 텍스트 바로 그 자리에 보여줘야 함!!** 매번 귀찮게 버튼 누르는 짓은 하고 싶지 않잖아? 솔직히 입력과 출력을 분리하는 게 더 훨씬 쉬움.
- 실시간으로 업데이트가 일어나는 도중에도 편집을 방해하면 안됨. 미세한 딜레이라든지 의도하지 않은 커서위치 변경, 한글입력상태 복원 등등(한글입력상태 복원 방법은 없다 보면 됨. 우회하는 방법은 업데이트를 안하는것, 최소한 현재 커서가 위치한 노드에 대해서는 업데이트를 안하고 미루는 방법이 거의 유일함).
- 업데이트마다 DOM을 완전히 싹 갈아엎지 말고 가능한 경우 기존 노드들을 재사용.
- 편집기(그냥 단순 `<div contenteditable>`임)의 기본적인 기능(복붙,undo/redo,...)들은 되도록 브라우저에게 넘길 것. 이런 기능들은 숨쉬기와 같아서 예상대로 작동 안하는 순간 짜증 솟구침. 또한 나처럼 깐깐한 사람에게 어색함이 안느껴질만큼 제대로 구현하기는 쉽지 않음(커서위치, 텍스트선택범위, 스크롤 위치, 얼마나 많은 편집을 얼마의 딜레이 간격으로 하나의 히스토리 엔트리로 묶을 것인가, 그리고 양쪽 편집기를 왔다갔다 했을 때 등 생각보다 신경쓸 게 많음. 단순히 text만 보관하는 것으로는 어림 없음).
- 위와 같은 이유로, 편집기와 실제 diff 하이라이트 영역(mirror)을 따로 관리하면서 1px의 오차 없이 정확하게 겹치게 만드는 얍삽한 방법을 씀. 이건 그냥 센스다. editor(see-through) → mirror
- 크기가 큰 텍스트(5만글자 이상)를 비교할 때에도 편집기가 **충분히(아주 충분히) 반응적일 것**. 딜레이 최소화! 단순 debouncing이 아니라 그 이상이 필요(web worker, RequestIdleCallback, ...)
- 다른 문자(문자code가 다른 경우)지만 같다고 여겨질 수 있는 경우도 처리하였지만 이건 이러한 문자들을 직접 추가해줘야함(`constants.ts/NORMALIZE_CHARS`).
- (추가),(신설),(현행과 같음),(삭제) 등은 wildcard로 처리. 이 토큰들은 괄호 안 공백을 무시하고 절대로 중간에서 안잘리게(`(현행과`,`같음)`이 되지 않게) 만들어놨지만 아직은 딱 거기까지임.
- diff 하이라이트 색들은 정말 **세심하게 고른** 것들임. 절대 불만을 가져서는 안됨. 빨간색 계통은 배경과 확실히 대비되지 않을 수 있기 때문에 의도적으로 제외(`constants.ts/DIFF_COLOR_HUES`).
- 큰 워드문서에서 복붙을 할 때에 복사가 바로 되지 않는 문제가 있는데 절대적으로 MS워드의 문제임. 될때까지 붙여넣기 하면 언젠가는 된다(기다리는 동안 워드는 먹통됨).
    - 처음엔 이전에 클립보드에 들어있던 내용이 붙여넣기 됨
    - 재시도(`ctrl-v`) 하다보면 빈 텍스트가 붙여넣기 됨
    - 계속... 재시도(`ctrl-v`)하다보면 결국 성공함.
- 개정대비표vs전문, 전문vs전문, 웹전문vs전문 **전체를 한번**에 복/붙해서 비교할 수 있어야함(수십번씩 드래그,복/붙을 하는 것보다는 무조건 편함!!). 그래서 만든게  Aligned Mode
- 엣지(혹은 크롬) 전용. 인간적으로 2025년에 ie를 왜 써야하지?
- Heading(*1. 개요*, *(가) 어쩌고*, 등)도 찾아내서 시각적 강조를 주긴 했지만 딱 거기까지임. 애당초 원본 문서 구조가 엉망이라서 100% 정확한/의미 있는 heading을 추출하기는 어려움. 어설프게 반은 맞고 반은 틀린 정보를 제공하는 것보다는 아예 정보를 주지 않는 것이 낫다.
- 붙여넣기는 plaintext만. html 붙여넣기도 만들어 봤지만 득보다 실이 많은 느낌(이전 버전 코드 뒤져보면 있음).
- 좌/우 텍스트가 완전히 일치하는 경우 쌍둥이👬를 보여줌. 이건 ctrl-c가 제대로 안되었거나(손가락 힘 부족?) 워드 문제로 복붙이 제대로 되지 않은 경우에 내가 확실히 인지할 수 있도록 넣은 것임. 재미로 넣은 거 아님.

### Aligned Mode
- 이름은 맘에 안들지만 암튼 양쪽 텍스트에서 서로 대비되는 줄들의 위치를 같게 맞춰주는 기능. `F2`로 토글.
- 양쪽 스크롤 동기화됨.
- readonly 모드임(간단한 수정을 시도하면 기본 모드로 전환되면서 바로 수정이 적용되게는 해놨음).
- Aligned Mode는 까만 배경임(마음에 안들지만 **기본 모드와 확실히 대비되는 느낌이 있어야 했음**).
- 두 모드를 전환할때 선택된 텍스트의 범위를 유지하려고 노력한 부분은 칭찬 받아야 함. 생각보다 까다로움(수고했어~).
- 컨트롤 키를 누른채로 텍스트를 클릭하면 기본 모드로 전환되면서 클릭한 위치로 커서를 옮김(수고했어~).
- 양쪽 diff부분을 블럭단위로 표시할 수 있는 경우는 그러려고 노력(!)했음.
- 양쪽 대비(매치)되는 부분의 위치의 차이는 padding요소를 넣어서 메꿈. TODO: 여러개의 빈줄로 인해 발생하는 위치 차이는 padding이 아니라 빈줄들을 collapse하는 쪽으로 해야 더 보기 좋을 것 같음.

### 인터넷도 안되고 아무것도 없는... 있는 거라곤 브라우저, 메모장 밖에 없는 pc에서 돌려야함.
- html + css + js는 어쩔 수 없는 선택. react? 꿈도 꾸지마. 쌩html 쌩css 쌩js로 구현
- 당연히 웹서버 불가능이고 파일경로(`file:///...../diffseek.html`)로 열어야함. 제약 많음.
- 섬세하고 이쁜 UI요소가 부족한 것은 절대적으로 이 때문임. 요새 누가 UI요소를 하나하나 손수 만드나...
- 타입스크립트로 작성하고 컴파일된 js를 옮기는 건 가능.
- 닷넷, java 런타임은 깔려있는 것 같지만 그 뿐임. sdk가 없음.
- 아무튼 이러저러한 이유로 자바스크립트가 유일한 옵션인데 사실 웹브라우저에 익숙하지 않은 사람은 없고 기본적인 동작들은 모두 매끄럽게 구현이 다 되어있으니 어찌보면 최고/최선의 선택임.
- 인간적으로 vscode정도는... 쓰고싶다.

### 집에서 만든 코드를 회사로 옮기는 방법?
- 워크비 쪽지/내부메일로 보내고 회사에서 열고 메모장에 붙여넣기. 고로 코드가 너무 커지면 안됨. 외부 라이브러리? 어림도 없음.
- 다행히도 휴대폰 워크비앱 보안을 우회해서 복사/붙여넣기를 사용할 방법이 있더라(비밀 유지 필요..ㅋ 이거 막히면 더이상의 업데이트는 불가능함).
- 옮기기 전에 하나의 파일(diffseek.html)로 합친 후에 그 파일의 내용을 옮겨야함. 빌드된 파일이 4000줄이 넘으니 두어번에 걸쳐 복붙 필요.
- build, dist폴더를 모두 git에 포함한 것은 이러한 이유임(나눠서 복붙하다가 한두줄 빼먹은 경우에 휴대폰으로 github의 코드와 비교해봐야함).
- .ts로부터 컴파일된 .js파일에 주석을 남겨두는 것은 회사에서 디버깅을 해야되는 경우가 있기 때문.
- 회사에서 수정한 걸 집으로 가져가는건 쉽지 않음. 어느 부분을 어떻게 수정했는지 기억했다가 집에가서 다시 작업해야함. 오늘 먹은 반찬도 기억 안남.

### 브라우저에서 웹 주소가 아닌 파일을 여는 것이기 때문에 보안상 제약이 많음.
- 쿠키? localStorage? ... 당연히 불가 - 상태/옵션 저장하는건 절대 불가능.
- new Worker(url) - 파일 url을 열 수 없음(그래서 worker를 쓰려면 약간의 트릭 필요)
- 그 외 '이게 될까?' 싶은 것들은 안된다고 보면 됨
- 스크립트로 복사/붙여넣기를 실행할 때의 경고는 엣지 설정-whitelist에 등록해서 피할 수 있기는 함. 지금은 관련 기능들을 다 지워버렸으니까 필요 없지만 다시 넣을까함(단축키로 왼쪽창/오른쪽창 선택없이 바로 붙여넣기 등)

### 단축키?
- F2 - aligned mode 토글(양쪽 줄맞춤, 스크롤 동기화, 편집 불가)
- SHIFT-F2 - scroll sync 토글(약간의 줄맞춤, 약간의 스크롤 동기화, 편집 가능)
- ctrl-1/ctrl-2 편집기에 포커스
- 편집 중에 ctrl-space - 반대쪽 편집기의 스크롤 위치를 현재 편집기에 맞춤(가능한 경우)

### copy mode?
- 이건 아직 프로토타입 단계
- raw: 그냥 보통의 ctrl-c
- formatted: - 약간의 diff 하이라이트. 드래그 범위가 어설프게 단어 중간에서 시작되거나 끝나는 경우에는 단어의 경계(정확히는 토큰의 경계)로 맞춤
- compare: 한쪽의 텍스트를 복사했을 때 대응되는 반대쪽 텍스트까지 같이 복사해서 포맷함(*좌:그단어, 우:저단어*)

### histogram 알고리즘
- 가장 널리 쓰이는 알고리즘 중 하나인 것 같음...?
- 이 알고리즘에서 가장 중요한건 앵커(일치되는 기준점)를 그것도 아주 좋은놈으로 찾는 부분인 것 같은데 생각할 것이 많음. 각 섹션의 제목(1. 개요, 2. 업무처리 순서, ...)에 가중치를 주려했지만 해당 제목들은 업무매뉴얼 워드파일에서 맨 앞에 쏠려있는 경우(제목을 왼쪽 컬럼에 넣고 엔터키 수십번 눌러서 섹션을 나눈 경우)가 많아서 의미 없음. (1), (가), 1), 가)에는 적용했지만 얼마나 정확하고 효율적일지 감이 안와서 가중치를 높게 주지 않았음.
- 그외 줄의 시작/끝 부분에 가중치, 희귀도에 가중치, 앵커 문자열 길이에 가중치.
- 최우선순위 앵커 `@@@`, `###` (발견시 무조건 양쪽 텍스트에 나오는 이 앵커들을 순서대로 매치시킴). 좌우 문서가 너무 안맞을 때 강제로 특정위치를 매치시키고 싶을 때. 긴 문서 비교 시에 섹션 대 섹션이 매치가 잘 안될 경우 쓰면 편함.
- 단순히 단어vs단어 뿐만 아니라 n그램(복수개의 단어 매치), n개의 단어와 m개의 단어(단어 수가 다르지만 공백을 무시하고 비교할 경우 같은 단어들)도 매치되는 경우에도 앵커로 사용하려고 노력...은 함.
- 내 생각에 공통prefix/suffix를 스킵하는 부분 때문에 최고로 좋은 앵커를 찾을 기회를 놓치는 경우도 생길 수 있을 것 같지만 스킵 안하면 성능 개판 됨. 절대적으로 필요.
- 일치되는 단어가 다르다고 표시되는 경우는 있을 수 있음(문서 내에 같은 단어가 여러번 나오는 경우 그 중 어느 것에 매치시킬 것인가는 알고리즘 동작에 달려있음).
- 일치되지 않는 단어가 같다고 표시되는 경우는 당연히 없어야함(없음!).

### DiffSeek.diffOptions
정말로 정말로 really really 원한다면 브라우저 devtools 콘솔에서...
```
DiffSeek.diffOptions = {
    algorithm: "histogram" | "lcs"; // ("histogram")
	tokenization: "char" | "word" | "line"; // ("word")
	whitespace: "ignore" | "normalize"; //("ignore")
	useLengthBias: true | false; //(true)
	maxGram: 4; // 1~5정도만...
	lengthBiasFactor: 0.7; // 앵커 길이에 대한 가중치 조정
	sectionHeadingMultiplier: 1.3333; // 1 / 0.75
	lineStartMultiplier: 1.1764;  // 1 / 0.85
	lineEndMultiplier: 1.1111;  // 1 / 0.9
	uniqueMultiplier: 1.4999; // 1/ 0.6667
}
```
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script>"use strict";
// DIFF 색(HUE). 0(빨)은 DIFF 배경색으로 쓰이니 패스
// 완전한 색상 코드보다 HUE만 사용하면 용도에 따라 색을 조절하기 쉬움.
// 인접한 색상과 너무 가깝지 않도록 아주 CAREFUL하게 고른 순서. 과학이다.
const DIFF_COLOR_HUES = [
    30, // 주황?
    180, // cyan
    300, // 핑크?
    120, // 초록
    240, // 파랑
    60, // 노랑
    270, // 보라?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;
const COMPUTE_DEBOUNCE_TIME = 200; // ms
const FORCE_RENDER_TIMEOUT = 100; // ms
const PROCESSING_MESSAGES = [
    "한땀한땀 비교 중...",
    "인내심 테스트 중...",
    "생각 중...",
    "재부팅 준비 중...",
    "무한 루프 중...",
    "머리 긁는 중...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "퇴근 준비 중...",
];
const HANGUL_ORDER = "가나다라마바사아자차카타파하거너더러머버서어저처커터퍼허";
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
function isRectVisible(top, bottom, left, right, viewportTop, viewportLeft, viewportWidth, viewportHeight) {
    return bottom >= viewportTop && top <= viewportTop + viewportHeight && right >= viewportLeft && left <= viewportLeft + viewportWidth;
}
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
function findIndexByPos(arr, pos) {
    // binary search
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const item = arr[mid];
        const start = item.pos, end = item.pos + item.len;
        if (start <= pos && pos < end) {
            return mid;
        }
        else if (start > pos) {
            high = mid - 1;
        }
        else if (end <= pos) {
            low = mid + 1;
        }
    }
    return ~low;
}
function getSelectedTokenRange(tokens, startOffset, endOffset) {
    function findTokenIndex(offset, low) {
        let isStart;
        if (low === undefined) {
            isStart = true;
            low = 0;
        }
        else {
            isStart = false;
        }
        let high = tokens.length - 1;
        let result = isStart ? tokens.length : -1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = tokens[mid];
            const tokenEnd = token.pos + token.len;
            if (isStart) {
                const prevEnd = mid > 0 ? tokens[mid - 1].pos + tokens[mid - 1].len : 0;
                if (offset > prevEnd && offset < tokenEnd) {
                    return mid;
                }
                if (mid === 0 && offset >= token.pos && offset < tokenEnd) {
                    return 0;
                }
            }
            else {
                const nextStart = mid + 1 < tokens.length ? tokens[mid + 1].pos : Infinity;
                if (offset >= token.pos && offset < nextStart) {
                    return mid;
                }
            }
            if (isStart) {
                if (token.pos >= offset) {
                    result = mid;
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            else {
                if (tokenEnd < offset) {
                    result = mid;
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
        }
        return result;
    }
    const startIndex = findTokenIndex(startOffset);
    const endIndex = findTokenIndex(endOffset - 1, startIndex);
    return [startIndex, endIndex + 1]; // [inclusive, exclusive]
}
function findDiffEntryRangeByPos(entries, side, pos, endPos) {
    console.log("findDiffEntryRangeByPos", { entries, side, pos, endPos });
    let low = 0;
    let high = entries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (pos < s.pos) {
            high = mid - 1;
        }
        else if (pos >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = mid;
            break;
        }
    }
    low = mappedStart;
    high = entries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (endPos - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endPos - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = mid + 1;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function mapTokenRangeToOtherSide(rawEntries, side, startIndex, endIndex) {
    const otherSide = side === "left" ? "right" : "left";
    let low = 0;
    let high = rawEntries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (startIndex < s.pos) {
            high = mid - 1;
        }
        else if (startIndex >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = rawEntries[mid][otherSide].pos;
            low = mid; // reuse for mappedEnd search
            break;
        }
    }
    high = rawEntries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (endIndex - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endIndex - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function buildOutputHTMLFromRuns(text, textRuns, options) {
    let inDiff = false;
    let result = options.htmlPre ? "<pre>" : "";
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            const diffIndex = run.dataIndex;
            // result += "<mark>";
            const color = DIFF_COLOR_HUES[diffIndex % DIFF_COLOR_HUES.length];
            result += `<mark style="background-color: hsl(${color}, 100%, 80%);">`;
            inDiff = true;
        }
        else if (run.type === "DIFF_END") {
            if (inDiff) {
                // result += "</mark>";
                result += "</mark>";
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += escapeHTML(text.slice(run.pos, run.pos + run.len));
        }
        else if (run.type === "LINEBREAK") {
            result += "<br/>";
        }
    }
    if (inDiff)
        result += "</mark>";
    if (options.htmlPre)
        result += "</pre>";
    // result += "<br/>";
    return result;
}
function buildOutputPlainText(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const leftBody = buildOutputPlainTextFromRuns(leftText, leftRuns, options);
    const rightBody = buildOutputPlainTextFromRuns(rightText, rightRuns, options);
    return `${leftLabel}: ${leftBody}\n${rightLabel}: ${rightBody}\n`;
}
function buildOutputPlainTextFromRuns(text, textRuns, options) {
    const format = options.textFormat ?? 0;
    let result = "";
    let inDiff = false;
    let markStart;
    let markEnd;
    if (format === 1) {
        markStart = "**";
        markEnd = "**";
    }
    else if (format === 2) {
        markStart = "[[ ";
        markEnd = " ]]";
    }
    else {
        markStart = "";
        markEnd = "";
    }
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            if (format !== 0 && !inDiff) {
                result += markStart;
                inDiff = true;
            }
        }
        else if (run.type === "DIFF_END") {
            if (format !== 0 && inDiff) {
                result += markEnd;
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += text.slice(run.pos, run.pos + run.len);
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inDiff && format !== 0)
        result += markEnd;
    return result;
}
function buildOutputHTML(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const htmlFormat = options.htmlFormat ?? "div";
    if (htmlFormat === "table") {
        // Default: table format
        return `<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr><th>${escapeHTML(leftLabel)}</th><th>${escapeHTML(rightLabel)}</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></td>
      <td><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></td>
    </tr>
  </tbody>
</table>`.trim();
    }
    if (htmlFormat === "dl") {
        return `<dl>
  <dt>${escapeHTML(leftLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></dd>
  <dt>${escapeHTML(rightLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></dd>
</dl>`.trim();
    }
    return `<div>
<div><strong>${escapeHTML(leftLabel)}:</strong> ${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</div>
<div><strong>${escapeHTML(rightLabel)}:</strong> ${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</div>
</div>`.trim();
}
function escapeHTML(str) {
    return str.replace(/[&<>"]|'/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#039;";
            default:
                return char;
        }
    });
}
function parseOrdinalNumber(ordinalText) {
    const norm = ordinalText.replace(/[\(\)\.]/g, "");
    if (/^\d+$/.test(norm)) {
        return Number(norm);
    }
    const idx = HANGUL_ORDER.indexOf(norm);
    if (idx !== -1) {
        return idx + 1;
    }
    return NaN;
}
function findFirstNodeAfter(root, after) {
    let current = after;
    while (current && current !== root) {
        if (current.nextSibling) {
            return current.nextSibling;
        }
        else {
            current = current.parentNode;
        }
    }
    return null;
}
function getTextOffsetOfNode(root, node, end = false) {
    const filter = node.nodeType === 3 ? NodeFilter.SHOW_TEXT : NodeFilter.SHOW_ALL;
    let walker = document.createTreeWalker(root, filter, null);
    let pos = 0;
    let currentNode;
    while ((currentNode = walker.nextNode())) {
        if (currentNode === node && !end) {
            break;
        }
        if (currentNode.nodeType === 3) {
            pos += currentNode.nodeValue.length;
        }
        if (currentNode === node && end) {
            break;
        }
    }
    return pos;
}
function dumpRange() {
    const sel = window.getSelection();
    if (sel && sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        console.log("current selection", {
            range,
            startContainer: range.startContainer,
            startOffset: range.startOffset,
            endContainer: range.endContainer,
            endOffset: range.endOffset,
        });
        return range;
    }
    else {
        console.log("no selection");
    }
}
function advanceNode(node, skipChildren = false, rootNode) {
    return !skipChildren && node.firstChild ? node.firstChild : node.nextSibling ?? findNextAncestorSibling(node.parentNode, rootNode);
}
function retreatNode(currentNode) {
    if (!currentNode)
        return null;
    const prev = currentNode.previousSibling;
    if (prev) {
        let node = prev;
        while (node.lastChild)
            node = node.lastChild;
        return node;
    }
    return currentNode.parentNode;
}
function findNextAncestorSibling(node, rootNode) {
    while (node && node !== rootNode) {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
    return null;
}
function mergeRects(rects) {
    rects.sort((a, b) => a.y + a.height - (b.y + b.height));
    const merged = [];
    const used = new Array(rects.length).fill(false);
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = 0;
    let maxY = 0;
    for (let i = 0; i < rects.length; i++) {
        if (used[i])
            continue;
        let base = rects[i];
        for (let j = i + 1; j < rects.length; j++) {
            if (used[j])
                continue;
            const compare = rects[j];
            // 조기 종료: compare.y > base.y + base.height 이면 더 이상 겹칠 수 없음
            if (compare.y > base.y + base.height)
                break;
            // 완전 포함: base가 compare를 완전히 포함하는 경우
            if (base.x <= compare.x &&
                base.x + base.width >= compare.x + compare.width &&
                base.y <= compare.y &&
                base.y + base.height >= compare.y + compare.height) {
                used[j] = true;
                continue;
            }
            // 완전 포함: compare가 base를 완전히 포함하는 경우
            if (compare.x <= base.x &&
                compare.x + compare.width >= base.x + base.width &&
                compare.y <= base.y &&
                compare.y + compare.height >= base.y + base.height) {
                base = compare;
                used[j] = true;
                continue;
            }
            // y축 거의 같고, x축 겹치면 병합 (좌우 확장)
            const sameY = Math.abs(base.y - compare.y) < 1 && Math.abs(base.height - compare.height) < 1;
            const xOverlap = base.x <= compare.x + compare.width && compare.x <= base.x + base.width;
            if (sameY && xOverlap) {
                // 새 병합 사각형 계산
                const newX = Math.min(base.x, compare.x);
                const newWidth = Math.max(base.x + base.width, compare.x + compare.width) - newX;
                base = {
                    x: newX,
                    y: base.y,
                    width: newWidth,
                    height: base.height,
                };
                used[j] = true;
            }
        }
        merged.push(base);
        minX = Math.min(minX, base.x);
        minY = Math.min(minY, base.y);
        maxX = Math.max(maxX, base.x + base.width);
        maxY = Math.max(maxY, base.y + base.height);
        used[i] = true;
    }
    merged.sort((a, b) => (a.y !== b.y ? a.y - b.y : a.x - b.x));
    return {
        minX,
        minY,
        maxX,
        maxY,
        rects: merged,
    };
}
function isLastChildOrFollowing(container, child) {
    // fast path. 여기서 얼마나 걸릴 지 모르겠지만...
    if (container.lastChild === child || container.nextSibling === child) {
        return true;
    }
    const range = document.createRange();
    range.selectNode(container);
    range.comparePoint;
}
function extractTextRanges(sourceRange) {
    if (sourceRange.startContainer.nodeType === 3 && sourceRange.startContainer === sourceRange.endContainer) {
        return [sourceRange];
    }
    const result = [];
    const walker = document.createTreeWalker(sourceRange.commonAncestorContainer, NodeFilter.SHOW_ALL);
    let startNode;
    let endNode;
    let currentNode;
    if (sourceRange.startContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.startContainer, sourceRange.startOffset);
        r.setEnd(sourceRange.startContainer, sourceRange.startContainer.nodeValue.length);
        result.push(r);
        walker.currentNode = sourceRange.startContainer;
        currentNode = walker.nextNode();
    }
    else if (sourceRange.startContainer.nodeType === 1) {
        startNode = sourceRange.startContainer.childNodes[sourceRange.startOffset] || sourceRange.startContainer;
        walker.currentNode = currentNode = startNode;
    }
    else {
        throw new Error("Invalid start container");
    }
    if (sourceRange.endContainer.nodeType === 3) {
        endNode = sourceRange.endContainer;
    }
    else if (sourceRange.endContainer.nodeType === 1) {
        if (sourceRange.endOffset < sourceRange.endContainer.childNodes.length) {
            endNode = sourceRange.endContainer.childNodes[sourceRange.endOffset];
        }
        else {
            endNode = advanceNode(sourceRange.endContainer, true);
        }
    }
    else {
        throw new Error("Invalid end container");
    }
    while (currentNode && currentNode !== endNode) {
        if (currentNode.nodeType === 3) {
            const r = document.createRange();
            r.selectNode(currentNode);
            result.push(r);
        }
        else {
            if (currentNode.nodeName === "BR") {
                const r = document.createRange();
                r.selectNode(currentNode);
                result.push(r);
            }
            // do nothing for now
        }
        currentNode = walker.nextNode();
    }
    if (sourceRange.endContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.endContainer, 0);
        r.setEnd(sourceRange.endContainer, sourceRange.endOffset);
        result.push(r);
    }
    return result;
}
function findFirstTextNode(root) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (text.nodeValue && text.nodeValue.trim() !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        // 앞에서부터 순회 (0 → N)
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function findLastTextNode(root, skipEmpty = false) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (!skipEmpty || text.nodeValue !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function getNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const commonAncestor = range.commonAncestorContainer;
    const walker = document.createTreeWalker(commonAncestor, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        nodeRange.selectNodeContents(node);
        const startsBeforeEnd = nodeRange.compareBoundaryPoints(Range.END_TO_START, range) < 0;
        const endsAfterStart = nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0;
        if (startsBeforeEnd && endsAfterStart) {
            nodes.push(node);
        }
        else if (!startsBeforeEnd) {
            // 이미 범위를 지난 경우 break
            break;
        }
        node = walker.nextNode();
    }
    return nodes;
}
function getFullyContainedNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const walker = document.createTreeWalker(range.commonAncestorContainer, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        try {
            nodeRange.selectNode(node);
        }
        catch {
            // 텍스트 노드 등 selectNode 실패 시에는 selectNodeContents
            nodeRange.selectNodeContents(node);
        }
        const startsAfterOrAt = nodeRange.compareBoundaryPoints(Range.START_TO_START, range) >= 0;
        const endsBeforeOrAt = nodeRange.compareBoundaryPoints(Range.END_TO_END, range) <= 0;
        if (startsAfterOrAt && endsBeforeOrAt) {
            nodes.push(node);
        }
        else if (!startsAfterOrAt && nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0) {
            break; // 앞으로는 포함될 가능성 없음
        }
        node = walker.nextNode();
    }
    return nodes;
}
function isEmptyElement(el) {
    for (const node of Array.from(el.childNodes)) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent?.trim()) {
                return false; // 내용이 있는 텍스트
            }
        }
        else if (node.nodeType === Node.ELEMENT_NODE) {
            const elem = node;
            if (elem.tagName !== "BR") {
                return false; // <br> 외의 요소가 있음
            }
        }
        else {
            return false; // 알 수 없는 노드 (예: 주석 등)
        }
    }
    return true;
}
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
const STYLE_NONE = 0;
const STYLE_COLOR_RED = 1;
const STYLE_MASK_COLOR = STYLE_COLOR_RED;
const reddishCache = new Map([
    ["red", true],
    ["#ff0000", true],
    ["#e60000", true],
    ["#c00000", true],
    ["rgb(255,0,0)", true],
    ["rgb(230,0,0)", true],
    ["#000000", false],
    ["#333333", false],
    ["#ffffff", false],
    ["black", false],
    ["blue", false],
    ["white", false],
    ["window", false],
    ["windowtext", false],
]);
let _ctx = null;
// 캔버스는 많이 느릴테니까 최대한 정규식을 우선 씀!
// 정규식은 수명단축의 지름길이므로 절대적으로 chatgtp한테 맡기고 눈길 조차 주지 말 것.
function getRGB(color) {
    // #rrggbb
    const hex6 = /^#([0-9a-f]{6})$/i.exec(color);
    if (hex6) {
        const n = parseInt(hex6[1], 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    // #rgb
    const hex3 = /^#([0-9a-f]{3})$/i.exec(color);
    if (hex3) {
        const [r, g, b] = hex3[1].split("").map((c) => parseInt(c + c, 16));
        return [r, g, b];
    }
    // rgb(...) / rgba(...)
    const rgb = /^rgba?\(([^)]+)\)$/i.exec(color);
    if (rgb) {
        const parts = rgb[1].split(",").map((s) => parseInt(s.trim(), 10));
        if (parts.length >= 3)
            return [parts[0], parts[1], parts[2]];
    }
    // fallback: canvas. 아마도 많이 느릴 것...
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    try {
        _ctx.clearRect(0, 0, 1, 1);
        _ctx.fillStyle = color;
        _ctx.fillRect(0, 0, 1, 1);
        const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
        return [r, g, b];
    }
    catch {
        return null;
    }
}
function isReddish(color) {
    let isRed = reddishCache.get(color);
    if (isRed !== undefined)
        return isRed;
    console.log("no cache hit", color);
    const rgb = getRGB(color);
    isRed = rgb ? rgb[0] >= 139 && rgb[0] - Math.max(rgb[1], rgb[2]) >= 65 : false;
    reddishCache.set(color, isRed);
    return isRed;
}
const BLOCK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
    //TD: true,
    "#document-fragment": true,
};
const INLINE_ELEMENTS = {
    SPAN: true,
    A: true,
    B: true,
    I: true,
    U: true,
    EM: true,
    STRONG: true,
    S: true,
    STRIKE: true,
    SUB: true,
    SUP: true,
    SMALL: true,
    BIG: true,
    MARK: true,
    INS: true,
    DEL: true,
    CODE: true,
    KBD: true,
    SAMP: true,
    VAR: true,
    DFN: true,
    ABBR: true,
    TIME: true,
    CITE: true,
    Q: true,
    LABEL: true,
};
const LINEBREAK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
};
const TEXTLESS_ELEMENTS = {
    HR: true,
    BR: true,
    IMG: true,
    VIDEO: true,
    AUDIO: true,
    EMBED: true,
    OBJECT: true,
    CANVAS: true,
    SVG: true,
    TABLE: true,
    THEAD: true,
    TBODY: true,
    TFOOT: true,
    TR: true,
    OL: true,
    UL: true,
    DL: true,
    STYLE: true,
    HEAD: true,
    TITLE: true,
    SCRIPT: true,
    LINK: true,
    META: true,
    BASE: true,
    AREA: true,
    "#document-fragment": true,
};
const EXCLUDED_HTML_TAGS = {
    SCRIPT: 1,
    STYLE: 1,
    IFRAME: 1,
    OBJECT: 1,
    EMBED: 1,
    LINK: 1,
    META: 1,
    BASE: 1,
    APPLET: 1,
    FRAME: 1,
    FRAMESET: 1,
    NOSCRIPT: 1,
    SVG: 1,
    MATH: 1,
    TEMPLATE: 1,
    HEAD: 1,
};
const EMPTY_ATTRS = {};
const ALLOWED_CONTAINER_TAGS = {
    TABLE: EMPTY_ATTRS,
    TBODY: EMPTY_ATTRS,
    THEAD: EMPTY_ATTRS,
    TFOOT: EMPTY_ATTRS,
    CAPTION: EMPTY_ATTRS,
    TR: EMPTY_ATTRS,
    TH: { colspan: true, rowspan: true },
    TD: { colspan: true, rowspan: true },
    H1: EMPTY_ATTRS,
    H2: EMPTY_ATTRS,
    H3: EMPTY_ATTRS,
    H4: EMPTY_ATTRS,
    H5: EMPTY_ATTRS,
    H6: EMPTY_ATTRS,
    SUP: EMPTY_ATTRS,
    SUB: EMPTY_ATTRS,
    EM: EMPTY_ATTRS,
    I: EMPTY_ATTRS,
    S: EMPTY_ATTRS,
    B: EMPTY_ATTRS,
    STRONG: EMPTY_ATTRS,
    U: EMPTY_ATTRS,
    STRIKE: EMPTY_ATTRS,
    P: EMPTY_ATTRS,
    UL: EMPTY_ATTRS,
    OL: EMPTY_ATTRS,
    LI: EMPTY_ATTRS,
    DL: EMPTY_ATTRS,
    DT: EMPTY_ATTRS,
    DD: EMPTY_ATTRS,
    DIV: EMPTY_ATTRS,
    HEADER: EMPTY_ATTRS,
    FOOTER: EMPTY_ATTRS,
    SECTION: EMPTY_ATTRS,
    ARTICLE: EMPTY_ATTRS,
    ASIDE: EMPTY_ATTRS,
    BLOCKQUOTE: EMPTY_ATTRS,
    ADDRESS: EMPTY_ATTRS,
    //"#document-fragment": EMPTY_ATTRS,
};
const TEXT_FLOW_CONTAINERS = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
function customTrim(str) {
    return str.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
}
function coerceColor(color) {
    if (isReddish(color)) {
        return "red";
    }
    return undefined;
}
// 조건 시작 정규식 (주석 유무 상관없이, [if ...]> 또는 <![if ...]> 모두 포괄)
const ifRegex = /(?:<!--)?<?!?\[if\s+([^\]]+?)\]>?/gi;
// 조건 종료 정규식
const endifRegex = /<!\[endif\](?:-->|\])?/i;
/**
 * input: 파싱할 전체 문자열
 * start: 파싱 시작 위치 (무조건 [if ...]가 시작하는 위치여야 함)
 *
 * returns: [조건부 블록, 종료 위치]
 */
function parseIfBlock(input, start) {
    ifRegex.lastIndex = start;
    const ifMatch = ifRegex.exec(input);
    if (!ifMatch || ifMatch.index !== start) {
        console.error("parseIfBlock must start at an [if] condition", { ifMatch, start, input });
        throw new Error("parseIfBlock must start at an [if] condition");
    }
    const condition = ifMatch[1].trim();
    let cursor = ifRegex.lastIndex;
    const children = [];
    while (cursor < input.length) {
        ifRegex.lastIndex = cursor;
        endifRegex.lastIndex = cursor;
        const nextIf = ifRegex.exec(input);
        const nextEndIf = endifRegex.exec(input);
        if (nextEndIf && (!nextIf || nextEndIf.index < nextIf.index)) {
            // endif가 먼저 나오면 현재 조건 종료
            if (nextEndIf.index > cursor) {
                const text = input.slice(cursor, nextEndIf.index);
                if (text.trim())
                    children.push(text);
            }
            cursor = nextEndIf.index + nextEndIf[0].length;
            return [{ condition, children }, cursor];
        }
        if (nextIf && nextIf.index === cursor) {
            // 중첩된 if 조건 파싱 재귀 호출
            console.log("parseIfBlock called at pos:", start);
            console.log("String at start:", input.slice(start, start + 20));
            const [childBlock, newPos] = parseIfBlock(input, cursor);
            children.push(childBlock);
            cursor = newPos;
            continue;
        }
        // 일반 텍스트 추출 (다음 조건문 혹은 endif까지)
        let nextPos = input.length;
        if (nextIf)
            nextPos = Math.min(nextPos, nextIf.index);
        if (nextEndIf)
            nextPos = Math.min(nextPos, nextEndIf.index);
        const text = input.slice(cursor, nextPos);
        if (text.trim())
            children.push(text);
        cursor = nextPos;
    }
    throw new Error("Missing matching [endif]");
}
function sanitizeHTML(rawHTML) {
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length);
        }
    }
    const tmpl = document.createElement("template");
    tmpl.innerHTML = rawHTML;
    let flags = 0;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "🖼️";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName === "P" ? "DIV" : node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(tmpl.content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return result;
}
function sanitizeNode(content) {
    let hasBlockElements = false;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "🖼️";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        else if (!hasBlockElements && BLOCK_ELEMENTS[containerNode.nodeName]) {
            hasBlockElements = true;
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return [result, hasBlockElements];
}
//# sourceMappingURL=sanitize.js.map
</script>
<script>"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const LINE_START = 1 << 0; // 1
const LINE_END = 1 << 1; // 2
const CONTAINER_START = 1 << 2; // 4
const CONTAINER_END = 1 << 3; // 8
const TABLE_START = 1 << 4; // 16
const TABLE_END = 1 << 5; // 32
const TABLEROW_START = 1 << 6; // 64
const TABLEROW_END = 1 << 7; // 128
const TABLECELL_START = 1 << 8; // 256
const TABLECELL_END = 1 << 9; // 512
const NO_JOIN = 1 << 10; // @@@, ### 등등 // 16
const WILD_CARD = 1 << 11;
const MANUAL_ANCHOR = 12 << 6; // 32. @@@, ### 등등
const IMAGE = 1 << 13;
const SECTION_HEADING_BIT = 14;
const SECTION_HEADING_TYPE1 = 1 << (SECTION_HEADING_BIT + 0); // 1.
const SECTION_HEADING_TYPE2 = 1 << (SECTION_HEADING_BIT + 1); // 가.
const SECTION_HEADING_TYPE3 = 1 << (SECTION_HEADING_BIT + 2); // (1)
const SECTION_HEADING_TYPE4 = 1 << (SECTION_HEADING_BIT + 3); // (가)
const SECTION_HEADING_TYPE5 = 1 << (SECTION_HEADING_BIT + 4); // 1)
const SECTION_HEADING_TYPE6 = 1 << (SECTION_HEADING_BIT + 5); // 가)
const LINE_BOUNDARY = LINE_START | LINE_END;
const CONTAINER_BOUNDARY = CONTAINER_START | CONTAINER_END;
const SECTION_HEADING_MASK = SECTION_HEADING_TYPE1 | SECTION_HEADING_TYPE2 | SECTION_HEADING_TYPE3 | SECTION_HEADING_TYPE4 | SECTION_HEADING_TYPE5 | SECTION_HEADING_TYPE6;
// const normalizeChars: { [ch: string]: string } = {};
// text flow containers?
const containerElements = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
const spaceChars = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // 글쎄...
    "\f": true, // 이것들은...
    "\v": true, // 볼일이 없을것...
    "\u00A0": true, // &nbsp; ??
};
const splitChars = {
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
};
const normalizedCharMap = ((normChars) => {
    const result = {};
    let parser;
    function htmlEntityToChar(entity) {
        const doc = (parser = parser || new DOMParser()).parseFromString(entity, "text/html");
        const char = doc.body.textContent;
        if (char.length !== 1) {
            throw new Error("htmlEntityToChar: not a single character entity: " + entity);
        }
        return char;
    }
    for (const entry of normChars) {
        const [norm, ...variants] = entry;
        for (const variant of variants) {
            if (typeof variant === "number") {
                result[String.fromCharCode(variant)] = norm;
            }
            else if (typeof variant === "string") {
                if (variant.length === 1 || (variant.length === 2 && variant.charCodeAt(0) >= 0xd800)) {
                    result[variant] = norm;
                }
                else if (variant[0] === "&") {
                    result[htmlEntityToChar(variant)] = norm;
                }
            }
        }
    }
    return result;
})([
    ['"', "“", "”", "'", "‘", "’"], // 비즈플랫폼 편집기에서 작은따옴표를 큰따옴표로 바꾸어버림. WHY?
    ["-", "‐", "‑", "‒", "–", "﹘", "—", "－"],
    [".", "․", "．"],
    [",", "，"],
    ["•", "●"], // 이걸 중간점 용도로 쓰는 사람들은 정말 갈아마셔야된다. 도저히 용납해줄 수 없고 같은 문자로 인식하게 만들고 싶지 않다.
    ["◦", "○", "ㅇ"], // 자음 "이응"을 쓰는 사람들도 개인적으로 이해가 안되지만 많더라.
    ["■", "▪", "◼"],
    ["□", "▫", "◻", "ㅁ"],
    ["·", "⋅", "∙", "ㆍ", "‧"], // 유니코드를 만든 집단은 도대체 무슨 생각이었던걸까?...
    ["…", "⋯"],
    ["(", "（"],
    [")", "）"],
    ["[", "［"],
    ["]", "］"],
    ["{", "｛"],
    ["}", "｝"],
    ["<", "＜"],
    [">", "＞"],
    ["=", "＝"],
    ["+", "＋"],
    ["*", "＊", "✱", "×", "∗"],
    ["/", "／", "÷"],
    ["\\", "₩"], // 아마도 원화 기호로 사용했겠지
    ["&", "＆"],
    ["#", "＃"],
    ["@", "＠"],
    ["$", "＄"],
    ["%", "％"],
    ["^", "＾"],
    ["~", "～"],
    ["`", "｀"],
    ["|", "｜"],
    [":", "："],
    [";", "；"],
    ["?", "？"],
    ["!", "！"],
    ["_", "＿"],
    ["→", "⇒", "➡", "➔", "➞", "➟"],
    ["←", "⇐", "⬅", "⟵", "⟸"],
    ["↑", "⇑", "⬆"],
    ["↓", "⇓", "⬇"],
    ["↔", "⇔"],
    ["↕", "⇕"],
]);
const TOKEN_CACHE_SIZE = 2;
const tokenCache = {
    ["char"]: [],
    ["word"]: [],
    ["line"]: [],
};
// wildcards.
// 이걸 어떻게 구현해야할지 감이 안오지만 지금으로써는 얘네들을 atomic하게 취급(사이에 공백이 있어도 하나의 토큰으로 만듬. '(현행과 같음)'에서 일부분만 매치되는 것을 방지)
// 글자단위로 토큰화하는 경우에도 얘네들은 (...) 통채로 하나의 토큰으로 취급.
// 와일드카드diff인 경우 다른 diff와 병합되지 않으면 좋지만 와일드카드가 얼마나 greedy하게 반대쪽 텍스트를 잡아먹어야 할지
// 양쪽에 wildcard가 동시에 나오는 경우 경계를 어디서 어떻게 짤라야할지 쉽지 않음.
// 또한 wildcard를 강제로 다른 diff와 분리하는 경우 diff가 같은 위치에 두 개 이상 생기게 되는 수가 있다. (wildcard와 wildcard가 아닌 것)
// 이 경우 정확히 같은 위치에 두개의 diff를 렌더링해야하고 결국 두개가 겹쳐보이게 되는데 분간이 잘 안된다.
const wildcardTrie = createTrie(true);
wildcardTrie.insert("(추가)", WILD_CARD);
wildcardTrie.insert("(삭제)", WILD_CARD);
wildcardTrie.insert("(신설)", WILD_CARD);
wildcardTrie.insert("(생략)", WILD_CARD);
wildcardTrie.insert("(현행과같음)", WILD_CARD);
const wildcardTrieNode = wildcardTrie.root.next("(");
const sectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    sectionHeadingTrie.insert(`${i}.`, SECTION_HEADING_TYPE1);
    sectionHeadingTrie.insert(`(${i})`, SECTION_HEADING_TYPE3);
    sectionHeadingTrie.insert(`${i})`, SECTION_HEADING_TYPE5);
}
for (let i = 0; i < HANGUL_ORDER.length; i++) {
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]}.`, SECTION_HEADING_TYPE2);
    sectionHeadingTrie.insert(`(${HANGUL_ORDER[i]})`, SECTION_HEADING_TYPE4);
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]})`, SECTION_HEADING_TYPE6);
}
const SectionHeadingTrieNode = sectionHeadingTrie.root;
const sectionHeadingStartChars = extractStartCharsFromTrie(SectionHeadingTrieNode);
const manualAnchorTrie = createTrie(false);
manualAnchorTrie.insert(MANUAL_ANCHOR1, MANUAL_ANCHOR);
manualAnchorTrie.insert(MANUAL_ANCHOR2, MANUAL_ANCHOR);
const manualAnchorTrieNode = manualAnchorTrie.root;
const manualAnchorStartChars = extractStartCharsFromTrie(manualAnchorTrieNode);
function tokenizeByChar(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = LINE_START;
    const inputEnd = input.length;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (!spaceChars[ch]) {
            if (ch === "(") {
                const result = findInTrie(wildcardTrieNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= LINE_START;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (manualAnchorStartChars[ch]) {
                const nextNode = manualAnchorTrieNode.next(ch);
                const result = findInTrie(nextNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= LINE_START;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                flags |= LINE_START;
            }
            const normalized = normalizedCharMap[ch] || ch;
            tokens.push({
                text: normalized,
                pos: i,
                len: 1,
                lineNum,
                flags,
            });
            flags = 0;
        }
        if (ch === "\n") {
            lineNum++;
            flags = LINE_START;
            if (tokens.length) {
                tokens[tokens.length - 1].flags |= LINE_END;
            }
        }
    }
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LINE_END;
    }
    return tokens;
}
function tokenizeByWord(input) {
    const tokens = [];
    let currentStart = -1;
    let lineNum = 1;
    let flags = LINE_START;
    let shouldNormalize = false;
    const inputEnd = input.length;
    function emitToken(end) {
        const raw = input.slice(currentStart, end);
        const normalized = shouldNormalize ? normalize(raw) : raw;
        flags |= tokens.length === 0 || checkIfFirstOfLine(input, currentStart) ? LINE_START : 0;
        if (normalized === MANUAL_ANCHOR1 || normalized === MANUAL_ANCHOR2) {
            flags |= MANUAL_ANCHOR;
        }
        tokens.push({
            text: normalized,
            pos: currentStart,
            len: end - currentStart,
            lineNum,
            flags,
        });
        currentStart = -1;
        flags = 0;
        shouldNormalize = false;
    }
    for (let i = 0; i < inputEnd; i++) {
        let ch = input[i];
        if (spaceChars[ch]) {
            if (currentStart !== -1)
                emitToken(i);
            if (ch === "\n") {
                lineNum++;
                flags = LINE_START;
                if (tokens.length)
                    tokens[tokens.length - 1].flags |= LINE_END;
            }
            continue;
        }
        if (ch === "(") {
            const result = findInTrie(wildcardTrieNode, input, i);
            if (result) {
                if (currentStart !== -1)
                    emitToken(i);
                flags |= tokens.length === 0 || checkIfFirstOfLine(input, i) ? LINE_START : 0;
                tokens.push({
                    text: result.word,
                    pos: i,
                    len: result.end - i,
                    lineNum,
                    flags: flags | result.flags,
                });
                flags = 0;
                currentStart = -1;
                i = result.end - 1;
                continue;
            }
        }
        if (currentStart === -1 && flags & LINE_START && sectionHeadingStartChars[ch]) {
            const result = findInTrie(SectionHeadingTrieNode, input, i);
            if (result) {
                const nextChar = input[result.end];
                if (nextChar === " " || nextChar === "\t" || nextChar === "\u00A0") {
                    flags |= result.flags;
                }
                // let p = result.end;
                // while (p < inputEnd && SPACE_CHARS[input[p]]) p++;
                // if (p < inputEnd) flags |= result.flags;
            }
        }
        // if (SPLIT_CHARS[ch]) {
        // 	if (currentStart !== -1) emitToken(i);
        // 	flags |= tokens.length === 0 || checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
        // 	tokens.push({
        // 		text: ch,
        // 		pos: i,
        // 		len: 1,
        // 		lineNum,
        // 		flags,
        // 	});
        // 	flags = 0;
        // 	currentStart = -1;
        // 	continue;
        // }
        if (normalizedCharMap[ch]) {
            shouldNormalize = true;
        }
        if (currentStart === -1)
            currentStart = i;
    }
    if (currentStart !== -1)
        emitToken(inputEnd);
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LINE_END;
    }
    return tokens;
}
function tokenizeByLine(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = LINE_START | LINE_END;
    const inputEnd = input.length;
    let buffer = "";
    let started = false;
    let inSpace = false;
    let pos = -1;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (ch !== "\n") {
            if (!spaceChars[ch]) {
                if (!started) {
                    pos = i;
                    started = true;
                    const result = findInTrie(SectionHeadingTrieNode, input, i);
                    if (result) {
                        let p = result.end;
                        while (p < inputEnd && spaceChars[input[p]])
                            p++;
                        if (p < inputEnd)
                            flags |= result.flags;
                    }
                }
                if (inSpace && buffer.length > 0)
                    buffer += " ";
                buffer += ch;
                inSpace = false;
            }
            else {
                inSpace = started;
            }
        }
        else {
            if (started) {
                if (buffer === MANUAL_ANCHOR1 || buffer === MANUAL_ANCHOR2) {
                    flags |= MANUAL_ANCHOR;
                }
                tokens.push({
                    text: buffer,
                    pos,
                    len: i - pos,
                    lineNum,
                    flags,
                });
                buffer = "";
                started = false;
                inSpace = false;
                flags = LINE_START | LINE_END;
            }
            lineNum++;
        }
    }
    return tokens;
}
function tokenize(input, mode, noCache = false) {
    let cacheArr = !noCache && tokenCache[mode];
    if (cacheArr) {
        for (let i = 0; i < cacheArr.length; i++) {
            const cache = cacheArr[i];
            if (cache.text.length === input.length && cache.text === input) {
                if (i !== cacheArr.length - 1) {
                    cacheArr.splice(i, 1);
                    cacheArr.push(cache);
                }
                return cache.tokens;
            }
        }
    }
    const now = performance.now();
    let tokens;
    switch (mode) {
        case "char":
            tokens = tokenizeByChar(input);
            break;
        case "word":
            tokens = tokenizeByWord(input);
            break;
        case "line":
            tokens = tokenizeByLine(input);
            break;
        default:
            throw new Error("Unknown tokenization mode: " + mode);
    }
    console.debug("tokenize took %d ms", performance.now() - now);
    // tokens.push({
    // 	text: "",
    // 	pos: input.length,
    // 	len: 0,
    // 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
    // 	flags: FIRST_OF_LINE | LAST_OF_LINE,
    // });
    if (cacheArr) {
        if (cacheArr.length >= TOKEN_CACHE_SIZE) {
            cacheArr.shift();
        }
        cacheArr.push({ text: input, tokens: tokens });
    }
    return tokens;
}
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizedCharMap[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!spaceChars[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            node = node.addChild(word[i]);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
function createTrieNode(ignoreSpaces) {
    const children = {};
    const node = {
        children,
        word: null,
        flags: 0,
        next(char) {
            if (ignoreSpaces && char === " ")
                return node;
            return children[char] || null;
        },
        addChild(char) {
            return children[char] ?? (children[char] = createTrieNode(ignoreSpaces));
        },
    };
    return node;
}
function findInTrie(trie, input, start) {
    let node = trie;
    let i = start;
    while (i < input.length) {
        const ch = input[i++];
        node = node.next(ch);
        if (!node)
            break;
        if (node.word) {
            return { word: node.word, flags: node.flags, end: i };
        }
    }
    return null;
}
function extractStartCharsFromTrie(trie) {
    const table = {};
    for (const ch in trie.children) {
        table[ch] = 1;
    }
    return table;
}
function tokenizeNode(node) {
    const startTime = performance.now();
    let textPos = 0;
    let currentToken = null;
    const results = [];
    function processToken(text, start, length) {
        if (currentToken) {
            currentToken.text += text;
            currentToken.len = textPos - currentToken.pos;
        }
        else {
            currentToken = {
                text,
                pos: start,
                len: length,
                flags: 0,
                lineNum: 0,
            };
        }
    }
    function finalizeToken(flags = 0) {
        if (currentToken) {
            currentToken.len = textPos - currentToken.pos;
            currentToken.flags |= flags;
            results.push(currentToken);
            currentToken = null;
            return 1;
        }
        return 0;
    }
    function traverse(node) {
        if (node.nodeType === 3) {
            const text = node.nodeValue;
            if (text.length === 0)
                return;
            let nodeStart = textPos;
            let currentStart = -1;
            for (let i = 0; i < text.length; i++, textPos++) {
                const char = text[i];
                if (spaceChars[char]) {
                    if (currentStart >= 0) {
                        processToken(text.slice(currentStart, i), nodeStart + currentStart, i - currentStart);
                        currentStart = -1;
                    }
                    finalizeToken();
                }
                else {
                    if (currentStart < 0) {
                        currentStart = i;
                    }
                }
            }
            if (currentStart >= 0) {
                processToken(text.slice(currentStart), nodeStart + currentStart, text.length - currentStart);
            }
        }
        else if (node.nodeType === 1) {
            if (node.nodeName === "BR") {
                finalizeToken(LINE_END);
                return;
            }
            if (node.className === "img") {
                finalizeToken();
                results.push({
                    text: node.dataset.src || node.src || "🖼️",
                    pos: textPos,
                    len: node.textContent.length,
                    lineNum: 0,
                    flags: IMAGE | NO_JOIN,
                });
                textPos += node.textContent.length;
                return;
            }
            node.dataset.startOffset = String(textPos);
            if (TEXT_FLOW_CONTAINERS[node.nodeName]) {
                finalizeToken(CONTAINER_END | LINE_END);
            }
            const isTextFlowContainer = TEXT_FLOW_CONTAINERS[node.nodeName];
            const numTokensBefore = results.length;
            for (const child of node.childNodes) {
                traverse(child);
            }
            if (BLOCK_ELEMENTS[node.nodeName]) {
                finalizeToken();
            }
            const firstToken = results[numTokensBefore];
            const lastToken = results[results.length - 1];
            if (isTextFlowContainer) {
                if (firstToken) {
                    firstToken.flags |= CONTAINER_START | LINE_START;
                }
                if (lastToken) {
                    lastToken.flags |= CONTAINER_END | LINE_END;
                }
            }
            else if (node.nodeName === "P") {
                if (firstToken) {
                    firstToken.flags |= LINE_START;
                }
                if (lastToken) {
                    lastToken.flags |= LINE_END;
                }
            }
            node.dataset.endOffset = String(textPos);
            // currentContainer = containerStack.pop()!;
        }
    }
    traverse(node);
    finalizeToken();
    const endTime = performance.now();
    console.log("tokenizeNode", node.nodeName, node.nodeValue, results, Math.ceil(endTime - startTime) + "ms");
    return results;
}
//# sourceMappingURL=tokenize.js.map
</script>
<script>"use strict";
const TEXT_SELECTION_HIGHLIGHT_FILL_STYLE = "hsl(210 100% 40%)";
function createEditor(container, editorName, callbacks) {
    const { onDiffVisibilityChanged, onTextChanged } = callbacks;
    const _lineElements = [];
    const _diffElements = [];
    const _anchorElements = [];
    const _lineHints = [];
    const _visibleAnchors = new Set();
    const _visibleDiffIndices = new Set();
    const _diffRanges = [];
    const _diffRects = [];
    const _diffLineRects = [];
    const _tokens = [];
    const _ranges = [];
    const _anchors = new Map();
    let _textSelectionHighlight = null;
    // let _textHighlightItems: RenderItem[] | null = null;
    let _diffHighlightItems = null;
    let _renderPending = false;
    const _renderLayers = [
        { index: 0, dirty: true }, // static canvas
        { index: 1, dirty: true }, // highlight canvas
    ];
    const DIFF_LAYER = 0;
    const HIGHLIGHT_LAYER = 1;
    let _diffRectsDirty = true;
    let _hasRenderedAny = false;
    let _editMode = false;
    let _canvasWidth = 0;
    let _canvasHeight = 0;
    const wrapper = document.createElement("div");
    wrapper.id = editorName + "EditorWrapper";
    wrapper.classList.add("editor-wrapper");
    const staticCanvas = document.createElement("canvas");
    staticCanvas.id = editorName + "Canvas";
    staticCanvas.classList.add("canvas");
    const staticCanvasCtx = staticCanvas.getContext("2d");
    const highlightCanvas = document.createElement("canvas");
    highlightCanvas.id = editorName + "HighlightCanvas";
    highlightCanvas.classList.add("canvas");
    highlightCanvas.classList.add("highlight");
    const highlightCanvasCtx = highlightCanvas.getContext("2d");
    const INITIAL_EDITOR_HTML = "<DIV><BR/></DIV>";
    const editor = document.createElement("div");
    editor.id = editorName + "Editor";
    editor.classList.add("editor");
    editor.contentEditable = "true";
    editor.spellcheck = false;
    editor.innerHTML = `<table><tbody><tr><td><p>하나 은행</p></td><td><p>국민 은행</p></td><td><p>신한 은행</p></td></tr><tr><td><p>산업 은행</p></td><td><p>카카오 뱅크</p></td><td rowspan="2"><p>케이 뱅크</p></td></tr><tr><td><p>우리 은행</p></td><td><p>우체국</p></td></tr></tbody></table><p>hello</p>`;
    wrapper.appendChild(staticCanvas);
    wrapper.appendChild(highlightCanvas);
    wrapper.appendChild(editor);
    container.appendChild(wrapper);
    const resizeObserver = new ResizeObserver(() => {
        const rect = wrapper.getBoundingClientRect();
        staticCanvas.width = highlightCanvas.width = _canvasWidth = rect.width;
        staticCanvas.height = highlightCanvas.height = _canvasHeight = rect.height;
        _diffRectsDirty = true;
        if (_textSelectionHighlight) {
            _textSelectionHighlight.renderItem = undefined;
        }
        renderAll();
    });
    resizeObserver.observe(wrapper);
    // *** HTML 붙여넣기를 허용할 때만 사용할 코드 ***
    // 지금은 관련 코드를 다 지워버렸고 복구하려면 깃허브에서 이전 코드를 뒤져야함...
    const { observeEditor, unobserveEditor } = (() => {
        const mutationObserver = new MutationObserver((mutations) => {
            if (editor.childNodes.length === 0) {
                editor.innerHTML = INITIAL_EDITOR_HTML;
            }
        });
        function observeEditor() {
            mutationObserver.observe(editor, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true,
            });
        }
        function unobserveEditor() {
            mutationObserver.disconnect();
        }
        return { observeEditor, unobserveEditor };
    })();
    observeEditor();
    function formatPlaintext(plaintext) {
        const lines = plaintext.split("\n");
        const fragment = document.createDocumentFragment();
        for (const line of lines) {
            const p = document.createElement("p");
            p.textContent = line;
            fragment.appendChild(p);
        }
        return fragment;
    }
    editor.addEventListener("paste", (e) => {
        // 비교적 무거운 작업이지만 뒤로 미루면 안되는 작업이기 때문에 UI blocking을 피할 뾰족한 수가 없다.
        // 붙여넣기 이후 바로 추가 입력 => 붙여넣기를 뒤로 미루면 입력이 먼저 될테니까.
        console.time("paste");
        e.preventDefault();
        let rawHTML = e.clipboardData?.getData("text/html");
        let sanitized;
        if (rawHTML) {
            const START_TAG = "<!--StartFragment-->";
            const END_TAG = "<!--EndFragment-->";
            const startIndex = rawHTML.indexOf(START_TAG);
            if (startIndex >= 0) {
                const endIndex = rawHTML.lastIndexOf(END_TAG);
                if (endIndex >= 0) {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
                }
                else {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length);
                }
            }
            sanitized = sanitizeHTML(rawHTML);
        }
        else {
            sanitized = formatPlaintext(e.clipboardData?.getData("text/plain") || "");
        }
        // 자존심 상하지만 document.execCommand("insertHTML",...)를 써야한다.
        // 1. 브라우저가 undo/redo 히스토리 관리를 할 수 있음.
        // 2. 필요한 경우 브라우저가 알아서 DOM을 수정해 줌.
        // 	예: 인라인 엘러먼트 안에 블럭 엘러먼트를 붙여넣는 경우 브라우저가 알아서 인라인 요소를 반으로 갈라서 블럭 엘러먼트를 밖으로 꺼내준다.
        const div = document.createElement("DIV");
        div.appendChild(sanitized);
        document.execCommand("insertHTML", false, div.innerHTML);
        console.log("insertHTML", div.innerHTML);
        console.timeEnd("paste");
    });
    editor.addEventListener("input", onChange);
    wrapper.addEventListener("scroll", () => {
        renderAll();
    });
    function onChange() {
        tokenize();
    }
    function onTokenizeDone() {
        onTextChanged();
    }
    function getVisibleAnchors() {
        return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
    }
    // caret(텍스트커서 '|')가 있는 위치에 가장 가까운 앵커를 가져옴.
    // edit 모드가 아닌 경우에는 null 리턴
    function getClosestAnchorToCaret() {
        if (!_editMode) {
            return null;
        }
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null;
        }
        let range = selection.getRangeAt(0);
        if (!editor.contains(range.startContainer)) {
            return null;
        }
        let rect = range.getBoundingClientRect();
        let y;
        if (rect.left === 0 && rect.top === 0) {
            y = EDITOR_PADDING + TOPBAR_HEIGHT;
        }
        else {
            y = rect.top;
        }
        let closestAnchor = null;
        let minDistance = Number.MAX_SAFE_INTEGER;
        for (const anchor of _visibleAnchors) {
            const rect = anchor.getBoundingClientRect();
            const distance = Math.abs(rect.top - y);
            if (distance < minDistance) {
                minDistance = distance;
                closestAnchor = anchor;
            }
        }
        return closestAnchor;
    }
    function getFirstVisibleLineElement() {
        const lineEls = _lineElements;
        let low = 0;
        let high = lineEls.length - 1;
        let mid;
        let lineEl = null;
        let distance = null;
        while (low <= high) {
            mid = (low + high) >>> 1;
            const thisDistance = lineEls[mid].getBoundingClientRect().top - TOPBAR_HEIGHT;
            if (thisDistance >= -LINE_HEIGHT) {
                lineEl = lineEls[mid];
                distance = thisDistance;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return [lineEl, distance];
    }
    function scrollToDiff(diffIndex) {
        const diffRects = _diffRects[diffIndex];
        if (!diffRects) {
            return;
        }
        const diffRect = diffRects.rects[0];
        if (!diffRect) {
            return;
        }
        wrapper.scrollTop = diffRect.y - SCROLL_MARGIN;
    }
    function scrollToHeading(headingIndex) {
        const id = `${editorName}Heading${headingIndex}`;
        const el = document.getElementById(id);
        if (el) {
            const offsetTop = el.offsetTop - wrapper.clientTop;
            wrapper.scrollTop = offsetTop - SCROLL_MARGIN;
        }
    }
    // 내가 머리가 나쁘다는 걸 확실하게 알게 해주는 함수
    function scrollToLine(lineNum, margin = 0) {
        const lineEl = _lineElements[lineNum - 1];
        if (lineEl) {
            const scrollTop = lineEl.offsetTop - margin;
            wrapper.scrollTop = scrollTop;
        }
    }
    function getFirstVisibleAnchor() {
        let firstAnchor = null;
        let firstPos = null;
        for (const anchor of _visibleAnchors) {
            if (firstAnchor === null) {
                firstAnchor = anchor;
                firstPos = Number(anchor.dataset.pos);
            }
            else {
                const pos = Number(anchor.dataset.pos);
                if (pos < firstPos) {
                    firstAnchor = anchor;
                    firstPos = pos;
                }
            }
        }
        return firstAnchor;
    }
    function setEditMode(editMode) {
        _editMode = !!editMode;
    }
    // #region
    function getTextOffset(root, node, offset) {
        let result;
        if (node.nodeType === 1) {
            let container = editor;
            let offsetBase = 0;
            if (node.childNodes.length === offset) {
                // return Number((node as HTMLElement).dataset.endOffset);
                // offset이 node.childNode 배열 크기를 넘는 경우(정확히는 offset === childNode.length)
                // 이 경우 범위의 시작(또는 끝)은 node의 끝에 있다는 의미.
                // 현재 노드의 끝 위치를 계산해도 되지만 다음 노드의 시작 위치를 계산해도 될 것 같음.
                const nextNode = findFirstNodeAfter(root, node);
                if (nextNode === null) {
                    return -1;
                }
            }
            else {
                // node.childNodes[offset]의 시작부분에 범위의 시작(또는 끝)이 위치함.
                node = node.childNodes[offset];
            }
            let pos = getTextOffsetOfNode(container, node);
            result = offsetBase + pos;
        }
        else {
            console.assert(node.nodeType === 3, "nodeType is not text node");
            // 맨 처음부터 텍스트노드 길이 누적...
            result = getTextOffsetOfNode(root, node) + offset;
        }
        return result;
    }
    function getTextRangeRects(startOffset, endOffset) {
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let currentPos = 0;
        let currentNode;
        let result = [];
        // console.log(editorName, "getTextRangeRects", { startOffset, endOffset });
        if (startOffset === 0 && endOffset === 0) {
            let firstTextNode = walker.nextNode();
            let created = false;
            if (!firstTextNode || firstTextNode.nodeValue.length === 0) {
                firstTextNode = document.createTextNode("\u200b");
                editor.insertBefore(firstTextNode, editor.firstChild);
                created = true;
            }
            const range = document.createRange();
            range.setStart(firstTextNode, 0);
            range.setEnd(firstTextNode, 0);
            const rects = range.getClientRects();
            for (const rect of rects) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
            if (created) {
                firstTextNode.remove();
            }
        }
        else {
            let startNode = null;
            let startNodeOffset = 0;
            let endNode = null;
            let endNodeOffset = 0;
            function emit(startText, startTextOffset, endText, endTextOffset) {
                const range = document.createRange();
                range.setStart(startText, startTextOffset);
                range.setEnd(endText, endTextOffset);
                const rects = range.getClientRects();
                for (const rect of rects) {
                    // if (result.length > 0) {
                    // 	const prevRect = result[result.length - 1];
                    // 	if (prevRect.height === rect.height && prevRect.x + prevRect.width === rect.x) {
                    // 		prevRect.width += rect.width;
                    // 		continue;
                    // 	}
                    // }
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
            }
            while ((currentNode = walker.nextNode())) {
                const nodeLen = currentNode.nodeValue.length;
                const nodeEnd = currentPos + nodeLen;
                if (currentPos >= endOffset) {
                    break;
                }
                if (endOffset >= currentPos && startOffset <= nodeEnd) {
                    let start = 0;
                    let end = nodeLen;
                    if (currentPos < startOffset) {
                        start = startOffset - currentPos;
                    }
                    if (nodeEnd > endOffset) {
                        end = endOffset - currentPos;
                    }
                    if (startNode && startNode.parentNode !== currentNode.parentNode) {
                        emit(startNode, startNodeOffset, endNode, endNodeOffset);
                        startNode = endNode = null;
                        startNodeOffset = endNodeOffset = 0;
                    }
                    if (startNode === null) {
                        startNode = currentNode;
                        startNodeOffset = start;
                    }
                    endNode = currentNode;
                    endNodeOffset = end;
                    // if (start <= end) {
                    // 	let range = document.createRange();
                    // 	range.setStart(currentNode, start);
                    // 	range.setEnd(currentNode, end);
                    // 	// console.log("currentNode:", { text: currentNode.nodeValue, start, end });
                    // 	// console.log("range:", range);
                    // 	const rects = range.getClientRects();
                    // 	for (const rect of rects) {
                    // 		if (result.length > 0) {
                    // 			const prevRect = result[result.length - 1];
                    // 			if (prevRect.height === rect.height && prevRect.x + prevRect.width === rect.x) {
                    // 				prevRect.width += rect.width;
                    // 				continue;
                    // 			}
                    // 		}
                    // 		result.push({
                    // 			x: rect.x,
                    // 			y: rect.y,
                    // 			width: rect.width,
                    // 			height: rect.height,
                    // 		});
                    // 	}
                    // }
                    if (nodeEnd >= endOffset) {
                        break;
                    }
                }
                currentPos = nodeEnd;
            }
            if (startNode && endNode) {
                emit(startNode, startNodeOffset, endNode, endNodeOffset);
            }
        }
        if (result.length > 0) {
            // if (result[result.length - 1].width === 0) {
            // 	result.length--;
            // }
            // if (result.length > 0 && result[0].width === 0) {
            // 	result.shift();
            // }
        }
        return result;
    }
    function getTextSelectionRange() {
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount) {
            // console.debug("no selection or range count is 0");
            return [null, null];
        }
        const range = selection.getRangeAt(0);
        const root = editor.contains(range.commonAncestorContainer) ? editor : null;
        if (!root) {
            //console.debug(editorName, "no root found", { commonAncestorContainer: range.commonAncestorContainer, startContainer: range.startContainer, endContainer: range.endContainer });
            return [null, null];
        }
        // console.debug(editorName, "range", {
        // 	commonAncestorContainer: range.commonAncestorContainer,
        // 	startContainer: range.startContainer,
        // 	endContainer: range.endContainer,
        // 	startOffset: range.startOffset,
        // 	endOffset: range.endOffset,
        // });
        let startOffset = getTextOffset(root, range.startContainer, range.startOffset);
        let endOffset = getTextOffset(root, range.endContainer, range.endOffset);
        // console.debug(editorName, "startOffset, endOffset", { startOffset, endOffset });
        if (isNaN(startOffset) || isNaN(endOffset)) {
            //	console.debug(editorName, "no start or end offset found", { startOffset, endOffset });
            return [null, null];
        }
        // if (startOffset === -1 || startOffset >= _text.length) {
        // 	startOffset = _text.length - 1;
        // }
        // if (endOffset === -1 || endOffset >= _text.length) {
        // 	endOffset = _text.length - 1;
        // }
        // if (startOffset > endOffset) {
        // 	[startOffset, endOffset] = [endOffset, startOffset];
        // }
        // console.debug(editorName, "getTextSelectionRange", { startOffset, endOffset });
        return [startOffset, endOffset];
    }
    // 문자 오프셋만으로는 브라우저에서 텍스트를 드래그하듯 완전한 범위 선택을 할 수 없다.
    // 텍스트노드 자체가 없는데 마우스로 긁으면 선택이 되는 경우가 있다. <br><br><br> 이걸 마우스로 긁거나 CTRL-A를 누르면 3줄이 선택되지만
    // 문자 오프셋으로는 이걸 표현할 수가 없다. GREEDY하게 할지 LAZY하게 할지 전혀 선택하지 않을지 하나만 선택하게 할지 가장 먼저 나타나는 것을 선택할지 가장 마지막을 선택할지
    // 사용 시나리오를 살펴봐야한다.
    // 1. 텍스트를 긁었을 때 반대쪽 에디터에서 RANGE를 만들어서 하이라이팅
    // 이 경우 처음부터 길이가 0이라면 아무것도 선택하지 않고 리턴(NULL??)
    // 그렇지 않으면 범위의 시작과 끝 부분에 있는 길이가 0인 텍스트노드는 다 무시해야한다. 중간에 있는 것들은 포함
    // 2. DIFF 범위 하이라이팅
    // 이 경우 길이가 0인 경우가 문제가 된다.
    //
    function createTextRange(startOffset, endOffset) {
        const range = document.createRange();
        let pos = 0;
        let startSet = false, endSet = false;
        // 실패하는 경우는 endOffset과 그 이후에 텍스트노드가 없는 경우임.
        let skipLeadingEmptyTextNodes = endOffset > startOffset;
        let skipTrailingEmptyTextNodes = endOffset > startOffset;
        function walk(node) {
            if (node.nodeType === 3) {
                const text = node.nodeValue;
                const textLen = text.length;
                const endPos = pos + textLen;
                if (!startSet && startOffset >= pos && startOffset < endPos && (!skipLeadingEmptyTextNodes || textLen > startOffset - pos)) {
                    range.setStart(node, startOffset - pos);
                    startSet = true;
                }
                if (startSet && endOffset >= pos && endOffset <= endPos && (!skipTrailingEmptyTextNodes || endOffset > pos)) {
                    range.setEnd(node, endOffset - pos);
                    endSet = true;
                    return;
                }
                pos = endPos;
            }
            else if (node.nodeType === 1) {
                const childNodes = node.childNodes;
                if (childNodes.length > 0) {
                    for (let i = 0; i < childNodes.length; i++) {
                        walk(childNodes[i]);
                        if (startSet && endSet) {
                            return;
                        }
                    }
                }
                else {
                    pos += node.textContent.length;
                }
            }
        }
        walk(editor);
        if (!startSet) {
            let node = editor;
            while (node && node.firstChild) {
                node = node.firstChild;
            }
            range.setStart(node, 0);
            // while (node && node.firstChild) {
            // 	node = node.firstChild;
            // }
            // range.setStartBefore(node);
        }
        if (!endSet) {
            let node = editor;
            while (node && node.lastChild) {
                node = node.lastChild;
            }
            range.setEnd(node, 0);
        }
        // const sel = window.getSelection()!;
        // sel.removeAllRanges();
        // sel.addRange(range);
        return range;
    }
    function _createTextRange(startOffset, endOffset, startNode = editor, startPos = 0) {
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const range = document.createRange();
        let startSet = false, endSet = false;
        let pos = startPos;
        // 실패하는 경우는 endOffset과 그 이후에 텍스트노드가 없는 경우임.
        function walk(node) {
            if (node.nodeType === 3) {
                const text = node.nodeValue;
                const textLen = text.length;
                const endPos = pos + textLen;
                if (!startSet && startOffset >= pos && startOffset < endPos) {
                    range.setStart(node, startOffset - pos);
                    startSet = true;
                }
                else if (!startSet) {
                    console.log("start not set", node, startOffset, pos);
                }
                if (endOffset >= pos && endOffset <= endPos) {
                    range.setEnd(node, endOffset - pos);
                    console.log("found end", node, endOffset - pos, endOffset, pos);
                    endSet = true;
                    return;
                }
                else if (startSet && !endSet) {
                    console.log("end not set", node, startOffset, pos);
                }
                pos = endPos;
            }
            else if (node.nodeType === 1) {
                const childNodes = node.childNodes;
                if (childNodes.length > 0) {
                    for (let i = 0; i < childNodes.length; i++) {
                        walk(childNodes[i]);
                        if (startSet && endSet) {
                            return;
                        }
                    }
                }
                else {
                    pos += node.textContent.length;
                }
            }
        }
        walk(startNode || editor);
        if (!startSet) {
            let node = editor;
            while (node && node.firstChild) {
                node = node.firstChild;
            }
            range.setStart(node, 0);
            // while (node && node.firstChild) {
            // 	node = node.firstChild;
            // }
            // range.setStartBefore(node);
            console.log("start fallback", node);
        }
        if (!endSet) {
            let node = editor;
            while (node && node.lastChild) {
                node = node.lastChild;
            }
            range.setEnd(node, 0);
            console.log("end fallback", node);
        }
        // const sel = window.getSelection()!;
        // sel.removeAllRanges();
        // sel.addRange(range);
        return range;
    }
    function createTextRange2(startOffset, endOffset) {
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const range = document.createRange();
        let startSet = false;
        let endSet = false;
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        if (startOffset === 0 && endOffset === 0) {
            const firstChild = editor.firstChild;
            if (firstChild) {
                range.setStart(firstChild, 0);
                return range;
            }
            const firstTextNode = walker.nextNode();
            if (firstTextNode) {
                range.setStart(firstTextNode, 0);
                range.setEnd(firstTextNode, 0);
                return range;
            }
            else {
                return null;
            }
        }
        let currentNode;
        let pos = 0;
        while (!endSet && (currentNode = walker.nextNode())) {
            if (!startSet && pos + currentNode.nodeValue.length >= startOffset) {
                range.setStart(currentNode, startOffset - pos);
                startSet = true;
            }
            if (!endSet && pos + currentNode.nodeValue.length >= endOffset) {
                range.setEnd(currentNode, endOffset - pos);
                endSet = true;
            }
            pos += currentNode.nodeValue.length;
        }
        if (startSet && endSet) {
            return range;
        }
        else {
            return null;
        }
    }
    function selectTextRange(startOffset, endOffset) {
        const range = createTextRange(startOffset, endOffset);
        if (range) {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            return true;
        }
        return false;
    }
    // #endregion
    // =============================================================
    function mergeRects(rects) {
        rects.sort((a, b) => a.y + a.height - (b.y + b.height));
        const merged = [];
        const used = new Array(rects.length).fill(false);
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = 0;
        let maxY = 0;
        for (let i = 0; i < rects.length; i++) {
            if (used[i])
                continue;
            let base = rects[i];
            for (let j = i + 1; j < rects.length; j++) {
                if (used[j])
                    continue;
                const compare = rects[j];
                // 조기 종료: compare.y > base.y + base.height 이면 더 이상 겹칠 수 없음
                if (compare.y > base.y + base.height)
                    break;
                // 완전 포함: base가 compare를 완전히 포함하는 경우
                if (base.x <= compare.x &&
                    base.x + base.width >= compare.x + compare.width &&
                    base.y <= compare.y &&
                    base.y + base.height >= compare.y + compare.height) {
                    used[j] = true;
                    continue;
                }
                // 완전 포함: compare가 base를 완전히 포함하는 경우
                if (compare.x <= base.x &&
                    compare.x + compare.width >= base.x + base.width &&
                    compare.y <= base.y &&
                    compare.y + compare.height >= base.y + base.height) {
                    base = compare;
                    used[j] = true;
                    continue;
                }
                // y축 거의 같고, x축 겹치면 병합 (좌우 확장)
                const sameY = Math.abs(base.y - compare.y) < 1 && Math.abs(base.height - compare.height) < 1;
                const xOverlap = base.x <= compare.x + compare.width && compare.x <= base.x + base.width;
                if (sameY && xOverlap) {
                    // 새 병합 사각형 계산
                    const newX = Math.min(base.x, compare.x);
                    const newWidth = Math.max(base.x + base.width, compare.x + compare.width) - newX;
                    base = {
                        x: newX,
                        y: base.y,
                        width: newWidth,
                        height: base.height,
                    };
                    used[j] = true;
                }
            }
            merged.push(base);
            minX = Math.min(minX, base.x);
            minY = Math.min(minY, base.y);
            maxX = Math.max(maxX, base.x + base.width);
            maxY = Math.max(maxY, base.y + base.height);
            used[i] = true;
        }
        if (minX === Number.MAX_SAFE_INTEGER) {
            minX = 0;
        }
        if (minY === Number.MAX_SAFE_INTEGER) {
            minY = 0;
        }
        merged.sort((a, b) => (a.y !== b.y ? a.y - b.y : a.x - b.x));
        return {
            minX,
            minY,
            maxX,
            maxY,
            rects: merged,
        };
    }
    function getTextRects(startOffset, endOffset) {
        const range = createTextRange(startOffset, endOffset);
        let result = [];
        if (range) {
            let { x: baseX, y: baseY } = wrapper.getBoundingClientRect();
            baseX = -baseX + wrapper.scrollLeft;
            baseY = -baseY + wrapper.scrollTop;
            const rects = range.getClientRects();
            for (const rect of rects) {
                if (rect) {
                    rect.x += baseX;
                    rect.y += baseY;
                    result.push(rect);
                }
            }
        }
        if (result.length > 0) {
            let firstNonZero = -1;
            let lastNonZero = -1;
            for (let i = 0; i < result.length; i++) {
                if (result[i].width > 0) {
                    if (firstNonZero === -1) {
                        firstNonZero = i;
                    }
                    lastNonZero = i;
                }
            }
            if (firstNonZero !== -1 && lastNonZero !== -1) {
                result = result.slice(firstNonZero, lastNonZero + 1);
            }
            else if (result.length > 1) {
                result.length = 1;
            }
        }
        return result;
    }
    function calculateDiffRects() {
        const diffExpandX = 1;
        const diffExpandY = 0;
        let { x: baseX, y: baseY } = wrapper.getBoundingClientRect();
        baseX = -baseX;
        baseX += wrapper.scrollLeft;
        baseY += wrapper.scrollTop;
        _diffRects.length = 0;
        const temp = [];
        const allRects = [];
        const heightMultiplier = 1;
        for (let diffIndex = 0; diffIndex < _diffRanges.length; diffIndex++) {
            const ranges = _diffRanges[diffIndex];
            for (const range of ranges) {
                const rects = range.getClientRects();
                for (const rect of rects) {
                    if (rect) {
                        const newHeight = rect.height * heightMultiplier;
                        const heightDelta = newHeight - rect.height;
                        rect.x += baseX - diffExpandX;
                        rect.y += baseY - heightDelta / 2 - diffExpandY;
                        rect.width += diffExpandX * 2;
                        rect.height = newHeight + diffExpandY * 2;
                    }
                    temp.push(rect);
                    allRects.push(rect);
                }
            }
            _diffRects[diffIndex] = mergeRects(temp);
            // console.log(editorName, diffIndex, "beforeMerge", Array.from(temp), "afterMerge", _diffRects[diffIndex]);
            temp.length = 0;
        }
        _diffLineRects.length = 0;
        const canvasWidth = staticCanvas.width;
        allRects.sort((a, b) => a.y - b.y);
        let lineRect = null;
        const lineExpandY = 4;
        const lineHeightMultiplier = 1.1;
        for (const rect of allRects) {
            const y = rect.y - lineExpandY;
            const height = rect.height * lineHeightMultiplier + lineExpandY * 2;
            //const height = rect.height + lineExpand * 2;
            if (lineRect === null || y > lineRect.y + lineRect.height) {
                lineRect = {
                    x: 0,
                    y: y,
                    width: canvasWidth,
                    height: height,
                };
                _diffLineRects.push(lineRect);
            }
            else {
                lineRect.height = y + height - lineRect.y;
            }
        }
    }
    function renderAll() {
        _renderLayers[DIFF_LAYER].dirty = true;
        _renderLayers[HIGHLIGHT_LAYER].dirty = true;
        render();
    }
    function render(imediate = false) {
        if (!imediate) {
            if (_renderPending) {
                return;
            }
            _renderPending = true;
            requestAnimationFrame(() => {
                render(true);
                _renderPending = false;
            });
            return;
        }
        if (_renderLayers[DIFF_LAYER].dirty) {
            renderDiffLayer();
            _renderLayers[DIFF_LAYER].dirty = false;
        }
        if (_renderLayers[HIGHLIGHT_LAYER].dirty) {
            renderHighlightLayer();
            _renderLayers[HIGHLIGHT_LAYER].dirty = false;
        }
    }
    function renderDiffLayer() {
        if (_diffRectsDirty) {
            calculateDiffRects();
            _diffRectsDirty = false;
        }
        const visibilityChangeEntries = [];
        const ctx = staticCanvasCtx;
        const canvasWidth = staticCanvas.width, canvasHeight = staticCanvas.height;
        if (_hasRenderedAny) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            _hasRenderedAny = false;
        }
        const scrollTop = wrapper.scrollTop;
        const scrollLeft = wrapper.scrollLeft;
        ctx.fillStyle = "hsl(0 100% 95%)";
        for (const rect of _diffLineRects) {
            const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
            if (y + height < 0 || y > canvasHeight)
                continue;
            if (x + width < 0 || x > canvasWidth)
                continue;
            ctx.fillRect(x, y, width, height);
            _hasRenderedAny = true;
        }
        for (let diffIndex = 0; diffIndex < _diffRects.length; diffIndex++) {
            const diffRectSet = _diffRects[diffIndex];
            let previouslyVisible = _visibleDiffIndices.has(diffIndex);
            let isVisible = !(diffRectSet.maxY - scrollTop < 0 || diffRectSet.minY - scrollTop > canvasHeight) &&
                !(diffRectSet.maxX - scrollLeft < 0 || diffRectSet.minX - scrollLeft > canvasWidth);
            if (isVisible !== previouslyVisible) {
                if (isVisible) {
                    _visibleDiffIndices.add(diffIndex);
                }
                else {
                    _visibleDiffIndices.delete(diffIndex);
                }
                visibilityChangeEntries.push({
                    item: diffIndex,
                    isVisible,
                });
            }
            if (!isVisible) {
                continue;
            }
            const hue = DIFF_COLOR_HUES[diffIndex % NUM_DIFF_COLORS];
            ctx.fillStyle = `hsl(${hue} 100% 80%)`;
            ctx.strokeStyle = `hsl(${hue} 100% 40% / 0.5)`;
            for (const rect of diffRectSet.rects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                ctx.strokeRect(x, y, width, height);
                ctx.fillRect(x, y, width, height);
                _hasRenderedAny = true;
            }
        }
        if (visibilityChangeEntries.length > 0) {
            onDiffVisibilityChanged(visibilityChangeEntries);
        }
    }
    // function doRenderRects(ctx: CanvasRenderingContext2D, rects: Rect[], fillColor: string, strokeColor?: string) {
    // 	const scrollTop = wrapper.scrollTop;
    // 	const scrollLeft = wrapper.scrollLeft;
    // 	ctx.fillStyle = fillColor;
    // 	if (strokeColor) {
    // 		ctx.strokeStyle = strokeColor;
    // 	}
    // 	for (const rect of rects) {
    // 		const x = Math.floor(rect.x - scrollLeft),
    // 			y = Math.floor(rect.y - scrollTop),
    // 			width = Math.ceil(rect.width),
    // 			height = Math.ceil(rect.height);
    // 		if (y + height < 0 || y > _canvasHeight) continue;
    // 		if (x + width < 0 || x > _canvasWidth) continue;
    // 		if (fillColor) {
    // 			ctx.fillRect(x, y, width, height);
    // 		}
    // 		if (strokeColor) {
    // 			ctx.strokeRect(x, y, width, height);
    // 		}
    // 	}
    // }
    // len이 0인 span이 들어있을 수 있다.
    function getTextRanges(spans) {
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let currentNode = walker.nextNode();
        let pos = 0;
        const result = new Array(spans.length);
        function create(startOffset, endOffset) {
            const range = document.createRange();
            if (currentNode) {
                let startSet = false;
                do {
                    const nodeText = currentNode.nodeValue;
                    const nodeStart = pos;
                    const nodeEnd = pos + nodeText.length;
                    if (!startSet && startOffset >= nodeStart && startOffset < nodeEnd) {
                        range.setStart(currentNode, startOffset - nodeStart);
                        startSet = true;
                    }
                    if (startSet && endOffset <= nodeEnd) {
                        range.setEnd(currentNode, endOffset - nodeStart);
                        break;
                    }
                    pos = nodeEnd;
                } while ((currentNode = walker.nextNode()));
            }
            return range;
        }
        for (let i = 0; i < spans.length; i++) {
            const span = spans[i];
            if (span.len > 0) {
                const startOffset = span.pos;
                const endOffset = span.pos + span.len;
                const range = create(startOffset, endOffset);
                if (range.startContainer === document || range.endContainer === document) {
                    throw new Error("range is not valid");
                }
                result[i] = range;
            }
        }
        for (let i = 0; i < spans.length; i++) {
            if (!result[i]) {
                const range = document.createRange();
                if (i > 0) {
                    range.setStart(range.endContainer, range.endOffset);
                }
                else {
                    range.setStart(editor, 0);
                }
                range.setEnd(editor, editor.childNodes.length);
            }
        }
        return result;
    }
    function renderHighlightLayer() {
        const ctx = highlightCanvasCtx;
        const canvasWidth = _canvasWidth, canvasHeight = _canvasHeight;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        const scrollTop = wrapper.scrollTop;
        const scrollLeft = wrapper.scrollLeft;
        if (_textSelectionHighlight) {
            let item = _textSelectionHighlight.renderItem;
            if (!item) {
                const rects = getTextRects(_textSelectionHighlight.startOffset, _textSelectionHighlight.endOffset);
                const merged = mergeRects(rects);
                item = _textSelectionHighlight.renderItem = {
                    rects: merged.rects,
                    minX: merged.minX,
                    minY: merged.minY,
                    maxX: merged.maxX,
                    maxY: merged.maxY,
                };
            }
            if (isRectVisible(item.minY, item.maxY, item.minX, item.maxX, scrollTop, scrollLeft, canvasWidth, canvasHeight)) {
                ctx.fillStyle = TEXT_SELECTION_HIGHLIGHT_FILL_STYLE;
                for (const rect of item.rects) {
                    const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                    if (y + height < 0 || y > _canvasHeight)
                        continue;
                    if (x + width < 0 || x > _canvasWidth)
                        continue;
                    ctx.fillRect(x, y, width, height);
                }
            }
        }
        function doRender(items) {
            for (const item of items) {
                const x = Math.floor(item.x - scrollLeft), y = Math.floor(item.y - scrollTop), width = Math.ceil(item.w), height = Math.ceil(item.h);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                if (item.fillStyle) {
                    ctx.fillStyle = item.fillStyle;
                    ctx.fillRect(x, y, width, height);
                }
                if (item.strokeStyle) {
                    ctx.strokeStyle = item.strokeStyle;
                    ctx.strokeRect(x, y, width, height);
                }
            }
        }
        if (_diffHighlightItems && _diffHighlightItems.length > 0) {
            ctx.save();
            ctx.lineWidth = 2; // 선 굵기 조절
            // 글로우 효과 설정
            ctx.shadowColor = "hsl(0 100% 80%)"; // 그림자 색깔 = 빛나는 색깔
            ctx.shadowBlur = 15; // 얼마나 퍼질지
            doRender(_diffHighlightItems);
            ctx.restore();
        }
        // if (_textHighlightItems && _textHighlightItems.length > 0) {
        // 	doRender(_textHighlightItems);
        // 	// for (const item of _textHighlightItems) {
        // 	// 	const x = Math.floor(item.x - scrollLeft),
        // 	// 		y = Math.floor(item.y - scrollTop),
        // 	// 		width = Math.ceil(item.w),
        // 	// 		height = Math.ceil(item.h);
        // 	// 	if (y + height < 0 || y > canvasHeight) continue;
        // 	// 	if (x + width < 0 || x > canvasWidth) continue;
        // 	// 	ctx.fillStyle = item.fillStyle || "hsl(210 100% 80%)";
        // 	// 	ctx.fillRect(x, y, width, height);
        // 	// 	console.log("highlight", { x, y, width, height });
        // 	// }
        // }
    }
    function sliceText(startOffset, endOffset) {
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let currentNode;
        let pos = 0;
        let result = "";
        while ((currentNode = walker.nextNode())) {
            const nodeLen = currentNode.nodeValue.length;
            const nodeEnd = pos + nodeLen;
            if (nodeEnd >= startOffset && pos <= endOffset) {
                let start = 0;
                let end = nodeLen;
                if (pos < startOffset) {
                    start = startOffset - pos;
                }
                if (nodeEnd > endOffset) {
                    end = endOffset - pos;
                }
                result += currentNode.nodeValue.slice(start, end);
                if (nodeEnd >= endOffset) {
                    break;
                }
            }
            pos = nodeEnd;
        }
        return result;
    }
    function update(ctx) {
        if (!ctx.done) {
            return;
        }
        const started = performance.now();
        _diffRanges.length = 0;
        _diffRects.length = 0;
        _diffLineRects.length = 0;
        _visibleDiffIndices.clear();
        let pos = 0; // 전체 텍스트 위치 누적
        let diffPos;
        let diffEndPos;
        const diffs = ctx.diffs;
        let currentNode = editor.firstChild;
        function advance(skipChildren = false) {
            if (!currentNode || currentNode === editor) {
                return false;
            }
            if (!skipChildren && currentNode.firstChild) {
                currentNode = currentNode.firstChild;
                return true;
            }
            let node = currentNode;
            while (node && node !== editor) {
                if (node.nextSibling) {
                    currentNode = node.nextSibling;
                    return true;
                }
                node = node.parentNode;
            }
            currentNode = null;
            return false;
        }
        function collectRanges() {
            if (!currentNode) {
                throw new Error("currentNode is null");
            }
            const ranges = [];
            while (currentNode) {
                if (currentNode.nodeType === 3) {
                    const text = currentNode.nodeValue;
                    const nodeStart = pos;
                    let nodeEnd = nodeStart + text.length;
                    if (diffEndPos < nodeStart) {
                        break;
                    }
                    if (diffPos <= nodeEnd) {
                        const startOffset = Math.max(0, diffPos - nodeStart);
                        const endOffset = Math.min(text.length, diffEndPos - nodeStart);
                        const range = document.createRange();
                        range.setStart(currentNode, startOffset);
                        range.setEnd(currentNode, endOffset);
                        ranges.push(range);
                    }
                    if (diffEndPos < nodeEnd) {
                        // done this diff
                        // console.log(2, editorName, "diffEndPos <= nodeEnd", { diffEndPos, nodeEnd });
                        break;
                    }
                    pos = nodeEnd;
                    advance();
                }
                else if (currentNode.nodeType === 1) {
                    const nodeStart = Number(currentNode.dataset.startOffset);
                    const nodeEnd = Number(currentNode.dataset.endOffset);
                    if (!isNaN(nodeStart) && !isNaN(nodeEnd)) {
                        if (nodeStart >= diffPos && nodeEnd <= diffEndPos) {
                            // console.log(3, editorName, "nodeStart, nodeEnd", { currentNode, nodeStart, nodeEnd });
                            if (currentNode.nodeName === "P" || INLINE_ELEMENTS[currentNode.nodeName]) {
                                const range = document.createRange();
                                range.selectNodeContents(currentNode);
                                ranges.push(range);
                                pos = nodeEnd;
                                advance(true);
                                if (diffEndPos <= pos) {
                                    // done this diff
                                    break;
                                }
                                continue;
                            }
                        }
                        if (diffPos > nodeEnd) {
                            // console.log(4, editorName, "diffPos >= nodeEnd", { diffPos, nodeEnd });
                            pos = nodeEnd;
                            advance(true);
                            continue;
                        }
                    }
                    // console.log(editorName, "children", Array.from(currentNode.childNodes));
                    // console.log(5, editorName, "advance", { currentNode });
                    advance();
                    continue;
                }
                else {
                    console.warn(editorName, "unknown node type", { currentNode });
                    advance();
                    continue;
                }
            }
            return ranges;
        }
        const result = [];
        for (let diffIndex = 0; diffIndex < diffs.length; diffIndex++) {
            const diff = diffs[diffIndex];
            const span = diff[editorName];
            diffPos = span.pos;
            diffEndPos = span.pos + span.len;
            const ranges = collectRanges();
            result[diffIndex] = ranges;
            _diffRanges[diffIndex] = ranges;
        }
        const end = performance.now();
        console.log(editorName, "update", end - started);
        _diffRectsDirty = true;
        renderAll();
    }
    function setLayerDirty(layerIndex) {
        _renderLayers[layerIndex].dirty = true;
        render();
    }
    function applyTextSelectionHighlight(startOffset, endOffset) {
        if (_textSelectionHighlight?.startOffset === startOffset && _textSelectionHighlight?.endOffset === endOffset) {
            return;
        }
        _textSelectionHighlight = {
            startOffset,
            endOffset,
        };
        // let { x: baseX, y: baseY } = wrapper.getBoundingClientRect();
        // baseX = -baseX;
        // baseX += wrapper.scrollLeft;
        // baseY += wrapper.scrollTop;
        setLayerDirty(HIGHLIGHT_LAYER);
        renderHighlightLayer();
    }
    function clearTextSelectionHighlight() {
        _textSelectionHighlight = null;
        renderHighlightLayer();
    }
    let _highlightedDiffIndex = null;
    function applyDiffHighlight(diffIndex) {
        if (diffIndex === _highlightedDiffIndex) {
            return;
        }
        _highlightedDiffIndex = diffIndex;
        if (diffIndex >= 0 && diffIndex < _diffRects.length) {
            const rectSet = _diffRects[diffIndex];
            _diffHighlightItems = rectSet.rects.map((rect) => {
                return {
                    x: rect.x,
                    y: rect.y,
                    w: rect.width,
                    h: rect.height,
                    strokeStyle: "hsl(0 100% 50%)",
                    type: "diffhighlight",
                };
            });
        }
        renderHighlightLayer();
    }
    function clearDiffHighlight() {
        _highlightedDiffIndex = null;
        _diffHighlightItems = null;
        renderHighlightLayer();
    }
    // temp
    setTimeout(onChange, 0);
    // 앵커를 어떤식으로 추가할지
    // 1. classList에 넣고 anchor:before
    // 2. <a> 태그를 넣는다
    function insertAnchorBefore(tokenIndex) {
        const token = _tokens[tokenIndex];
        const range = _ranges[tokenIndex];
        // console.log("insertAnchorBefore", tokenIndex, token, range);
        let el = null;
        // if (token.flags & TABLE_START) {
        // 	// console.log("insertAnchorBefore: TABLE_START", tokenIndex, token);
        // 	el = (range.startContainer.parentNode as HTMLElement).closest("table");
        // }
        if (!el) {
            el = range.startContainer;
            if (el.nodeType === 3) {
                //console.assert(range.startOffset === 0);
            }
            else if (el.nodeType === 1) {
                console.assert(range.startOffset < range.startContainer.childNodes.length);
                el = el.childNodes[range.startOffset];
            }
        }
        if (!el)
            return null;
        if (el.previousSibling && el.previousSibling.nodeName === "A") {
            return el.previousSibling;
        }
        const anchorEl = document.createElement("A");
        anchorEl.classList.add("anchor");
        el.parentNode.insertBefore(anchorEl, el);
        // (el as HTMLElement).dataset.anchor = String(_anchorElements.length);
        // (el as HTMLElement).classList.add("anchor");
        // _anchorElements.push(el as HTMLElement);
        return anchorEl;
    }
    function insertAnchorAfter(tokenIndex) {
        const token = _tokens[tokenIndex];
        if (!token) {
            return null;
        }
        const range = _ranges[tokenIndex];
        // console.log("insertAnchorAfter", tokenIndex, token, range);
        let el = null;
        // if (token.flags & TABLE_START) {
        // 	// console.log("insertAnchorAfter: TABLE_START", tokenIndex, token);
        // 	el = (range.startContainer.parentNode as HTMLElement).closest("table");
        // }
        console.log("insertAnchorAfter", tokenIndex, token, range);
        let parent;
        let before = null;
        if (range.endContainer.nodeType === 3) {
            parent = range.endContainer.parentNode;
            before = range.endContainer.nextSibling;
        }
        else if (range.endContainer.nodeType === 1) {
            parent = range.endContainer;
            before = range.endContainer.childNodes[range.endOffset]?.nextSibling || null;
        }
        else {
            console.warn("Unexpected node type in range.endContainer", range.endContainer);
            return null;
        }
        if (before && before.nodeName === "A") {
            return before;
        }
        const anchorEl = document.createElement("A");
        anchorEl.classList.add("anchor");
        parent.insertBefore(anchorEl, before);
        return anchorEl;
    }
    function findAnchorTargetElement(tokenIndex) {
        const token = _tokens[tokenIndex];
        const range = _ranges[tokenIndex];
        // let parent: HTMLElement | null = null;
        // let childIndex = 0;
        // if (token.flags & TABLE_START) {
        // 	[parent, childIndex] = findClosestTable(range.startContainer);
        // }
        let el = range.startContainer;
        // 찾을 수 있는 가장 상위 요소를 찾는데
        // 1. TEXT_FLOW_CONTAINER의 자식이면서
        while (!BLOCK_ELEMENTS[el.nodeName]) {
            el = el.parentNode;
            if (!el || el === editor) {
                console.warn("couldn't find appropriate element for anchor");
                return null;
            }
        }
        // (el as HTMLElement).dataset.anchor = String(_anchorElements.length);
        // (el as HTMLElement).classList.add("anchor");
        // _anchorElements.push(el as HTMLElement);
        return el;
    }
    const { tokenize } = (function () {
        const TIMEOUT = 200;
        let _contextId = 0;
        let _callbackId = null;
        let _startTime = 0;
        function* tokenizeGenerator(ctx) {
            let idleDeadline = yield;
            let nodeCounter = 0;
            // console.log("BEFORE!", editorName, "tokenize", editor.textContent);
            const startTime = performance.now();
            let textPos = 0;
            let tokenIndex = 0;
            let currentToken = null;
            let currentRange = null;
            // function processToken(str: string, start: number, length: number) {
            // 	if (currentToken) {
            // 		currentToken.text += str;
            // 		currentToken.len = textPos - currentToken.pos;
            // 	} else {
            // 		currentToken = {
            // 			text: str,
            // 			pos: start,
            // 			len: length,
            // 			flags: 0,
            // 			lineNum: 0,
            // 		};
            // 	}
            // }
            function processToken2(text, startOffset, endOffset) {
                if (currentToken) {
                    currentToken.text += text.nodeValue.slice(startOffset, endOffset);
                    currentToken.len += endOffset - startOffset;
                    currentRange.setEnd(text, endOffset);
                }
                else {
                    currentToken = {
                        text: text.nodeValue.slice(startOffset, endOffset),
                        pos: textPos + startOffset,
                        len: endOffset - startOffset,
                        flags: 0,
                        lineNum: 0,
                    };
                    currentRange = document.createRange();
                    currentRange.setStart(text, startOffset);
                    currentRange.setEnd(text, endOffset);
                }
            }
            function finalizeToken(flags = 0) {
                if (currentToken) {
                    currentToken.flags |= flags;
                    _tokens[tokenIndex] = currentToken;
                    _ranges[tokenIndex] = currentRange;
                    currentToken = null;
                    tokenIndex++;
                    return 1;
                }
                return 0;
            }
            function* traverse(node) {
                if (ctx.id !== _contextId) {
                    throw new Error("cancelled");
                }
                if ((++nodeCounter & 31) === 0) {
                    if (idleDeadline.timeRemaining() < 1) {
                        idleDeadline = yield;
                    }
                }
                let currentStart = -1;
                if (node.nodeType === 3) {
                    const text = node.nodeValue;
                    if (text.length === 0)
                        return;
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        if (spaceChars[char]) {
                            if (currentStart >= 0) {
                                processToken2(node, currentStart, i);
                                currentStart = -1;
                            }
                            finalizeToken();
                        }
                        else {
                            if (currentStart < 0) {
                                currentStart = i;
                            }
                        }
                    }
                    if (currentStart >= 0) {
                        processToken2(node, currentStart, text.length);
                    }
                    textPos += text.length;
                }
                else if (node.nodeType === 1) {
                    if (node.nodeName === "BR") {
                        finalizeToken(LINE_END);
                        return;
                    }
                    if (node.className === "img") {
                        finalizeToken();
                        currentToken = {
                            text: node.dataset.src || node.src || "🖼️",
                            pos: textPos,
                            len: node.textContent.length,
                            lineNum: 0,
                            flags: IMAGE | NO_JOIN,
                        };
                        currentRange = document.createRange();
                        currentRange.setStart(node, 0);
                        currentRange.setEnd(node, node.childNodes.length);
                        finalizeToken();
                        textPos += node.textContent.length; // 아마도 0이겠지
                        return;
                    }
                    node.dataset.startOffset = String(textPos);
                    if (TEXT_FLOW_CONTAINERS[node.nodeName]) {
                        finalizeToken(CONTAINER_END | LINE_END);
                    }
                    const isTextFlowContainer = TEXT_FLOW_CONTAINERS[node.nodeName];
                    const numTokensBefore = tokenIndex;
                    for (const child of node.childNodes) {
                        yield* traverse(child);
                    }
                    if (BLOCK_ELEMENTS[node.nodeName]) {
                        finalizeToken();
                    }
                    const firstToken = _tokens[numTokensBefore];
                    const lastToken = _tokens[tokenIndex - 1];
                    if (isTextFlowContainer) {
                        if (firstToken) {
                            firstToken.flags |= CONTAINER_START | LINE_START;
                        }
                        if (lastToken) {
                            lastToken.flags |= CONTAINER_END | LINE_END;
                        }
                    }
                    if (node.nodeName === "P") {
                        if (firstToken) {
                            firstToken.flags |= LINE_START;
                        }
                        if (lastToken) {
                            lastToken.flags |= LINE_END;
                        }
                    }
                    if (node.nodeName === "TR") {
                        if (firstToken) {
                            firstToken.flags |= TABLEROW_START;
                        }
                        if (lastToken) {
                            lastToken.flags |= TABLEROW_END;
                        }
                    }
                    if (node.nodeName === "TD" || node.nodeName === "TH") {
                        if (firstToken) {
                            firstToken.flags |= TABLECELL_START;
                        }
                        if (lastToken) {
                            lastToken.flags |= TABLECELL_END;
                        }
                    }
                    if (node.nodeName === "TABLE") {
                        if (firstToken) {
                            firstToken.flags |= TABLE_START;
                        }
                        if (lastToken) {
                            lastToken.flags |= TABLE_END;
                        }
                    }
                    node.dataset.endOffset = String(textPos);
                    // currentContainer = containerStack.pop()!;
                }
            }
            yield* traverse(editor);
            finalizeToken();
            _tokens.length = tokenIndex;
            _ranges.length = tokenIndex;
            const endTime = performance.now();
            console.log(editorName, "tokenize", Math.ceil(endTime - startTime) + "ms", { _tokens, _ranges });
        }
        function tokenize() {
            _startTime = performance.now();
            const ctx = {
                id: ++_contextId,
            };
            const generator = tokenizeGenerator(ctx);
            const step = (idleDeadline) => {
                _callbackId = null;
                try {
                    const { done } = generator.next(idleDeadline);
                    if (done) {
                        const endTime = performance.now();
                        console.log(editorName, "tokenize done", Math.ceil(endTime - _startTime) + "ms", { _tokens, _ranges });
                        onTokenizeDone();
                    }
                    else {
                        if (ctx.id === _contextId) {
                            _callbackId = requestIdleCallback(step, { timeout: TIMEOUT });
                        }
                        else {
                            console.log(editorName, "tokenize cancelled");
                        }
                    }
                }
                catch (e) {
                    if (e.message === "cancelled") {
                        console.log(editorName, "tokenize cancelled");
                    }
                    else {
                        console.error(editorName, "tokenize error", e);
                    }
                }
            };
            _callbackId = requestIdleCallback(step, { timeout: TIMEOUT });
        }
        return { tokenize };
    })();
    return {
        insertAnchorBefore,
        insertAnchorAfter,
        findAnchorTargetElement,
        createTextRange2,
        update,
        sliceText,
        name: editorName,
        wrapper,
        editor,
        // updateText,
        // setText,
        scrollToDiff,
        scrollToHeading,
        // saveCaret,
        // restoreCaret,
        getVisibleAnchors,
        getFirstVisibleAnchor,
        scrollToLine,
        getFirstVisibleLineElement,
        getClosestAnchorToCaret: getClosestAnchorToCaret,
        setEditMode,
        getTextSelectionRange,
        selectTextRange,
        createTextRange,
        getTextRects,
        applyTextHighlight: applyTextSelectionHighlight,
        clearTextHighlight: clearTextSelectionHighlight,
        applyDiffHighlight,
        clearDiffHighlight,
        getRangeForToken,
        // 그냥 states 객체를 하나 만들어서 리턴할까...
        // get text() {
        // 	return _text;
        // },
        get lineElements() {
            return _lineElements;
        },
        get diffElements() {
            return _diffElements;
        },
        get visibleAnchors() {
            return _visibleAnchors;
        },
        get anchorElements() {
            return _anchorElements;
        },
        get visibleDiffIndices() {
            return _visibleDiffIndices;
        },
        get tokens() {
            return _tokens;
        },
        get ranges() {
            return _ranges;
        },
    };
    function getRangeForToken(index, count = 1) {
        const ranges = _ranges;
        const range = document.createRange();
        if (count === 1) {
            return ranges[index];
        }
        if (count > 1) {
            range.setStart(ranges[index].startContainer, ranges[index].startOffset);
            range.setEnd(ranges[index + count - 1].endContainer, ranges[index + count - 1].endOffset);
            return range;
        }
        if (index > 0) {
            const prevRange = ranges[index - 1];
            range.setStart(prevRange.endContainer, prevRange.endOffset);
        }
        else {
            range.setStart(editor, 0);
        }
        if (index < ranges.length) {
            const nextRange = ranges[index];
            console.log("next range", nextRange);
            range.setEnd(nextRange.startContainer, nextRange.startOffset);
        }
        else {
            range.setEnd(editor, editor.childNodes.length);
        }
        return range;
    }
}
//# sourceMappingURL=editor.js.map
</script>
<script>"use strict";
function createRenderer(_container, _leftEditor, _rightEditor, callbacks) {
    // diff index to rect array(하나의 diff가 여러개의 rect를 가질 수 있음)
    const DIFF_LINE_HEIGHT_MULTIPLIER = 1.1;
    const DIFF_LINE_EXPAND_Y = 4;
    const DIFF_LINE_FILL_STYLE = "hsl(0 100% 95%)";
    const onDiffVisibilityChanged = callbacks.onDiffVisibilityChanged || (() => { });
    const _leftRegion = {
        editor: _leftEditor,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        scrollTop: 0,
        scrollLeft: 0,
        dirtyFlags: 0,
        diffRanges: null,
        diffRenderItems: null,
        diffLineRects: null,
        visibleDiffIndices: new Set(),
    };
    const _rightRegion = {
        editor: _rightEditor,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        scrollTop: 0,
        scrollLeft: 0,
        dirtyFlags: 0,
        diffRanges: null,
        diffRenderItems: null,
        diffLineRects: null,
        visibleDiffIndices: new Set(),
    };
    let _canvasX = 0;
    let _canvasY = 0;
    let _canvasWidth = 0;
    let _canvasHeight = 0;
    let _textHighlights = null;
    let _renderPending = false;
    const diffCanvas = document.createElement("canvas");
    const diffCanvasCtx = diffCanvas.getContext("2d");
    _container.appendChild(diffCanvas);
    const highlightCanvas = document.createElement("canvas");
    const highlightCanvasCtx = highlightCanvas.getContext("2d");
    _container.appendChild(highlightCanvas);
    const resizeObserver = new ResizeObserver((entries) => {
        updateLayout();
        render();
    });
    resizeObserver.observe(_container);
    resizeObserver.observe(_leftEditor.wrapper);
    resizeObserver.observe(_rightEditor.wrapper);
    function onEditorScroll(e) {
        const editor = e.target === _leftEditor.wrapper ? _leftEditor : _rightEditor;
        const editorName = editor.name;
        const scrollTop = editor.wrapper.scrollTop;
        const scrollLeft = editor.wrapper.scrollLeft;
        const region = editorName === "left" ? _leftRegion : _rightRegion;
        if (region.scrollTop !== scrollTop || region.scrollLeft !== scrollLeft) {
            region.scrollTop = scrollTop;
            region.scrollLeft = scrollLeft;
            region.dirtyFlags |= 3 /* RenderFlags.ALL */;
            render();
        }
    }
    _leftEditor.wrapper.addEventListener("scroll", onEditorScroll);
    _rightEditor.wrapper.addEventListener("scroll", onEditorScroll);
    function updateLayout() {
        const { x, y, width, height } = _container.getBoundingClientRect();
        if (_canvasWidth === width && _canvasHeight === height && _canvasX === x && _canvasY === y) {
            return;
        }
        _canvasX = x;
        _canvasY = y;
        _canvasWidth = width;
        _canvasHeight = height;
        diffCanvas.width = width;
        diffCanvas.height = height;
        highlightCanvas.width = width;
        highlightCanvas.height = height;
        for (const editor of [_leftEditor, _rightEditor]) {
            const editorName = editor.name;
            const region = editorName === "left" ? _leftRegion : _rightRegion;
            const { x, y, width, height } = editor.wrapper.getBoundingClientRect();
            region.x = x - _canvasX;
            region.y = y - _canvasY;
            region.width = width;
            region.height = height;
            region.scrollTop = editor.wrapper.scrollTop;
            region.scrollLeft = editor.wrapper.scrollLeft;
            region.diffRenderItems = null;
            region.dirtyFlags |= 3 /* RenderFlags.ALL */;
        }
        render();
    }
    function setTextHighlight(region, ranges) { }
    function setDiffRanges(editor, ranges) {
        const region = editor === "left" ? _leftRegion : _rightRegion;
        region.diffRanges = ranges;
        region.diffRenderItems = null;
        region.dirtyFlags |= 1 /* RenderFlags.DIFF */;
        render();
    }
    let _renderCounter = 0;
    function render() {
        if (_renderPending) {
            return;
        }
        _renderPending = true;
        requestAnimationFrame(() => {
            ++_renderCounter;
            if (_leftRegion.dirtyFlags !== 0) {
                renderEditorRegion("left");
                _leftRegion.dirtyFlags = 0;
            }
            if (_rightRegion.dirtyFlags !== 0) {
                renderEditorRegion("right");
                _rightRegion.dirtyFlags = 0;
            }
            _renderPending = false;
        });
    }
    function renderEditorRegion(editorName) {
        const region = editorName === "left" ? _leftRegion : _rightRegion;
        if (region.dirtyFlags & 1 /* RenderFlags.DIFF */) {
            const ctx = diffCanvasCtx;
            const { scrollLeft, scrollTop } = region;
            ctx.clearRect(region.x, region.y, region.width, region.height);
            let visibleDiffIndices = region.visibleDiffIndices;
            let renderItems = region.diffRenderItems;
            if (!renderItems) {
                buildDiffRenderItems(region);
                console.log("buildDiffRenderItems!!:", region);
                renderItems = region.diffRenderItems;
            }
            // render diff lines
            ctx.fillStyle = DIFF_LINE_FILL_STYLE;
            console.log("diffLineRects:", region.diffLineRects);
            for (const rect of region.diffLineRects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0 || y > _canvasHeight)
                    continue;
                if (x + width < 0 || x > _canvasWidth)
                    continue;
                ctx.fillRect(x, y, width, height);
            }
            let shown = [];
            let hidden = [];
            for (let diffIndex = 0; diffIndex < renderItems.length; ++diffIndex) {
                const item = renderItems[diffIndex];
                if (!item) {
                    continue;
                }
                item.renderedRect.length = 0;
                let isVisible = !(item.maxY - scrollTop < 0 || item.minY - scrollTop > _canvasHeight) &&
                    !(item.maxX - scrollLeft < 0 || item.minX - scrollLeft > _canvasWidth);
                if (isVisible) {
                    if (!visibleDiffIndices.has(diffIndex)) {
                        visibleDiffIndices.add(diffIndex);
                        shown.push(diffIndex);
                    }
                }
                else {
                    if (visibleDiffIndices.has(diffIndex)) {
                        visibleDiffIndices.delete(diffIndex);
                        hidden.push(diffIndex);
                    }
                    continue;
                }
                ctx.fillStyle = item.fill;
                ctx.strokeStyle = item.stroke;
                for (const rect of item.rects) {
                    const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                    if (y + height < 0 || y > _canvasHeight)
                        continue;
                    if (x + width < 0 || x > _canvasWidth)
                        continue;
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeRect(x, y, width, height);
                    item.renderedRect.push(rect);
                }
            }
            if (shown.length > 0 || hidden.length > 0) {
                onDiffVisibilityChanged(editorName, shown, hidden);
            }
        }
    }
    function buildDiffRenderItems(region) {
        const rangesMap = region.diffRanges;
        if (!rangesMap || rangesMap.length === 0) {
            region.diffRenderItems = [];
            region.diffLineRects = [];
            return [];
        }
        const expandX = 1;
        const expandY = 0;
        const { left: canvasLeft, right: canvasRight } = diffCanvas.getBoundingClientRect();
        const { x: regionX, y: regionY, width: regionWidth, height: regionHeight, scrollLeft, scrollTop } = region;
        const offsetX = scrollLeft;
        const offsetY = scrollTop;
        const result = new Array(rangesMap.length);
        const allRects = [];
        for (let diffIndex = 0; diffIndex < rangesMap.length; ++diffIndex) {
            const ranges = rangesMap[diffIndex];
            const hue = DIFF_COLOR_HUES[diffIndex % NUM_DIFF_COLORS];
            const rawRects = [];
            for (const range of ranges) {
                const clientRects = range.getClientRects();
                for (let i = 0; i < clientRects.length; ++i) {
                    const rect = {
                        x: clientRects[i].x + offsetX - expandX,
                        y: clientRects[i].y + offsetY - expandY,
                        width: clientRects[i].width + expandX * 2,
                        height: clientRects[i].height + expandY * 2,
                    };
                    rawRects.push(rect);
                    allRects.push(rect);
                }
            }
            const merged = mergeRects(rawRects);
            result[diffIndex] = {
                diffIndex,
                editor: region.editor.name,
                minX: merged.minX,
                minY: merged.minY,
                maxX: merged.maxX,
                maxY: merged.maxY,
                rects: merged.rects,
                fill: `hsl(${hue} 100% 80%)`,
                stroke: `hsl(${hue} 100% 40% / 0.5)`,
                renderedRect: [],
            };
        }
        region.diffRenderItems = result;
        buildDiffLineRects(region, allRects);
        return result;
    }
    function buildDiffLineRects(region, diffRects) {
        diffRects.sort((a, b) => a.y - b.y);
        const result = [];
        let lineRect = null;
        for (const rect of diffRects) {
            const y = rect.y - DIFF_LINE_EXPAND_Y;
            const height = rect.height * DIFF_LINE_HEIGHT_MULTIPLIER + DIFF_LINE_EXPAND_Y * 2;
            //const height = rect.height + lineExpand * 2;
            if (lineRect === null || y > lineRect.y + lineRect.height) {
                lineRect = {
                    x: region.x,
                    y: y,
                    width: region.width,
                    height: height,
                };
                result.push(lineRect);
            }
            else {
                lineRect.height = y + height - lineRect.y;
            }
        }
        region.diffLineRects = result;
        console.log("diffLineRects:", result);
    }
    updateLayout();
    function markDirty(editor, flags) {
        const region = editor === "left" ? _leftRegion : _rightRegion;
        region.dirtyFlags |= flags;
        if (region.dirtyFlags & 1 /* RenderFlags.DIFF */) {
            region.diffRenderItems = null;
        }
        render();
    }
    return {
        updateLayout,
        setDiffRanges,
        markDirty,
    };
}
//# sourceMappingURL=renderer.js.map
</script>
<script id="worker.js" type="text/plain">"use strict";
const LINE_START = 1;
const LINE_END = 2;
const CONTAINER_START = 1 << 2;
const CONTAINER_END = 1 << 3;
const NO_JOIN = 1 << 4; // @@@, ### 등등
const WILD_CARD = 1 << 5;
const MANUAL_ANCHOR = 1 << 6; // 32. @@@, ### 등등
const IMAGE = 1 << 7;
const SECTION_HEADING_BIT = 10;
const SECTION_HEADING_TYPE1 = 1 << (SECTION_HEADING_BIT + 0); // 1.
const SECTION_HEADING_TYPE2 = 1 << (SECTION_HEADING_BIT + 1); // 가.
const SECTION_HEADING_TYPE3 = 1 << (SECTION_HEADING_BIT + 2); // (1)
const SECTION_HEADING_TYPE4 = 1 << (SECTION_HEADING_BIT + 3); // (가)
const SECTION_HEADING_TYPE5 = 1 << (SECTION_HEADING_BIT + 4); // 1)
const SECTION_HEADING_TYPE6 = 1 << (SECTION_HEADING_BIT + 5); // 가)
const LINE_BOUNDARY = LINE_START | LINE_END;
const CONTAINER_BOUNDARY = CONTAINER_START | CONTAINER_END;
const SECTION_HEADING_MASK = SECTION_HEADING_TYPE1 | SECTION_HEADING_TYPE2 | SECTION_HEADING_TYPE3 | SECTION_HEADING_TYPE4 | SECTION_HEADING_TYPE5 | SECTION_HEADING_TYPE6;
let _nextCtx = null;
let _currentCtx = null;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            diffs: result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhsTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    // return postProcess(ctx, rawResult, lhsTokens, rhsTokens);
    return rawResult;
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // 텍스트가 길어지는 경우(토큰이 많은 경우) 끔찍하게 많은 반복을 수행하게된다.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // 주기적으로 yield 해서 취소요청을 받아야함.
            // performance.now()는 미친게 아닌가 싶을 정도로 무거운 함수이기 때문에 되도록 자제.
            // await new Promise(...) 역시 자주 사용하면 안됨
            // (i+j) % 0x4000 === 0 일 때만 사용하기로. 브라우저 js엔진의 비트연산 속도를 믿어본다 ㅋ
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 50) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// 정들었던 diff 함수. 폐기처분 예정.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                // empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                // empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && i < lcsEntry.leftIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && j < lcsEntry.rightIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Histogram Algorithm
// 일단 지금은 이놈이 디폴트
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    // ctx.entries = [] as DiffEntry[];
    let leftAnchors = [];
    let rightAnchors = [];
    for (let i = 0; i < lhsTokens.length; i++) {
        if (lhsTokens[i].flags & MANUAL_ANCHOR) {
            leftAnchors.push(i);
        }
    }
    if (leftAnchors.length > 0) {
        for (let i = 0; i < rhsTokens.length; i++) {
            if (rhsTokens[i].flags & MANUAL_ANCHOR) {
                rightAnchors.push(i);
            }
        }
    }
    const matches = [];
    if (rightAnchors.length > 0) {
        let rightPos = 0;
        for (let l = 0; l < leftAnchors.length; l++) {
            const leftTokenIndex = leftAnchors[l];
            for (let r = rightPos; r < rightAnchors.length; r++) {
                const rightTokenIndex = rightAnchors[r];
                if (lhsTokens[leftTokenIndex].text === rhsTokens[rightTokenIndex].text) {
                    matches.push({ lhsIndex: leftTokenIndex, rhsIndex: rightTokenIndex });
                    rightPos = r + 1;
                    break;
                }
            }
        }
    }
    let prevLhs = 0;
    let prevRhs = 0;
    for (const match of matches) {
        const lhsAnchor = match.lhsIndex;
        const rhsAnchor = match.rhsIndex;
        if (prevLhs < lhsAnchor || prevRhs < rhsAnchor) {
            // console.log("diffCore", {
            // 	lhsTokens,
            // 	lhsLower: prevLhs,
            // 	lhsUpper: lhsAnchor,
            // 	rhsTokens,
            // 	rhsLower: prevRhs,
            // 	rhsUpper: rhsAnchor,
            // });
            await diffCore(ctx, lhsTokens, prevLhs, lhsAnchor, rhsTokens, prevRhs, rhsAnchor, findBestHistogramAnchor);
        }
        ctx.entries.push({
            type: 0,
            left: {
                pos: lhsAnchor,
                len: 1,
            },
            right: {
                pos: rhsAnchor,
                len: 1,
            },
        });
        prevLhs = lhsAnchor + 1;
        prevRhs = rhsAnchor + 1;
    }
    if (prevLhs < lhsTokens.length || prevRhs < rhsTokens.length) {
        // console.log("diffCore", {
        // 	lhsTokens,
        // 	lhsLower: prevLhs,
        // 	lhsUpper: lhsTokens.length,
        // 	rhsTokens,
        // 	rhsLower: prevRhs,
        // 	rhsUpper: rhsTokens.length,
        // });
        await diffCore(ctx, lhsTokens, prevLhs, lhsTokens.length, rhsTokens, prevRhs, rhsTokens.length, findBestHistogramAnchor);
    }
    // const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findBestHistogramAnchor);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return ctx.entries;
}
// histogram diff에서 가장 중요한 함수
// 얼마나 값어치 있는 공통 앵커를 찾느냐가 매우 중요하고 고로 그 값어치를 매기는 기준과 방법이 또 매우 중요함
// 여러가지 생각해볼 것들이 많지만...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // 길이가 너무 크게 영향을 주는 경향이 있어서 이걸로 조절
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const CONTAINER_START_BONUS = 1 / (diffOptions.containerStartMultiplier || 1 / 0.85);
    const CONTAINER_END_BONUS = 1 / (diffOptions.containerEndMultiplier || 1 / 0.8);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.sectionHeadingMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; n그램을 사용시 여러단어가 매치되는 경우 오히려 마지막 단어가 다음 줄로 넘어가서 보너스를 못 받을 수가 있다
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + lhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + rhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // 특수 케이스
        // 강제로 문서의 특정 지점끼리 매칭시킴. 문서 구조가 항상 내 맘 같은 것이 아니야. ㅠ
        // if (lhsTokens[i].flags & MANUAL_ANCHOR) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			console.log("manual anchor", ltext1, i, j);
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    // if (lhsTokens[li].flags & rhsTokens[ri].flags & MANUAL_ANCHOR) {
                    // 	return {
                    // 		lhsIndex: li,
                    // 		lhsLength: 1,
                    // 		rhsIndex: ri,
                    // 		rhsLength: 1,
                    // 	};
                    // }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext.length !== rtext.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                let boundaryBonus = 1;
                if (boundaryBonus > CONTAINER_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & CONTAINER_START) {
                    boundaryBonus = CONTAINER_START_BONUS;
                }
                if (boundaryBonus > CONTAINER_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & CONTAINER_END) {
                    boundaryBonus = CONTAINER_END_BONUS;
                }
                if (boundaryBonus > LINE_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & LINE_START) {
                    boundaryBonus = LINE_START_BONUS;
                }
                if (boundaryBonus > LINE_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LINE_END) {
                    boundaryBonus = LINE_END_BONUS;
                }
                score *= boundaryBonus;
                // if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING_MASK) {
                // 	// if ((lhsTokens[i].flags & SECTION_HEADING_MASK) !== 0) {
                // 	// 	// LEVEL1은 무시. 문서 구조가 영구같은 경우가 많음.
                // 	// } else {
                // 	// }
                // 	score *= SECTION_HEADING_BONUS;
                // }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience 알고리즘에 공통으로 사용되는 재귀함수
// 1. 양 텍스트를 공통되는 부분(앵커)으로 분할
// 2. 분할된 영역에 대해서 재귀호출
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor, consumeDirections = 3) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // 사실 이걸 쓰면 리턴값이 필요 없는데...
    // 함수 시그니처를 고치기 귀찮아서 일단 내비둠.
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // 공통 부분을 스킵하는건데 문제는 여기에서 HEAD, TAIL을 스킵하고
    // 이후에 diffCore를 재귀적으로 호출할 때 앞쪽 절반에 대해서 HEAD부분, 뒤쪽 절반에 대해서 TAIL부분을 다시 한번 스킵을 시도하게 된다.
    // 더 이상 스킵할 게 없으니 결과에는 차이가 없겠지만 불필요한 시도를 안하는 쪽으로 개선해 볼 필요가 있음!
    // 생각해볼 것: 공통 prefix,suffix를 스킵하지 않았을 경우 스킵되지 않은 부분에서 더 나은 앵커가 나올 확률이 있다.
    // 그렇지만 스킵하지 않으면 성능 상 아주 큰 문제가 생김!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize", consumeDirections);
    // 	entries.push(...skippedHead); 이렇게 넣으면 폭발함.
    for (const item of skippedHead) {
        entries.push(item);
    }
    // 양쪽 모두 남아있는 영역이 있는 경우 공통 앵커를 찾아본다!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! 적어도 한쪽이라도 영역을 줄여야 무한루프 안 생길 듯?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        // console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor, 2);
        // 의도적으로 앵커 영역까지 포함해서 호출함
        await diffCore(ctx, leftTokens, anchor.lhsIndex, lhsUpper, rightTokens, anchor.rhsIndex, rhsUpper, findAnchor, 1);
        // await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor, 1);
    }
    else {
        // 유효한 앵커는 못찾았지만 남아있는 토큰들이 있다면 diff로 처리
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    for (const item of skippedTail) {
        entries.push(item);
    }
    return entries;
}
// function appendEqualEntriesFromAnchor(
// 	leftTokens: Token[],
// 	lhsIndex: number,
// 	lhsLength: number,
// 	rightTokens: Token[],
// 	rhsIndex: number,
// 	rhsLength: number,
// 	whitespace: WhitespaceHandling = "ignore",
// 	entries: DiffEntry[]
// ) {
// 	let li = lhsIndex;
// 	let ri = rhsIndex;
// 	while (li < lhsIndex + lhsLength && ri < rhsIndex + rhsLength) {
// 		const lt = leftTokens[li];
// 		const rt = rightTokens[ri];
// 		if (lt.text === rt.text) {
// 			entries.push({
// 				type: 0,
// 				left: { pos: li, len: 1 },
// 				right: { pos: ri, len: 1 },
// 			});
// 			li++;
// 			ri++;
// 		} else if (whitespace === "ignore" && lt.text.length !== rt.text.length && lt.text[0] === rt.text[0]) {
// 			// 1:N, N:1 or N:M → custom matching (e.g. matchPrefixTokens)
// 			const match = matchPrefixTokens(leftTokens, li, lhsIndex + lhsLength, rightTokens, ri, rhsIndex + rhsLength);
// 			if (!match) break;
// 			entries.push({
// 				type: 0,
// 				left: { pos: li, len: match[0] },
// 				right: { pos: ri, len: match[1] },
// 			});
// 			li += match[0];
// 			ri += match[1];
// 		} else {
// 			break;
// 		}
// 	}
// }
// 공백을 완전히 무시하는 경우 "안녕 하세요" vs "안녕하세요"는 같다고 처리해야하지만
// 단어단위 토큰인 경우 토큰 대 토큰 비교는 실패할 수 밖에 없다.
// 따라서 각 토큰의 글자를 한땀한땀 매치시켜봐야하고 양쪽에서 토큰이 끝나는 시점까지 모든 글자가 매치되었다면
// 그 끝나는 시점까지의 토큰 수만큼 consume을 함.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore", consumeDirections = 3) {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    if (consumeDirections & 1) {
        while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
            if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
                head.push({
                    type: 0,
                    left: { pos: lhsLower, len: 1 },
                    right: { pos: rhsLower, len: 1 },
                });
                lhsLower++;
                rhsLower++;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
                lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
                (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                head.push({
                    type: 0,
                    left: {
                        pos: lhsLower,
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsLower,
                        len: matchedCount[1],
                    },
                });
                lhsLower += matchedCount[0];
                rhsLower += matchedCount[1];
            }
            else {
                break;
            }
        }
    }
    // Suffix
    if (consumeDirections & 2) {
        while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
            if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
                tail.push({
                    type: 0,
                    left: { pos: lhsUpper - 1, len: 1 },
                    right: { pos: rhsUpper - 1, len: 1 },
                });
                lhsUpper--;
                rhsUpper--;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
                lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
                (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                tail.push({
                    type: 0,
                    left: {
                        pos: lhsUpper - matchedCount[0],
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsUpper - matchedCount[1],
                        len: matchedCount[1],
                    },
                });
                lhsUpper -= matchedCount[0];
                rhsUpper -= matchedCount[1];
            }
            else {
                break;
            }
        }
        tail.reverse();
    }
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    let lhsToken = leftTokens[i++], ltext = lhsToken.text, lhsLen = ltext.length;
    let rhsToken = rightTokens[j++], rtext = rhsToken.text, rhsLen = rtext.length;
    while (true) {
        while (ci < lhsLen && cj < rhsLen) {
            if (ltext[ci++] !== rtext[cj++]) {
                return false;
            }
        }
        // 문자 불일치 없이 양쪽 토큰이 동시에 끝난 경우
        if (ci === lhsLen && cj === rhsLen)
            return [i - lhsLower, j - rhsLower];
        if (ci === lhsLen) {
            if (i === lhsUpper)
                return false;
            if (lhsToken.flags & CONTAINER_END)
                return false;
            lhsToken = leftTokens[i++];
            if (!lhsToken || lhsToken.flags & CONTAINER_START)
                return false;
            ltext = lhsToken.text;
            lhsLen = ltext.length;
            ci = 0;
        }
        if (cj === rhsLen) {
            if (j === rhsUpper)
                return false;
            if (rhsToken.flags & CONTAINER_END)
                return false;
            rhsToken = rightTokens[j++];
            if (!rhsToken || rhsToken.flags & CONTAINER_START)
                return false;
            rtext = rhsToken.text;
            rhsLen = rtext.length;
            cj = 0;
        }
    }
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let lhsToken = leftTokens[i--], ltext = lhsToken.text, rhsToken = rightTokens[j--], rtext = rhsToken.text;
    let ci = ltext.length - 1, cj = rtext.length - 1;
    while (true) {
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                return false;
            }
        }
        if (ci < 0 && cj < 0)
            return [lhsUpper - i - 1, rhsUpper - j - 1];
        if (ci < 0) {
            if (i < lhsLower)
                return false;
            if (lhsToken.flags & CONTAINER_START)
                return false;
            lhsToken = leftTokens[i--];
            if (lhsToken.flags & CONTAINER_END)
                return false;
            ltext = lhsToken.text;
            ci = lhsToken.text.length - 1;
        }
        if (cj < 0) {
            if (j < rhsLower)
                return false;
            if (rhsToken.flags & CONTAINER_START)
                return false;
            rhsToken = rightTokens[j--];
            if (rhsToken.flags & CONTAINER_END)
                return false;
            rtext = rhsToken.text;
            cj = rhsToken.text.length - 1;
        }
    }
}
//# sourceMappingURL=worker.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 22px;
	font-size: 16px;
	--container-gap: 8px;
	--sidebar-width: 200px;
	--text-container-padding-block: 4px;
	--text-container-padding-inline: 4px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
	/* font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; */
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr var(--sidebar-width);
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 var(--container-gap, 0px);
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	/* font-family: "돋움체", monospace; */
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	/* white-space: pre-wrap; */
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

#main > canvas {
	position: fixed;
	top: 0;
	left: 0;
	bottom: var(--status-bar-height, 0px);
	width: calc(100vw - var(--sidebar-width) - var(--container-gap, 0px));
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -1;
	will-change: transform; /* 정확히 뭘하는 놈인지 알아봐야함 */
}

.editor-wrapper canvas {
	position: fixed;
	bottom: var(--status-bar-height, 0px);
	width: calc((100vw - var(--sidebar-width) - var(--container-gap, 0px)) / 2);
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -2;
	will-change: transform; /* 정확히 뭘하는 놈인지 알아봐야함 */
}

.editor-wrapper canvas.highlight {
	z-index: -1;
	opacity: 0.3;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -99;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: transparent;
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: #ccc;
	background-color: #000;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
	display: contents;
}

mark {
	background-color: inherit;
	color: inherit;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
}

mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-block으로 안해두면 높이 1px이 모자르게 된다. 묻지마... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
공간을 전혀 차지하지 않으면서도 visual이 있어야함
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
줄(div)안에 블럭 엘러먼트를 넣어서 강제로 줄바꿈 효과를 주었을 때
diff가 없는 가상의 줄도 diff가 있는 줄처럼 표시되는 문제.
당연한거긴 한데... 쉬운 해결방법이 떠오르질 않는다!
고민 필요
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

#diffList .heading {
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	display: block;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "👬";
	font-size: 128px;
	font-weight: bold;
	font-family: monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "💭";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "◀️"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "▶️" !important; */
}

.edit hr {
	height: 0 !important;
}

/* 의미없다
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: -98;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.edit .mirror {
	display: none !important;
}

.aligned canvas {
	display: none !important;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}

.editor-wrapper h6 {
	all: unset;
}

.edit .editor-wrapper h6 {
	all: unset;
	text-decoration-color: #000;
}

.aligned .editor-wrapper h6 {
	color: #fff;
	font-weight: bold;
}

/* .edit .mirror br {
	display: none;
}

.aligned .mirror {
	white-space: normal;
}

.aligned .mirror div {
	display: contents;;
} */

.editor table {
	border-collapse: collapse;
	border-spacing: 0;
}

.editor th,
.editor td {
	vertical-align: top;
	border: 1px solid #000;
	padding: var(--text-container-padding-block, 0px) var(--text-container-padding-inline, 0px);
	user-select: none;
}

.editor div,
.editor section,
.editor header,
.editor footer,
.editor article,
.editor aside,
.editor nav,
.editor main {
	/* padding: var(--text-container-padding-block, 0px) var(--text-container-padding-inline, 0px); */
}

.editor p:empty::before {
	content: "\00a0";
}

.color-red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-size: inherit;
}

.padtop:before {
	content: "";
	display: block;
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
	height: var(--padding);
}

.bottom-padding {
	display: block;
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.editor {
	min-height: max(100%, var(--min-height, 100%));
}

.editor::after {
	content: "";
	display: block;
	height: var(--bottom-padding, 0px);

	background: red repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.editor a {
	pointer-events: none;
	user-select: none;
}

</style>
</head>

<body>
    <div class="container">
        <main id="main">
            <div id="scrollSyncIndicator">🔗</div>
            <!--leftEditor will be here -->
            <!-- rightEditor will be here -->
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>
    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT}px;\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script>"use strict";
// 이것저것 이어붙이는 코드 집합
const DiffSeek = (function () {
    let _activeEditor = null;
    let _lastFocusedEditor = null;
    let _lastScrolledEditor = null;
    let _currentlyScrollingEditor = null;
    let _preventScrollSync = false;
    let _currentDiffIndex = -1;
    let _syncEditor = false;
    let _resetCurrentlyScrollingEditorId = null;
    // let _diffResult: DiffResponse | null = null;
    let _diffContext = { done: false, reqId: 0 };
    let _outputOptions = {
        // 어차피 나만 쓰는 기능일테니
        leftLabel: "대비표",
        rightLabel: "전문",
        htmlFormat: "div",
        textFormat: 0,
    };
    let _copyMode = "raw";
    let _lastNonRawCopyMode = "compare";
    let _diffListItemElements = [];
    let _aligned = true;
    const _anchors = [];
    const _leftBottomPadding = document.createElement("A");
    _leftBottomPadding.contentEditable = "false";
    _leftBottomPadding.className = "bottom-padding";
    const _rightBottomPadding = document.createElement("A");
    _rightBottomPadding.contentEditable = "false";
    _rightBottomPadding.className = "bottom-padding";
    // 정말 지저분한 코드 시작
    const _diffOptions = (function (defaultValues) {
        let _diffOptions = { ...defaultValues };
        function setValue(key, value) {
            if (_diffOptions[key] !== value) {
                _diffOptions[key] = value;
                computeDiff();
            }
        }
        return {
            get algorithm() {
                return _diffOptions.algorithm;
            },
            set algorithm(value) {
                if (value !== "histogram" && value !== "lcs") {
                    throw new Error("Invalid algorithm: " + value);
                }
                setValue("algorithm", value);
            },
            get tokenization() {
                return _diffOptions.tokenization;
            },
            set tokenization(value) {
                if (value !== "char" && value !== "word" && value !== "line") {
                    throw new Error("Invalid tokenization: " + value);
                }
                setValue("tokenization", value);
            },
            get whitespace() {
                return _diffOptions.whitespace;
            },
            set whitespace(value) {
                if (value !== "ignore" && value !== "normalize") {
                    throw new Error("Invalid whitespace handling: " + value);
                }
                setValue("whitespace", value);
            },
            get greedyMatch() {
                return !!_diffOptions.greedyMatch;
            },
            set greedyMatch(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid greedyMatch: " + value);
                }
                setValue("greedyMatch", !!value);
            },
            get useLengthBias() {
                return !!_diffOptions.useLengthBias;
            },
            set useLengthBias(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid useLengthBias: " + value);
                }
                setValue("useLengthBias", !!value);
            },
            get maxGram() {
                return _diffOptions.maxGram;
            },
            set maxGram(value) {
                if (value < 1) {
                    throw new Error("Invalid maxGram: " + value);
                }
                setValue("maxGram", value);
            },
            get lengthBiasFactor() {
                return _diffOptions.lengthBiasFactor;
            },
            set lengthBiasFactor(value) {
                if (value <= 0) {
                    throw new Error("Invalid lengthBiasFactor: " + value);
                }
                setValue("lengthBiasFactor", value);
            },
            get sectionHeadingMultiplier() {
                return _diffOptions.sectionHeadingMultiplier;
            },
            set sectionHeadingMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid sectionHeadingMultiplier: " + value);
                }
                setValue("sectionHeadingMultiplier", value);
            },
            get lineStartMultiplier() {
                return _diffOptions.lineStartMultiplier;
            },
            set lineStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineStartMultiplier: " + value);
                }
                setValue("lineStartMultiplier", value);
            },
            get lineEndMultiplier() {
                return _diffOptions.lineEndMultiplier;
            },
            set lineEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineEndMultiplier: " + value);
                }
                setValue("lineEndMultiplier", value);
            },
            get uniqueMultiplier() {
                return _diffOptions.uniqueMultiplier;
            },
            set uniqueMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid uniqueMultiplier: " + value);
                }
                setValue("uniqueMultiplier", value);
            },
            get containerStartMultiplier() {
                return _diffOptions.containerStartMultiplier;
            },
            set containerStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid containerStartMultiplier: " + value);
                }
                setValue("containerStartMultiplier", value);
            },
            get containerEndMultiplier() {
                return _diffOptions.containerEndMultiplier;
            },
            set containerEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid containerEndMultiplier: " + value);
                }
                setValue("containerEndMultiplier", value);
            },
        };
    })({
        algorithm: "histogram",
        tokenization: "word",
        whitespace: "ignore",
        greedyMatch: false,
        useLengthBias: true,
        maxGram: 4,
        lengthBiasFactor: 0.7,
        containerStartMultiplier: 1 / 0.85,
        containerEndMultiplier: 1 / 0.9,
        sectionHeadingMultiplier: 1 / 0.75,
        lineStartMultiplier: 1 / 0.9,
        lineEndMultiplier: 1 / 0.95,
        uniqueMultiplier: 1 / 0.6667,
    });
    const mainContainer = document.getElementById("main");
    const leftEditor = createEditor(mainContainer, "left", getEditorCallbacks("left"));
    const rightEditor = createEditor(mainContainer, "right", getEditorCallbacks("right"));
    const diffCanvas = document.createElement("canvas");
    diffCanvas.id = "diffCanvas";
    mainContainer.appendChild(diffCanvas);
    const diffCanvasCtx = diffCanvas.getContext("2d");
    const highlightCanvas = document.createElement("canvas");
    highlightCanvas.id = "highlightCanvas";
    mainContainer.appendChild(highlightCanvas);
    leftEditor.wrapper.tabIndex = 100;
    rightEditor.wrapper.tabIndex = 101;
    const body = document.querySelector("body");
    const diffList = document.getElementById("diffList");
    const highlightStyle = document.getElementById("highlightStyle");
    const progress = document.getElementById("progress");
    const scrollSyncIndicator = document.getElementById("scrollSyncIndicator");
    const alignmentStyleElement = document.createElement("style");
    document.head.appendChild(alignmentStyleElement);
    const renderer = createRenderer(mainContainer, leftEditor, rightEditor, {
        onDiffVisibilityChanged,
    });
    function onDiffVisibilityChanged(editorName, shown, hidden) { }
    function onSelectionChanged() {
        if (_diffContext.done === false) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const range = selection.getRangeAt(0);
        const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
            ? leftEditor
            : rightEditor.wrapper.contains(range.commonAncestorContainer)
                ? rightEditor
                : null;
        if (editor === null) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const [startOffset, endOffset] = editor.getTextSelectionRange();
        if (startOffset === null || endOffset === null) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const rawEntries = _diffContext.rawEntries;
        const tokens = editor === leftEditor ? _diffContext.leftTokens : _diffContext.rightTokens;
        const otherTokens = editor === leftEditor ? _diffContext.rightTokens : _diffContext.leftTokens;
        const sideKey = editor === leftEditor ? "left" : "right";
        const otherEditor = editor === leftEditor ? rightEditor : leftEditor;
        const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
        const otherStartToken = otherTokens[mappedStartIndex];
        const otherEndToken = otherTokens[mappedEndIndex - 1];
        if (otherStartToken && otherEndToken) {
            const otherStartPos = otherStartToken.pos;
            const otherEndPos = otherEndToken.pos + otherEndToken.len;
            otherEditor.applyTextHighlight(otherStartPos, otherEndPos);
            // const rectSet = otherEditor.getTextRects(otherStartPos, otherEndPos);
            // console.log("Rect set:", rectSet);
            // if (rectSet && rectSet.rects.length > 0) {
            // 	_selectionHighlight = {
            // 		editor: otherEditor,
            // 		rects: rectSet!.rects,
            // 	};
            // }
            // updateHighlightCanvas();
        }
    }
    function getEditorCallbacks(editorName) {
        const pendingDiffVisibilities = new Map();
        let updateDiffVisilitiesPending = false;
        return {
            onTextChanged: function () {
                onSelectionChanged();
                computeDiff();
            },
            // 현재 화면 상에 보이는 diff 아이템들.
            onDiffVisibilityChanged: (entries) => {
                for (const entry of entries) {
                    const diffIndex = entry.item;
                    pendingDiffVisibilities.set(diffIndex, entry.isVisible);
                }
                if (!updateDiffVisilitiesPending) {
                    updateDiffVisilitiesPending = true;
                    requestAnimationFrame(() => {
                        updateDiffVisilitiesPending = false;
                        for (const [diffIndex, visible] of pendingDiffVisibilities) {
                            const listItem = _diffListItemElements[diffIndex];
                            if (listItem) {
                                const button = listItem.firstElementChild;
                                button.classList.toggle(editorName + "-visible", visible);
                            }
                        }
                        pendingDiffVisibilities.clear();
                    });
                }
            },
        };
    }
    function createWorker() {
        // 보안 상 new Worker("worker.js")는 실행 안됨.
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerURL);
        return worker;
    }
    const { computeDiff } = (function () {
        const worker = createWorker();
        let _reqId = 0;
        let computeDiffTimeoutId = null;
        function* computeDiffGenerator(ctx) {
            let idleDeadline = yield ctx;
            ctx.leftTokens = leftEditor.tokens;
            if (idleDeadline.timeRemaining() <= 1) {
                idleDeadline = yield;
            }
            ctx.rightTokens = rightEditor.tokens;
            if (idleDeadline.timeRemaining() <= 1) {
                idleDeadline = yield;
            }
            const request = {
                type: "diff",
                reqId: ctx.reqId,
                options: ctx.diffOptions,
                leftTokens: ctx.leftTokens,
                rightTokens: ctx.rightTokens,
            };
            console.debug("diff request:", request);
            worker.postMessage(request);
        }
        function computeDiff() {
            if (computeDiffTimeoutId) {
                cancelIdleCallback(computeDiffTimeoutId);
                //clearTimeout(computeDiffTimeoutId);
            }
            _currentDiffIndex = -1;
            // const leftText = leftEditor.text;
            // const rightText = rightEditor.text;
            body.classList.add("computing");
            progress.textContent = "...";
            const ctx = (_diffContext = {
                reqId: ++_reqId, //overflow 되는 순간 지구 멸망
                // leftText: leftText,
                // rightText: rightText,
                diffOptions: { ..._diffOptions },
                done: false,
                processTime: 0,
            });
            const generator = computeDiffGenerator(ctx);
            const step = (idleDeadline) => {
                computeDiffTimeoutId = null;
                const { done } = generator.next(idleDeadline);
                if (!done && ctx === _diffContext) {
                    computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
                }
            };
            computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
        }
        worker.onmessage = function (e) {
            const data = e.data;
            console.debug("message received:", e);
            if (data.type === "diff") {
                if (data.reqId === _reqId) {
                    body.classList.remove("computing");
                    _diffContext.rawEntries = data.diffs;
                    postProcess(_diffContext);
                    _diffContext.done = true;
                    _diffContext.processTime = data.processTime;
                    renderer.setDiffRanges("left", _diffContext.leftDiffRanges);
                    renderer.setDiffRanges("right", _diffContext.rightDiffRanges);
                    onDiffComputed(_diffContext);
                }
            }
            else if (data.type === "start") {
                progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
            }
        };
        function onDiffComputed(diffContext) {
            // leftEditor.update(diffContext);
            // rightEditor.update(diffContext);
            // calculateDiffRects();
            // leftEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            // rightEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            // updateDiffList();
        }
        return { computeDiff };
    })();
    function restoreSelectionRange({ editor, startOffset, endOffset }) {
        if (editor) {
            editor.selectTextRange(startOffset, endOffset);
        }
    }
    function getSelectionRange() {
        let editor = null;
        let [startOffset, endOffset] = leftEditor.getTextSelectionRange();
        if (startOffset !== null) {
            editor = leftEditor;
        }
        else {
            [startOffset, endOffset] = rightEditor.getTextSelectionRange();
            if (startOffset !== null) {
                editor = rightEditor;
            }
        }
        if (editor) {
            return {
                editor,
                startOffset: startOffset,
                endOffset: endOffset,
            };
        }
        else {
            return null;
        }
    }
    function syncScrollPosition(sourceEditor) {
        if (_preventScrollSync) {
            return;
        }
        if (!sourceEditor) {
            sourceEditor = _currentlyScrollingEditor || _activeEditor || _lastFocusedEditor;
            if (!sourceEditor) {
                return;
            }
        }
        if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
            return;
        }
        _preventScrollSync = true;
        const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
        let sourceAnchor = null;
        let targetAnchor = null;
        sourceAnchor = sourceEditor.getClosestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
        if (sourceAnchor) {
            const anchorIndex = Number(sourceAnchor.dataset.anchor);
            targetAnchor = targetEditor.anchorElements[anchorIndex];
        }
        if (sourceAnchor && targetAnchor) {
            const prevLastScrolledEditor = _lastScrolledEditor;
            const sourceWrapper = sourceEditor.wrapper;
            const targetWrapper = targetEditor.wrapper;
            targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
            _lastScrolledEditor = prevLastScrolledEditor;
        }
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    let resetHighlightId = null;
    function highlightDiff(diffIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
	box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
	animation: highlightAnimation 0.3s linear 3; 
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 3000);
    }
    function highlightHeading(headingIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `[data-heading="${headingIndex}"] { 
	text-decoration-line: underline !important;
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 2000);
    }
    document.addEventListener("mouseover", (e) => {
        if (e.target.dataset.diff !== undefined) {
            const diff = Number(e.target.dataset.diff);
            leftEditor.applyDiffHighlight(diff);
            rightEditor.applyDiffHighlight(diff);
            // highlightDiff(diff);
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            const heading = Number(e.target.dataset.heading);
            highlightHeading(heading);
        }
    });
    document.addEventListener("mouseout", (e) => {
        if (e.target.dataset.diff !== undefined) {
            // const diff = Number((e.target as HTMLElement).dataset.diff);
            leftEditor.clearDiffHighlight();
            rightEditor.clearDiffHighlight();
            // highlightStyle.textContent = "";
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            highlightStyle.textContent = "";
            if (resetHighlightId !== null) {
                clearTimeout(resetHighlightId);
            }
        }
    });
    document.addEventListener("selectionchange", (e) => {
        onSelectionChanged();
    });
    // syncScrollToggle.addEventListener("click", () => {
    // 	toggleSyncScroll();
    // });
    // alignedModeToggle.addEventListener("click", () => {
    // 	if (_alignedMode) {
    // 		disableAlignedMode();
    // 	} else {
    // 		enableAlignedMode();
    // 	}
    // });
    function toggleSyncScroll() {
        _syncEditor = !_syncEditor;
    }
    function updateDiffList() {
        if (!_diffContext.done) {
            return;
        }
        const diffs = _diffContext.diffs;
        const headings = _diffContext.headings ?? [];
        _diffListItemElements.length = 0;
        const fragment = document.createDocumentFragment();
        let headingIndex = 0;
        let leftPos = 0;
        for (let i = 0; i < diffs.length; i++) {
            const diff = diffs[i];
            const thisLeftPos = diff.left.pos;
            // 귀찮음의 정점. 대충 돌아가게만... 딱 거기까지만...
            for (let j = leftPos; j < thisLeftPos; j++) {
                for (; headingIndex < headings.length; headingIndex++) {
                    const heading = headings[headingIndex];
                    if (heading.left.pos > thisLeftPos) {
                        break;
                    }
                    const li = document.createElement("LI");
                    const hd = document.createElement("A");
                    hd.className = "heading";
                    hd.dataset.heading = headingIndex.toString();
                    hd.textContent = heading.ordinalText + " " + heading.title;
                    li.appendChild(hd);
                    fragment.appendChild(li);
                }
            }
            const li = document.createElement("LI");
            const button = document.createElement("MARK");
            button.draggable = true;
            button.dataset.diff = i.toString();
            button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
            li.appendChild(button);
            const leftText = leftEditor.sliceText(diff.left.pos, diff.left.pos + diff.left.len);
            const leftSpan = document.createElement("SPAN");
            leftSpan.textContent = leftText;
            leftSpan.classList.add("left");
            button.appendChild(leftSpan);
            const rightText = rightEditor.sliceText(diff.right.pos, diff.right.pos + diff.right.len);
            const rightSpan = document.createElement("SPAN");
            rightSpan.textContent = rightText;
            rightSpan.classList.add("right");
            button.appendChild(rightSpan);
            fragment.appendChild(li);
            _diffListItemElements[i] = li;
            leftPos = thisLeftPos;
        }
        for (; headingIndex < headings.length; headingIndex++) {
            const heading = headings[headingIndex];
            const li = document.createElement("LI");
            const hd = document.createElement("A");
            hd.className = "heading";
            hd.dataset.heading = headingIndex.toString();
            hd.textContent = heading.ordinalText + " " + heading.title;
            li.appendChild(hd);
            fragment.appendChild(li);
        }
        diffList.innerHTML = "";
        diffList.appendChild(fragment);
    }
    document.addEventListener("copy", (e) => {
        if (_diffContext.done === false) {
            return;
        }
        if (true) {
            return;
        }
        // const selection = window.getSelection();
        // if (!selection || selection.isCollapsed) return;
        // const range = selection.getRangeAt(0);
        // const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? leftEditor
        // 	: rightEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? rightEditor
        // 	: null;
        // if (editor === null) {
        // 	return;
        // }
        // const [startOffset, endOffset] = editor.getTextSelectionRange();
        // if (startOffset === null || endOffset === null) return;
        // if (_copyMode === "raw" && !_alignedMode) {
        // 	return;
        // }
        // e.preventDefault();
        // const text = editor.text;
        // const tokens = editor === leftEditor ? _diffContext.leftTokens! : _diffContext.rightTokens!;
        // const otherTokens = editor === leftEditor ? _diffContext.rightTokens! : _diffContext.leftTokens!;
        // const rawEntries = _diffContext.rawEntries!;
        // const sideKey = editor === leftEditor ? "left" : "right";
        // const otherSideKey = sideKey === "left" ? "right" : "left";
        // const diffs = _diffContext.diffs!;
        // if (_copyMode === "raw") {
        // 	const plain = editor.text.slice(startOffset, endOffset);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else if (_copyMode === "compare") {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const otherStartToken = otherTokens[mappedStartIndex];
        // 	const otherEndToken = otherTokens[mappedEndIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const otherStartPos = otherStartToken?.pos ?? 0;
        // 	const otherEndPos = otherEndToken ? otherEndToken.pos + otherEndToken.len : otherStartPos;
        // 	const leftRuns = getTextRuns(
        // 		"left",
        // 		leftEditor.text,
        // 		{ diffs },
        // 		sideKey === "left" ? startPos : otherStartPos,
        // 		sideKey === "left" ? endPos : otherEndPos
        // 	);
        // 	const rightRuns = getTextRuns(
        // 		"right",
        // 		rightEditor.text,
        // 		{ diffs },
        // 		sideKey === "right" ? startPos : otherStartPos,
        // 		sideKey === "right" ? endPos : otherEndPos
        // 	);
        // 	const html = buildOutputHTML(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	const plain = buildOutputPlainText(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const textRuns = getTextRuns(sideKey, leftEditor.text, { diffs }, startPos, endPos);
        // 	const html = buildOutputHTMLFromRuns(text, textRuns, _outputOptions);
        // 	const plain = buildOutputPlainTextFromRuns(text, textRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // }
    });
    document.addEventListener("keydown", (e) => {
        // 어느 단축키를 써야 잘썼다고 소문나냐?
        if (e.key === "F2") {
            e.preventDefault();
            if (e.shiftKey) {
                toggleSyncScroll();
                return;
            }
            return;
        }
        if (e.key === "F4") {
            e.preventDefault();
            if (_copyMode === "raw") {
                _copyMode = _lastNonRawCopyMode;
            }
            else {
                _lastNonRawCopyMode = _copyMode;
                _copyMode = "raw";
            }
            return;
        }
        if (e.key === "F8") {
            _diffOptions.whitespace = _diffOptions.whitespace === "ignore" ? "normalize" : "ignore";
        }
        // 기본적으로 브라우저의 첫번째 탭, 두번째 탭을 선택하는 단축키인데...
        // 브라우저에서 기본적으로 사용되는 단축키를 덮어쓰는 건 정말 못된 짓이긴 한데...
        // 사용자의 의도를 무시해버릴 수 있는 아주 나쁜 단축키지만... 인터넷도 안되는 컴에서 누가 엣지에 탭을 여러개 열어놓고 쓸까 싶다.
        if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
            e.preventDefault();
            const editor = e.key === "1" ? leftEditor : rightEditor;
            editor.editor.focus();
            return;
        }
        // diff cycling
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            e.preventDefault();
            if (_diffContext.done) {
                const diffs = _diffContext.diffs;
                if (!diffs || diffs.length === 0) {
                    return;
                }
                _currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
                if (_currentDiffIndex < 0) {
                    _currentDiffIndex = diffs.length - 1;
                }
                if (_currentDiffIndex >= diffs.length) {
                    _currentDiffIndex = 0;
                }
                scrollToDiff(_currentDiffIndex);
                highlightDiff(_currentDiffIndex);
            }
        }
    });
    diffList.addEventListener("click", (e) => {
        const diffIndex = Number(e.target.dataset.diff);
        if (!isNaN(diffIndex)) {
            _currentDiffIndex = diffIndex;
            scrollToDiff(diffIndex);
            return;
        }
        const headingIndex = Number(e.target.dataset.heading);
        if (!isNaN(headingIndex)) {
            scrollToHeading(headingIndex);
            return;
        }
    });
    function scrollToDiff(diffIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToDiff(diffIndex);
        rightEditor.scrollToDiff(diffIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    function scrollToHeading(headingIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToHeading(headingIndex);
        rightEditor.scrollToHeading(headingIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    for (const editor of [leftEditor, rightEditor]) {
        editor.wrapper.addEventListener("scroll", (e) => {
            // updateCanvas();
            if (_preventScrollSync) {
                return;
            }
            //_preventScrollSync = true;
            const otherEditor = editor === leftEditor ? rightEditor : leftEditor;
            otherEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
            _resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
                //	_preventScrollSync = false;
            });
        });
        function onFocus() {
            _activeEditor = _lastFocusedEditor = editor;
        }
        function onBlur() {
            _activeEditor = null;
        }
        editor.editor.addEventListener("focus", onFocus);
        editor.editor.addEventListener("blur", onBlur);
        editor.editor.addEventListener("keydown", (e) => {
            if (e.key === " " && e.ctrlKey) {
                // 에디터에서 편집 중 반대쪽 에디터의 스크롤 위치를 현재 에디터의 내용에 맞추...려고 시도만 해 봄.
                syncScrollPosition(editor);
                return;
            }
            if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
                // 이정도 스크롤은 기본적으로 되어되는거 아니야?? 이 기능 나만 쓰나?
                // 스크롤 영역 밖의 딱 한두줄! 딱 그정도만 보면 된다 싶을 때?
                // 텍스트커서가 중앙 부분에 위치하지 않으면 마음이 놓이지 않아서 지금 당장 위아래로 조금 스크롤 해야만 할 때!!!!
                const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2;
                editor.wrapper.scrollTop += delta;
                e.preventDefault();
            }
            if (e.key === "Escape") {
                const sel = window.getSelection();
                if (sel)
                    sel.removeAllRanges(); // 선택 해제
            }
        });
        // editor.editor.addEventListener("click", (e) => {
        // 	if (e.ctrlKey) {
        // 		enableAlignedMode(true);
        // 	}
        // });
        function onClick(e) {
            if (e.altKey) {
                // const [start, end] = editor.getTextSelectionRange();
                // if (start !== null && end !== null && start === end) {
                // 	_activeEditor = editor;
                // 	disableAlignedMode();
                // 	setTimeout(() => {
                // 		//syncScrollPosition(editor);
                // 		document.execCommand("insertText", false, " " + MANUAL_ANCHOR1 + " ");
                // 		requestAnimationFrame(() => {
                // 			editor.updateText();
                // 		});
                // 	}, 0);
                // 	return;
                // }
            }
        }
        editor.editor.addEventListener("click", onClick);
    }
    function clearAnchors() {
        for (let i = 0; i < _anchors.length; i++) {
            const entry = _anchors[i];
            const leftEl = entry.leftEl;
            const rightEl = entry.rightEl;
            leftEl.classList.remove("padtop");
            leftEl.removeAttribute("data-anchor");
            leftEl.style.removeProperty("--padding");
            rightEl.classList.remove("padtop");
            rightEl.removeAttribute("data-anchor");
            leftEl.style.removeProperty("--padding");
        }
        _anchors.length = 0;
    }
    function alignAnchors() {
        // _leftBottomPadding.remove();
        // _rightBottomPadding.remove();
        let changed = false;
        const leftScrollTop = leftEditor.wrapper.scrollTop;
        const rightScrollTop = rightEditor.wrapper.scrollTop;
        const MAX_ITERATIONS = 10;
        let iteration = 0;
        do {
            changed = false;
            for (let i = 0; i < _anchors.length; i++) {
                const entry = _anchors[i];
                const { leftTokenIndex, leftEl, rightTokenIndex, rightEl } = entry;
                const leftRange = leftEditor.getRangeForToken(leftTokenIndex, 1);
                const rightRange = rightEditor.getRangeForToken(rightTokenIndex, 1);
                // reset current padding. 이걸 하지 않으면 패딩이 줄어들지 않고 계속 쌓여나가기만 함.
                leftEl.classList.remove("padtop");
                rightEl.classList.remove("padtop");
                // padtop 클래스가 있어야 --padding 값이 적용이 되므로 --padding 값을 지울 필요는 없을 것 같지만
                // 지우지 않고 냅두면 당최 이해가 안되는 괴상한 rect가 튀어나올 수 있다.
                leftEl.style.removeProperty("--padding");
                rightEl.style.removeProperty("--padding");
                let leftY = leftRange.getBoundingClientRect().y + leftScrollTop;
                let rightY = rightRange.getBoundingClientRect().y + rightScrollTop;
                let delta = Math.round(leftY - rightY);
                if (delta !== 0) {
                    delta = Math.round(leftY - rightY);
                    if (delta > 0) {
                        rightEl.classList.add("padtop");
                        leftEl.classList.remove("padtop");
                        rightEl.style.setProperty("--padding", `${delta}px`);
                        changed = true;
                    }
                    else if (delta < 0) {
                        // pad left
                        leftEl.classList.add("padtop");
                        rightEl.classList.remove("padtop");
                        leftEl.style.setProperty("--padding", `${-delta}px`);
                        changed = true;
                    }
                }
                if (entry.delta !== delta) {
                    entry.delta = delta;
                    changed = true;
                }
            }
        } while (changed && ++iteration < MAX_ITERATIONS);
        console.log("sync height:", {
            leftWrapperScrollHeight: leftEditor.wrapper.scrollHeight,
            rightWrapperScrollHeight: rightEditor.wrapper.scrollHeight,
            leftWrapperHeight: leftEditor.wrapper.clientHeight,
            rightWrapperHeight: rightEditor.wrapper.clientHeight,
            leftEditorHeight: leftEditor.editor.clientHeight,
            rightEditorHeight: rightEditor.editor.clientHeight,
            leftEditorScrollHeight: leftEditor.editor.scrollHeight,
            rightEditorScrollHeight: rightEditor.editor.scrollHeight,
            leftScrollTop: leftScrollTop,
            rightScrollTop: rightScrollTop,
            leftEditorWrapperRect: leftEditor.wrapper.getBoundingClientRect(),
            rightEditorWrapperRect: rightEditor.wrapper.getBoundingClientRect(),
            leftEditorRect: leftEditor.editor.getBoundingClientRect(),
            rightEditorRect: rightEditor.editor.getBoundingClientRect(),
        });
        // 이것도 --padding 값과 마찬가지로 지우지 않고 냅두면 어느순간 납득이 안되는 높이가 나온다.
        leftEditor.editor.style.removeProperty("--min-height");
        rightEditor.editor.style.removeProperty("--min-height");
        requestAnimationFrame(() => {
            const leftHeight = leftEditor.editor.scrollHeight;
            const rightHeight = rightEditor.editor.scrollHeight;
            const maxHeight = Math.max(leftHeight, rightHeight);
            // leftEditor.wrapper.style.setProperty("--bottom-padding", `${maxHeight - leftHeight}px`);
            // rightEditor.wrapper.style.setProperty("--bottom-padding", `${maxHeight - rightHeight}px`);
            leftEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
            rightEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
        });
    }
    // function alignAnchors(iteration = 0) {
    // 	if (iteration === 0) {
    // 		_leftBottomPadding.remove();
    // 		_rightBottomPadding.remove();
    // 	}
    // 	let changed = false;
    // 	const leftScrollTop = leftEditor.wrapper.scrollTop;
    // 	const rightScrollTop = rightEditor.wrapper.scrollTop;
    // 	for (let i = 0; i < _anchors.length; i++) {
    // 		const entry = _anchors[i];
    // 		const leftRange = leftEditor.getRangeForToken(entry.leftTokenIndex, 1);
    // 		const rightRange = rightEditor.getRangeForToken(entry.rightTokenIndex, 1);
    // 		let { y: leftY } = leftRange.getBoundingClientRect();
    // 		let { y: rightY } = rightRange.getBoundingClientRect();
    // 		leftY += leftScrollTop;
    // 		rightY += rightScrollTop;
    // 		// console.log("[CURRENT] Left Y:", leftY, "Right Y:", rightY);
    // 		let delta = Math.round(leftY - rightY);
    // 		if (delta !== 0) {
    // 			// 1. reset current padding
    // 			entry.leftEl.classList.remove("padtop");
    // 			entry.rightEl.classList.remove("padtop");
    // 			entry.leftEl.style.removeProperty("--padding");
    // 			entry.rightEl.style.removeProperty("--padding");
    // 			// void entry.leftEl.offsetHeight;
    // 			// void entry.rightEl.offsetHeight;
    // 			// void (leftRange.startContainer.parentNode! as HTMLElement).offsetHeight;
    // 			// void (rightRange.startContainer.parentNode! as HTMLElement).offsetHeight;
    // 			// leftY = leftRange.getBoundingClientRect().y + leftScrollTop;
    // 			// rightY = rightRange.getBoundingClientRect().y + rightScrollTop;
    // 			if (entry.delta > 0) {
    // 				rightY -= entry.delta;
    // 			} else if (entry.delta < 0) {
    // 				leftY += -entry.delta;
    // 			}
    // 			// console.log("[AFTER RESET] Left Y:", leftY, "Right Y:", rightY);
    // 			delta = Math.round(leftY - rightY);
    // 			if (delta > 0) {
    // 				entry.rightEl.classList.add("padtop");
    // 				entry.leftEl.classList.remove("padtop");
    // 				entry.rightEl.style.setProperty("--padding", `${delta}px`);
    // 				changed = true;
    // 			} else if (delta < 0) {
    // 				// pad left
    // 				entry.leftEl.classList.add("padtop");
    // 				entry.rightEl.classList.remove("padtop");
    // 				entry.leftEl.style.setProperty("--padding", `${-delta}px`);
    // 				changed = true;
    // 			}
    // 			entry.delta = delta;
    // 		}
    // 		// if (entry.delta !== delta) {
    // 		// 	if (delta > 0) {
    // 		// 		entry.rightEl.classList.add("padtop");
    // 		// 		entry.rightEl.style.setProperty("--padding", `${delta}px`);
    // 		// 		entry.rightTop = delta;
    // 		// 		entry.leftEl.classList.remove("padtop");
    // 		// 		changed = true;
    // 		// 	} else {
    // 		// 		// pad left
    // 		// 		entry.leftEl.classList.add("padtop");
    // 		// 		entry.leftEl.style.setProperty("--padding", `${-delta}px`);
    // 		// 		entry.leftTop = -delta;
    // 		// 		entry.rightEl.classList.remove("padtop");
    // 		// 		changed = true;
    // 		// 	}
    // 		// 	entry.delta = delta;
    // 		// }
    // 	}
    // 	if (changed) {
    // 		renderer.markDirty("left", RenderFlags.ALL);
    // 		renderer.markDirty("right", RenderFlags.ALL);
    // 		if (iteration < 10) {
    // 			requestAnimationFrame(() => {
    // 				alignAnchors(iteration + 1);
    // 			});
    // 			return;
    // 		}
    // 	}
    // 	requestAnimationFrame(() => {
    // 		const leftHeight = leftEditor.editor.scrollHeight;
    // 		const rightHeight = rightEditor.editor.scrollHeight;
    // 		if (leftHeight > rightHeight) {
    // 			_leftBottomPadding.style.height = "0px";
    // 			_rightBottomPadding.style.height = `${leftHeight - rightHeight}px`;
    // 		} else {
    // 			_leftBottomPadding.style.height = `${rightHeight - leftHeight}px`;
    // 			_rightBottomPadding.style.height = "0px";
    // 		}
    // 		leftEditor.editor.appendChild(_leftBottomPadding);
    // 		rightEditor.editor.appendChild(_rightBottomPadding);
    // 		// const height = Math.max(leftEditor.editor.scrollHeight, rightEditor.editor.scrollHeight);
    // 		// leftEditor.editor.style.height = height + "px";
    // 		// rightEditor.editor.style.height = height + "px";
    // 	});
    // }
    // 무식하게 큰 함수
    // 찝찝한데... 재미 없는 부분이라...
    function postProcess(diffContext) {
        // const leftText = diffContext.leftText!;
        // const rightText = diffContext.rightText!;
        const leftTokens = diffContext.leftTokens;
        const rightTokens = diffContext.rightTokens;
        const rawEntries = diffContext.rawEntries;
        const leftRanges = leftEditor.ranges;
        const rightRanges = rightEditor.ranges;
        const diffs = [];
        const anchors = [];
        const sectionHeadings = [];
        const headingStack = [];
        const MAX_ANCHOR_SKIP = 5;
        let anchorSkipCount = 0;
        const leftDiffRanges = [];
        const rightDiffRanges = [];
        diffContext.leftDiffRanges = leftDiffRanges;
        diffContext.rightDiffRanges = rightDiffRanges;
        clearAnchors();
        void leftEditor.wrapper.offsetHeight;
        void rightEditor.wrapper.offsetHeight;
        let currentDiff = null;
        for (let i = 0; i < rawEntries.length; i++) {
            const entry = rawEntries[i];
            const left = entry.left;
            const right = entry.right;
            let leftRange = null;
            let rightRange = null;
            if (entry.type) {
                // diff entry
                if (currentDiff) {
                    console.assert(currentDiff.left.pos + currentDiff.left.len === entry.left.pos, currentDiff, entry);
                    console.assert(currentDiff.right.pos + currentDiff.right.len === entry.right.pos, currentDiff, entry);
                    currentDiff.type |= entry.type;
                    currentDiff.left.len += entry.left.len;
                    currentDiff.right.len += entry.right.len;
                }
                else {
                    currentDiff = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
                    //prevEntry = entry;
                }
            }
            else {
                // common entry
                if (currentDiff) {
                    finalizeDiff();
                }
                currentDiff = null;
                const leftToken = leftTokens[left.pos];
                const rightToken = rightTokens[right.pos];
                if (leftToken.flags & rightToken.flags & LINE_START) {
                    const leftEl = leftEditor.insertAnchorBefore(left.pos);
                    const rightEl = rightEditor.insertAnchorBefore(right.pos);
                    if (leftEl && rightEl) {
                        _anchors.push({ leftEl, rightEl, leftTokenIndex: left.pos, rightTokenIndex: right.pos, delta: 0 });
                    }
                }
            }
        }
        if (currentDiff) {
            finalizeDiff();
            // mappings.push(prevEntry);
        }
        function adjustEmptyRange(originalRange, otherToken) {
            console.log("Adjusting empty range for token:", otherToken, "original range:", originalRange);
            if (otherToken.flags & LINE_START) {
                const candidates = getFullyContainedNodesInRange(originalRange, NodeFilter.SHOW_ALL, (node) => {
                    console.log("Checking node:", node);
                    if (node.nodeName === "P" || node.nodeName === "DIV") {
                        if (isEmptyElement(node)) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    }
                    console.log("REJECTING NODE:", node);
                    return NodeFilter.FILTER_REJECT;
                });
                if (candidates.length > 0) {
                    console.log("Adjusting empty range for token:", otherToken, "to:", candidates);
                    const newRange = document.createRange();
                    newRange.selectNodeContents(candidates[0]);
                    return [newRange];
                }
            }
            const candidates = getFullyContainedNodesInRange(originalRange, NodeFilter.SHOW_ALL, (node) => {
                if (node.nodeType === 3) {
                    return NodeFilter.FILTER_ACCEPT;
                }
                if (node.nodeName === "A") {
                    return NodeFilter.FILTER_REJECT;
                }
                if (INLINE_ELEMENTS[node.nodeName]) {
                    return NodeFilter.FILTER_ACCEPT;
                }
                if (node.nodeName === "BR") {
                    return NodeFilter.FILTER_ACCEPT;
                }
                console.log("WTF?:", node);
                return NodeFilter.FILTER_SKIP;
            });
            console.log("second path:", candidates);
            if (candidates.length > 0) {
                return candidates.map((node) => {
                    const r = document.createRange();
                    r.selectNodeContents(node);
                    return r;
                });
            }
            return [originalRange];
        }
        // TODO: => finalizeDiff 로 바꾸고 args 제거
        function finalizeDiff() {
            const leftIndex = currentDiff.left.pos;
            const rightIndex = currentDiff.right.pos;
            const leftTokenCount = currentDiff.left.len;
            const rightTokenCount = currentDiff.right.len;
            let leftPos, leftLen, rightPos, rightLen;
            let leftBeforeAnchorPos, rightBeforeAnchorPos, leftAfterAnchorPos, rightAfterAnchorPos, leftEmpty, rightEmpty;
            let type;
            let asBlock = false;
            // let leftToken = leftTokens[leftIndex];
            // let rightToken = rightTokens[rightIndex];
            // let leftEndToken = leftTokens[leftIndex + leftTokenCount - 1];
            // let rightEndToken = rightTokens[rightIndex + rightTokenCount - 1];
            let leftRange = leftEditor.getRangeForToken(leftIndex, leftTokenCount);
            let rightRange = rightEditor.getRangeForToken(rightIndex, rightTokenCount);
            if (leftTokenCount === 0) {
                const otherToken = rightTokens[rightIndex];
                const otherEndToken = rightTokens[rightIndex + rightTokenCount - 1];
                if (otherToken.flags & LINE_START && otherEndToken.flags & LINE_END) {
                    // add anchor
                    const leftEl = leftEditor.insertAnchorAfter(leftIndex - 1);
                    if (leftEl) {
                        leftEl.classList.add("diff-block");
                        console.log("Inserted anchor for left empty range:", leftIndex, leftTokenCount, leftRange, leftEl);
                    }
                    else {
                        console.warn("Failed to insert anchor for left empty range:", leftIndex, leftTokenCount, leftRange);
                    }
                }
            }
            let leftExtractedRanges = extractTextRanges(leftRange);
            let rightExtractedRanges = extractTextRanges(rightRange);
            if (leftTokenCount === 0) {
                console.log("left empty range:", leftRange);
                leftExtractedRanges = adjustEmptyRange(leftRange, rightTokens[rightIndex]);
            }
            if (rightTokenCount === 0) {
                console.log("right empty range:", rightRange);
                rightExtractedRanges = adjustEmptyRange(rightRange, leftTokens[leftIndex]);
            }
            leftDiffRanges.push(leftExtractedRanges);
            rightDiffRanges.push(rightExtractedRanges);
        }
        alignAnchors();
        // setTimeout(() => {
        // 	requestAnimationFrame(() => {
        // 	});
        // }, 1);
        // return { diffs, anchors, leftTokenCount: leftTokens.length, rightTokenCount: rightTokens.length, sectionHeadings };
    }
    _diffContext = {
        reqId: 0,
        // leftText: leftEditor.text,
        // rightText: rightEditor.text,
        diffOptions: { ..._diffOptions },
        done: false,
    };
    computeDiff();
    return {
        get dump() {
            // 디버깅 할 때...
            return {
                _diffContext: _diffContext,
                // diffs: _diffResult?.diffs,
                // anchors: _diffResult?.anchors,
                diffOptions: _diffOptions,
                leftEditor,
                rightEditor,
                activeEditor: _activeEditor,
            };
        },
        clearAnchors,
        compute: computeDiff,
        diffOptions: _diffOptions,
        get outputOptions() {
            return _outputOptions;
        },
    };
})();
//# sourceMappingURL=main.js.map
</script>
</body>

</html>
