<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script id="worker.js" type="text/plain">"use strict";
const SECTION_HEADING_MASK = 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */ |
    1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */ |
    2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */ |
    4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */;
let _nextCtx = null;
let _currentCtx = null;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (ctx.leftTokens === null) {
            ctx.leftTokens = _currentCtx.leftTokens;
        }
        if (ctx.rightTokens === null) {
            ctx.rightTokens = _currentCtx.rightTokens;
        }
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            diffs: result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhsTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    // return postProcess(ctx, rawResult, lhsTokens, rhsTokens);
    return rawResult;
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // 텍스트가 길어지는 경우(토큰이 많은 경우) 끔찍하게 많은 반복을 수행하게된다.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // 주기적으로 yield 해서 취소요청을 받아야함.
            // performance.now()는 미친게 아닌가 싶을 정도로 무거운 함수이기 때문에 되도록 자제.
            // await new Promise(...) 역시 자주 사용하면 안됨
            // (i+j) % 0x4000 === 0 일 때만 사용하기로. 브라우저 js엔진의 비트연산 속도를 믿어본다 ㅋ
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 50) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// 정들었던 diff 함수. 폐기처분 예정.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                // empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                // empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && i < lcsEntry.leftIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && j < lcsEntry.rightIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Histogram Algorithm
// 일단 지금은 이놈이 디폴트
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    // ctx.entries = [] as DiffEntry[];
    let leftAnchors = [];
    let rightAnchors = [];
    for (let i = 0; i < lhsTokens.length; i++) {
        if (lhsTokens[i].flags & 32768 /* TokenFlags.MANUAL_ANCHOR */) {
            leftAnchors.push(i);
        }
    }
    if (leftAnchors.length > 0) {
        for (let i = 0; i < rhsTokens.length; i++) {
            if (rhsTokens[i].flags & 32768 /* TokenFlags.MANUAL_ANCHOR */) {
                rightAnchors.push(i);
            }
        }
    }
    const matches = [];
    if (rightAnchors.length > 0) {
        let rightPos = 0;
        for (let l = 0; l < leftAnchors.length; l++) {
            const leftTokenIndex = leftAnchors[l];
            for (let r = rightPos; r < rightAnchors.length; r++) {
                const rightTokenIndex = rightAnchors[r];
                if (lhsTokens[leftTokenIndex].text === rhsTokens[rightTokenIndex].text) {
                    matches.push({ lhsIndex: leftTokenIndex, rhsIndex: rightTokenIndex });
                    rightPos = r + 1;
                    break;
                }
            }
        }
    }
    let prevLhs = 0;
    let prevRhs = 0;
    for (const match of matches) {
        const lhsAnchor = match.lhsIndex;
        const rhsAnchor = match.rhsIndex;
        if (prevLhs < lhsAnchor || prevRhs < rhsAnchor) {
            // console.log("diffCore", {
            // 	lhsTokens,
            // 	lhsLower: prevLhs,
            // 	lhsUpper: lhsAnchor,
            // 	rhsTokens,
            // 	rhsLower: prevRhs,
            // 	rhsUpper: rhsAnchor,
            // });
            await diffCore(ctx, lhsTokens, prevLhs, lhsAnchor, rhsTokens, prevRhs, rhsAnchor, findBestHistogramAnchor);
        }
        ctx.entries.push({
            type: 0,
            left: {
                pos: lhsAnchor,
                len: 1,
            },
            right: {
                pos: rhsAnchor,
                len: 1,
            },
        });
        prevLhs = lhsAnchor + 1;
        prevRhs = rhsAnchor + 1;
    }
    if (prevLhs < lhsTokens.length || prevRhs < rhsTokens.length) {
        // console.log("diffCore", {
        // 	lhsTokens,
        // 	lhsLower: prevLhs,
        // 	lhsUpper: lhsTokens.length,
        // 	rhsTokens,
        // 	rhsLower: prevRhs,
        // 	rhsUpper: rhsTokens.length,
        // });
        await diffCore(ctx, lhsTokens, prevLhs, lhsTokens.length, rhsTokens, prevRhs, rhsTokens.length, findBestHistogramAnchor);
    }
    // const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findBestHistogramAnchor);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return ctx.entries;
}
// histogram diff에서 가장 중요한 함수
// 얼마나 값어치 있는 공통 앵커를 찾느냐가 매우 중요하고 고로 그 값어치를 매기는 기준과 방법이 또 매우 중요함
// 여러가지 생각해볼 것들이 많지만...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // 길이가 너무 크게 영향을 주는 경향이 있어서 이걸로 조절
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const CONTAINER_START_BONUS = 1 / (diffOptions.containerStartMultiplier || 1 / 0.85);
    const CONTAINER_END_BONUS = 1 / (diffOptions.containerEndMultiplier || 1 / 0.8);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.sectionHeadingMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; n그램을 사용시 여러단어가 매치되는 경우 오히려 마지막 단어가 다음 줄로 넘어가서 보너스를 못 받을 수가 있다
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            let failed = false;
            // if (!(lhsTokens[i].flags & NO_JOIN)) {
            for (let k = 1; k < n; k++) {
                // if (lhsTokens[i + k].flags & NO_JOIN) {
                // 	failed = true;
                // 	break;
                // }
                key += delimiter + lhsTokens[i + k].text;
            }
            // } else {
            // 	failed = n > 1;
            // }
            // if (!failed) {
            freq[key] = (freq[key] || 0) + 1;
            // }
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            let failed = false;
            // if (!(rhsTokens[i].flags & NO_JOIN)) {
            for (let k = 1; k < n; k++) {
                // if (rhsTokens[i + k].flags & NO_JOIN) {
                // 	failed = true;
                // 	break;
                // }
                key += delimiter + rhsTokens[i + k].text;
            }
            // } else {
            // 	failed = n > 1;
            // }
            // if (!failed) {
            freq[key] = (freq[key] || 0) + 1;
            // }
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // 특수 케이스
        // 강제로 문서의 특정 지점끼리 매칭시킴. 문서 구조가 항상 내 맘 같은 것이 아니야. ㅠ
        // if (lhsTokens[i].flags & MANUAL_ANCHOR) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			console.log("manual anchor", ltext1, i, j);
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    // if (lhsTokens[li].flags & rhsTokens[ri].flags & MANUAL_ANCHOR) {
                    // 	return {
                    // 		lhsIndex: li,
                    // 		lhsLength: 1,
                    // 		rhsIndex: ri,
                    // 		rhsLength: 1,
                    // 	};
                    // }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext.length !== rtext.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                let boundaryBonus = 1;
                // if (boundaryBonus > CONTAINER_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & CONTAINER_START) {
                // 	boundaryBonus = CONTAINER_START_BONUS;
                // }
                // if (boundaryBonus > CONTAINER_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & CONTAINER_END) {
                // 	boundaryBonus = CONTAINER_END_BONUS;
                // }
                // if (boundaryBonus > LINE_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & LINE_START) {
                // 	boundaryBonus = LINE_START_BONUS;
                // }
                // if (boundaryBonus > LINE_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LINE_END) {
                // 	boundaryBonus = LINE_END_BONUS;
                // }
                score *= boundaryBonus;
                // if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING_MASK) {
                // 	// if ((lhsTokens[i].flags & SECTION_HEADING_MASK) !== 0) {
                // 	// 	// LEVEL1은 무시. 문서 구조가 영구같은 경우가 많음.
                // 	// } else {
                // 	// }
                // 	score *= SECTION_HEADING_BONUS;
                // }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience 알고리즘에 공통으로 사용되는 재귀함수
// 1. 양 텍스트를 공통되는 부분(앵커)으로 분할
// 2. 분할된 영역에 대해서 재귀호출
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor, consumeDirections = 3) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // 사실 이걸 쓰면 리턴값이 필요 없는데...
    // 함수 시그니처를 고치기 귀찮아서 일단 내비둠.
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // 공통 부분을 스킵하는건데 문제는 여기에서 HEAD, TAIL을 스킵하고
    // 이후에 diffCore를 재귀적으로 호출할 때 앞쪽 절반에 대해서 HEAD부분, 뒤쪽 절반에 대해서 TAIL부분을 다시 한번 스킵을 시도하게 된다.
    // 더 이상 스킵할 게 없으니 결과에는 차이가 없겠지만 불필요한 시도를 안하는 쪽으로 개선해 볼 필요가 있음!
    // 생각해볼 것: 공통 prefix,suffix를 스킵하지 않았을 경우 스킵되지 않은 부분에서 더 나은 앵커가 나올 확률이 있다.
    // 그렇지만 스킵하지 않으면 성능 상 아주 큰 문제가 생김!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize", consumeDirections);
    // 	entries.push(...skippedHead); 이렇게 넣으면 폭발함.
    for (const item of skippedHead) {
        entries.push(item);
    }
    // 양쪽 모두 남아있는 영역이 있는 경우 공통 앵커를 찾아본다!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! 적어도 한쪽이라도 영역을 줄여야 무한루프 안 생길 듯?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        // console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor, 2);
        // 의도적으로 앵커 영역까지 포함해서 호출함
        await diffCore(ctx, leftTokens, anchor.lhsIndex, lhsUpper, rightTokens, anchor.rhsIndex, rhsUpper, findAnchor, 1);
        // await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor, 1);
    }
    else {
        // 유효한 앵커는 못찾았지만 남아있는 토큰들이 있다면 diff로 처리
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    for (const item of skippedTail) {
        entries.push(item);
    }
    return entries;
}
// 공백을 완전히 무시하는 경우 "안녕 하세요" vs "안녕하세요"는 같다고 처리해야하지만
// 단어단위 토큰인 경우 토큰 대 토큰 비교는 실패할 수 밖에 없다.
// 따라서 각 토큰의 글자를 한땀한땀 매치시켜봐야하고 양쪽에서 토큰이 끝나는 시점까지 모든 글자가 매치되었다면
// 그 끝나는 시점까지의 토큰 수만큼 consume을 함.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore", consumeDirections = 3) {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    if (consumeDirections & 1) {
        while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
            if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
                head.push({
                    type: 0,
                    left: { pos: lhsLower, len: 1 },
                    right: { pos: rhsLower, len: 1 },
                });
                lhsLower++;
                rhsLower++;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
                lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
                (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                head.push({
                    type: 0,
                    left: {
                        pos: lhsLower,
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsLower,
                        len: matchedCount[1],
                    },
                });
                lhsLower += matchedCount[0];
                rhsLower += matchedCount[1];
            }
            else {
                break;
            }
        }
    }
    // Suffix
    if (consumeDirections & 2) {
        while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
            if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
                tail.push({
                    type: 0,
                    left: { pos: lhsUpper - 1, len: 1 },
                    right: { pos: rhsUpper - 1, len: 1 },
                });
                lhsUpper--;
                rhsUpper--;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
                lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
                (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                tail.push({
                    type: 0,
                    left: {
                        pos: lhsUpper - matchedCount[0],
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsUpper - matchedCount[1],
                        len: matchedCount[1],
                    },
                });
                lhsUpper -= matchedCount[0];
                rhsUpper -= matchedCount[1];
            }
            else {
                break;
            }
        }
        tail.reverse();
    }
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    let lhsToken = leftTokens[i++], ltext = lhsToken.text, lhsLen = ltext.length;
    let rhsToken = rightTokens[j++], rtext = rhsToken.text, rhsLen = rtext.length;
    // if (lhsToken.flags & NO_JOIN_NEXT || rhsToken.flags & NO_JOIN_NEXT) {
    // 	// return false;
    // }
    while (true) {
        while (ci < lhsLen && cj < rhsLen) {
            if (ltext[ci++] !== rtext[cj++]) {
                return false;
            }
        }
        // 문자 불일치 없이 양쪽 토큰이 동시에 끝난 경우
        if (ci === lhsLen && cj === rhsLen)
            return [i - lhsLower, j - rhsLower];
        if (ci === lhsLen) {
            if (i === lhsUpper)
                return false;
            if (lhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            lhsToken = leftTokens[i++];
            if (!lhsToken)
                return false;
            if (lhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            ltext = lhsToken.text;
            lhsLen = ltext.length;
            ci = 0;
        }
        if (cj === rhsLen) {
            if (j === rhsUpper)
                return false;
            if (rhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            rhsToken = rightTokens[j++];
            if (!rhsToken)
                return false;
            if (rhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            rtext = rhsToken.text;
            rhsLen = rtext.length;
            cj = 0;
        }
    }
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let lhsToken = leftTokens[i--], ltext = lhsToken.text, rhsToken = rightTokens[j--], rtext = rhsToken.text;
    let ci = ltext.length - 1, cj = rtext.length - 1;
    // if (lhsToken.flags & NO_JOIN_PREV || rhsToken.flags & NO_JOIN_PREV) {
    // 	return false;
    // }
    while (true) {
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                return false;
            }
        }
        if (ci < 0 && cj < 0)
            return [lhsUpper - i - 1, rhsUpper - j - 1];
        if (ci < 0) {
            if (i < lhsLower)
                return false;
            if (lhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            lhsToken = leftTokens[i--];
            if (!lhsToken)
                return false;
            if (lhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            ltext = lhsToken.text;
            ci = lhsToken.text.length - 1;
        }
        if (cj < 0) {
            if (j < rhsLower)
                return false;
            if (rhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            rhsToken = rightTokens[j--];
            if (!rhsToken)
                return false;
            if (rhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            rtext = rhsToken.text;
            cj = rhsToken.text.length - 1;
        }
    }
}
//# sourceMappingURL=worker.js.map
</script>
<script>"use strict";
// DIFF 색(HUE). 0(빨)은 DIFF 배경색으로 쓰이니 패스
// 완전한 색상 코드보다 HUE만 사용하면 용도에 따라 색을 조절하기 쉬움.
// 인접한 색상과 너무 가깝지 않도록 아주 CAREFUL하게 고른 순서. 과학이다.
const DIFF_COLOR_HUES = [
    30, // 주황?
    180, // cyan
    300, // 핑크?
    120, // 초록
    240, // 파랑
    60, // 노랑
    270, // 보라?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const BASE_FONT_SIZE = 16;
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 1.5;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 2 * BASE_FONT_SIZE; // px
const COMPUTE_DEBOUNCE_TIME = 200; // ms
const FORCE_RENDER_TIMEOUT = 100; // ms
const PROCESSING_MESSAGES = [
    "한땀한땀 비교 중...",
    "인내심 테스트 중...",
    "생각 중...",
    "재부팅 준비 중...",
    "무한 루프 중...",
    "머리 긁는 중...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "퇴근 준비 중...",
];
const HANGUL_ORDER = "가나다라마바사아자차카타파하거너더러머버서어저처커터퍼허";
const VOID_ELEMENTS = {
    AREA: true,
    BASE: true,
    BR: true,
    COL: true,
    COMMAND: true,
    EMBED: true,
    HR: true,
    IMG: true,
    INPUT: true,
    LINK: true,
    META: true,
    PARAM: true,
    SOURCE: true,
    TRACK: true,
    WBR: true,
};
const TEXTLESS_ELEMENTS = {
    ...VOID_ELEMENTS,
    VIDEO: true,
    AUDIO: true,
    OBJECT: true,
    CANVAS: true,
    SVG: true,
    TABLE: true,
    THEAD: true,
    TBODY: true,
    TFOOT: true,
    TR: true,
    OL: true,
    UL: true,
    DL: true,
    STYLE: true,
    HEAD: true,
    TITLE: true,
    SCRIPT: true,
    "#document-fragment": true,
};
const LINE_ELEMENTS = {
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
};
// 많은 요소들이 있지만 다 무시하고 root와 td/th만 생각함.
// 다른 요소들은 어차피 레이아웃과 무관
const TEXT_FLOW_CONTAINERS = {
    TD: true,
    TH: true,
    // DIV: true,
    // PRE: true,
    // BLOCKQUOTE: true,
    // LI: true,
    // SECTION: true,
    // ARTICLE: true,
    // HEADER: true,
    // FOOTER: true,
    // ASIDE: true,
    // MAIN: true,
    // CAPTION: true,
    // FIGURE: true,
    // FIGCAPTION: true,
};
const BLOCK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
    //TD: true,
    "#document-fragment": true,
};
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
function findIndexByPos(arr, pos) {
    // binary search
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const item = arr[mid];
        const start = item.pos, end = item.pos + item.len;
        if (start <= pos && pos < end) {
            return mid;
        }
        else if (start > pos) {
            high = mid - 1;
        }
        else if (end <= pos) {
            low = mid + 1;
        }
    }
    return ~low;
}
function findDiffEntryRangeByPos(entries, side, pos, endPos) {
    let low = 0;
    let high = entries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (pos < s.pos) {
            high = mid - 1;
        }
        else if (pos >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = mid;
            break;
        }
    }
    low = mappedStart;
    high = entries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (endPos - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endPos - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = mid + 1;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function mapTokenRangeToOtherSide(rawEntries, side, startIndex, endIndex) {
    // console.log("mapTokenRangeToOtherSide", { rawEntries, side, startIndex, endIndex });
    const otherSide = side === "left" ? "right" : "left";
    let low = 0;
    let high = rawEntries.length - 1;
    let mappedStart = -1;
    let mappedEnd = -1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (startIndex < s.pos) {
            high = mid - 1;
        }
        else if (startIndex >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = rawEntries[mid][otherSide].pos;
            if (endIndex <= s.pos + s.len) {
                mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            }
            // if (rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len < endIndex) {
            // 	mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            // }
            low = mid; // reuse for mappedEnd search
            break;
        }
    }
    if (mappedStart >= 0 && mappedEnd === -1) {
        mappedEnd = mappedStart;
        high = rawEntries.length - 1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const s = rawEntries[mid][side];
            if (endIndex - 1 < s.pos) {
                high = mid - 1;
            }
            else if (endIndex - 1 >= s.pos + s.len) {
                low = mid + 1;
            }
            else {
                mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
                break;
            }
        }
    }
    // console.warn("mapTokenRangeToOtherSide result", { mappedStart, mappedEnd });
    return [mappedStart, mappedEnd];
}
function buildOutputHTMLFromRuns(text, textRuns, options) {
    let inDiff = false;
    let result = options.htmlPre ? "<pre>" : "";
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            const diffIndex = run.dataIndex;
            // result += "<mark>";
            const color = DIFF_COLOR_HUES[diffIndex % DIFF_COLOR_HUES.length];
            result += `<mark style="background-color: hsl(${color}, 100%, 80%);">`;
            inDiff = true;
        }
        else if (run.type === "DIFF_END") {
            if (inDiff) {
                // result += "</mark>";
                result += "</mark>";
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += escapeHTML(text.slice(run.pos, run.pos + run.len));
        }
        else if (run.type === "LINEBREAK") {
            result += "<br/>";
        }
    }
    if (inDiff)
        result += "</mark>";
    if (options.htmlPre)
        result += "</pre>";
    // result += "<br/>";
    return result;
}
function buildOutputPlainText(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const leftBody = buildOutputPlainTextFromRuns(leftText, leftRuns, options);
    const rightBody = buildOutputPlainTextFromRuns(rightText, rightRuns, options);
    return `${leftLabel}: ${leftBody}\n${rightLabel}: ${rightBody}\n`;
}
function buildOutputPlainTextFromRuns(text, textRuns, options) {
    const format = options.textFormat ?? 0;
    let result = "";
    let inDiff = false;
    let markStart;
    let markEnd;
    if (format === 1) {
        markStart = "**";
        markEnd = "**";
    }
    else if (format === 2) {
        markStart = "[[ ";
        markEnd = " ]]";
    }
    else {
        markStart = "";
        markEnd = "";
    }
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            if (format !== 0 && !inDiff) {
                result += markStart;
                inDiff = true;
            }
        }
        else if (run.type === "DIFF_END") {
            if (format !== 0 && inDiff) {
                result += markEnd;
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += text.slice(run.pos, run.pos + run.len);
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inDiff && format !== 0)
        result += markEnd;
    return result;
}
function buildOutputHTML(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const htmlFormat = options.htmlFormat ?? "div";
    if (htmlFormat === "table") {
        // Default: table format
        return `<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr><th>${escapeHTML(leftLabel)}</th><th>${escapeHTML(rightLabel)}</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></td>
      <td><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></td>
    </tr>
  </tbody>
</table>`.trim();
    }
    if (htmlFormat === "dl") {
        return `<dl>
  <dt>${escapeHTML(leftLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></dd>
  <dt>${escapeHTML(rightLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></dd>
</dl>`.trim();
    }
    return `<div>
<div><strong>${escapeHTML(leftLabel)}:</strong> ${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</div>
<div><strong>${escapeHTML(rightLabel)}:</strong> ${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</div>
</div>`.trim();
}
function escapeHTML(str) {
    return str.replace(/[&<>"]|'/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#039;";
            default:
                return char;
        }
    });
}
function parseOrdinalNumber(ordinalText) {
    const norm = ordinalText.replace(/[\(\)\.]/g, "");
    if (/^\d+$/.test(norm)) {
        return Number(norm);
    }
    const idx = HANGUL_ORDER.indexOf(norm);
    if (idx !== -1) {
        return idx + 1;
    }
    return NaN;
}
function findFirstNodeAfter(root, after) {
    let current = after;
    while (current && current !== root) {
        if (current.nextSibling) {
            return current.nextSibling;
        }
        else {
            current = current.parentNode;
        }
    }
    return null;
}
function getTextOffsetOfNode(root, node, end = false) {
    const filter = node.nodeType === 3 ? NodeFilter.SHOW_TEXT : NodeFilter.SHOW_ALL;
    let walker = document.createTreeWalker(root, filter, null);
    let pos = 0;
    let currentNode;
    while ((currentNode = walker.nextNode())) {
        if (currentNode === node && !end) {
            break;
        }
        if (currentNode.nodeType === 3) {
            pos += currentNode.nodeValue.length;
        }
        if (currentNode === node && end) {
            break;
        }
    }
    return pos;
}
function dumpRange() {
    const sel = window.getSelection();
    if (sel && sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        console.log("current selection", {
            range,
            startContainer: range.startContainer,
            startOffset: range.startOffset,
            endContainer: range.endContainer,
            endOffset: range.endOffset,
        });
        return range;
    }
    else {
        console.log("no selection");
    }
}
function findAdjacentTextNode(node, skipEmpty = false) {
    let root = node;
    while (root && !BLOCK_ELEMENTS[root.nodeName]) {
        root = root.parentNode;
    }
    let next = advanceNode(node, root, true);
    while (next) {
        if (next.nodeType === 3) {
            if (!skipEmpty || next.nodeValue.length > 0) {
                return next;
            }
        }
        else {
            const nextName = next.nodeName;
            if (BLOCK_ELEMENTS[nextName]) {
                break;
            }
            if (nextName === "BR" || nextName === "IMG" || nextName === "HR") {
                break;
            }
        }
        next = advanceNode(next, root);
    }
    return null;
}
function advanceNode(currentNode, rootNode = null, skipChildren = false) {
    if (!skipChildren && currentNode.firstChild) {
        return currentNode.firstChild;
    }
    let node = currentNode;
    while (node && node !== rootNode) {
        if (node.nextSibling) {
            return node.nextSibling;
        }
        node = node.parentNode;
    }
    return null;
}
function retreatNode(currentNode) {
    if (!currentNode)
        return null;
    const prev = currentNode.previousSibling;
    if (prev) {
        let node = prev;
        while (node.lastChild)
            node = node.lastChild;
        return node;
    }
    return currentNode.parentNode;
}
function findNextAncestorSibling(node, rootNode) {
    while (node && node !== rootNode) {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
    return null;
}
function mergeRects(rects, toleranceX = 0, toleranceY = 0) {
    rects.sort((a, b) => a.y - b.y || a.x - b.x);
    const merged = [];
    const used = new Array(rects.length).fill(false);
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = 0;
    let maxY = 0;
    for (let i = 0; i < rects.length; i++) {
        if (used[i])
            continue;
        let base = rects[i];
        for (let j = i + 1; j < rects.length; j++) {
            if (used[j])
                continue;
            const compare = rects[j];
            // 세로 위치/높이 거의 같아야 병합 대상이 됨
            const sameY = Math.abs(base.y - compare.y) <= toleranceY && Math.abs(base.height - compare.height) <= toleranceY;
            if (!sameY)
                continue;
            // x축 겹치거나 toleranceX 이내
            const baseRight = base.x + base.width;
            const compareRight = compare.x + compare.width;
            const xOverlapOrClose = baseRight >= compare.x - toleranceX && compareRight >= base.x - toleranceX;
            if (xOverlapOrClose) {
                const newX = Math.min(base.x, compare.x);
                const newRight = Math.max(baseRight, compareRight);
                base = {
                    x: newX,
                    y: Math.min(base.y, compare.y),
                    width: newRight - newX,
                    height: Math.max(base.height, compare.height),
                };
                used[j] = true;
            }
        }
        merged.push(base);
        used[i] = true;
        minX = Math.min(minX, base.x);
        minY = Math.min(minY, base.y);
        maxX = Math.max(maxX, base.x + base.width);
        maxY = Math.max(maxY, base.y + base.height);
    }
    return {
        minX,
        minY,
        maxX,
        maxY,
        rects: merged,
    };
}
function isLastChildOrFollowing(container, child) {
    // fast path. 여기서 얼마나 걸릴 지 모르겠지만...
    if (container.lastChild === child || container.nextSibling === child) {
        return true;
    }
    const range = document.createRange();
    range.selectNode(container);
    range.comparePoint;
}
function extractTextRanges(sourceRange) {
    if (sourceRange.startContainer.nodeType === 3 && sourceRange.startContainer === sourceRange.endContainer) {
        return [sourceRange];
    }
    const root = sourceRange.commonAncestorContainer;
    const result = [];
    const walker = document.createTreeWalker(sourceRange.commonAncestorContainer, NodeFilter.SHOW_ALL);
    let startNode;
    let endNode;
    let currentNode;
    if (sourceRange.startContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.startContainer, sourceRange.startOffset);
        r.setEnd(sourceRange.startContainer, sourceRange.startContainer.nodeValue.length);
        result.push(r);
        walker.currentNode = sourceRange.startContainer;
        currentNode = walker.nextNode();
    }
    else if (sourceRange.startContainer.nodeType === 1) {
        startNode = sourceRange.startContainer.childNodes[sourceRange.startOffset] || sourceRange.startContainer;
        walker.currentNode = currentNode = startNode;
    }
    else {
        throw new Error("Invalid start container");
    }
    if (sourceRange.endContainer.nodeType === 3) {
        endNode = sourceRange.endContainer;
    }
    else if (sourceRange.endContainer.nodeType === 1) {
        if (sourceRange.endOffset < sourceRange.endContainer.childNodes.length) {
            endNode = sourceRange.endContainer.childNodes[sourceRange.endOffset];
        }
        else {
            endNode = advanceNode(sourceRange.endContainer, root, true);
        }
    }
    else {
        throw new Error("Invalid end container");
    }
    while (currentNode && currentNode !== endNode) {
        if (currentNode.nodeType === 3) {
            const r = document.createRange();
            r.selectNodeContents(currentNode);
            result.push(r);
        }
        else {
            if (currentNode.nodeName === "BR") {
                const r = document.createRange();
                r.selectNode(currentNode);
                result.push(r);
            }
            // do nothing for now
        }
        currentNode = walker.nextNode();
    }
    if (sourceRange.endContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.endContainer, 0);
        r.setEnd(sourceRange.endContainer, sourceRange.endOffset);
        result.push(r);
    }
    return result;
}
function findFirstTextNode(root) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (text.nodeValue && text.nodeValue.trim() !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        // 앞에서부터 순회 (0 → N)
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function findLastTextNode(root, skipEmpty = false) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (!skipEmpty || text.nodeValue !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function getNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const commonAncestor = range.commonAncestorContainer;
    const walker = document.createTreeWalker(commonAncestor, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        nodeRange.selectNodeContents(node);
        const startsBeforeEnd = nodeRange.compareBoundaryPoints(Range.END_TO_START, range) < 0;
        const endsAfterStart = nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0;
        if (startsBeforeEnd && endsAfterStart) {
            nodes.push(node);
        }
        else if (!startsBeforeEnd) {
            // 이미 범위를 지난 경우 break
            break;
        }
        node = walker.nextNode();
    }
    return nodes;
}
function getFullyContainedNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const walker = document.createTreeWalker(range.commonAncestorContainer, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        try {
            nodeRange.selectNode(node);
        }
        catch {
            // 텍스트 노드 등 selectNode 실패 시에는 selectNodeContents
            nodeRange.selectNodeContents(node);
        }
        const startsAfterOrAt = nodeRange.compareBoundaryPoints(Range.START_TO_START, range) >= 0;
        const endsBeforeOrAt = nodeRange.compareBoundaryPoints(Range.END_TO_END, range) <= 0;
        if (startsAfterOrAt && endsBeforeOrAt) {
            nodes.push(node);
        }
        else if (!startsAfterOrAt && nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0) {
            break; // 앞으로는 포함될 가능성 없음
        }
        node = walker.nextNode();
    }
    return nodes;
}
function isEmptyElement(el) {
    for (const node of Array.from(el.childNodes)) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent?.trim()) {
                return false; // 내용이 있는 텍스트
            }
        }
        else if (node.nodeType === Node.ELEMENT_NODE) {
            const elem = node;
            if (elem.tagName !== "BR") {
                return false; // <br> 외의 요소가 있음
            }
        }
        else {
            return false; // 알 수 없는 노드 (예: 주석 등)
        }
    }
    return true;
}
function isNodeStartInsideRange(element, range) {
    const elementStart = document.createRange();
    elementStart.setStartBefore(element);
    elementStart.setEndBefore(element);
    return range.compareBoundaryPoints(Range.START_TO_START, elementStart) <= 0 && range.compareBoundaryPoints(Range.END_TO_START, elementStart) > 0;
}
function extractRects(sourceRange, forceAnchorRects = false) {
    // console.debug("extractRects", sourceRange);
    const result = [];
    const tempRange = document.createRange();
    let startNode;
    if (sourceRange.startContainer.nodeType === 3) {
        tempRange.setStart(sourceRange.startContainer, sourceRange.startOffset);
        if (sourceRange.startContainer === sourceRange.endContainer) {
            tempRange.setEnd(sourceRange.startContainer, sourceRange.endOffset);
        }
        else {
            tempRange.setEnd(sourceRange.startContainer, sourceRange.startContainer.nodeValue.length);
        }
        for (const rect of tempRange.getClientRects()) {
            result.push({
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
            });
        }
        startNode = advanceNode(sourceRange.startContainer);
    }
    else {
        startNode = sourceRange.startContainer.childNodes[sourceRange.startOffset];
        if (!startNode) {
            startNode = advanceNode(sourceRange.startContainer, null, true);
            if (!startNode) {
                console.warn("extractRects: No startNode found", sourceRange);
                return result;
            }
        }
    }
    const endContainer = sourceRange.endContainer;
    let endOffset;
    let endNode;
    if (endContainer.nodeType === 3) {
        endNode = endContainer;
        endOffset = sourceRange.endOffset;
    }
    else {
        endNode = endContainer.childNodes[sourceRange.endOffset];
        if (!endNode) {
            endNode = advanceNode(endContainer, null, true);
        }
        endOffset = -1;
    }
    // console.debug("extractRects", { sourceRange, startNode, endNode, endOffset });
    const walker = document.createTreeWalker(sourceRange.commonAncestorContainer, NodeFilter.SHOW_ALL);
    if (!startNode || !endNode) {
        console.warn("extractRects: No startNode or endNode", sourceRange);
        return result;
    }
    if (endNode.compareDocumentPosition(startNode) & Node.DOCUMENT_POSITION_FOLLOWING) {
        // startNode가 endNode보다 뒤에 있는 경우
        // console.warn("extractRects: startNode is after endNode", startNode, endNode);
        return result;
    }
    walker.currentNode = startNode;
    // const hardEnd = advanceNode(editor);
    do {
        const currentNode = walker.currentNode;
        if (!currentNode) {
            console.error("extractRects: currentNode is null", sourceRange);
        }
        if (currentNode === endNode) {
            if (currentNode.nodeType === 3 && endOffset >= 0) {
                tempRange.setStart(endNode, 0);
                tempRange.setEnd(endNode, endOffset);
                for (const rect of tempRange.getClientRects()) {
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
            }
            break;
        }
        // if (currentNode === hardEnd) {
        // 	console.warn("extractRects: reached hard end", currentNode, endOffset);
        // 	break;
        // }
        if (currentNode.nodeType === 3) {
            tempRange.selectNodeContents(currentNode);
            for (const rect of tempRange.getClientRects()) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
        }
        else if (currentNode.nodeName === "BR") {
            //
        }
        else if (currentNode.nodeName === "A") {
            if (forceAnchorRects) {
                // 가장 확실한 방법이지만 넣었다 뺐다 잘못하면 인생 망가짐... reflow 유발 => 많이 느리다.
                const tempText = document.createTextNode("\u200B"); // zero-width space
                currentNode.appendChild(tempText);
                tempRange.selectNodeContents(tempText);
                for (const rect of tempRange.getClientRects()) {
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
                tempText.remove();
            }
            else {
                for (const rect of currentNode.getClientRects()) {
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
            }
        }
        else if (currentNode.nodeName === "IMG") {
            tempRange.selectNode(currentNode);
            for (const rect of tempRange.getClientRects()) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
        }
    } while (walker.nextNode());
    return result;
}
// plaintext를 복붙할 때...
function formatPlaintext(plaintext) {
    const lines = plaintext.split(/\r?\n/);
    const fragment = document.createDocumentFragment();
    for (const line of lines) {
        const p = document.createElement("P");
        if (line === "") {
            p.appendChild(document.createElement("BR"));
        }
        else {
            p.appendChild(document.createTextNode(line));
        }
        fragment.appendChild(p);
    }
    return fragment;
}
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
const __ATOMS__ = {};
function createAtom(name, initialValue) {
    if (__ATOMS__[name]) {
        return __ATOMS__[name];
    }
    if (initialValue === undefined) {
        throw new Error(`Atom "${name}" is not initialized and no initial value provided.`);
    }
    let value = initialValue;
    const listeners = new Set();
    const atom = {
        get() {
            return value;
        },
        set(newValue) {
            value = newValue;
            listeners.forEach((fn) => fn(value));
        },
        subscribe(fn) {
            listeners.add(fn);
            fn(value);
            return () => listeners.delete(fn);
        },
    };
    __ATOMS__[name] = atom;
    return atom;
}
function createEventAtom(name) {
    // name은 그냥 디버깅 용도로...
    const listeners = new Set();
    return {
        emit(payload) {
            listeners.forEach((fn) => fn(payload));
        },
        subscribe(fn) {
            listeners.add(fn);
            return () => listeners.delete(fn);
        },
    };
}
//# sourceMappingURL=atom.js.map
</script>
<script>"use strict";
const STYLE_NONE = 0;
const STYLE_COLOR_RED = 1;
const STYLE_MASK_COLOR = STYLE_COLOR_RED;
const reddishCache = new Map([
    ["red", true],
    ["#ff0000", true],
    ["#e60000", true],
    ["#c00000", true],
    ["rgb(255,0,0)", true],
    ["rgb(230,0,0)", true],
    ["#000000", false],
    ["#333333", false],
    ["#ffffff", false],
    ["black", false],
    ["blue", false],
    ["white", false],
    ["window", false],
    ["windowtext", false],
]);
let _ctx = null;
// 캔버스는 많이 느릴테니까 최대한 정규식을 우선 씀!
// 정규식은 수명단축의 지름길이므로 절대적으로 chatgtp한테 맡기고 눈길 조차 주지 말 것.
function getRGB(color) {
    // #rrggbb
    const hex6 = /^#([0-9a-f]{6})$/i.exec(color);
    if (hex6) {
        const n = parseInt(hex6[1], 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    // #rgb
    const hex3 = /^#([0-9a-f]{3})$/i.exec(color);
    if (hex3) {
        const [r, g, b] = hex3[1].split("").map((c) => parseInt(c + c, 16));
        return [r, g, b];
    }
    // rgb(...) / rgba(...)
    const rgb = /^rgba?\(([^)]+)\)$/i.exec(color);
    if (rgb) {
        const parts = rgb[1].split(",").map((s) => parseInt(s.trim(), 10));
        if (parts.length >= 3)
            return [parts[0], parts[1], parts[2]];
    }
    // fallback: canvas. 아마도 많이 느릴 것...
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    try {
        _ctx.clearRect(0, 0, 1, 1);
        _ctx.fillStyle = color;
        _ctx.fillRect(0, 0, 1, 1);
        const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
        return [r, g, b];
    }
    catch {
        return null;
    }
}
function isReddish(color) {
    let isRed = reddishCache.get(color);
    if (isRed !== undefined)
        return isRed;
    const rgb = getRGB(color);
    isRed = rgb ? rgb[0] >= 139 && rgb[0] - Math.max(rgb[1], rgb[2]) >= 65 : false;
    reddishCache.set(color, isRed);
    return isRed;
}
const COMMON_ALLOWED_STYLES = {
    textAlign: true,
    fontSize: true,
    fontWeight: true,
    fontStyle: true,
    margin: true,
    marginLeft: true,
    marginRight: true,
    marginTop: true,
    marginBottom: true,
    marginBlockStart: true,
    marginBlockEnd: true,
    marginBlock: true,
    marginInlineStart: true,
    marginInlineEnd: true,
    marginInline: true,
    padding: true,
    paddingLeft: true,
    paddingRight: true,
    paddingTop: true,
    paddingBottom: true,
    paddingBlockStart: true,
    paddingBlockEnd: true,
    paddingBlock: true,
    paddingInlineStart: true,
    paddingInlineEnd: true,
    paddingInline: true,
};
const DefaultElementOptions = {
    allowedStyles: COMMON_ALLOWED_STYLES,
};
const AsDivElementOptions = {
    replaceTag: "DIV",
};
const SMART_TAG_OPTIONS = {
    unwrap: true,
};
const ALLOWED_ELEMENTS = {
    TABLE: DefaultElementOptions,
    TBODY: DefaultElementOptions,
    THEAD: DefaultElementOptions,
    TFOOT: DefaultElementOptions,
    CAPTION: DefaultElementOptions,
    TR: DefaultElementOptions,
    TH: { allowedAttrs: { colspan: true, rowspan: true }, allowedStyles: COMMON_ALLOWED_STYLES },
    TD: { allowedAttrs: { colspan: true, rowspan: true }, allowedStyles: COMMON_ALLOWED_STYLES },
    H1: DefaultElementOptions,
    H2: DefaultElementOptions,
    H3: DefaultElementOptions,
    H4: DefaultElementOptions,
    H5: DefaultElementOptions,
    H6: DefaultElementOptions,
    SUP: DefaultElementOptions,
    SUB: DefaultElementOptions,
    EM: DefaultElementOptions,
    I: DefaultElementOptions,
    S: DefaultElementOptions,
    B: DefaultElementOptions,
    STRONG: DefaultElementOptions,
    U: DefaultElementOptions,
    STRIKE: DefaultElementOptions,
    P: DefaultElementOptions,
    UL: DefaultElementOptions,
    OL: DefaultElementOptions,
    LI: DefaultElementOptions,
    DL: DefaultElementOptions,
    DT: DefaultElementOptions,
    DD: DefaultElementOptions,
    DIV: DefaultElementOptions,
    BLOCKQUOTE: DefaultElementOptions,
    ADDRESS: DefaultElementOptions,
    FIELDSET: DefaultElementOptions,
    LEGEND: DefaultElementOptions,
    MARK: DefaultElementOptions,
    CODE: DefaultElementOptions,
    PRE: DefaultElementOptions,
    SMALL: DefaultElementOptions,
    DEL: DefaultElementOptions,
    INS: DefaultElementOptions,
    IMG: { allowedAttrs: { src: true, width: true, height: true }, allowedStyles: { width: true, height: true } },
    SPAN: DefaultElementOptions,
    LABEL: DefaultElementOptions,
    BR: { void: true },
    HR: { void: true },
    FORM: AsDivElementOptions,
    NAV: AsDivElementOptions,
    MAIN: AsDivElementOptions,
    HEADER: AsDivElementOptions,
    FOOTER: AsDivElementOptions,
    SECTION: AsDivElementOptions,
    ARTICLE: AsDivElementOptions,
    ASIDE: AsDivElementOptions,
    A: {
        replaceTag: "SPAN",
        allowedStyles: COMMON_ALLOWED_STYLES,
    },
    "#document-fragment": DefaultElementOptions,
};
function coerceColor(color) {
    if (isReddish(color)) {
        return "red";
    }
    return undefined;
}
// 조건 시작 정규식 (주석 유무 상관없이, [if ...]> 또는 <![if ...]> 모두 포괄)
const ifRegex = /(?:<!--)?<?!?\[if\s+([^\]]+?)\]>?/gi;
// 조건 종료 정규식
const endifRegex = /<!\[endif\](?:-->|\])?/i;
/**
 * input: 파싱할 전체 문자열
 * start: 파싱 시작 위치 (무조건 [if ...]가 시작하는 위치여야 함)
 *
 * returns: [조건부 블록, 종료 위치]
 */
function parseIfBlock(input, start) {
    ifRegex.lastIndex = start;
    const ifMatch = ifRegex.exec(input);
    if (!ifMatch || ifMatch.index !== start) {
        console.error("parseIfBlock must start at an [if] condition", { ifMatch, start, input });
        throw new Error("parseIfBlock must start at an [if] condition");
    }
    const condition = ifMatch[1].trim();
    let cursor = ifRegex.lastIndex;
    const children = [];
    while (cursor < input.length) {
        ifRegex.lastIndex = cursor;
        endifRegex.lastIndex = cursor;
        const nextIf = ifRegex.exec(input);
        const nextEndIf = endifRegex.exec(input);
        if (nextEndIf && (!nextIf || nextEndIf.index < nextIf.index)) {
            // endif가 먼저 나오면 현재 조건 종료
            if (nextEndIf.index > cursor) {
                const text = input.slice(cursor, nextEndIf.index);
                if (text.trim())
                    children.push(text);
            }
            cursor = nextEndIf.index + nextEndIf[0].length;
            return [{ condition, children }, cursor];
        }
        if (nextIf && nextIf.index === cursor) {
            // 중첩된 if 조건 파싱 재귀 호출
            console.log("parseIfBlock called at pos:", start);
            console.log("String at start:", input.slice(start, start + 20));
            const [childBlock, newPos] = parseIfBlock(input, cursor);
            children.push(childBlock);
            cursor = newPos;
            continue;
        }
        // 일반 텍스트 추출 (다음 조건문 혹은 endif까지)
        let nextPos = input.length;
        if (nextIf)
            nextPos = Math.min(nextPos, nextIf.index);
        if (nextEndIf)
            nextPos = Math.min(nextPos, nextEndIf.index);
        const text = input.slice(cursor, nextPos);
        if (text.trim())
            children.push(text);
        cursor = nextPos;
    }
    throw new Error("Missing matching [endif]");
}
const TRIM_CHARS = {
    " ": true,
    "\n": true,
    "\r": true,
    "\t": true,
    "\f": true,
};
// TODO
// 워드에서 복붙할때 빈줄이 <p><o:p></o:p></p> 이런식으로 들어올 수도 있다
// 이 경우 <p><br></p>로 바꿔야 한다.
function sanitizeHTML(rawHTML) {
    // 보통 복붙을 하면 <!--StartFragment-->와 <!--EndFragment--> 태그로 감싸져 있다.
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length);
        }
    }
    // console.debug("sanitizeHTML called with rawHTML:", rawHTML);
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType !== 1 && // element
            node.nodeType !== 11 // document fragment
        ) {
            return null;
        }
        const nodeName = node.nodeName;
        let elementOptions = ALLOWED_ELEMENTS[nodeName];
        if (!elementOptions) {
            if (nodeName === "O:P" && node.childNodes.length === 1 && node.childNodes[0].nodeValue === "\u00A0") {
                // 워드에서 복붙할때 빈줄이 <p><o:p></o:p></p> 이런식으로 들어올 수도 있다
                return document.createElement("BR");
            }
            else if (nodeName.startsWith("ST1:")) {
                elementOptions = SMART_TAG_OPTIONS;
            }
            if (!elementOptions) {
                return null;
            }
        }
        let containerNode;
        if (elementOptions.unwrap) {
            containerNode = containerStack[containerStack.length - 1].node;
        }
        else {
            if (node.nodeType === 1) {
                containerNode = document.createElement(elementOptions.replaceTag || nodeName);
                if (elementOptions.allowedAttrs) {
                    for (const attr of node.attributes) {
                        if (elementOptions.allowedAttrs[attr.name]) {
                            containerNode.setAttribute(attr.name, attr.value);
                        }
                    }
                }
                if (elementOptions.allowedStyles) {
                    const style = node.style;
                    for (const prop in elementOptions.allowedStyles) {
                        if (style[prop]) {
                            containerNode.style[prop] = style[prop];
                        }
                    }
                }
                let colorValue = node.style?.color;
                if (colorValue) {
                    if (colorValue === "inherit") {
                        // use parent color
                    }
                    else {
                        if (isReddish(colorValue)) {
                            containerNode.classList.add("color-red");
                        }
                    }
                }
            }
            else {
                // document fragment
                containerNode = document.createDocumentFragment();
            }
            containerStack.push({ node: containerNode });
        }
        if (!elementOptions.void) {
            let isTextless = TEXTLESS_ELEMENTS[nodeName];
            for (const childNode of node.childNodes) {
                let sanitizedChild = null;
                if (childNode.nodeType === 3) {
                    if (isTextless) {
                        continue;
                    }
                    sanitizedChild = document.createTextNode(childNode.nodeValue);
                }
                else {
                    sanitizedChild = traverse(childNode);
                    if (!sanitizedChild) {
                        continue;
                    }
                }
                containerNode.appendChild(sanitizedChild);
            }
        }
        // containerNode.normalize();
        // if (containerNode.nodeName === "P") {
        // 	if (containerNode.childNodes.length === 0) {
        // 		containerNode.appendChild(document.createElement("BR"));
        // 	}
        // } else {
        // 	if (BLOCK_ELEMENTS[nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
        // 		containerNode.appendChild(document.createElement("BR"));
        // 	}
        // }
        // if (containerNode.nodeType !== 11) {
        // }
        if ((elementOptions.unwrap || (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName])) && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (!elementOptions.unwrap) {
            containerStack.pop();
        }
        return containerNode;
    }
    const tmpl = document.createElement("template");
    tmpl.innerHTML = rawHTML;
    const root = document.createDocumentFragment();
    containerStack.push({ node: root });
    const result = traverse(tmpl.content);
    // result.normalize();
    // if (result.childNodes.length === 0) {
    // 	result.appendChild(document.createTextNode(""));
    // }
    return result;
}
//# sourceMappingURL=sanitize.js.map
</script>
<script>"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const SECTION_HEADING_MASK = 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */ |
    1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */ |
    2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */ |
    4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */;
// const normalizeChars: { [ch: string]: string } = {};
// text flow containers?
const containerElements = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
const spaceChars = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // 글쎄...
    "\f": true, // 이것들은...
    "\v": true, // 볼일이 없을것...
    "\u00A0": true, // &nbsp; ??
};
const splitChars = {
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
};
const normalizedCharMap = ((normChars) => {
    const result = {};
    let parser;
    function htmlEntityToChar(entity) {
        const doc = (parser = parser || new DOMParser()).parseFromString(entity, "text/html");
        const char = doc.body.textContent;
        if (char.length !== 1) {
            throw new Error("htmlEntityToChar: not a single character entity: " + entity);
        }
        return char;
    }
    for (const entry of normChars) {
        const [norm, ...variants] = entry;
        for (const variant of variants) {
            if (typeof variant === "number") {
                result[String.fromCharCode(variant)] = norm;
            }
            else if (typeof variant === "string") {
                if (variant.length === 1 || (variant.length === 2 && variant.charCodeAt(0) >= 0xd800)) {
                    result[variant] = norm;
                }
                else if (variant[0] === "&") {
                    result[htmlEntityToChar(variant)] = norm;
                }
            }
        }
    }
    return result;
})([
    ['"', "“", "”", "'", "‘", "’"], // 비즈플랫폼 편집기에서 작은따옴표를 큰따옴표로 바꾸어버림. WHY?
    ["-", "‐", "‑", "‒", "–", "﹘", "—", "－"],
    [".", "․", "．"],
    [",", "，"],
    ["•", "●"], // 이걸 중간점 용도로 쓰는 사람들은 정말 갈아마셔야된다. 도저히 용납해줄 수 없고 같은 문자로 인식하게 만들고 싶지 않다.
    ["◦", "○", "ㅇ"], // 자음 "이응"을 쓰는 사람들도 개인적으로 이해가 안되지만 많더라.
    ["■", "▪", "◼"],
    ["□", "▫", "◻", "ㅁ"],
    ["·", "⋅", "∙", "ㆍ", "‧"], // 유니코드를 만든 집단은 도대체 무슨 생각이었던걸까?...
    ["…", "⋯"],
    ["(", "（"],
    [")", "）"],
    ["[", "［"],
    ["]", "］"],
    ["{", "｛"],
    ["}", "｝"],
    ["<", "＜"],
    [">", "＞"],
    ["=", "＝"],
    ["+", "＋"],
    ["*", "＊", "✱", "×", "∗"],
    ["/", "／", "÷"],
    ["\\", "₩"], // 아마도 원화 기호로 사용했겠지
    ["&", "＆"],
    ["#", "＃"],
    ["@", "＠"],
    ["$", "＄"],
    ["%", "％"],
    ["^", "＾"],
    ["~", "～"],
    ["`", "｀"],
    ["|", "｜"],
    [":", "："],
    [";", "；"],
    ["?", "？"],
    ["!", "！"],
    ["_", "＿"],
    ["→", "⇒", "➡", "➔", "➞", "➟"],
    ["←", "⇐", "⬅", "⟵", "⟸"],
    ["↑", "⇑", "⬆"],
    ["↓", "⇓", "⬇"],
    ["↔", "⇔"],
    ["↕", "⇕"],
    [" ", "\u00A0"],
]);
// wildcards.
// 이걸 어떻게 구현해야할지 감이 안오지만 지금으로써는 얘네들을 atomic하게 취급(사이에 공백이 있어도 하나의 토큰으로 만듬. '(현행과 같음)'에서 일부분만 매치되는 것을 방지)
// 글자단위로 토큰화하는 경우에도 얘네들은 (...) 통채로 하나의 토큰으로 취급.
// 와일드카드diff인 경우 다른 diff와 병합되지 않으면 좋지만 와일드카드가 얼마나 greedy하게 반대쪽 텍스트를 잡아먹어야 할지
// 양쪽에 wildcard가 동시에 나오는 경우 경계를 어디서 어떻게 짤라야할지 쉽지 않음.
// 또한 wildcard를 강제로 다른 diff와 분리하는 경우 diff가 같은 위치에 두 개 이상 생기게 되는 수가 있다. (wildcard와 wildcard가 아닌 것)
// 이 경우 정확히 같은 위치에 두개의 diff를 렌더링해야하고 결국 두개가 겹쳐보이게 되는데 분간이 잘 안된다.
const wildcardTrie = createTrie(true);
wildcardTrie.insert("(추가)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(삭제)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(신설)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(생략)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(현행과같음)", 16384 /* TokenFlags.WILD_CARD */);
const wildcardTrieNode = wildcardTrie.root.next("(");
const sectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    sectionHeadingTrie.insert(`${i}.`, 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */);
    sectionHeadingTrie.insert(`(${i})`, 2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */);
    sectionHeadingTrie.insert(`${i})`, 8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */);
}
for (let i = 0; i < HANGUL_ORDER.length; i++) {
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]}.`, 1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */);
    sectionHeadingTrie.insert(`(${HANGUL_ORDER[i]})`, 4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */);
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]})`, 8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */);
}
const SectionHeadingTrieNode = sectionHeadingTrie.root;
const sectionHeadingStartChars = extractStartCharsFromTrie(SectionHeadingTrieNode);
const manualAnchorTrie = createTrie(false);
manualAnchorTrie.insert(MANUAL_ANCHOR1, 32768 /* TokenFlags.MANUAL_ANCHOR */);
manualAnchorTrie.insert(MANUAL_ANCHOR2, 32768 /* TokenFlags.MANUAL_ANCHOR */);
const manualAnchorTrieNode = manualAnchorTrie.root;
const manualAnchorStartChars = extractStartCharsFromTrie(manualAnchorTrieNode);
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizedCharMap[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!spaceChars[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            node = node.addChild(word[i]);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
function createTrieNode(ignoreSpaces) {
    const children = {};
    const node = {
        children,
        word: null,
        flags: 0,
        next(char) {
            if (ignoreSpaces && char === " ")
                return node;
            return children[char] || null;
        },
        addChild(char) {
            return children[char] ?? (children[char] = createTrieNode(ignoreSpaces));
        },
    };
    return node;
}
function findInTrie(trie, input, start) {
    let node = trie;
    let i = start;
    while (i < input.length) {
        const ch = input[i++];
        node = node.next(ch);
        if (!node)
            break;
        if (node.word) {
            return { word: node.word, flags: node.flags, end: i };
        }
    }
    return null;
}
function extractStartCharsFromTrie(trie) {
    const table = {};
    for (const ch in trie.children) {
        table[ch] = 1;
    }
    return table;
}
// const TOKEN_BOUNDARY_ELEMENTS: Record<string, boolean> = {
// 	...BLOCK_ELEMENTS,
// 	BR: true,
// 	HR: true,
// 	IMG: true,
// };
// function* tokenizeWithContainers(root: Node): Generator<TokenizationEvent, void, unknown> {
// 	const containerStack: ContainerInfo[] = [];
// 	function* traverse(node: Node, depth: number, indexInParent: number): Generator<TokenizationEvent> {
// 		// 컨테이너 여부 판단
// 		const nodeName = node.nodeName;
// 		const isTokenBoundary = nodeName === "BR" || BLOCK_ELEMENTS[nodeName];
// 		// 논리적으로 의미가 있는, 토큰화에 쓸모 있는 정보를 제공할 수 있는 container 노드만 취급
// 		const isContainer =
// 			BLOCK_ELEMENTS[nodeName] || // 블럭요소는 블럭의 시작과 끝을 판단하는데 필요
// 			nodeName === "TABLE" || // 마찬가지 테이블 행의 시작과 끝
// 			nodeName === "TR" || // 테이블 행의 시작과 끝
// 			nodeName === "TD" || // 테이블 셀의 시작과 끝
// 			nodeName === "TH" || // 테이블 셀의 시작과 끝
// 			nodeName === "SUP" || // SUP
// 			nodeName === "SUB"; // SUB
// 		if (isContainer) {
// 			const containerInfo: ContainerInfo = {
// 				node,
// 				depth,
// 			};
// 			containerStack.push(containerInfo);
// 			yield { type: "containerStart", container: containerInfo };
// 		}
// 		if (node.nodeType === 3) {
// 			// 텍스트 노드일 때
// 			if (containerStack.length > 0) {
// 				const parentContainer = containerStack[containerStack.length - 1];
// 				yield {
// 					type: "textNode",
// 					node: node as Text,
// 					parent: parentContainer,
// 					indexInParent,
// 					text: node.nodeValue!,
// 				};
// 				if (containerStack.length > 0) {
// 					containerStack[containerStack.length - 1].tokenCount++;
// 				}
// 			}
// 		} else if (node.nodeType === 1) {
// 			if (nodeName === "IMG") {
// 				yield { type: "img", node, src: (node as HTMLImageElement).src, indexInParent };
// 			}
// 			if (nodeName === "BR") {
// 				yield { type: "break" };
// 			}
// 			if (nodeName === "A") {
// 				return;
// 			}
// 			// 엘리먼트 노드
// 			let childIndex = 0;
// 			for (const child of node.childNodes) {
// 				yield* traverse(child, depth + 1, childIndex++);
// 			}
// 		}
// 		if (isContainer) {
// 			const containerInfo = containerStack.pop()!;
// 			yield { type: "containerEnd", container: containerInfo };
// 		}
// 	}
// 	yield* traverse(root, 0, 0);
// }
// function* tokenize2(ctx: TokinizeContext) {
// 	const tokens: RichToken[] = (ctx.tokens ??= []);
// 	let tokenIndex = 0;
// 	let buffer: TextTokenizationEvent[] = [];
// 	const iterator = tokenizeWithContainers(ctx.content);
// 	let nextResult = iterator.next();
// 	let currentToken: RichToken | null = null;
// 	let currentFlags = LINE_START;
// 	let shouldNormalize = false;
// 	let containerStack: ContainerInfo[] = [];
// 	let currentContainer: ContainerInfo = {
// 		node: ctx.content,
// 		depth: 0,
// 		indexInParent: 0,
// 		tokenStartIndex: 0,
// 		tokenCount: 0,
// 		commonFlags: 0,
// 	};
// 	function processToken(textNode: Text, startOffset: number, endOffset: number, flags: number = 0) {
// 		let str = textNode.nodeValue!.slice(startOffset, endOffset);
// 		if (shouldNormalize) {
// 			str = normalize(str);
// 			shouldNormalize = false;
// 		}
// 		if (currentToken) {
// 			currentToken.text += str;
// 			currentToken.endContainer = textNode;
// 			currentToken.endOffset = endOffset;
// 		} else {
// 			currentToken = {
// 				text: str,
// 				flags: currentFlags | flags,
// 				startContainer: textNode,
// 				startOffset: startOffset,
// 				endContainer: textNode,
// 				endOffset: endOffset,
// 			};
// 		}
// 	}
// 	function finalizeToken(flags: number = 0) {
// 		if (currentToken) {
// 			currentToken.flags |= flags;
// 			tokens[tokenIndex] = currentToken;
// 			tokenIndex++;
// 			currentToken = null;
// 			currentFlags = 0;
// 		}
// 	}
// 	function findInTrie2(trie: TrieNode, buffer: TextTokenizationEvent[], bufferIndex: number, bufferCount: number, charIndex: number) {
// 		let node: TrieNode | null = trie;
// 		let i = bufferIndex;
// 		let j = charIndex;
// 		do {
// 			const text = buffer[i].text;
// 			for (; j < text.length; j++) {
// 				node = node!.next(text[j]);
// 				if (!node) {
// 					return null;
// 				}
// 				if (node.word) {
// 					return { bufferIndex: i, charIndex: j + 1, word: node.word, flags: node.flags };
// 				}
// 			}
// 			i++;
// 			j = 0;
// 		} while (i < bufferCount);
// 		return null;
// 	}
// 	while (!nextResult.done) {
// 		let event = nextResult.value;
// 		if (event.type === "textNode") {
// 			console.assert(currentToken === null, "currentToken should be null at this point");
// 			let bufferCount = 0;
// 			do {
// 				buffer[bufferCount++] = event;
// 			} while (!(nextResult = iterator.next()).done && (event = nextResult.value).type === "textNode");
// 			let i = 0;
// 			OUTER: for (let bufferIndex = 0; bufferIndex < bufferCount; bufferIndex++) {
// 				const text = buffer[bufferIndex].text;
// 				const textLen = text.length;
// 				let currentStart = -1;
// 				for (; i < textLen; i++) {
// 					let char = text[i];
// 					char = normalizedCharMap[char] || char; // normalize the character
// 					if (spaceChars[char]) {
// 						if (currentStart !== -1) {
// 							processToken(buffer[bufferIndex].node, currentStart, i);
// 							currentStart = -1;
// 						}
// 						finalizeToken();
// 					} else {
// 						// 모든 문자에 대해서 trie를 탐색하는건 너무 비효율적이라서...
// 						if (char === "(") {
// 							// 정말 지저분하지만... 별 수 없다.
// 							const found = findInTrie2(wildcardTrieNode, buffer, bufferIndex, bufferCount, i + 1);
// 							if (found) {
// 								const startContainer = buffer[bufferIndex].node;
// 								const startOffset = i;
// 								if (currentStart !== -1) {
// 									processToken(buffer[bufferIndex].node, currentStart, i);
// 									currentStart = -1;
// 								}
// 								finalizeToken();
// 								tokens[tokenIndex++] = {
// 									text: found.word,
// 									flags: currentFlags | found.flags,
// 									startContainer,
// 									startOffset,
// 									endContainer: buffer[found.bufferIndex].node,
// 									endOffset: found.charIndex,
// 								};
// 								currentFlags = 0;
// 								bufferIndex = found.bufferIndex - 1;
// 								i = found.charIndex; // continue OUTER로 넘어갈 때 i++는 실행이 안된다!
// 								continue OUTER;
// 							}
// 						}
// 						if (currentFlags & LINE_START && sectionHeadingStartChars[char]) {
// 							const found = findInTrie2(SectionHeadingTrieNode, buffer, bufferIndex, bufferCount, i);
// 							if (found) {
// 								const startContainer = buffer[bufferIndex].node;
// 								const startOffset = i;
// 								if (currentStart !== -1) {
// 									processToken(buffer[bufferIndex].node, currentStart, i);
// 									currentStart = -1;
// 								}
// 								finalizeToken();
// 								tokens[tokenIndex++] = {
// 									text: found.word,
// 									flags: currentFlags | found.flags,
// 									startContainer,
// 									startOffset,
// 									endContainer: buffer[found.bufferIndex].node,
// 									endOffset: found.charIndex,
// 								};
// 								currentFlags = 0;
// 								bufferIndex = found.bufferIndex - 1;
// 								i = found.charIndex; // continue OUTER로 넘어갈 때 i++는 실행이 안된다!
// 								continue OUTER;
// 							}
// 						}
// 						if (normalizedCharMap[char]) {
// 							shouldNormalize = true;
// 						}
// 						if (currentStart === -1) {
// 							currentStart = i;
// 						}
// 					}
// 				}
// 				if (currentStart !== -1) {
// 					processToken(buffer[bufferIndex].node, currentStart, textLen);
// 				}
// 				i = 0;
// 			}
// 			if (currentToken) {
// 				finalizeToken();
// 			}
// 			if (nextResult.done) {
// 				break;
// 			}
// 		}
// 		console.assert(currentToken === null, "currentToken should be null at this point");
// 		if (event.type === "containerStart") {
// 			containerStack.push(currentContainer);
// 			currentContainer = event.container;
// 			currentContainer.tokenStartIndex = tokenIndex;
// 		} else if (event.type === "containerEnd") {
// 			currentContainer.tokenCount = tokenIndex - currentContainer.tokenStartIndex;
// 			(currentContainer.node as HTMLElement).dataset.tokenStart = String(currentContainer.tokenStartIndex);
// 			(currentContainer.node as HTMLElement).dataset.tokenEnd = String(tokenIndex);
// 			const nodeName = currentContainer.node.nodeName;
// 			const firstToken = tokens[currentContainer.tokenStartIndex];
// 			const lastToken = tokens[tokenIndex - 1];
// 			if (currentContainer.commonFlags !== 0) {
// 				for (let i = currentContainer.tokenStartIndex; i < tokenIndex; i++) {
// 					tokens[i].flags |= currentContainer.commonFlags;
// 				}
// 			}
// 			if (TEXT_FLOW_CONTAINERS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | CONTAINER_START | BLOCK_START | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= CONTAINER_END | BLOCK_END | LINE_END;
// 				}
// 			} else if (LINEBREAK_ELEMENTS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= LINE_END;
// 				}
// 			}
// 			if (LINE_ELEMENTS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= LINE_END;
// 				}
// 			}
// 			if (nodeName === "TD" || nodeName === "TH") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLECELL_START | NO_JOIN_PREV;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLECELL_END | NO_JOIN_NEXT;
// 				}
// 			} else if (nodeName === "TR") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLEROW_START | NO_JOIN_PREV;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLEROW_END | NO_JOIN_NEXT;
// 				}
// 			} else if (nodeName === "TABLE") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLE_END;
// 				}
// 			}
// 			currentContainer = containerStack.pop()!;
// 			currentFlags &= ~CONTAINER_START;
// 		} else if (event.type === "break") {
// 			if (tokenIndex > 0) {
// 				tokens[tokenIndex - 1].flags |= LINE_END;
// 			}
// 			currentFlags |= LINE_START;
// 		} else if (event.type === "img") {
// 			tokens[tokenIndex++] = {
// 				text: event.src || "🖼️",
// 				flags: IMAGE | NO_JOIN_PREV | NO_JOIN_NEXT | currentFlags,
// 				startContainer: event.node.parentNode!,
// 				startOffset: currentContainer.indexInParent,
// 				endContainer: event.node.parentNode!,
// 				endOffset: currentContainer.indexInParent + 1,
// 			};
// 		}
// 		nextResult = iterator.next();
// 	}
// 	if (currentToken) {
// 		finalizeToken();
// 	}
// 	tokens.length = tokenIndex;
// 	return tokens;
// }
//
// 왕왕 큰 함수. 그래도 괜히 여러 함수로 쪼개서 성능 손해 보고 싶지 않은 마음...
function* tokenizer(ctx, idleDeadline) {
    const tokens = [];
    const containers = new Map();
    const root = ctx.content;
    const textNodes = [];
    const textNodeIndices = [];
    let tokenIndex = 0;
    let currentToken = null;
    let nextTokenFlags = 0;
    let recursionCount = 0;
    let lineNum = 1;
    const containerStack = [];
    let currentContainer = null;
    function processToken(textNode, startOffset, endOffset, flags = 0) {
        if (currentToken) {
            currentToken.text += textNode.nodeValue.slice(startOffset, endOffset);
            currentToken.range.endContainer = textNode;
            currentToken.range.endOffset = endOffset;
        }
        else {
            currentToken = {
                text: textNode.nodeValue.slice(startOffset, endOffset),
                flags: nextTokenFlags | flags,
                range: {
                    startContainer: textNode,
                    startOffset: startOffset,
                    endContainer: textNode,
                    endOffset: endOffset,
                },
                container: currentContainer,
                lineNum: lineNum,
            };
            nextTokenFlags = 0;
        }
    }
    function finalizeToken(flags = 0) {
        if (currentToken) {
            currentToken.flags |= flags;
            tokens[tokenIndex++] = currentToken;
            currentToken = null;
        }
    }
    function findInTrie2(trie, bufferIndex, charIndex) {
        let node = trie;
        let i = bufferIndex;
        let j = charIndex;
        do {
            const text = textNodes[i].nodeValue;
            for (; j < text.length; j++) {
                let ch = text[j];
                ch = normalizedCharMap[ch] || ch;
                node = node.next(ch);
                if (!node) {
                    return null;
                }
                if (node.word) {
                    return { bufferIndex: i, charIndex: j + 1, word: node.word, flags: node.flags };
                }
            }
            i++;
            j = 0;
        } while (i < textNodes.length);
        return null;
    }
    function doTokenize() {
        console.assert(textNodes.length > 0, "textNodes should not be empty at this point");
        let nodeIndex = 0;
        let charIndex = 0;
        // for loop를 쓰면 머리 아파진다.
        // trie 매칭이 성공 했을때 임의로 nodeIndex와 charIndex를 advance 시켜야하기 때문에
        // continue 할때 인덱스 값을 하나 빼줘야하는지 말아야하는지 생각을 안해도 된다면 그것만으로 while의 가치는 충분함!
        do {
            const textNode = textNodes[nodeIndex];
            const text = textNode.nodeValue;
            const textLen = text.length;
            let shouldNormalize = false;
            let currentStart = -1;
            while (charIndex < textLen) {
                // 4byte 문자를 생각해야한다. later....
                const cp = text.codePointAt(charIndex);
                // todo 문자가 아니라 코드포인트로 spaceChar나 normalizeChar 등등 확인하기
                let char = text[charIndex];
                if (spaceChars[char]) {
                    // split here
                    if (currentStart !== -1) {
                        processToken(textNode, currentStart, charIndex);
                        currentStart = -1;
                    }
                    finalizeToken();
                }
                else {
                    if (char === "(") {
                        const match = findInTrie2(wildcardTrieNode, nodeIndex, charIndex + 1);
                        if (match) {
                            const startContainer = textNode;
                            const startOffset = charIndex;
                            if (currentStart !== -1) {
                                processToken(textNode, currentStart, charIndex);
                                currentStart = -1;
                            }
                            finalizeToken();
                            tokens[tokenIndex++] = {
                                text: match.word,
                                flags: nextTokenFlags | match.flags,
                                range: {
                                    startContainer,
                                    startOffset,
                                    endContainer: textNodes[match.bufferIndex],
                                    endOffset: match.charIndex,
                                },
                                container: currentContainer,
                                lineNum: lineNum,
                            };
                            nextTokenFlags = 0;
                            nodeIndex = match.bufferIndex;
                            charIndex = match.charIndex;
                            continue;
                        }
                    }
                    if (sectionHeadingStartChars[char] && nextTokenFlags & 1 /* TokenFlags.LINE_START */) {
                    }
                    if (currentStart === -1) {
                        currentStart = charIndex;
                    }
                }
                // ...
                // ...
                charIndex++;
                if (cp > 0xffff) {
                    charIndex++;
                }
            }
            if (currentStart !== -1) {
                processToken(textNode, currentStart, textLen);
                currentStart = -1;
            }
            nodeIndex++;
            charIndex = 0;
        } while (nodeIndex < textNodes.length);
        finalizeToken();
        textNodes.length = 0;
        textNodeIndices.length = 0;
    }
    function* traverse(node) {
        const nodeName = node.nodeName;
        const isTextFlowContainer = TEXT_FLOW_CONTAINERS[nodeName] || node === ctx.content;
        const isBlockElement = BLOCK_ELEMENTS[nodeName];
        let containerCreated = false;
        if (isBlockElement || isTextFlowContainer) {
            nextTokenFlags |= 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
            if (isTextFlowContainer) {
                nextTokenFlags |= 16 /* TokenFlags.CONTAINER_START */;
            }
            containerStack.push(currentContainer);
            currentContainer = {
                element: node,
                depth: (currentContainer?.depth ?? -1) + 1,
                startTokenIndex: tokenIndex,
                tokenCount: 0,
                parent: currentContainer || null,
            };
            containerCreated = true;
        }
        const isTokenBoundary = isTextFlowContainer || isBlockElement || nodeName === "TD";
        if (isTokenBoundary && textNodes.length > 0) {
            doTokenize();
        }
        const childNodes = node.childNodes;
        const tokenStartIndex = tokenIndex;
        for (let i = 0; i < childNodes.length; i++) {
            if ((++recursionCount & 31) === 0 && idleDeadline.timeRemaining() < 1) {
                idleDeadline = yield;
            }
            const child = childNodes[i];
            if (child.nodeType === 3) {
                textNodes.push(child);
                textNodeIndices.push(i);
            }
            else if (child.nodeType === 1) {
                const childNodeName = child.nodeName;
                // 재귀 호출을 안해도 되는 단순한 case
                if (childNodeName === "A" || VOID_ELEMENTS[childNodeName]) {
                    if (childNodeName === "BR" || childNodeName === "HR") {
                        if (textNodes.length > 0) {
                            doTokenize();
                        }
                        nextTokenFlags |= 1 /* TokenFlags.LINE_START */;
                        lineNum++;
                    }
                    else if (childNodeName === "IMG") {
                        if (textNodes.length > 0) {
                            doTokenize();
                        }
                        const range = document.createRange();
                        range.selectNode(child);
                        tokens[tokenIndex++] = {
                            text: quickHash53ToString(child.src),
                            flags: 65536 /* TokenFlags.IMAGE */ | 4096 /* TokenFlags.NO_JOIN_PREV */ | 8192 /* TokenFlags.NO_JOIN_NEXT */ | nextTokenFlags,
                            range,
                            container: currentContainer,
                            lineNum: lineNum,
                        };
                        nextTokenFlags = 0;
                    }
                    continue;
                }
                yield* traverse(child);
            }
        }
        if (isTokenBoundary && textNodes.length > 0) {
            doTokenize();
        }
        const tokenCount = tokenIndex - tokenStartIndex;
        if (tokenCount > 0) {
            const firstToken = tokens[tokenStartIndex];
            const lastToken = tokens[tokenIndex - 1];
            if (nodeName === "SUP" || nodeName === "SUB") {
                // SUP + SUP는 조인이 가능해야 하므로 NO_JOIN_PREV, NO_JOIN_NEXT 플래그를 주지 않음
                // 예: <sup>주</sup><sup>1)</sup> 이런 거지같은 상황이 나올 수도 있다.
                const commonFlags = nodeName === "SUP" ? 131072 /* TokenFlags.HTML_SUP */ : 262144 /* TokenFlags.HTML_SUB */;
                for (let i = tokenStartIndex; i < tokenIndex; i++) {
                    tokens[i].flags |= commonFlags;
                }
            }
            else if (nodeName === "TD" || nodeName === "TH") {
                if (firstToken) {
                    firstToken.flags |=
                        1024 /* TokenFlags.TABLECELL_START */ | 4096 /* TokenFlags.NO_JOIN_PREV */ | 16 /* TokenFlags.CONTAINER_START */ | 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
                }
                if (lastToken) {
                    lastToken.flags |=
                        2048 /* TokenFlags.TABLECELL_END */ | 8192 /* TokenFlags.NO_JOIN_NEXT */ | 32 /* TokenFlags.CONTAINER_END */ | 8 /* TokenFlags.BLOCK_END */ | 2 /* TokenFlags.LINE_END */;
                }
                if (tokenCount > 0) {
                    lineNum++;
                }
            }
            else if (nodeName === "TR") {
                if (firstToken) {
                    firstToken.flags |= 256 /* TokenFlags.TABLEROW_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 512 /* TokenFlags.TABLEROW_END */;
                }
            }
            else if (nodeName === "TABLE") {
                if (firstToken) {
                    firstToken.flags |= 64 /* TokenFlags.TABLE_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 128 /* TokenFlags.TABLE_END */;
                }
            }
            if (BLOCK_ELEMENTS[nodeName]) {
                if (firstToken) {
                    firstToken.flags |= nextTokenFlags | 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 8 /* TokenFlags.BLOCK_END */ | 2 /* TokenFlags.LINE_END */;
                }
                nextTokenFlags |= 1 /* TokenFlags.LINE_START */;
                if (tokenCount > 0) {
                    lineNum++;
                }
            }
            if (node === ctx.content) {
                firstToken.flags |= nextTokenFlags | 4 /* TokenFlags.BLOCK_START */ | 16 /* TokenFlags.CONTAINER_START */ | 1 /* TokenFlags.LINE_START */;
                lastToken.flags |= 8 /* TokenFlags.BLOCK_END */ | 32 /* TokenFlags.CONTAINER_END */ | 2 /* TokenFlags.LINE_END */;
            }
        }
        if (containerCreated) {
            if (tokenCount > 0) {
                currentContainer.startTokenIndex = tokenStartIndex;
                currentContainer.tokenCount = tokenCount;
                containers.set(node, currentContainer);
            }
            currentContainer = containerStack.pop();
        }
    }
    yield* traverse(root);
    tokens.length = tokenIndex;
    return { tokens, containers };
}
function quickHash53ToString(str) {
    let hash = 0n;
    const PRIME = 131n;
    for (let i = 0; i < str.length; i++) {
        hash = hash * PRIME + BigInt(str.charCodeAt(i));
        hash &= 0x1fffffffffffffn; // 53비트 마스크
    }
    return hash.toString(36); // 36진수 문자열 변환
}
//# sourceMappingURL=tokenize.js.map
</script>
<script>"use strict";
const INITIAL_EDITOR_HTML = document.createElement("P");
INITIAL_EDITOR_HTML.appendChild(document.createElement("BR"));
// 만약 renderer를 Editor 인스턴스가 갖지 않고 외부로 빼낸다면...
// 그리고 Editor는 diff에 대해서 전혀 알지 못하게 한다면...?
// diff anchor도 외부에서 만들어야함
// hit test도 외부에서
// scroll to diff X
// scrollTo, scrollBy 만 제공
// 외부에서는 diffComputed 때 diff 범위 계산(getTokenRange 이용...)
// renderer에 range와 셋팅된 DiffRenderItem[]을 넘겨줌
class Editor {
    #editorName;
    #container;
    #wrapper = document.createElement("div");
    #editor = document.createElement("div");
    #mutationObserver;
    #anchors = [];
    #tokens = [];
    #tokenizeContext = null;
    #tokenizeCallbackId = null;
    #callbacks;
    #renderer;
    #hoveredDiffIndex = null;
    #aligning = false;
    constructor(container, editorName, callbacks) {
        this.#editorName = editorName;
        this.#container = container;
        this.#callbacks = callbacks;
        this.#editor.id = editorName + "Editor";
        this.#editor.classList.add("editor");
        this.#editor.contentEditable = "true";
        this.#editor.spellcheck = false;
        this.#editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
        this.#wrapper.id = editorName + "EditorWrapper";
        this.#wrapper.classList.add("editor-wrapper");
        this.#wrapper.appendChild(this.#editor);
        this.#container.appendChild(this.#wrapper);
        this.#renderer = new Renderer(this, this.#wrapper, { diffVisibilityChanged: (e) => this.onDiffVisibilityChanged(e) });
        this.#mutationObserver = new MutationObserver((mutations) => this.#onMutation(mutations));
        this.#observeMutation();
        this.#wrapper.addEventListener("scroll", (e) => {
            this.onScroll(e);
        });
        this.#wrapper.addEventListener("scrollend", () => {
            callbacks.onScrollEnd(this);
        });
        this.#editor.addEventListener("paste", (e) => this.#onPaste(e));
        this.#editor.addEventListener("input", () => this.onInput());
        this.#editor.addEventListener("keydown", (e) => this.onKeyDown(e));
        this.#editor.addEventListener("focus", () => {
            callbacks.onFocus(this);
        });
        this.#editor.addEventListener("blur", () => {
            callbacks.onBlur(this);
        });
        //setTimeout(() => this.tokenize(), 0);
        this.#wrapper.addEventListener("mousemove", (e) => this.onMouseMove(e));
        this.#wrapper.addEventListener("mouseleave", () => {
            if (this.#hoveredDiffIndex !== null) {
                this.#hoveredDiffIndex = null;
                this.#callbacks.onHoverDiff(this, null);
                this.#callbacks.onRenderInvalidated(this, 12 /* RenderFlags.HIGHLIGHT */);
            }
        });
        const resizeObserver = new ResizeObserver(() => this.#onResize());
        resizeObserver.observe(this.#editor);
    }
    get name() {
        return this.#editorName;
    }
    get wrapper() {
        return this.#wrapper;
    }
    get editor() {
        return this.#editor;
    }
    get tokens() {
        return this.#tokens;
    }
    get scrollTop() {
        return this.#wrapper.scrollTop;
    }
    set scrollTop(value) {
        this.#wrapper.scrollTop = value;
    }
    get scrollLeft() {
        return this.#wrapper.scrollLeft;
    }
    set scrollLeft(value) {
        this.#wrapper.scrollLeft = value;
    }
    scrollToOffset(offset) {
        this.#wrapper.scrollTop = offset;
    }
    scrollByOffset(offset) {
        this.#wrapper.scrollTop += offset;
    }
    onMouseMove(e) {
        const rect = this.#wrapper.getBoundingClientRect();
        let x = e.clientX - rect.x + this.#wrapper.scrollLeft;
        let y = e.clientY - rect.y + this.#wrapper.scrollTop;
        const diffIndex = this.#renderer.getDiffAtPoint(x, y);
        if (diffIndex !== this.#hoveredDiffIndex) {
            this.#hoveredDiffIndex = diffIndex;
            this.#callbacks.onHoverDiff(this, diffIndex);
        }
    }
    onDiffVisibilityChanged(entries) {
        this.#callbacks.onDiffVisibilityChanged(this, entries);
    }
    onKeyDown(e) {
        if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            // vscode나 기타 등등 코드에디터나 IDE에서 흔하게 사용하는 단축키.
            // 마우스에 손대지 않고 살짝 2-3줄 정도만 스크롤하고 싶은데 커서가 너무 멀리 있는 경우...
            e.preventDefault();
            const fontSize = parseFloat(getComputedStyle(this.#editor).fontSize);
            const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2 * fontSize;
            this.#wrapper.scrollBy({
                top: delta,
                behavior: "instant",
            });
        }
    }
    onScroll(e) {
        this.#renderer.markDirty(13 /* RenderFlags.SCROLL */);
        this.#callbacks.onScroll(this, this.#wrapper.scrollTop, this.#wrapper.scrollLeft);
    }
    onInput() {
        this.#renderer.markDirty(15 /* RenderFlags.ALL */);
        this.#callbacks.onContentChanging(this);
        this.tokenize();
    }
    #onMutation(mutations) {
        if (this.#editor.childNodes.length === 0) {
            this.#editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
        }
    }
    #observeMutation() {
        this.#mutationObserver.observe(this.#wrapper, {
            childList: true,
            subtree: true,
            //attributes: true,
            //characterData: true,
        });
    }
    #unobserveMutation() {
        this.#mutationObserver.disconnect();
    }
    #onPaste(e) {
        // 비교적 무거운 작업이지만 뒤로 미루면 안되는 작업이기 때문에 UI blocking을 피할 뾰족한 수가 없다.
        // 사용자가 붙여넣기 이후 바로 추가 입력을 하는 경우 => 붙여넣기를 뒤로 미루면 입력이 먼저 될테니까.
        console.time("paste");
        e.preventDefault();
        this.#unobserveMutation();
        console.time("paste getData");
        let rawHTML = e.clipboardData?.getData("text/html") ?? "";
        console.timeEnd("paste getData");
        console.time("paste sanitizeHTML");
        let sanitized;
        if (rawHTML) {
            sanitized = sanitizeHTML(rawHTML);
        }
        else {
            sanitized = formatPlaintext(e.clipboardData?.getData("text/plain") ?? "");
        }
        const div = document.createElement("DIV");
        div.appendChild(sanitized);
        const sanitizedHTML = div.innerHTML;
        console.timeEnd("paste sanitizeHTML");
        // document.execCommand("insertHTML",...)는 미친게 아닌가 싶을 정도로 오래 걸린다. 농담 아님.
        // BUT 직접 노드를 삽입하면 undo/redo 히스토리가 깨지기 때문에 자존심 상해도 어쩔 수 없이 써야함.
        console.time("paste execCommand");
        document.execCommand("insertHTML", false, sanitizedHTML);
        console.timeEnd("paste execCommand");
        console.timeEnd("paste");
        this.#observeMutation();
    }
    findTokenOverlapIndices(range) {
        let low = 0;
        let high = this.#tokens.length - 1;
        let startIndex = -1;
        let endIndex = -1;
        // collapsed, 즉 범위 없이 텍스트커서만 있는 경우 커서가 토큰의 맨앞이나 맨뒤에 있어도 해당 토큰이 선택된 것으로 간주함.
        // 범위가 있는 경우는 범위 밖 토큰들이 같이 선택되면 안됨!
        const collapsed = range.collapsed;
        // range의 끝부분이 텍스트노드의 끝부분에 있고 비교대상 토큰의 시작부분은 인접한 텍스트노드의 시작점(0)에 있는 경우
        // 그 토큰의 범위에 커서가 걸쳐있다고 봐야 맞는데(단어 앞에 커서가 있는 경우 그 단어가 선택되었다고 판단)
        // 텍스트노드 사이에 커서가 있으면 경계가 intersecting되지 않는다고 판단하기 때문에 의도적으로 범위를 확장시켜줘야함.
        // 단순히 <textnode><textnode>의 경우는 쉽지만
        // <textnode><span><em>text</em></span><textnode>의 경우 span,em 안을 파고 들어가야함.
        if (range.endContainer.nodeType === 3 && range.endOffset === range.endContainer.nodeValue.length) {
            let adjText = findAdjacentTextNode(range.endContainer, true);
            if (adjText) {
                range = range.cloneRange(); // 지금으로써는 clone까지는 필요는 없지만... 일단 뭐...
                range.setEnd(adjText, 0);
            }
        }
        // console.debug(editorName, "findTokenOverlapIndices", { range, text: range.toString() });
        const tokenRange = document.createRange();
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = this.#tokens[mid].range;
            tokenRange.setStart(token.startContainer, token.startOffset);
            tokenRange.setEnd(token.endContainer, token.endOffset);
            let c = range.compareBoundaryPoints(Range.END_TO_START, tokenRange);
            if (c < 0 || (collapsed && c === 0)) {
                // 토큰의 끝점이 range의 시작점보다 뒤에 있다. 이 토큰을 포함해서 왼쪽토큰들이 첫 토큰 후보.
                // 단, range의 끝점도 토큰의 시작점 이후에 있어야 intersecting이라고 볼 수 있음.
                // 단단, startIndex가 이미 -1이 아니라면 startIndex의 토큰보다 왼쪽의 토큰이므로 비교하지 않아도 됨(무조건 통과)
                if (startIndex !== -1 || (c = range.compareBoundaryPoints(Range.START_TO_END, tokenRange)) > 0 || (collapsed && c === 0)) {
                    startIndex = mid;
                    // } else {
                    // 	console.warn(this.#editorName, "NOT THIS TOKEN", mid, {
                    // 		range,
                    // 		tokenRange: tokenRange.cloneRange(),
                    // 		c: tokenRange.compareBoundaryPoints(Range.END_TO_START, range),
                    // 	});
                }
                high = mid - 1; // 왼쪽으로
            }
            else {
                low = mid + 1; // 오른쪽으로
            }
        }
        // console.debug("after 1st loop", "findTokenOverlapIndices",  startIndex);
        if (startIndex !== -1) {
            tokenRange.setStart(this.#tokens[startIndex].range.startContainer, this.#tokens[startIndex].range.startOffset);
            low = endIndex = startIndex;
            high = this.#tokens.length - 1;
            while (low <= high) {
                const mid = (low + high) >> 1;
                const token = this.#tokens[mid].range;
                tokenRange.setStart(token.startContainer, token.startOffset);
                tokenRange.setEnd(token.endContainer, token.endOffset);
                const c = range.compareBoundaryPoints(Range.START_TO_END, tokenRange);
                if (c > 0) {
                    endIndex = mid + 1;
                    low = mid + 1; // 오른쪽으로
                }
                else {
                    high = mid - 1; // 왼쪽으로
                }
            }
        }
        return [startIndex, endIndex];
    }
    getTokenRange(index, count = 1) {
        const range = document.createRange();
        if (count === 1 && index >= 0 && index < this.#tokens.length) {
            const token = this.#tokens[index];
            range.setStart(token.range.startContainer, token.range.startOffset);
            range.setEnd(token.range.endContainer, token.range.endOffset);
        }
        else if (count > 0) {
            const startToken = this.#tokens[index];
            const endToken = this.#tokens[index + count - 1];
            if (startToken) {
                range.setStart(startToken.range.startContainer, startToken.range.startOffset);
            }
            else {
                range.setStart(this.#editor, 0);
            }
            if (endToken) {
                range.setEnd(endToken.range.endContainer, endToken.range.endOffset);
            }
            else {
                range.setEnd(this.#editor, this.#editor.childNodes.length);
            }
        }
        else {
            const prevToken = this.#tokens[index - 1];
            if (prevToken) {
                range.setStart(prevToken.range.endContainer, prevToken.range.endOffset);
                range.setEnd(prevToken.range.endContainer, prevToken.range.endOffset);
                return range;
            }
            const nextToken = this.#tokens[index];
            if (nextToken) {
                range.setStart(nextToken.range.startContainer, 0);
                range.setEnd(nextToken.range.startContainer, 0);
            }
        }
        return range;
    }
    tokenize() {
        const _TIMEOUT = 200;
        if (this.#tokenizeCallbackId !== null) {
            // 아직 실행되지 않고 대기 중인 콜백 취소
            cancelIdleCallback(this.#tokenizeCallbackId);
            this.#tokenizeCallbackId = null;
        }
        if (this.#tokenizeContext) {
            // 이미 콜백이 실행 중이라면 다음 step에서 취소처리해야하므로...
            this.#tokenizeContext.cancelled = true;
        }
        const startTime = performance.now();
        const ctx = {
            cancelled: false,
            content: this.#editor,
        };
        this.#tokenizeContext = ctx;
        // 여기서 바로 generator를 생성을 해버리면 idleDeadline을 바로 넘겨줄 수가 없다.
        // generator 내부에서 idleDeadline을 획득하려면 "성급하게" yield를 한번 하고 외부에서 next(idleDeadline)으로 넘겨줘야하는데
        // 그러면 황금같은 유휴시간을 한번 낭비하게 됨. 그래서 generator 생성은 콜백 안에서...
        let generator = null;
        const step = (idleDeadline) => {
            this.#tokenizeCallbackId = null;
            if (ctx.cancelled) {
                // 어차피 단일쓰레드 환경이므로 콜백이 실행되는 도중에는 cancelled 값이 바뀔 가능성은 0이기 때문에
                // 취소확인은 next()를 호출하기 전에나 한번씩 해주면 됨.
                // generator 내부에서 yield를 해주지 않으면 함수 종료시까지 cancelled=true가 실행될 기화가 생기지 않음.
                console.debug(this.#editorName, "tokenize cancelled");
                return;
            }
            if (generator === null) {
                generator = tokenizer(ctx, idleDeadline);
            }
            const { done, value } = generator.next(idleDeadline);
            if (done && !ctx.cancelled) {
                const endTime = performance.now();
                this.#tokens = value.tokens;
                console.debug(this.#editorName, "tokenize done", Math.ceil(endTime - startTime) + "ms", value);
                if (!ctx.cancelled) {
                    this.#onTokenizeDone();
                }
            }
            else if (!ctx.cancelled) {
                this.#tokenizeCallbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
            }
        };
        this.#tokenizeCallbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
    }
    #onTokenizeDone() {
        this.#callbacks.onContentChanged(this);
    }
    #getOrInsertStartAnchor(tokenIndex, flags) {
        const token = this.#tokens[tokenIndex];
        if (!token) {
            return null;
        }
        let container = token.range.startContainer;
        let insertPoint;
        if (container.nodeType === 3) {
            insertPoint = container;
            container = container.parentElement;
        }
        else {
            container = token.range.startContainer.parentNode;
            insertPoint = token.range.startContainer;
        }
        let found = false;
        let lastAnchor = this.#anchors[this.#anchors.length - 1];
        do {
            if (!lastAnchor || lastAnchor.compareDocumentPosition(insertPoint) & Node.DOCUMENT_POSITION_FOLLOWING) {
                if (flags & 32 /* AnchorFlags.PREFER_TABLE_START */) {
                    if (insertPoint.nodeName === "TABLE") {
                        found = true;
                        break;
                        // return this.#getExistingOrCreateAnchor(container as HTMLElement, beforeNode as HTMLElement);
                    }
                }
                else if (flags & (8 /* AnchorFlags.PREFER_TABLECELL_START */ | 16 /* AnchorFlags.PREFER_TABLEROW_START */)) {
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        found = true;
                        break;
                        // return this.#getExistingOrCreateAnchor(container as HTMLElement, beforeNode as HTMLElement);
                    }
                }
                else if (flags & 2 /* AnchorFlags.PREFER_BLOCK_START */) {
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        found = true;
                        break;
                        // return this.#getExistingOrCreateAnchor(container as HTMLElement, beforeNode as HTMLElement);
                    }
                }
                else {
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        found = true;
                        break;
                    }
                }
            }
            // if (BLOCK_ELEMENTS[container.nodeName]) {
            // 	firstContainer = container;
            // 	firstBeforeNode = beforeNode;
            // }
            if (container === this.#editor) {
                break;
            }
            insertPoint = container;
            container = container.parentNode;
        } while (container);
        if (found) {
            while (insertPoint.previousSibling) {
                let prev = insertPoint.previousSibling;
                if (prev.nodeName === "BR" || BLOCK_ELEMENTS[prev.nodeName]) {
                    break;
                }
                if (prev.nodeType === 3 && prev.nodeValue.trim() === "") {
                    // 빈 텍스트노드는 무시
                    insertPoint = prev;
                    continue;
                }
                break;
            }
            if (insertPoint && insertPoint.nodeName === "A" && insertPoint.classList.contains("diff")) {
                insertPoint = insertPoint.nextSibling;
            }
            return this.#getExistingOrCreateAnchor(container, insertPoint);
        }
        console.warn(this.#editorName, "getOrInsertStartAnchor", "No suitable container found for anchor", {
            tokenIndex,
            token,
            flags,
            beforeNode: insertPoint,
            container,
        });
        // if (firstContainer && firstBeforeNode) {
        // 	return this.#getExistingOrCreateAnchor(firstContainer as HTMLElement, firstBeforeNode);
        // }
        return null;
    }
    #getExistingOrCreateAnchor(container, beforeNode) {
        if (beforeNode && beforeNode.nodeName === "A" && beforeNode.classList.contains("anchor")) {
            return beforeNode;
        }
        let anchor = document.createElement("A");
        anchor.classList.add("anchor");
        container.insertBefore(anchor, beforeNode);
        return anchor;
    }
    // #getDiffRange(diff: EditorDiff): [Range, HTMLElement | null] {
    // 	let range: Range | null = null;
    // 	let anchorEl: HTMLElement | null = null;
    // 	if (diff.tokenCount === 0) {
    // 		let bestInsertionPoint: InsertionPoint | null = null;
    // 		let bestScore = -1;
    // 		for (const point of this.#yieldDiffAnchorPointsInRange(diff.tokenIndex)) {
    // 			let score = 0;
    // 			if (diff.preferBlockStart && point.flags & InsertionPointFlags.BLOCK_START) {
    // 				score += 1;
    // 			}
    // 			// if (diff.preferBlockEnd && point.flags & InsertionPointFlags.BlockEnd) {
    // 			// 	score += 1;
    // 			// }
    // 			if (bestInsertionPoint === null || score > bestScore) {
    // 				bestInsertionPoint = point;
    // 				bestScore = score;
    // 			}
    // 			console.debug(this.#editorName, "yieldAnchorPointsInRange", diff, point, score);
    // 		}
    // 		if (bestInsertionPoint) {
    // 			console.debug(this.#editorName, "best", bestInsertionPoint);
    // 			[range, anchorEl] = this.#getDiffAnchor(bestInsertionPoint);
    // 		}
    // 	}
    // 	if (!range) {
    // 		range = this.getTokenRange(diff.tokenIndex, diff.tokenCount);
    // 	}
    // 	return [range, anchorEl];
    // }
    *#yieldDiffAnchorPointsInRange(tokenIndex) {
        const prevToken = this.#tokens[tokenIndex - 1];
        const nextToken = this.#tokens[tokenIndex];
        let lastAnchorRange = null;
        if (this.#anchors.length > 0) {
            lastAnchorRange = document.createRange();
            lastAnchorRange.selectNode(this.#anchors[this.#anchors.length - 1]);
        }
        let endContainer;
        let endOffset;
        // let endNode: Node;
        let lastYielded = null;
        // console.log(editorName, "generateInsertionPointsInRange", { tokenIndex, prevToken, nextToken });
        let container;
        let childIndex;
        const indexStack = [];
        if (prevToken && nextToken && prevToken.range.endContainer === nextToken.range.startContainer && prevToken.range.endContainer.nodeType === 3) {
            yield* createPoint(prevToken.range.endContainer, prevToken.range.endOffset);
            return;
        }
        if (prevToken) {
            container = prevToken.range.endContainer;
            childIndex = prevToken.range.endOffset;
            if (container.nodeType === 3) {
                // 텍스트노드는 컨테이너로 지정되지 않음!
                //yield* createPoint(container, childIndex);
                childIndex = Array.prototype.indexOf.call(container.parentNode.childNodes, container) + 1;
                container = container.parentNode;
            }
        }
        else {
            container = this.#editor;
            childIndex = 0;
        }
        if (nextToken) {
            endContainer = nextToken.range.startContainer;
            endOffset = nextToken.range.startOffset;
        }
        else {
            endContainer = this.#editor;
            endOffset = this.#editor.childNodes.length;
        }
        if (container === endContainer) {
            if (container.nodeType === 3) {
                yield* createPoint(container, childIndex);
                return;
            }
        }
        while (container) {
            if (!TEXTLESS_ELEMENTS[container.nodeName]) {
                yield* createPoint(container, childIndex);
            }
            if (container === endContainer && childIndex >= endOffset) {
                break;
            }
            let current = container.childNodes[childIndex];
            if (!current) {
                current = container;
                container = container.parentNode;
                if (indexStack.length > 0) {
                    childIndex = indexStack.pop();
                }
                else {
                    if (!container || !container.childNodes) {
                        console.warn(this.#editorName, "No childNodes in container", current, container, prevToken, nextToken);
                    }
                    childIndex = Array.prototype.indexOf.call(container.childNodes, current);
                }
                childIndex++;
                continue;
            }
            if (current.nodeName === "A") {
            }
            else {
                if (current.nodeType === 1 && !VOID_ELEMENTS[current.nodeName]) {
                    // 주어진 childIndex에 해당하는 자식으로 들어가기
                    if (current.firstChild) {
                        indexStack.push(childIndex);
                        container = current;
                        childIndex = 0;
                        continue;
                    }
                    else {
                        // 자식이 없더라도 요소 안에 하나의 point는 만들어야함.
                        // firstChild 조건 체크 없이 container=current, childIndex=0으로 설정해두고 continue 해버려도 되지만
                        // 일단 그냥 여기서 처리하고 루프 한바퀴 건너뛰자.
                        if (!TEXTLESS_ELEMENTS[current.nodeName]) {
                            yield* createPoint(current, 0);
                        }
                    }
                }
                else if (current.nodeType === 3) {
                    if (current === endContainer) {
                        yield* createPoint(current, endOffset);
                        break;
                    }
                }
            }
            childIndex++;
        }
        function* createPoint(container, offset, flags = 0) {
            if (lastYielded && lastYielded.container === container && lastYielded.offset === offset) {
                return;
            }
            if (lastAnchorRange && lastAnchorRange.comparePoint(container, offset) <= 0) {
                return;
            }
            let existingAnchor = null;
            if (container.nodeType === 3) {
                return;
            }
            else {
                existingAnchor = container.childNodes[offset] || null;
                if (existingAnchor && (existingAnchor.nodeName !== "A" || !existingAnchor.classList.contains("diff"))) {
                    existingAnchor = null;
                }
                const comparePrev = prevToken ? container.compareDocumentPosition(prevToken.range.endContainer) : 0;
                const compareNext = nextToken ? container.compareDocumentPosition(nextToken.range.startContainer) : 0;
                if (offset === 0 || !(comparePrev & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 16 /* InsertionPointFlags.CONTAINER_START */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 64 /* InsertionPointFlags.BLOCK_START */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 256 /* InsertionPointFlags.TABLECELL_START */;
                        const tr = container.parentNode;
                        if (tr.firstElementChild === container) {
                            flags |= 1024 /* InsertionPointFlags.TABLEROW_START */;
                            if (!tr.previousElementSibling || tr.previousElementSibling.nodeName !== "TR") {
                                flags |= 4096 /* InsertionPointFlags.TABLE_START */;
                            }
                            else if (tr.parentNode.firstElementChild === tr) {
                                flags |= 4096 /* InsertionPointFlags.TABLE_START */;
                            }
                        }
                    }
                }
                if (offset === container.childNodes.length || !(compareNext & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 32 /* InsertionPointFlags.CONTAINER_END */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 128 /* InsertionPointFlags.BLOCK_END */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 512 /* InsertionPointFlags.TABLECELL_END */;
                        const tr = container.parentNode;
                        if (tr.lastElementChild === container) {
                            flags |= 2048 /* InsertionPointFlags.TABLEROW_END */;
                            if (!tr.nextElementSibling || tr.nextElementSibling.nodeName !== "TR") {
                                flags |= 8192 /* InsertionPointFlags.TABLE_END */;
                            }
                            else if (tr.parentNode.lastElementChild === tr) {
                                flags |= 8192 /* InsertionPointFlags.TABLE_END */;
                            }
                        }
                    }
                }
            }
            lastYielded = { container: container, offset, flags, existingAnchor };
            yield lastYielded;
        }
    }
    #getDiffAnchor(point) {
        const before = point.container.childNodes[point.offset] || null;
        if (before && before.nodeName === "A" && before.classList.contains("diff")) {
            return before;
        }
        const anchorEl = document.createElement("A");
        anchorEl.classList.add("diff");
        point.container.insertBefore(anchorEl, before);
        return anchorEl;
    }
    withUpdate(updateFn) {
        const unusedAnchors = new Set(this.#anchors);
        this.#anchors.length = 0;
        const renderItems = [];
        const setDiff = (range, diff) => {
            const renderItem = {
                diffIndex: diff.diffIndex,
                range,
                hue: diff.hue,
                geometry: null,
            };
            renderItems[diff.diffIndex] = renderItem;
        };
        const getAnchor = (tokenIndex, flags) => {
            const el = this.#getOrInsertStartAnchor(tokenIndex, flags);
            if (el) {
                this.#anchors.push(el);
            }
            return el;
        };
        const getDiffAnchor = (point) => {
            const el = this.#getDiffAnchor(point);
            if (el) {
                this.#anchors.push(el);
            }
            return el;
        };
        const getTokenRange = (index, count) => {
            return this.getTokenRange(index, count);
        };
        const getDiffAnchorPointsInRange = (tokenIndex) => {
            return this.#yieldDiffAnchorPointsInRange(tokenIndex);
        };
        try {
            updateFn({
                setDiff,
                getTokenRange,
                getAnchor,
                getDiffAnchor,
                getDiffAnchorPointsInRange,
            });
        }
        finally {
            for (const anchor of this.#anchors) {
                unusedAnchors.delete(anchor);
            }
            for (const anchor of unusedAnchors) {
                anchor.remove();
            }
        }
        // console.log("diffs:", renderItems);
        this.#renderer.setDiffs(renderItems);
    }
    render() {
        this.#renderer.render();
    }
    setSelectionHighlight(range) {
        return this.#renderer.setSelectionHighlight(range);
    }
    setDiffHighlight(diffIndex) {
        if (this.#hoveredDiffIndex !== diffIndex) {
            this.#hoveredDiffIndex = diffIndex;
        }
        return this.#renderer.setDiffHighlight(diffIndex);
    }
    scrollTo(offset, options) {
        if (this.#wrapper.scrollTop !== offset) {
            this.#wrapper.scrollTo({
                top: offset,
                behavior: options?.behavior,
            });
        }
    }
    scrollToDiff(diffIndex, scrollMargin = SCROLL_MARGIN) {
        const y = this.#renderer.getDiffOffsetY(diffIndex);
        if (y !== undefined) {
            this.#wrapper.scrollTo({
                top: y - scrollMargin,
                behavior: "smooth",
            });
        }
    }
    getDiffRect(diffIndex) {
        return this.#renderer.getDiffRect(diffIndex);
    }
    #onResize() {
        if (this.#aligning) {
            return;
        }
        this.#renderer.updateLayout();
        this.#callbacks.onResize(this);
    }
    get height() {
        return this.#wrapper.offsetHeight;
    }
    get scrollHeight() {
        return this.#wrapper.scrollHeight;
    }
}
//# sourceMappingURL=Editor.js.map
</script>
<script>"use strict";
const DIFF_EXPAND_X = 2;
const DIFF_EXPAND_Y = 0;
const DIFF_LINE_EXPAND_Y = 0;
const DIFF_LINE_FILL_STYLE = "hsl(0 100% 95%)";
const DIFF_LINE_HEIGHT_MULTIPLIER = 1.1;
const SELECTION_HIGHLIGHT_FILL_STYLE = "rgba(128, 128, 128, 0.3)";
class Renderer {
    #container;
    #editor;
    #canvas;
    #ctx;
    #shouldClearCanvas = false;
    #highlightCanvas;
    #highlightCtx;
    #shouldClearHighlightCanvas = false;
    #canvasX = 0;
    #canvasY = 0;
    #canvasWidth = 0;
    #canvasHeight = 0;
    #diffs = [];
    #diffGeometries = [];
    #diffLineRects = [];
    #selectionHighlight = null;
    #selectionHighlightRects = null;
    #dirtyFlags = 0;
    #renderPending = false;
    #visibleDiffIndices = new Set();
    #callbacks;
    #highlightedDiffIndex = null;
    constructor(editor, container, callbacks) {
        this.#editor = editor;
        this.#container = container;
        this.#callbacks = callbacks;
        this.#canvas = document.createElement("canvas");
        this.#ctx = this.#canvas.getContext("2d");
        container.appendChild(this.#canvas);
        this.#highlightCanvas = document.createElement("canvas");
        this.#highlightCtx = this.#highlightCanvas.getContext("2d");
        container.appendChild(this.#highlightCanvas);
        this.updateLayout();
    }
    updateLayout() {
        const { x, y, width, height } = this.#container.getBoundingClientRect();
        this.#canvasX = x;
        this.#canvasY = y;
        this.#canvasWidth = width;
        this.#canvasHeight = height;
        this.#canvas.width = width;
        this.#canvas.height = height;
        this.#highlightCanvas.width = width;
        this.#highlightCanvas.height = height;
        this.markDirty(15 /* RenderFlags.ALL */);
    }
    setDiffs(diffs) {
        {
            const entries = [];
            for (let i = 0; i < this.#diffs.length; i++) {
                entries.push({ item: i, isVisible: false });
            }
            this.#callbacks.diffVisibilityChanged(entries);
        }
        this.#diffs = diffs;
        this.markDirty(1 /* RenderFlags.DIFF */ | 2 /* RenderFlags.GEOMETRY */);
        this.#visibleDiffIndices.clear();
        this.#selectionHighlight = null;
    }
    setSelectionHighlight(range) {
        const current = this.#selectionHighlight;
        if (current === range) {
            return false; // No change
        }
        if (current &&
            range &&
            current.startContainer === range.startContainer &&
            current.endContainer === range.endContainer &&
            current.startOffset === range.startOffset &&
            current.endOffset === range.endOffset) {
            return false; // No change in selection
        }
        this.#selectionHighlight = range;
        this.#selectionHighlightRects = null;
        this.markDirty(8 /* RenderFlags.HIGHLIGHT_SELECTION */);
        return true;
    }
    markDirty(flags) {
        this.#dirtyFlags |= flags;
        if (this.#renderPending) {
            return;
        }
    }
    getDiffAtPoint(x, y) {
        // console.log("Getting diff at point:", x, y);
        for (const diffIndex of this.#visibleDiffIndices) {
            // console.log("Checking diff index:", diffIndex, "at point:", x, y);
            const geometry = this.#diffGeometries[diffIndex];
            // console.log("Geometry for diff index:", diffIndex, "is", geometry);
            for (const rect of geometry.rects) {
                // console.log("Checking rect:", rect, "at point:", x, y);
                if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                    // console.log("Found diff at index:", diffIndex);
                    return diffIndex;
                }
            }
        }
        return null;
    }
    render() {
        if (this.#dirtyFlags & 1 /* RenderFlags.DIFF */) {
            this.renderDiffs();
        }
        if (this.#dirtyFlags & 12 /* RenderFlags.HIGHLIGHT */) {
            this.renderHighlightLayer();
        }
        this.#dirtyFlags = 0;
    }
    renderDiffs() {
        if (this.#dirtyFlags & 2 /* RenderFlags.GEOMETRY */) {
            this.buildDiffGeometries();
        }
        // console.log("Rendering diffs:", this.#diffs, this.#diffGeometries);
        const ctx = this.#ctx;
        const canvasWidth = this.#canvasWidth;
        const canvasHeight = this.#canvasHeight;
        const visibleDiffIndices = this.#visibleDiffIndices;
        const visChangeEntries = [];
        if (this.#shouldClearCanvas) {
            ctx.clearRect(0, 0, this.#canvasWidth, this.#canvasHeight);
            this.#shouldClearCanvas = false;
        }
        let renderedAny = false;
        const { scrollLeft, scrollTop } = this.#container;
        ctx.fillStyle = DIFF_LINE_FILL_STYLE;
        for (const rect of this.#diffLineRects) {
            const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
            if (y + height < 0)
                continue;
            if (y > canvasHeight)
                break;
            ctx.fillRect(x, y, width, height);
            renderedAny = true;
        }
        const visibleIndices = new Set();
        for (let diffIndex = 0; diffIndex < this.#diffGeometries.length; diffIndex++) {
            const geometry = this.#diffGeometries[diffIndex];
            let isVisible = !(geometry.maxY - scrollTop < 0 || geometry.minY - scrollTop > canvasHeight) &&
                !(geometry.maxX - scrollLeft < 0 || geometry.minX - scrollLeft > canvasWidth);
            if (isVisible) {
                visibleIndices.add(diffIndex);
                if (!visibleDiffIndices.has(diffIndex)) {
                    visibleDiffIndices.add(diffIndex);
                    visChangeEntries.push({ item: diffIndex, isVisible: true });
                }
            }
            else {
                if (visibleDiffIndices.has(diffIndex)) {
                    visibleDiffIndices.delete(diffIndex);
                    visChangeEntries.push({ item: diffIndex, isVisible: false });
                }
                continue;
            }
            ctx.fillStyle = geometry.fillStyle;
            ctx.strokeStyle = geometry.strokeStyle;
            for (const rect of geometry.rects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                // console.log("rendering rect:", x, y, width, height, "isVisible:", isVisible);
                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
                renderedAny = true;
            }
        }
        if (visChangeEntries.length > 0) {
            this.#callbacks.diffVisibilityChanged(visChangeEntries);
        }
        this.#shouldClearCanvas = renderedAny;
    }
    buildDiffGeometries() {
        const scrollTop = this.#container.scrollTop;
        const scrollLeft = this.#container.scrollLeft;
        const offsetX = -this.#canvasX + scrollLeft;
        const offsetY = -this.#canvasY + scrollTop;
        //void this.#container.offsetWidth; // force reflow
        const allDiffRects = [];
        this.#diffGeometries.length = this.#diffs.length;
        for (let diffIndex = 0; diffIndex < this.#diffs.length; diffIndex++) {
            const item = this.#diffs[diffIndex];
            const range = item.range;
            const rawRects = extractRects(range, true);
            for (const rect of rawRects) {
                rect.x += offsetX - DIFF_EXPAND_X;
                rect.y += offsetY - DIFF_EXPAND_Y;
                rect.width += DIFF_EXPAND_X * 2;
                rect.height += DIFF_EXPAND_Y * 2;
                allDiffRects.push(rect);
            }
            const mergedRects = mergeRects(rawRects, 1, 1);
            mergedRects.fillStyle = `hsl(${item.hue} 100% 80%)`;
            mergedRects.strokeStyle = `hsl(${item.hue} 100% 40% / 0.5)`;
            this.#diffGeometries[diffIndex] = mergedRects;
            item.geometry = mergedRects;
        }
        this.buildDiffLineRects(allDiffRects);
    }
    buildDiffLineRects(diffRects) {
        const TOLERANCE = 1;
        const lineRects = [];
        diffRects.sort((a, b) => a.y - b.y);
        const rects = [];
        const canvasWidth = this.#canvasWidth;
        let lineRect = null;
        for (const rect of diffRects) {
            const y = rect.y - DIFF_LINE_EXPAND_Y;
            const height = rect.height * DIFF_LINE_HEIGHT_MULTIPLIER + DIFF_LINE_EXPAND_Y * 2;
            if (lineRect === null || y > lineRect.y + lineRect.height) {
                lineRect = {
                    x: 0,
                    y: y,
                    width: canvasWidth,
                    height: height,
                };
                rects.push(lineRect);
            }
            else {
                lineRect.height = y + height - lineRect.y;
            }
        }
        if (rects.length > 0) {
            let current = rects[0];
            for (let i = 1; i < rects.length; i++) {
                const next = rects[i];
                const currentBottom = current.y + current.height;
                const nextTop = next.y;
                const gap = nextTop - currentBottom;
                if (gap <= TOLERANCE) {
                    const newBottom = Math.max(currentBottom, next.y + next.height);
                    current = {
                        x: current.x,
                        y: current.y,
                        width: current.width,
                        height: newBottom - current.y,
                    };
                }
                else {
                    // 병합 불가: 현재까지 병합된 것 push
                    lineRects.push(current);
                    current = next;
                }
            }
            lineRects.push(current);
        }
        this.#diffLineRects = lineRects;
    }
    renderHighlightLayer() {
        // console.log("Rendering selection highlight:", this.#selectionHighlight);
        const ctx = this.#highlightCtx;
        if (this.#shouldClearHighlightCanvas) {
            ctx.clearRect(0, 0, this.#highlightCanvas.width, this.#highlightCanvas.height);
            this.#shouldClearHighlightCanvas = false;
        }
        const scrollTop = this.#container.scrollTop;
        const scrollLeft = this.#container.scrollLeft;
        const canvasWidth = this.#canvasWidth;
        const canvasHeight = this.#canvasHeight;
        let renderedAny = false;
        if (this.#highlightedDiffIndex !== null) {
            // console.log("Rendering highlighted diff index:", this.#highlightedDiffIndex);
            const diff = this.#diffs[this.#highlightedDiffIndex];
            const rects = this.#diffGeometries[this.#highlightedDiffIndex];
            if (rects) {
                let isVisible = !(rects.maxY - scrollTop < 0 || rects.minY - scrollTop > canvasHeight) &&
                    !(rects.maxX - scrollLeft < 0 || rects.minX - scrollLeft > canvasWidth);
                if (!isVisible) {
                    return;
                }
                ctx.lineWidth = 2;
                ctx.strokeStyle = `hsl(${diff.hue} 100% 50% / 0.5)`;
                // ctx.shadowColor = `hsl(${baseHue} 100% 60% / 0.8)`;
                // ctx.shadowBlur = 20;
                for (const rect of rects.rects) {
                    const x = Math.floor(rect.x - scrollLeft) - 1, y = Math.floor(rect.y - scrollTop) - 1, width = Math.ceil(rect.width) + 2, height = Math.ceil(rect.height) + 2;
                    if (y + height < 0 || y > canvasHeight)
                        continue;
                    if (x + width < 0 || x > canvasWidth)
                        continue;
                    ctx.strokeRect(x, y, width, height);
                    // ctx.lineWidth = 2;
                    // ctx.strokeStyle = "white";
                    // ctx.shadowBlur = 0;
                    // ctx.shadowColor = "transparent";
                    // ctx.strokeRect(x-1, y-1, width + 2, height + 2);
                    renderedAny = true;
                }
            }
            ctx.lineWidth = 1;
            // ctx.shadowBlur = 0;
            // ctx.strokeStyle = "transparent";
        }
        if (this.#selectionHighlight) {
            if (!this.#selectionHighlightRects || this.#dirtyFlags & 2 /* RenderFlags.GEOMETRY */) {
                let start = performance.now();
                const offsetX = -this.#canvasX + scrollLeft;
                const offsetY = -this.#canvasY + scrollTop;
                const rawRects = extractRects(this.#selectionHighlight);
                let end = performance.now();
                start = end;
                const mergedRect = mergeRects(rawRects, 1, 1);
                for (const rect of mergedRect.rects) {
                    rect.x += offsetX;
                    rect.y += offsetY;
                }
                mergedRect.minX += offsetX;
                mergedRect.minY += offsetY;
                mergedRect.maxX += offsetX;
                mergedRect.maxY += offsetY;
                mergedRect.fillStyle = SELECTION_HIGHLIGHT_FILL_STYLE;
                mergedRect.strokeStyle = null;
                this.#selectionHighlightRects = mergedRect;
                // console.log("Extracted selection highlight rects in", performance.now() - start, "ms");
            }
            let geometry = this.#selectionHighlightRects;
            let isVisible = !(geometry.maxY - scrollTop < 0 || geometry.minY - scrollTop > canvasHeight) &&
                !(geometry.maxX - scrollLeft < 0 || geometry.minX - scrollLeft > canvasWidth);
            if (!isVisible) {
                return;
            }
            ctx.fillStyle = geometry.fillStyle;
            for (const rect of geometry.rects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0)
                    continue;
                if (y > canvasHeight)
                    break;
                ctx.fillRect(x, y, width, height);
                renderedAny = true;
            }
        }
        if (renderedAny) {
            this.#shouldClearHighlightCanvas = true;
        }
    }
    setDiffHighlight(diffIndex) {
        if (this.#highlightedDiffIndex === diffIndex) {
            return; // No change
        }
        // RECT는 필요 없음
        let prevShowing = this.#highlightedDiffIndex !== null && this.#visibleDiffIndices.has(this.#highlightedDiffIndex);
        this.#highlightedDiffIndex = diffIndex;
        let shouldShow = diffIndex !== null && this.#visibleDiffIndices.has(diffIndex);
        this.#dirtyFlags |= 4 /* RenderFlags.HIGHLIGHT_DIFF */;
        return prevShowing || shouldShow;
    }
    getDiffOffsetY(diffIndex) {
        const geometry = this.#diffGeometries[diffIndex];
        if (!geometry) {
            return undefined;
        }
        return geometry.minY;
    }
    getDiffRect(diffIndex) {
        const geometry = this.#diffGeometries[diffIndex];
        if (geometry) {
            return {
                x: geometry.minX,
                y: geometry.minY,
                width: geometry.maxX - geometry.minX,
                height: geometry.maxY - geometry.minY,
            };
        }
        return null;
    }
}
//# sourceMappingURL=Renderer.js.map
</script>
<script>"use strict";
class SideView {
    #callbacks;
    #root;
    #diffListElement;
    #diffListItems = [];
    constructor(container, callbacks) {
        this.#callbacks = callbacks;
        this.#root = document.createElement("DIV");
        this.#diffListElement = document.createElement("UL");
        this.#diffListElement.id = "diffList";
        this.#root.appendChild(this.#diffListElement);
        container.appendChild(this.#root);
    }
    setDiffs(diffs) {
        for (const diff of diffs) {
        }
        for (let diffIndex = 0; diffIndex < diffs.length; diffIndex++) {
            const diff = diffs[diffIndex];
            let item = this.#diffListItems[diffIndex];
            if (!item) {
                item = new DiffListItem(this.#diffListElement);
                this.#diffListItems[diffIndex] = item;
            }
            item.update(diff);
        }
        for (let i = this.#diffListItems.length - 1; i >= diffs.length; i--) {
            const item = this.#diffListItems[i];
            item.update(null);
        }
        this.#diffListItems.length = diffs.length;
    }
    onDiffItemMouseOver(diffIndex) {
        //this.#callbacks.onDiffItemMouseOver(diffIndex);
        highlightedDiffIndexAtom.set(diffIndex);
    }
    onDiffItemMouseOut(diffIndex) {
        highlightedDiffIndexAtom.set(null);
        this.#callbacks.onDiffItemMouseOut(diffIndex);
    }
    onDiffVisibilityChange(editorName, entries) {
        for (const entry of entries) {
            const item = this.#diffListItems[entry.item];
            if (item) {
                item.onDiffVisibilityChange(editorName, entry.isVisible);
            }
        }
    }
}
class DiffListItem {
    #element;
    #leftEl;
    #rightEl;
    #diff = null;
    constructor(listElement) {
        this.#element = document.createElement("LI");
        this.#leftEl = document.createElement("SPAN");
        this.#leftEl.className = "left";
        this.#rightEl = document.createElement("SPAN");
        this.#rightEl.className = "right";
        this.#element.appendChild(this.#leftEl);
        this.#element.appendChild(this.#rightEl);
        listElement.appendChild(this.#element);
        // event listeners
        this.#element.addEventListener("mouseover", () => {
            highlightedDiffIndexAtom.set(this.#diff.diffIndex);
        });
        this.#element.addEventListener("mouseout", () => {
            highlightedDiffIndexAtom.set(null);
        });
        this.#element.addEventListener("click", () => {
            diffItemClickedEvent.emit(this.#diff.diffIndex);
        });
    }
    update(diff) {
        this.#diff = diff;
        if (diff) {
            this.#element.style.removeProperty("display");
            this.#element.style.setProperty("--diff-hue", diff.hue.toString());
            this.#leftEl.textContent = diff.leftRange.toString();
            this.#rightEl.textContent = diff.rightRange.toString();
        }
        else {
            this.#element.style.display = "none";
        }
    }
    onDiffVisibilityChange(editorName, visible) {
        this.#element.classList.toggle(`${editorName}-visible`, visible);
    }
}
//# sourceMappingURL=SideView.js.map
</script>
<script>"use strict";
// computeDiffAsync는 queue 방식으로 동작하지 않음!
// 현재 진행 중인 작업이 있다면 무조건 reject/cancel하고 새 작업을 시작함
const computeDiffAsync = (() => {
    const worker = (() => {
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        return new Worker(workerURL);
    })();
    let _reqId = 0;
    let _current = null;
    worker.onmessage = (e) => {
        const data = e.data;
        if (data.type === "diff") {
            if (_current && data.reqId === _current.request.reqId) {
                if (data.reqId === _current.request.reqId) {
                    const result = {
                        diffs: data.diffs,
                        processTime: data.processTime,
                    };
                    _current.resolve(result);
                }
                else {
                    // 이 경우는 worker가 이전 요청을 처리하는 도중 새 요청이 들어온 경우임
                    _current.reject(new Error("cancelled"));
                }
            }
        }
    };
    worker.onerror = (e) => {
        //
    };
    function computeDiffAsync(leftTokens, rightTokens, options) {
        if (_current) {
            // 현재 컨텍스트가 있다면 일단 reject.
            // 작업 중인 worker는 새 작업을 받으면 알아서 취소하게 되어있음
            _current.reject(new Error("cancelled"));
        }
        return new Promise((resolve, reject) => {
            const request = {
                type: "diff",
                reqId: ++_reqId,
                options: { ...options },
                leftTokens: leftTokens,
                rightTokens: rightTokens,
            };
            _current = {
                resolve,
                reject,
                request,
            };
            worker.postMessage(request);
        });
    }
    return computeDiffAsync;
})();
//# sourceMappingURL=diff.js.map
</script>
<script>"use strict";
// atoms
// 이렇게까지 하게 될지는 몰랐는데 ui요소마다 콜백을 넘기고 또 그걸 또 감싸서 자식으로 넘기고... 귀찮잖아...
const highlightedDiffIndexAtom = createAtom("highlightedDiffIndex", null);
const diffItemClickedEvent = createEventAtom("diffItemClickedEvent");
function translateTokenFlagsToAnchorFlags(tokenFlags) {
    let flags = 0;
    if (tokenFlags & 1 /* TokenFlags.LINE_START */) {
        flags |= 1 /* AnchorFlags.PREFER_LINE_START */;
    }
    if (tokenFlags & 16 /* TokenFlags.CONTAINER_START */) {
        flags |= 4 /* AnchorFlags.PREFER_CONTAINER_START */;
    }
    if (tokenFlags & 64 /* TokenFlags.TABLE_START */) {
        flags |= 32 /* AnchorFlags.PREFER_TABLE_START */;
    }
    if (tokenFlags & 256 /* TokenFlags.TABLEROW_START */) {
        flags |= 16 /* AnchorFlags.PREFER_TABLEROW_START */;
    }
    if (tokenFlags & 1024 /* TokenFlags.TABLECELL_START */) {
        flags |= 8 /* AnchorFlags.PREFER_TABLECELL_START */;
    }
    return flags;
}
class DiffSeek {
    #mainContainer;
    //#preventScrollSync = false;
    #renderCallbackId = null;
    #leftEditor;
    #rightEditor;
    #editorContentsChanged = {
        left: false,
        right: false,
    };
    #diffOptions;
    #diffContext = null;
    #computeDiffCallbackId = null;
    #diffComputedCallbackId = null;
    #alignAnchorsCallbackId = null;
    #anchorsAligned = false;
    #textSelectionRange = null;
    #zoom = window.devicePixelRatio;
    #sideView;
    #syncScroll = false;
    #scrollingEditor = null;
    #lastScrolledEditor = null;
    #preventScrollSync = false;
    #activeEditor = null;
    #lastActiveEditor = null;
    highlightedDiffIndexAtom = createAtom("highlightedDiffIndex", null);
    constructor(mainContainer, asideContainer) {
        this.#mainContainer = mainContainer;
        this.#diffOptions = {
            algorithm: "histogram",
            tokenization: "word",
            whitespace: "ignore",
            greedyMatch: false,
            useLengthBias: true,
            maxGram: 4,
            lengthBiasFactor: 0.7,
            containerStartMultiplier: 1 / 0.85,
            containerEndMultiplier: 1 / 0.9,
            sectionHeadingMultiplier: 1 / 0.75,
            lineStartMultiplier: 1 / 0.9,
            lineEndMultiplier: 1 / 0.95,
            uniqueMultiplier: 1 / 0.6667,
        };
        const editorCallbacks = {
            onContentChanging: (editor) => this.#onEditorContentChanging(editor),
            onContentChanged: (editor) => this.#onEditorContentChanged(editor),
            onHoverDiff: (editor, diffIndex) => this.#onEditorHoverDiff(editor, diffIndex),
            onRender: (editor) => this.#onEditorRender(editor),
            onScroll: (editor, scrollTop, scrollLeft) => this.#onEditorScroll(editor, scrollTop, scrollLeft),
            onScrollEnd: (editor) => this.#onEditorScrollEnd(editor),
            onResize: (editor) => this.#onEditorResize(editor),
            onDiffVisibilityChanged: (editor, entries) => this.#onEditorDiffVisibilityChanged(editor, entries),
            onRenderInvalidated: (editor, flags) => this.#onEditorRenderInvalidated(editor, flags),
            onFocus: (editor) => {
                this.#lastActiveEditor = this.#activeEditor = editor;
            },
            onBlur: (editor) => {
                this.#activeEditor = null;
            },
        };
        this.#leftEditor = new Editor(mainContainer, "left", editorCallbacks);
        this.#rightEditor = new Editor(mainContainer, "right", editorCallbacks);
        this.#editorContentsChanged = { left: true, right: true };
        this.#sideView = new SideView(asideContainer, this.#sideViewCallbacks);
        this.setupEventListeners();
    }
    #sideViewCallbacks = {
        onDiffItemMouseOver: (diffIndex) => {
            this.#leftEditor.setDiffHighlight(diffIndex);
            this.#rightEditor.setDiffHighlight(diffIndex);
            this.#requestRender();
        },
        onDiffItemMouseOut: () => {
            this.#leftEditor.setDiffHighlight(null);
            this.#rightEditor.setDiffHighlight(null);
            this.#requestRender();
        },
    };
    setupEventListeners() {
        window.addEventListener("resize", () => { });
        document.addEventListener("selectionchange", () => {
            this.#updateTextSelection();
        });
        document.addEventListener("keydown", (e) => {
            if (e.key === "F8") {
                this.#diffOptions.whitespace = this.#diffOptions.whitespace === "ignore" ? "normalize" : "ignore";
            }
            if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
                e.preventDefault();
                const editor = e.key === "1" ? this.#leftEditor : this.#rightEditor;
                editor.editor.focus();
                return;
            }
            if (e.key === "F2") {
                e.preventDefault();
                this.syncScroll = !this.#syncScroll;
            }
        }, true);
        highlightedDiffIndexAtom.subscribe((diffIndex) => {
            this.#leftEditor.setDiffHighlight(diffIndex);
            this.#rightEditor.setDiffHighlight(diffIndex);
            this.#requestRender();
        });
        diffItemClickedEvent.subscribe((diffIndex) => {
            // let count = 2;
            // function onScrollEnd() {
            // 	if (--count === 0) {
            // 		preventScrollSync = false;
            // 	}
            // }
            // this.#leftEditor.wrapper.addEventListener("scrollend", onScrollEnd, { once: true });
            // this.#rightEditor.wrapper.addEventListener("scrollend", onScrollEnd, { once: true });
            // this.#leftEditor.scrollToDiff(diffIndex);
            // TODO
            // 양쪽 에디터에서 해당 diff의 y좌표를 구해서 그 중 작은 값을 기준으로 스크롤 해야함.
            // 혹은 위로 스크롤 해야되는지 아래로 스크롤 해야하는지를 확인해서...
            this.scrollToDiff(diffIndex);
        });
    }
    #onEditorContentChanging(editor) {
        this.reset();
        this.#leftEditor.setDiffHighlight(null);
        this.#rightEditor.setDiffHighlight(null);
        this.#cancelAllCallbacks();
    }
    #onEditorContentChanged(editor) {
        this.#editorContentsChanged[editor.name] = true;
        this.#cancelAllCallbacks();
        this.#computeDiff();
    }
    #onEditorHoverDiff(editor, diffIndex) {
        // this.#leftEditor.setDiffHighlight(diffIndex);
        // this.#rightEditor.setDiffHighlight(diffIndex);
        this.#requestRender();
    }
    #onEditorScroll(editor, scrollTop, scrollLeft) {
        if (this.#scrollingEditor === null) {
            this.#lastScrolledEditor = this.#scrollingEditor = editor;
        }
        if (this.#syncScroll) {
            if (!this.#preventScrollSync && this.#scrollingEditor === editor) {
                const otherEditor = editor === this.#leftEditor ? this.#rightEditor : this.#leftEditor;
                otherEditor.scrollTo(scrollTop, { behavior: "instant" });
            }
        }
        this.#requestRender();
    }
    #onEditorScrollEnd(editor) {
        if (this.#scrollingEditor === editor) {
            this.#scrollingEditor = null;
        }
    }
    #onEditorResize(editor) {
        this.#anchorsAligned = false;
        this.#requestRender();
    }
    #onEditorDiffVisibilityChanged(editor, entries) {
        this.#sideView.onDiffVisibilityChange(editor.name, entries);
    }
    #onEditorRenderInvalidated(editor, flags = 0 /* RenderFlags.NONE */) {
        this.#requestRender();
    }
    #onEditorRender(editor) {
        this.#anchorsAligned = false;
        this.#requestRender();
    }
    #requestRender() {
        if (this.#renderCallbackId) {
            // 거~의 모든 경우에 render는 가장 마지막에 일어나야 하므로 이미 예약된 콜백을 취소하고 다시 등록함.
            cancelAnimationFrame(this.#renderCallbackId);
            this.#renderCallbackId = null;
        }
        if (this.#syncScroll && !this.#anchorsAligned) {
            this.alignAnchors();
        }
        this.#renderCallbackId = requestAnimationFrame(() => {
            this.#renderCallbackId = null;
            this.#doRender();
        });
    }
    #doRender() {
        this.#leftEditor.render();
        this.#rightEditor.render();
    }
    #updateTextSelection() {
        if (!this.#diffContext || !this.#diffContext.rawDiffs)
            return;
        const selection = window.getSelection();
        let editor = null;
        let targetEditor = null;
        let targetRange = null;
        if (selection && selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            if (this.#leftEditor.wrapper.contains(range.commonAncestorContainer)) {
                editor = this.#leftEditor;
            }
            else if (this.#rightEditor.wrapper.contains(range.commonAncestorContainer)) {
                editor = this.#rightEditor;
            }
            if (editor) {
                // onContentChanging에서 diffContext를 null로 설정하므로 이 시점에서 에디터는 유효한 토큰 배열을 가지고 있다고 볼 수 있다.
                const [startTokenIndex, endTokenIndex] = editor.findTokenOverlapIndices(range);
                if (startTokenIndex >= 0 && endTokenIndex >= startTokenIndex) {
                    const [otherStartTokenIndex, otherEndTokenIndex] = mapTokenRangeToOtherSide(this.#diffContext.rawDiffs, editor === this.#leftEditor ? "left" : "right", startTokenIndex, endTokenIndex);
                    if (otherStartTokenIndex >= 0) {
                        targetEditor = editor === this.#leftEditor ? this.#rightEditor : this.#leftEditor;
                        const otherStartToken = targetEditor.tokens[otherStartTokenIndex];
                        const otherEndToken = targetEditor.tokens[otherEndTokenIndex - 1];
                        if (otherStartToken && otherEndToken) {
                            targetRange = document.createRange();
                            targetRange.setStart(otherStartToken.range.startContainer, otherStartToken.range.startOffset);
                            targetRange.setEnd(otherEndToken.range.endContainer, otherEndToken.range.endOffset);
                        }
                    }
                }
            }
        }
        if (this.#textSelectionRange === targetRange) {
            return;
        }
        if (this.#textSelectionRange && targetRange) {
            if (targetRange.startContainer === this.#textSelectionRange.startContainer &&
                targetRange.startOffset === this.#textSelectionRange.startOffset &&
                targetRange.endContainer === this.#textSelectionRange.endContainer &&
                targetRange.endOffset === this.#textSelectionRange.endOffset) {
                return;
            }
        }
        this.#textSelectionRange = targetRange;
        if (targetRange) {
            editor.setSelectionHighlight(null);
            targetEditor.setSelectionHighlight(targetRange);
        }
        else {
            this.#leftEditor.setSelectionHighlight(null);
            this.#rightEditor.setSelectionHighlight(null);
        }
        this.#requestRender();
    }
    #computeDiff() {
        this.#cancelAllCallbacks();
        const leftRichTokens = this.#leftEditor.tokens;
        const rightRichTokens = this.#rightEditor.tokens;
        const options = { ...this.#diffOptions };
        const diffContext = {
            leftTokens: leftRichTokens,
            rightTokens: rightRichTokens,
            diffOptions: options,
            outdated: false,
        };
        this.#diffContext = diffContext;
        function buildTokenArray(richTokens) {
            const result = new Array(richTokens.length);
            for (let i = 0; i < richTokens.length; i++) {
                const richToken = richTokens[i];
                result[i] = {
                    text: richToken.text,
                    flags: richToken.flags,
                };
            }
            return result;
        }
        this.#computeDiffCallbackId = requestIdleCallback(async () => {
            this.#computeDiffCallbackId = null;
            if (this.#diffContext !== diffContext) {
                return;
            }
            // worker에서 이전 토큰들을 캐시하고 있기 때문에 변경되지 않았으면 그냥 null을 보냄
            const leftTokens = this.#editorContentsChanged.left ? buildTokenArray(leftRichTokens) : null;
            const rightTokens = this.#editorContentsChanged.right ? buildTokenArray(rightRichTokens) : null;
            let result;
            try {
                result = await computeDiffAsync(leftTokens, rightTokens, options);
            }
            catch (error) {
                if (error instanceof Error && error.message === "cancelled") {
                    return;
                }
                throw error;
            }
            if (this.#diffContext !== diffContext) {
                return;
            }
            diffContext.rawDiffs = result.diffs;
            diffContext.processTime = result.processTime;
            // if (this.#diffComputedCallbackId !== null) {
            // 	cancelIdleCallback(this.#diffComputedCallbackId);
            // 	this.#diffComputedCallbackId = null;
            // }
            this.#diffComputedCallbackId = requestIdleCallback(() => {
                this.#diffComputedCallbackId = null;
                if (this.#diffContext !== diffContext) {
                    return;
                }
                // 이게 짜증날정도로 오래 걸린다면 generator로 쪼개서 스텝 바이 스텝으로 처리해야된다.
                // 지금은 일단 그냥 둠.
                this.#onDiffComputed(diffContext);
            });
        });
    }
    #onDiffComputed(diffContext) {
        const leftTokens = diffContext.leftTokens;
        const rightTokens = diffContext.rightTokens;
        const rawEntries = diffContext.rawDiffs;
        const diffs = [];
        const anchors = [];
        // 지옥으로 간다...
        this.#leftEditor.withUpdate((leftFn) => {
            this.#rightEditor.withUpdate((rightFn) => {
                const ANCHOR_MIN_LINE_BREAKS = 1; // 앵커를 붙일 때 최소한의 줄바꿈 수.
                let forceStart = true;
                let currentDiff = null;
                for (let i = 0; i < rawEntries.length; i++) {
                    const rawEntry = rawEntries[i];
                    const left = rawEntry.left;
                    const right = rawEntry.right;
                    if (rawEntry.type) {
                        if (currentDiff) {
                            console.assert(currentDiff.left.pos + currentDiff.left.len === rawEntry.left.pos, currentDiff, rawEntry);
                            console.assert(currentDiff.right.pos + currentDiff.right.len === rawEntry.right.pos, currentDiff, rawEntry);
                            currentDiff.type |= rawEntry.type;
                            currentDiff.left.len += rawEntry.left.len;
                            currentDiff.right.len += rawEntry.right.len;
                        }
                        else {
                            currentDiff = { left: { ...rawEntry.left }, right: { ...rawEntry.right }, type: rawEntry.type };
                        }
                    }
                    else {
                        // common entry
                        if (currentDiff) {
                            finalizeDiff();
                        }
                        const leftToken = leftTokens[left.pos];
                        const rightToken = rightTokens[right.pos];
                        const leftTokenFlags = leftToken.flags;
                        const rightTokenFlags = rightToken.flags;
                        const commonFlags = leftTokenFlags & rightTokenFlags;
                        let anchorEligible = false;
                        if (commonFlags & 1 /* TokenFlags.LINE_START */) {
                            anchorEligible = forceStart;
                            if (!anchorEligible && commonFlags & 16 /* TokenFlags.CONTAINER_START */) {
                                anchorEligible = true;
                            }
                            if (!anchorEligible && commonFlags & SECTION_HEADING_MASK) {
                                anchorEligible = true;
                            }
                            if (!anchorEligible) {
                                const leftPrevToken = leftTokens[left.pos - 1];
                                const rightPrevToken = rightTokens[right.pos - 1];
                                if ((leftTokenFlags | rightTokenFlags) &
                                    (1024 /* TokenFlags.TABLECELL_START */ | 256 /* TokenFlags.TABLEROW_START */ | 64 /* TokenFlags.TABLE_START */ | 16 /* TokenFlags.CONTAINER_START */)) {
                                    anchorEligible = true;
                                }
                                if (!anchorEligible) {
                                    const l = !leftPrevToken || leftToken.lineNum - leftTokens[left.pos - 1].lineNum >= ANCHOR_MIN_LINE_BREAKS;
                                    const r = !rightPrevToken || rightToken.lineNum - rightTokens[right.pos - 1].lineNum >= ANCHOR_MIN_LINE_BREAKS;
                                    anchorEligible = l || r;
                                }
                            }
                        }
                        if (anchorEligible) {
                            forceStart = false;
                            const leftAnchorEl = leftFn.getAnchor(left.pos, translateTokenFlagsToAnchorFlags(leftTokenFlags));
                            const rightAnchorEl = rightFn.getAnchor(right.pos, translateTokenFlagsToAnchorFlags(rightTokenFlags));
                            if (leftAnchorEl && rightAnchorEl) {
                                leftAnchorEl.dataset.tokenIndex = String(left.pos);
                                rightAnchorEl.dataset.tokenIndex = String(right.pos);
                                anchors.push({
                                    leftEl: leftAnchorEl,
                                    rightEl: rightAnchorEl,
                                });
                            }
                            else {
                            }
                        }
                    }
                }
                if (currentDiff) {
                    finalizeDiff();
                }
                function finalizeDiff() {
                    const diffIndex = diffs.length;
                    const leftIndex = currentDiff.left.pos;
                    const rightIndex = currentDiff.right.pos;
                    const leftTokenCount = currentDiff.left.len;
                    const rightTokenCount = currentDiff.right.len;
                    const hue = DIFF_COLOR_HUES[diffIndex % NUM_DIFF_COLORS];
                    let leftRange;
                    let rightRange;
                    let leftAnchorEl = null;
                    let rightAnchorEl = null;
                    const leftDiffItem = {
                        diffIndex,
                        tokenIndex: leftIndex,
                        tokenCount: leftTokenCount,
                        flags: 0,
                        hue,
                        preferBlockStart: false,
                    };
                    const rightDiffItem = {
                        diffIndex,
                        tokenIndex: rightIndex,
                        tokenCount: rightTokenCount,
                        flags: 0,
                        hue,
                        preferBlockStart: false,
                    };
                    if (leftTokenCount > 0 && rightTokenCount > 0) {
                        leftRange = leftFn.getTokenRange(leftIndex, leftTokenCount);
                        rightRange = rightFn.getTokenRange(rightIndex, rightTokenCount);
                        const leftToken = leftTokens[leftIndex];
                        const rightToken = rightTokens[rightIndex];
                        if (leftToken.flags & rightToken.flags & 1 /* TokenFlags.LINE_START */) {
                            leftAnchorEl = leftFn.getAnchor(leftIndex, translateTokenFlagsToAnchorFlags(leftToken.flags));
                            rightAnchorEl = rightFn.getAnchor(rightIndex, translateTokenFlagsToAnchorFlags(rightToken.flags));
                        }
                    }
                    else {
                        let filledItem, emptyItem;
                        let filledTokens, emptyTokens;
                        let filledTokenIndex, emptyTokenIndex;
                        let filledTokenCount;
                        let filledFn;
                        let emptyFn;
                        let filledAnchor = null;
                        let emptyAnchor = null;
                        if (leftTokenCount > 0) {
                            filledItem = leftDiffItem;
                            filledTokens = leftTokens;
                            filledTokenIndex = leftIndex;
                            filledTokenCount = leftTokenCount;
                            filledFn = leftFn;
                            emptyItem = rightDiffItem;
                            emptyTokenIndex = rightIndex;
                            emptyTokens = rightTokens;
                            emptyFn = rightFn;
                        }
                        else {
                            filledItem = rightDiffItem;
                            filledTokens = rightTokens;
                            filledTokenIndex = rightIndex;
                            filledTokenCount = rightTokenCount;
                            filledFn = rightFn;
                            emptyItem = leftDiffItem;
                            emptyTokens = leftTokens;
                            emptyTokenIndex = leftIndex;
                            emptyFn = leftFn;
                        }
                        const filledToken = filledTokens[filledTokenIndex];
                        const filledStartFlags = filledToken.flags;
                        let bestPoint = null;
                        let bestScore = 0;
                        for (const point of emptyFn.getDiffAnchorPointsInRange(emptyTokenIndex)) {
                            let score = 0;
                            if (point.flags & 1024 /* InsertionPointFlags.TABLEROW_START */ && filledStartFlags & 256 /* TokenFlags.TABLEROW_START */) {
                                score += 5;
                            }
                            else if (point.flags & 1024 /* InsertionPointFlags.TABLEROW_START */ && filledStartFlags & 256 /* TokenFlags.TABLEROW_START */) {
                                score += 4;
                            }
                            else if (point.flags & 256 /* InsertionPointFlags.TABLECELL_START */ && filledStartFlags & 1024 /* TokenFlags.TABLECELL_START */) {
                                score += 3;
                            }
                            else if (point.flags & 16 /* InsertionPointFlags.CONTAINER_START */ && filledStartFlags & 16 /* TokenFlags.CONTAINER_START */) {
                                score += 2;
                            }
                            else if (point.flags & 64 /* InsertionPointFlags.BLOCK_START */ && filledStartFlags & 4 /* TokenFlags.BLOCK_START */) {
                                score += 1;
                            }
                            if (score > bestScore) {
                                bestScore = score;
                                bestPoint = point;
                            }
                        }
                        if (bestPoint) {
                            emptyAnchor = emptyFn.getDiffAnchor(bestPoint);
                            if (emptyAnchor) {
                                if (filledStartFlags & 1 /* TokenFlags.LINE_START */) {
                                    filledAnchor = filledFn.getAnchor(filledTokenIndex, translateTokenFlagsToAnchorFlags(filledStartFlags));
                                }
                            }
                        }
                        const filledRange = filledFn.getTokenRange(filledTokenIndex, filledTokenCount);
                        let emptyRange = null;
                        if (emptyAnchor) {
                            emptyRange = document.createRange();
                            emptyRange.selectNode(emptyAnchor);
                        }
                        else {
                            emptyRange = emptyFn.getTokenRange(emptyTokenIndex, 0);
                        }
                        if (leftTokenCount > 0) {
                            leftRange = filledRange;
                            leftAnchorEl = filledAnchor;
                            rightRange = emptyRange;
                            rightAnchorEl = emptyAnchor;
                        }
                        else {
                            rightRange = filledRange;
                            rightAnchorEl = filledAnchor;
                            leftRange = emptyRange;
                            leftAnchorEl = emptyAnchor;
                        }
                    }
                    leftFn.setDiff(leftRange, leftDiffItem);
                    rightFn.setDiff(rightRange, rightDiffItem);
                    diffs.push({
                        diffIndex,
                        hue,
                        leftRange,
                        rightRange,
                    });
                    if (leftAnchorEl && rightAnchorEl) {
                        anchors.push({
                            leftEl: leftAnchorEl,
                            rightEl: rightAnchorEl,
                            diffIndex,
                        });
                    }
                    currentDiff = null;
                    forceStart = true;
                }
            });
        });
        diffContext.diffs = diffs;
        diffContext.anchors = anchors;
        this.#diffContext = diffContext;
        // console.log("results", diffs, anchors);
        // this.alignAnchors();
        this.#updateTextSelection();
        this.#requestRender();
        this.#sideView.setDiffs(diffs);
    }
    #_resizeCancelId = null;
    /*
    눈물나게 무거운 작업임. 연속적으로 reflow 발생.
    특히 앵커가 많은 경우 브라우저가 "좀 심한데?"라고 경고를 던져주는데 딱히 대안이 없음.
    대안1: 화면에 렌더링되는 앵커들만 맞춰준다? 이건 현재 보이는 영역보다 위의 앵커들이 다 맞춰진 걸로 치고 거기서부터 기준점을 잡고 화면을 벗어날 때까지 앵커좌표를 맞춰가는 건데
          문서의 흐름이 반드시 위에서 아래로 흐르지는 않기 때문에(table) 하나의 기준점을 찾기가 어렵다.
    */
    alignAnchors() {
        if (this.#_resizeCancelId !== null) {
            cancelIdleCallback(this.#_resizeCancelId);
            this.#_resizeCancelId = null;
        }
        if (!this.#syncScroll) {
            return;
        }
        if (this.#anchorsAligned) {
            return;
        }
        if (!this.#diffContext || !this.#diffContext.anchors) {
            return;
        }
        this.#preventScrollSync = true;
        const MIN_DELTA = 1;
        const MIN_STRIPED_DELTA = 10;
        const leftEditor = this.#leftEditor;
        const rightEditor = this.#rightEditor;
        let leftScrollTop = leftEditor.scrollTop;
        let rightScrollTop = rightEditor.scrollTop;
        const anchors = this.#diffContext.anchors;
        for (let i = 0; i < anchors.length; i++) {
            const { leftEl, rightEl } = anchors[i];
            leftEl.classList.remove("padtop", "striped");
            rightEl.classList.remove("padtop", "striped");
            leftEl.style.removeProperty("--padding");
            rightEl.style.removeProperty("--padding");
            void this.#leftEditor.wrapper.offsetHeight; // force reflow
            void this.#rightEditor.wrapper.offsetHeight; // force reflow
            let leftY;
            let rightY;
            let delta;
            leftY = leftEl.getBoundingClientRect().y + leftScrollTop; //leftEditor.wrapper.scrollTop;
            rightY = rightEl.getBoundingClientRect().y + rightScrollTop; //rightEditor.wrapper.scrollTop;
            delta = leftY - rightY;
            if (delta > -MIN_DELTA && delta < MIN_DELTA) {
                continue;
            }
            delta = Math.round(delta);
            let theEl;
            if (delta > 0) {
                theEl = rightEl;
            }
            else {
                delta = -delta;
                theEl = leftEl;
            }
            theEl.classList.add("padtop");
            theEl.style.setProperty("--padding", `${delta}px`);
            if (delta >= MIN_STRIPED_DELTA) {
                theEl.classList.add("striped");
            }
        }
        leftEditor.editor.style.removeProperty("--min-height");
        rightEditor.editor.style.removeProperty("--min-height");
        this.#_resizeCancelId = requestAnimationFrame(() => {
            this.#anchorsAligned = true; // do we really need this?
            const leftHeight = leftEditor.editor.scrollHeight;
            const rightHeight = rightEditor.editor.scrollHeight;
            const maxHeight = Math.max(leftHeight, rightHeight);
            leftEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
            rightEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
            const currentEditor = this.#lastScrolledEditor ?? this.#lastActiveEditor ?? this.#rightEditor;
            const newScrollTop = currentEditor.scrollTop;
            this.#scrollingEditor = null;
            if (currentEditor === leftEditor) {
                rightEditor.scrollTo(newScrollTop, { behavior: "instant" });
            }
            else {
                leftEditor.scrollTo(newScrollTop, { behavior: "instant" });
            }
            this.#preventScrollSync = false;
        });
        this.#anchorsAligned = true;
    }
    #cancelAllCallbacks() {
        if (this.#alignAnchorsCallbackId !== null) {
            cancelAnimationFrame(this.#alignAnchorsCallbackId);
            this.#alignAnchorsCallbackId = null;
        }
        if (this.#computeDiffCallbackId !== null) {
            cancelIdleCallback(this.#computeDiffCallbackId);
            this.#computeDiffCallbackId = null;
        }
        if (this.#diffComputedCallbackId !== null) {
            cancelIdleCallback(this.#diffComputedCallbackId);
            this.#diffComputedCallbackId = null;
        }
    }
    reset() {
        this.#diffContext = null;
        this.#textSelectionRange = null;
        this.#anchorsAligned = false;
        this.#leftEditor.setSelectionHighlight(null);
        this.#rightEditor.setSelectionHighlight(null);
    }
    scrollToDiff(diffIndex) {
        const leftRect = this.#leftEditor.getDiffRect(diffIndex);
        const rightRect = this.#rightEditor.getDiffRect(diffIndex);
        if (!leftRect || !rightRect) {
            return;
        }
        if (this.#syncScroll) {
            let scrollTop = Math.min(leftRect.y, rightRect.y);
            scrollTop = Math.max(scrollTop - SCROLL_MARGIN, 0);
            this.#leftEditor.scrollTo(scrollTop, { behavior: "smooth" });
        }
        else {
            const leftScrollTop = leftRect.y - SCROLL_MARGIN;
            const rightScrollTop = rightRect.y - SCROLL_MARGIN;
            this.#leftEditor.scrollTo(leftScrollTop, { behavior: "smooth" });
            this.#rightEditor.scrollTo(rightScrollTop, { behavior: "smooth" });
        }
    }
    get syncScroll() {
        return this.#syncScroll;
    }
    set syncScroll(value) {
        value = !!value;
        if (value === this.#syncScroll) {
            return;
        }
        this.#syncScroll = value;
        this.#mainContainer.classList.toggle("sync-scroll", value);
        if (value) {
            if (this.#alignAnchorsCallbackId !== null) {
                cancelAnimationFrame(this.#alignAnchorsCallbackId);
                this.#alignAnchorsCallbackId = null;
            }
            this.#alignAnchorsCallbackId = requestAnimationFrame(() => {
                this.#alignAnchorsCallbackId = null;
                this.alignAnchors();
            });
            this.#requestRender();
        }
    }
}
//# sourceMappingURL=DiffSeek.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	font-size: 16px;
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 0px;
	--container-gap: 8px;
	--sidebar-width: 200px;
	--text-container-padding-block: 4px;
	--text-container-padding-inline: 4px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
	/* font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; */
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr var(--sidebar-width);
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 var(--container-gap, 0px);
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

.sync-scroll #scrollSyncIndicator {
	display: block;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
	overflow-anchor: none;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	/* font-family: "돋움체", monospace; */
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	/* white-space: pre-wrap; */
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

#main > canvas {
	position: fixed;
	top: 0;
	left: 0;
	bottom: var(--status-bar-height, 0px);
	width: calc(100vw - var(--sidebar-width) - var(--container-gap, 0px));
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -1;
	will-change: transform; /* 정확히 뭘하는 놈인지 알아봐야함 */
}

.editor-wrapper canvas {
	position: fixed;
	bottom: var(--status-bar-height, 0px);
	width: calc((100vw - var(--sidebar-width) - var(--container-gap, 0px)) / 2);
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -2;
	will-change: transform; /* 정확히 뭘하는 놈인지 알아봐야함 */
}

.editor-wrapper canvas.highlight {
	z-index: -1;
	opacity: 0.3;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -99;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: transparent;
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: #ccc;
	background-color: #000;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
	display: contents;
}

mark {
	background-color: inherit;
	color: inherit;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
}

mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-block으로 안해두면 높이 1px이 모자르게 된다. 묻지마... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
공간을 전혀 차지하지 않으면서도 visual이 있어야함
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
줄(div)안에 블럭 엘러먼트를 넣어서 강제로 줄바꿈 효과를 주었을 때
diff가 없는 가상의 줄도 diff가 있는 줄처럼 표시되는 문제.
당연한거긴 한데... 쉬운 해결방법이 떠오르질 않는다!
고민 필요
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

#diffList .heading {
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	display: block;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "👬";
	font-size: 128px;
	font-weight: bold;
	font-family: monospace;
	text-align: center;
	display: block;
}

#diffList li {
	cursor: pointer;
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "💭";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "◀️"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "▶️" !important; */
}

.edit hr {
	height: 0 !important;
}

/* 의미없다
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: -98;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.edit .mirror {
	display: none !important;
}

.aligned canvas {
	display: none !important;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}

.editor-wrapper h6 {
	all: unset;
}

.edit .editor-wrapper h6 {
	all: unset;
	text-decoration-color: #000;
}

.aligned .editor-wrapper h6 {
	color: #fff;
	font-weight: bold;
}

/* .edit .mirror br {
	display: none;
}

.aligned .mirror {
	white-space: normal;
}

.aligned .mirror div {
	display: contents;;
} */

.editor table {
	border-collapse: collapse;
	border-spacing: 0;
}

.editor th,
.editor td {
	vertical-align: top;
	border: 1px solid #000;
	padding: var(--text-container-padding-block, 0px) var(--text-container-padding-inline, 0px);
	user-select: none;
}

.editor p:empty::before {
	content: "\00a0";
}

.color-red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-size: inherit;
}

.bottom-padding {
	display: block;
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}


.editor::after {
	content: "";
	display: block;
	height: var(--bottom-padding, 0px);

	background: red repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.editor a {
	pointer-events: none;
	user-select: none;
}


.sync-scroll .padtop::before {
	content: "";
	display: block;
	height: var(--padding, 0px);
}

.sync-scroll .padtop.striped::before {
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.sync-scroll .editor {
	min-height: max(100%, var(--min-height, 100%));
}


.diff-anchor:not(p .diff-anchor)::before {
	/* content: "";
	display: block;
	min-height: calc(1em * var(--line-height, 1.5));
	*/
}

.diff-anchor-block {
}

.diff-anchor-block::before {
	/* content: "";
	display: block;
	min-height: calc(1em * var(--line-height, 1.5)); */
}

@keyframes fadein {
	from {
		opacity: 0;
	}
	to {
		opacity: 1;
	}
}

@keyframes fadeout {
	from {
		opacity: 1;
	}
	to {
		opacity: 0;
	}
}

.fade-in {
	animation: fadein 0.5s forwards;
}

.fade-out {
	animation: fadeout 0.1s forwards;
}

canvas {
	transition: opacity 0.3s ease;
	opacity: 1;
}

.dimmed {
	opacity: 0.5;
}

.restored {
	transition: none !important; /* 복원 시 즉시 반영 */
	opacity: 1;
}

.editor p {
	min-height: calc(0.5em * var(--line-height, 1.5));
}

</style>
</head>

<body>
    <div class="container">
        <main id="main"><div id="scrollSyncIndicator">🔗</div></main>
        <div id="sidebar"></div>
    </div>

    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>
    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT};\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
    <script>
        window.DiffSeek = new DiffSeek(document.getElementById("main"), document.getElementById("sidebar"));
    </script>
</body>

</html>
