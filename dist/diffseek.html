<!DOCTYPE html>
<!--
# DiffSeek 

### Í∞úÏöî
- Ï†ïÎßê ÏÑºÏä§ÎßåÏ†ê Ïù¥Î¶Ñ. Ï§ëÍµ≠ÏÇ∞ DeepSeek ÏïÑÎãò. diffÎ•º seekÌï®.
- ÌïúÍ∏ÄÏûê ÌïúÍ∏ÄÏûê ÎààÏúºÎ°ú ÎπÑÍµêÌïòÎäîÍ±¥ Ï£ΩÏñ¥ÎèÑ Î™ªÌïòÍ≤†Í≥† Ï£ΩÏñ¥ÎèÑ ÌïòÍ∏∞ Ïã´Ïñ¥ÏÑú.
- Í≥µÎ∞± Î¨¥Ïãú. Í≥µÎ∞±ÏùÑ ÏôÑÏ†ÑÌûà Î¨¥ÏãúÌïòÎäîÍ±¥ ÏôÑÏ†ÑÌûà ÏùòÎèÑÎêú Í≤ÉÏûÑ. **ÏóÖÎ¨¥Îß§Îâ¥ÏñºÏùò Ï§ÑÎ∞îÍøà ÏúÑÏπòÎäî Ï†àÎåÄÎ°ú Î¨∏Ïû•Ïùò ÎÅù ÌòπÏùÄ Îã®ÎùΩÏùò ÎÅùÍ≥º ÏùºÏπòÌïòÏßÄ ÏïäÏùå!** Í≥µÎ∞±ÏùÑ Ï†ÑÌòÄ Î¨¥ÏãúÌïòÏßÄ ÏïäÍ±∞ÎÇò Ï†ïÍ∑úÌôî(Ïó¨Îü¨Í∞úÏùò Ïó∞ÏÜçÎêú Í≥µÎ∞±ÏùÑ ÌïòÎÇòÎ°ú Ïù∏Ïãù)Ìï¥ÏÑú ÎπÑÍµêÌïòÎäî ÏΩîÎìúÎ•º ÏßúÎäîÍ≤å 100ÎßåÎ∞∞ ÏâΩÍ≥† Í≥ÑÏÇ∞ÏÜçÎèÑÎèÑ Ìõ®Ïî¨ Îπ†Î¶Ñ. (ÌÜ†Í∏Ä Í∞ÄÎä•: `DiffSeek.diffOptions.whitespace = "ignore" | "normalize"`)
- Îã®Ïñ¥ Îã®ÏúÑ diffÍ∞Ä Í∏∞Î≥∏. Í∏ÄÏûê Îã®ÏúÑ diffÎäî ÏÑ±Îä•ÎèÑ ÏÑ±Îä•Ïù¥ÏßÄÎßå ÏÇ¨ÎûåÏùò ÎààÏóê Ïò§ÌûàÎ†§ Îçî ÌîºÍ≥§ÌïòÍ∏∞Îßå Ìï®. Ï§Ñ Îã®ÏúÑÏùò Í≤ΩÏö∞ÎèÑ Î¨∏ÏÑúÎßàÎã§ Ï§ÑÎ∞îÍøàÏùò ÏúÑÏπòÍ∞Ä ÏßÄÎ©ãÎåÄÎ°úÎùº ÎπÑÌö®Ïú®Ï†ÅÏûÑ. (ÌÜ†Í∏Ä Í∞ÄÎä•: `DiffSeek.diffOptions.tokenization = "char" | "word" | "line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

### Íµ¨ÌòÑ ÏùòÎèÑ? Ï∞∏Í≥†ÏÇ¨Ìï≠?
- ÏñëÏ™ΩÏóê ÌÖçÏä§Ìä∏ Î∂ôÏó¨ÎÑ£Í≥† Ïã§ÌñâÎ≤ÑÌäº Îî±~ ÎàÑÎ•¥Î©¥ diffÎì§Ïù¥ ÌëúÏãúÎêò.... 
    *Ïôú???? Î≤ÑÌäºÏùÑ Î≠êÌïòÎü¨ ÎàåÎü¨?*
    **diffÎäî ÌÖçÏä§Ìä∏ Î≥ÄÍ≤ΩÏãú Ïã§ÏãúÍ∞ÑÏúºÎ°ú, ÏûÖÎ†•Ìïú ÌÖçÏä§Ìä∏ Î∞îÎ°ú Í∑∏ ÏûêÎ¶¨Ïóê Î≥¥Ïó¨Ï§òÏïº Ìï®!!** Îß§Î≤à Í∑ÄÏ∞ÆÍ≤å Î≤ÑÌäº ÎàÑÎ•¥Îäî ÏßìÏùÄ ÌïòÍ≥† Ïã∂ÏßÄ ÏïäÏûñÏïÑ? ÏÜîÏßÅÌûà ÏûÖÎ†•Í≥º Ï∂úÎ†•ÏùÑ Î∂ÑÎ¶¨ÌïòÎäî Í≤å Îçî Ìõ®Ïî¨ Ïâ¨ÏõÄ.
- Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏùºÏñ¥ÎÇòÎäî ÎèÑÏ§ëÏóêÎèÑ Ìé∏ÏßëÏùÑ Î∞©Ìï¥ÌïòÎ©¥ ÏïàÎê®. ÎØ∏ÏÑ∏Ìïú ÎîúÎ†àÏù¥ÎùºÎì†ÏßÄ ÏùòÎèÑÌïòÏßÄ ÏïäÏùÄ Ïª§ÏÑúÏúÑÏπò Î≥ÄÍ≤Ω, ÌïúÍ∏ÄÏûÖÎ†•ÏÉÅÌÉú Î≥µÏõê Îì±Îì±(ÌïúÍ∏ÄÏûÖÎ†•ÏÉÅÌÉú Î≥µÏõê Î∞©Î≤ïÏùÄ ÏóÜÎã§ Î≥¥Î©¥ Îê®. Ïö∞ÌöåÌïòÎäî Î∞©Î≤ïÏùÄ ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏïàÌïòÎäîÍ≤É, ÏµúÏÜåÌïú ÌòÑÏû¨ Ïª§ÏÑúÍ∞Ä ÏúÑÏπòÌïú ÎÖ∏ÎìúÏóê ÎåÄÌï¥ÏÑúÎäî ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏïàÌïòÍ≥† ÎØ∏Î£®Îäî Î∞©Î≤ïÏù¥ Í±∞Ïùò Ïú†ÏùºÌï®).
- ÏóÖÎç∞Ïù¥Ìä∏ÎßàÎã§ DOMÏùÑ ÏôÑÏ†ÑÌûà Ïãπ Í∞àÏïÑÏóéÏßÄ ÎßêÍ≥† Í∞ÄÎä•Ìïú Í≤ΩÏö∞ Í∏∞Ï°¥ ÎÖ∏ÎìúÎì§ÏùÑ Ïû¨ÏÇ¨Ïö©.
- Ìé∏ÏßëÍ∏∞(Í∑∏ÎÉ• Îã®Ïàú `<div contenteditable>`ÏûÑ)Ïùò Í∏∞Î≥∏Ï†ÅÏù∏ Í∏∞Îä•(Î≥µÎ∂ô,undo/redo,...)Îì§ÏùÄ ÎêòÎèÑÎ°ù Î∏åÎùºÏö∞Ï†ÄÏóêÍ≤å ÎÑòÍ∏∏ Í≤É. Ïù¥Îü∞ Í∏∞Îä•Îì§ÏùÄ Ïà®Ïâ¨Í∏∞ÏôÄ Í∞ôÏïÑÏÑú ÏòàÏÉÅÎåÄÎ°ú ÏûëÎèô ÏïàÌïòÎäî ÏàúÍ∞Ñ ÏßúÏ¶ù ÏÜüÍµ¨Ïπ®. ÎòêÌïú ÎÇòÏ≤òÎüº ÍπêÍπêÌïú ÏÇ¨ÎûåÏóêÍ≤å Ïñ¥ÏÉâÌï®Ïù¥ ÏïàÎäêÍª¥ÏßàÎßåÌÅº Ï†úÎåÄÎ°ú Íµ¨ÌòÑÌïòÍ∏∞Îäî ÏâΩÏßÄ ÏïäÏùå(Ïª§ÏÑúÏúÑÏπò, ÌÖçÏä§Ìä∏ÏÑ†ÌÉùÎ≤îÏúÑ, Ïä§ÌÅ¨Î°§ ÏúÑÏπò, ÏñºÎßàÎÇò ÎßéÏùÄ Ìé∏ÏßëÏùÑ ÏñºÎßàÏùò ÎîúÎ†àÏù¥ Í∞ÑÍ≤©ÏúºÎ°ú ÌïòÎÇòÏùò ÌûàÏä§ÌÜ†Î¶¨ ÏóîÌä∏Î¶¨Î°ú Î¨∂ÏùÑ Í≤ÉÏù∏Í∞Ä, Í∑∏Î¶¨Í≥† ÏñëÏ™Ω Ìé∏ÏßëÍ∏∞Î•º ÏôîÎã§Í∞îÎã§ ÌñàÏùÑ Îïå Îì± ÏÉùÍ∞ÅÎ≥¥Îã§ Ïã†Í≤ΩÏì∏ Í≤å ÎßéÏùå. Îã®ÏàúÌûà textÎßå Î≥¥Í¥ÄÌïòÎäî Í≤ÉÏúºÎ°úÎäî Ïñ¥Î¶º ÏóÜÏùå).
- ÏúÑÏôÄ Í∞ôÏùÄ Ïù¥Ïú†Î°ú, Ìé∏ÏßëÍ∏∞ÏôÄ Ïã§Ï†ú diff ÌïòÏù¥ÎùºÏù¥Ìä∏ ÏòÅÏó≠(mirror)ÏùÑ Îî∞Î°ú Í¥ÄÎ¶¨ÌïòÎ©¥ÏÑú 1pxÏùò Ïò§Ï∞® ÏóÜÏù¥ Ï†ïÌôïÌïòÍ≤å Í≤πÏπòÍ≤å ÎßåÎìúÎäî ÏñçÏÇΩÌïú Î∞©Î≤ïÏùÑ ÏîÄ. Ïù¥Í±¥ Í∑∏ÎÉ• ÏÑºÏä§Îã§. editor(see-through) ‚Üí mirror
- ÌÅ¨Í∏∞Í∞Ä ÌÅ∞ ÌÖçÏä§Ìä∏(5ÎßåÍ∏ÄÏûê Ïù¥ÏÉÅ)Î•º ÎπÑÍµêÌï† ÎïåÏóêÎèÑ Ìé∏ÏßëÍ∏∞Í∞Ä **Ï∂©Î∂ÑÌûà(ÏïÑÏ£º Ï∂©Î∂ÑÌûà) Î∞òÏùëÏ†ÅÏùº Í≤É**. ÎîúÎ†àÏù¥ ÏµúÏÜåÌôî! Îã®Ïàú debouncingÏù¥ ÏïÑÎãàÎùº Í∑∏ Ïù¥ÏÉÅÏù¥ ÌïÑÏöî(web worker, RequestIdleCallback, ...)
- Îã§Î•∏ Î¨∏Ïûê(Î¨∏ÏûêcodeÍ∞Ä Îã§Î•∏ Í≤ΩÏö∞)ÏßÄÎßå Í∞ôÎã§Í≥† Ïó¨Í≤®Ïßà Ïàò ÏûàÎäî Í≤ΩÏö∞ÎèÑ Ï≤òÎ¶¨ÌïòÏòÄÏßÄÎßå Ïù¥Í±¥ Ïù¥Îü¨Ìïú Î¨∏ÏûêÎì§ÏùÑ ÏßÅÏ†ë Ï∂îÍ∞ÄÌï¥Ï§òÏïºÌï®(`constants.ts/NORMALIZE_CHARS`).
- (Ï∂îÍ∞Ä),(Ïã†ÏÑ§),(ÌòÑÌñâÍ≥º Í∞ôÏùå),(ÏÇ≠Ï†ú) Îì±ÏùÄ wildcardÎ°ú Ï≤òÎ¶¨. Ïù¥ ÌÜ†ÌÅ∞Îì§ÏùÄ Í¥ÑÌò∏ Ïïà Í≥µÎ∞±ÏùÑ Î¨¥ÏãúÌïòÍ≥† Ï†àÎåÄÎ°ú Ï§ëÍ∞ÑÏóêÏÑú ÏïàÏûòÎ¶¨Í≤å(`(ÌòÑÌñâÍ≥º`,`Í∞ôÏùå)`Ïù¥ ÎêòÏßÄ ÏïäÍ≤å) ÎßåÎì§Ïñ¥ÎÜ®ÏßÄÎßå ÏïÑÏßÅÏùÄ Îî± Í±∞Í∏∞ÍπåÏßÄÏûÑ.
- diff ÌïòÏù¥ÎùºÏù¥Ìä∏ ÏÉâÎì§ÏùÄ Ï†ïÎßê **ÏÑ∏Ïã¨ÌïòÍ≤å Í≥†Î•∏** Í≤ÉÎì§ÏûÑ. Ï†àÎåÄ Î∂àÎßåÏùÑ Í∞ÄÏ†∏ÏÑúÎäî ÏïàÎê®. Îπ®Í∞ÑÏÉâ Í≥ÑÌÜµÏùÄ Î∞∞Í≤ΩÍ≥º ÌôïÏã§Ìûà ÎåÄÎπÑÎêòÏßÄ ÏïäÏùÑ Ïàò ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê ÏùòÎèÑÏ†ÅÏúºÎ°ú Ï†úÏô∏(`constants.ts/DIFF_COLOR_HUES`).
- ÌÅ∞ ÏõåÎìúÎ¨∏ÏÑúÏóêÏÑú Î≥µÎ∂ôÏùÑ Ìï† ÎïåÏóê Î≥µÏÇ¨Í∞Ä Î∞îÎ°ú ÎêòÏßÄ ÏïäÎäî Î¨∏Ï†úÍ∞Ä ÏûàÎäîÎç∞ Ï†àÎåÄÏ†ÅÏúºÎ°ú MSÏõåÎìúÏùò Î¨∏Ï†úÏûÑ. Îê†ÎïåÍπåÏßÄ Î∂ôÏó¨ÎÑ£Í∏∞ ÌïòÎ©¥ Ïñ∏Ï††Í∞ÄÎäî ÎêúÎã§(Í∏∞Îã§Î¶¨Îäî ÎèôÏïà ÏõåÎìúÎäî Î®πÌÜµÎê®).
    - Ï≤òÏùåÏóî Ïù¥Ï†ÑÏóê ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Îì§Ïñ¥ÏûàÎçò ÎÇ¥Ïö©Ïù¥ Î∂ôÏó¨ÎÑ£Í∏∞ Îê®
    - Ïû¨ÏãúÎèÑ(`ctrl-v`) ÌïòÎã§Î≥¥Î©¥ Îπà ÌÖçÏä§Ìä∏Í∞Ä Î∂ôÏó¨ÎÑ£Í∏∞ Îê®
    - Í≥ÑÏÜç... Ïû¨ÏãúÎèÑ(`ctrl-v`)ÌïòÎã§Î≥¥Î©¥ Í≤∞Íµ≠ ÏÑ±Í≥µÌï®.
- Í∞úÏ†ïÎåÄÎπÑÌëúvsÏ†ÑÎ¨∏, Ï†ÑÎ¨∏vsÏ†ÑÎ¨∏, ÏõπÏ†ÑÎ¨∏vsÏ†ÑÎ¨∏ **Ï†ÑÏ≤¥Î•º ÌïúÎ≤à**Ïóê Î≥µ/Î∂ôÌï¥ÏÑú ÎπÑÍµêÌï† Ïàò ÏûàÏñ¥ÏïºÌï®(ÏàòÏã≠Î≤àÏî© ÎìúÎûòÍ∑∏,Î≥µ/Î∂ôÏùÑ ÌïòÎäî Í≤ÉÎ≥¥Îã§Îäî Î¨¥Ï°∞Í±¥ Ìé∏Ìï®!!). Í∑∏ÎûòÏÑú ÎßåÎì†Í≤å  Aligned Mode
- Ïó£ÏßÄ(ÌòπÏùÄ ÌÅ¨Î°¨) Ï†ÑÏö©. Ïù∏Í∞ÑÏ†ÅÏúºÎ°ú 2025ÎÖÑÏóê ieÎ•º Ïôú Ïç®ÏïºÌïòÏßÄ?
- Heading(*1. Í∞úÏöî*, *(Í∞Ä) Ïñ¥Ï©åÍ≥†*, Îì±)ÎèÑ Ï∞æÏïÑÎÇ¥ÏÑú ÏãúÍ∞ÅÏ†Å Í∞ïÏ°∞Î•º Ï£ºÍ∏¥ ÌñàÏßÄÎßå Îî± Í±∞Í∏∞ÍπåÏßÄÏûÑ. Ïï†ÎãπÏ¥à ÏõêÎ≥∏ Î¨∏ÏÑú Íµ¨Ï°∞Í∞Ä ÏóâÎßùÏù¥ÎùºÏÑú 100% Ï†ïÌôïÌïú/ÏùòÎØ∏ ÏûàÎäî headingÏùÑ Ï∂îÏ∂úÌïòÍ∏∞Îäî Ïñ¥Î†§ÏõÄ. Ïñ¥ÏÑ§ÌîÑÍ≤å Î∞òÏùÄ ÎßûÍ≥† Î∞òÏùÄ ÌãÄÎ¶∞ Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌïòÎäî Í≤ÉÎ≥¥Îã§Îäî ÏïÑÏòà Ï†ïÎ≥¥Î•º Ï£ºÏßÄ ÏïäÎäî Í≤ÉÏù¥ ÎÇ´Îã§.
- Î∂ôÏó¨ÎÑ£Í∏∞Îäî plaintextÎßå. html Î∂ôÏó¨ÎÑ£Í∏∞ÎèÑ ÎßåÎì§Ïñ¥ Î¥§ÏßÄÎßå ÎìùÎ≥¥Îã§ Ïã§Ïù¥ ÎßéÏùÄ ÎäêÎÇå(Ïù¥Ï†Ñ Î≤ÑÏ†Ñ ÏΩîÎìú Îí§Ï†∏Î≥¥Î©¥ ÏûàÏùå).
- Ï¢å/Ïö∞ ÌÖçÏä§Ìä∏Í∞Ä ÏôÑÏ†ÑÌûà ÏùºÏπòÌïòÎäî Í≤ΩÏö∞ ÏåçÎë•Ïù¥üë¨Î•º Î≥¥Ïó¨Ï§å. Ïù¥Í±¥ ctrl-cÍ∞Ä Ï†úÎåÄÎ°ú ÏïàÎêòÏóàÍ±∞ÎÇò(ÏÜêÍ∞ÄÎùΩ Ìûò Î∂ÄÏ°±?) ÏõåÎìú Î¨∏Ï†úÎ°ú Î≥µÎ∂ôÏù¥ Ï†úÎåÄÎ°ú ÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞Ïóê ÎÇ¥Í∞Ä ÌôïÏã§Ìûà Ïù∏ÏßÄÌï† Ïàò ÏûàÎèÑÎ°ù ÎÑ£ÏùÄ Í≤ÉÏûÑ. Ïû¨ÎØ∏Î°ú ÎÑ£ÏùÄ Í±∞ ÏïÑÎãò.

### Aligned Mode
- Ïù¥Î¶ÑÏùÄ ÎßòÏóê ÏïàÎì§ÏßÄÎßå ÏïîÌäº ÏñëÏ™Ω ÌÖçÏä§Ìä∏ÏóêÏÑú ÏÑúÎ°ú ÎåÄÎπÑÎêòÎäî Ï§ÑÎì§Ïùò ÏúÑÏπòÎ•º Í∞ôÍ≤å ÎßûÏ∂∞Ï£ºÎäî Í∏∞Îä•. `F2`Î°ú ÌÜ†Í∏Ä.
- ÏñëÏ™Ω Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞ÌôîÎê®.
- readonly Î™®ÎìúÏûÑ(Í∞ÑÎã®Ìïú ÏàòÏ†ïÏùÑ ÏãúÎèÑÌïòÎ©¥ Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ï†ÑÌôòÎêòÎ©¥ÏÑú Î∞îÎ°ú ÏàòÏ†ïÏù¥ Ï†ÅÏö©ÎêòÍ≤åÎäî Ìï¥ÎÜ®Ïùå).
- Aligned ModeÎäî ÍπåÎßå Î∞∞Í≤ΩÏûÑ(ÎßàÏùåÏóê ÏïàÎì§ÏßÄÎßå **Í∏∞Î≥∏ Î™®ÎìúÏôÄ ÌôïÏã§Ìûà ÎåÄÎπÑÎêòÎäî ÎäêÎÇåÏù¥ ÏûàÏñ¥Ïïº ÌñàÏùå**).
- Îëê Î™®ÎìúÎ•º Ï†ÑÌôòÌï†Îïå ÏÑ†ÌÉùÎêú ÌÖçÏä§Ìä∏Ïùò Î≤îÏúÑÎ•º Ïú†ÏßÄÌïòÎ†§Í≥† ÎÖ∏Î†•Ìïú Î∂ÄÎ∂ÑÏùÄ Ïπ≠Ï∞¨ Î∞õÏïÑÏïº Ìï®. ÏÉùÍ∞ÅÎ≥¥Îã§ ÍπåÎã§Î°úÏõÄ(ÏàòÍ≥†ÌñàÏñ¥~).
- Ïª®Ìä∏Î°§ ÌÇ§Î•º ÎàÑÎ•∏Ï±ÑÎ°ú ÌÖçÏä§Ìä∏Î•º ÌÅ¥Î¶≠ÌïòÎ©¥ Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ï†ÑÌôòÎêòÎ©¥ÏÑú ÌÅ¥Î¶≠Ìïú ÏúÑÏπòÎ°ú Ïª§ÏÑúÎ•º ÏòÆÍπÄ(ÏàòÍ≥†ÌñàÏñ¥~).
- ÏñëÏ™Ω diffÎ∂ÄÎ∂ÑÏùÑ Î∏îÎü≠Îã®ÏúÑÎ°ú ÌëúÏãúÌï† Ïàò ÏûàÎäî Í≤ΩÏö∞Îäî Í∑∏Îü¨Î†§Í≥† ÎÖ∏Î†•(!)ÌñàÏùå.
- ÏñëÏ™Ω ÎåÄÎπÑ(Îß§Ïπò)ÎêòÎäî Î∂ÄÎ∂ÑÏùò ÏúÑÏπòÏùò Ï∞®Ïù¥Îäî paddingÏöîÏÜåÎ•º ÎÑ£Ïñ¥ÏÑú Î©îÍøà. TODO: Ïó¨Îü¨Í∞úÏùò ÎπàÏ§ÑÎ°ú Ïù∏Ìï¥ Î∞úÏÉùÌïòÎäî ÏúÑÏπò Ï∞®Ïù¥Îäî paddingÏù¥ ÏïÑÎãàÎùº ÎπàÏ§ÑÎì§ÏùÑ collapseÌïòÎäî Ï™ΩÏúºÎ°ú Ìï¥Ïïº Îçî Î≥¥Í∏∞ Ï¢ãÏùÑ Í≤É Í∞ôÏùå.

### Ïù∏ÌÑ∞ÎÑ∑ÎèÑ ÏïàÎêòÍ≥† ÏïÑÎ¨¥Í≤ÉÎèÑ ÏóÜÎäî... ÏûàÎäî Í±∞ÎùºÍ≥§ Î∏åÎùºÏö∞Ï†Ä, Î©îÎ™®Ïû• Î∞ñÏóê ÏóÜÎäî pcÏóêÏÑú ÎèåÎ†§ÏïºÌï®.
- html + css + jsÎäî Ïñ¥Ï©î Ïàò ÏóÜÎäî ÏÑ†ÌÉù. react? ÍøàÎèÑ Íæ∏ÏßÄÎßà. Ïå©html Ïå©css Ïå©jsÎ°ú Íµ¨ÌòÑ
- ÎãπÏó∞Ìûà ÏõπÏÑúÎ≤Ñ Î∂àÍ∞ÄÎä•Ïù¥Í≥† ÌååÏùºÍ≤ΩÎ°ú(`file:///...../diffseek.html`)Î°ú Ïó¥Ïñ¥ÏïºÌï®. Ï†úÏïΩ ÎßéÏùå.
- ÏÑ¨ÏÑ∏ÌïòÍ≥† Ïù¥ÏÅú UIÏöîÏÜåÍ∞Ä Î∂ÄÏ°±Ìïú Í≤ÉÏùÄ Ï†àÎåÄÏ†ÅÏúºÎ°ú Ïù¥ ÎïåÎ¨∏ÏûÑ. ÏöîÏÉà ÎàÑÍ∞Ä UIÏöîÏÜåÎ•º ÌïòÎÇòÌïòÎÇò ÏÜêÏàò ÎßåÎìúÎÇò...
- ÌÉÄÏûÖÏä§ÌÅ¨Î¶ΩÌä∏Î°ú ÏûëÏÑ±ÌïòÍ≥† Ïª¥ÌååÏùºÎêú jsÎ•º ÏòÆÍ∏∞Îäî Í±¥ Í∞ÄÎä•.
- Îã∑ÎÑ∑, java Îü∞ÌÉÄÏûÑÏùÄ ÍπîÎ†§ÏûàÎäî Í≤É Í∞ôÏßÄÎßå Í∑∏ ÎøêÏûÑ. sdkÍ∞Ä ÏóÜÏùå.
- ÏïÑÎ¨¥Ìäº Ïù¥Îü¨Ï†ÄÎü¨Ìïú Ïù¥Ïú†Î°ú ÏûêÎ∞îÏä§ÌÅ¨Î¶ΩÌä∏Í∞Ä Ïú†ÏùºÌïú ÏòµÏÖòÏù∏Îç∞ ÏÇ¨Ïã§ ÏõπÎ∏åÎùºÏö∞Ï†ÄÏóê ÏùµÏàôÌïòÏßÄ ÏïäÏùÄ ÏÇ¨ÎûåÏùÄ ÏóÜÍ≥† Í∏∞Î≥∏Ï†ÅÏù∏ ÎèôÏûëÎì§ÏùÄ Î™®Îëê Îß§ÎÅÑÎüΩÍ≤å Íµ¨ÌòÑÏù¥ Îã§ ÎêòÏñ¥ÏûàÏúºÎãà Ïñ¥Ï∞åÎ≥¥Î©¥ ÏµúÍ≥†/ÏµúÏÑ†Ïùò ÏÑ†ÌÉùÏûÑ.
- Ïù∏Í∞ÑÏ†ÅÏúºÎ°ú vscodeÏ†ïÎèÑÎäî... Ïì∞Í≥†Ïã∂Îã§.

### ÏßëÏóêÏÑú ÎßåÎì† ÏΩîÎìúÎ•º ÌöåÏÇ¨Î°ú ÏòÆÍ∏∞Îäî Î∞©Î≤ï?
- ÏõåÌÅ¨ÎπÑ Ï™ΩÏßÄ/ÎÇ¥Î∂ÄÎ©îÏùºÎ°ú Î≥¥ÎÇ¥Í≥† ÌöåÏÇ¨ÏóêÏÑú Ïó¥Í≥† Î©îÎ™®Ïû•Ïóê Î∂ôÏó¨ÎÑ£Í∏∞. Í≥†Î°ú ÏΩîÎìúÍ∞Ä ÎÑàÎ¨¥ Ïª§ÏßÄÎ©¥ ÏïàÎê®. Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨? Ïñ¥Î¶ºÎèÑ ÏóÜÏùå.
- Îã§ÌñâÌûàÎèÑ Ìú¥ÎåÄÌè∞ ÏõåÌÅ¨ÎπÑÏï± Î≥¥ÏïàÏùÑ Ïö∞ÌöåÌï¥ÏÑú Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞Î•º ÏÇ¨Ïö©Ìï† Î∞©Î≤ïÏù¥ ÏûàÎçîÎùº(ÎπÑÎ∞Ä Ïú†ÏßÄ ÌïÑÏöî..„Öã Ïù¥Í±∞ ÎßâÌûàÎ©¥ ÎçîÏù¥ÏÉÅÏùò ÏóÖÎç∞Ïù¥Ìä∏Îäî Î∂àÍ∞ÄÎä•Ìï®).
- ÏòÆÍ∏∞Í∏∞ Ï†ÑÏóê ÌïòÎÇòÏùò ÌååÏùº(diffseek.html)Î°ú Ìï©Ïπú ÌõÑÏóê Í∑∏ ÌååÏùºÏùò ÎÇ¥Ïö©ÏùÑ ÏòÆÍ≤®ÏïºÌï®. ÎπåÎìúÎêú ÌååÏùºÏù¥ 4000Ï§ÑÏù¥ ÎÑòÏúºÎãà ÎëêÏñ¥Î≤àÏóê Í±∏Ï≥ê Î≥µÎ∂ô ÌïÑÏöî.
- build, distÌè¥ÎçîÎ•º Î™®Îëê gitÏóê Ìè¨Ìï®Ìïú Í≤ÉÏùÄ Ïù¥Îü¨Ìïú Ïù¥Ïú†ÏûÑ(ÎÇòÎà†ÏÑú Î≥µÎ∂ôÌïòÎã§Í∞Ä ÌïúÎëêÏ§Ñ ÎπºÎ®πÏùÄ Í≤ΩÏö∞Ïóê Ìú¥ÎåÄÌè∞ÏúºÎ°ú githubÏùò ÏΩîÎìúÏôÄ ÎπÑÍµêÌï¥Î¥êÏïºÌï®).
- .tsÎ°úÎ∂ÄÌÑ∞ Ïª¥ÌååÏùºÎêú .jsÌååÏùºÏóê Ï£ºÏÑùÏùÑ ÎÇ®Í≤®ÎëêÎäî Í≤ÉÏùÄ ÌöåÏÇ¨ÏóêÏÑú ÎîîÎ≤ÑÍπÖÏùÑ Ìï¥ÏïºÎêòÎäî Í≤ΩÏö∞Í∞Ä ÏûàÍ∏∞ ÎïåÎ¨∏.
- ÌöåÏÇ¨ÏóêÏÑú ÏàòÏ†ïÌïú Í±∏ ÏßëÏúºÎ°ú Í∞ÄÏ†∏Í∞ÄÎäîÍ±¥ ÏâΩÏßÄ ÏïäÏùå. Ïñ¥Îäê Î∂ÄÎ∂ÑÏùÑ Ïñ¥ÎñªÍ≤å ÏàòÏ†ïÌñàÎäîÏßÄ Í∏∞ÏñµÌñàÎã§Í∞Ä ÏßëÏóêÍ∞ÄÏÑú Îã§Ïãú ÏûëÏóÖÌï¥ÏïºÌï®. Ïò§Îäò Î®πÏùÄ Î∞òÏ∞¨ÎèÑ Í∏∞Ïñµ ÏïàÎÇ®.

### Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïõπ Ï£ºÏÜåÍ∞Ä ÏïÑÎãå ÌååÏùºÏùÑ Ïó¨Îäî Í≤ÉÏù¥Í∏∞ ÎïåÎ¨∏Ïóê Î≥¥ÏïàÏÉÅ Ï†úÏïΩÏù¥ ÎßéÏùå.
- Ïø†ÌÇ§? localStorage? ... ÎãπÏó∞Ìûà Î∂àÍ∞Ä - ÏÉÅÌÉú/ÏòµÏÖò Ï†ÄÏû•ÌïòÎäîÍ±¥ Ï†àÎåÄ Î∂àÍ∞ÄÎä•.
- new Worker(url) - ÌååÏùº urlÏùÑ Ïó¥ Ïàò ÏóÜÏùå(Í∑∏ÎûòÏÑú workerÎ•º Ïì∞Î†§Î©¥ ÏïΩÍ∞ÑÏùò Ìä∏Î¶≠ ÌïÑÏöî)
- Í∑∏ Ïô∏ 'Ïù¥Í≤å Îê†Íπå?' Ïã∂ÏùÄ Í≤ÉÎì§ÏùÄ ÏïàÎêúÎã§Í≥† Î≥¥Î©¥ Îê®
- Ïä§ÌÅ¨Î¶ΩÌä∏Î°ú Î≥µÏÇ¨/Î∂ôÏó¨ÎÑ£Í∏∞Î•º Ïã§ÌñâÌï† ÎïåÏùò Í≤ΩÍ≥†Îäî Ïó£ÏßÄ ÏÑ§Ï†ï-whitelistÏóê Îì±Î°ùÌï¥ÏÑú ÌîºÌï† Ïàò ÏûàÍ∏∞Îäî Ìï®. ÏßÄÍ∏àÏùÄ Í¥ÄÎ†® Í∏∞Îä•Îì§ÏùÑ Îã§ ÏßÄÏõåÎ≤ÑÎ†∏ÏúºÎãàÍπå ÌïÑÏöî ÏóÜÏßÄÎßå Îã§Ïãú ÎÑ£ÏùÑÍπåÌï®(Îã®Ï∂ïÌÇ§Î°ú ÏôºÏ™ΩÏ∞Ω/Ïò§Î•∏Ï™ΩÏ∞Ω ÏÑ†ÌÉùÏóÜÏù¥ Î∞îÎ°ú Î∂ôÏó¨ÎÑ£Í∏∞ Îì±)

### Îã®Ï∂ïÌÇ§?
- F2 - aligned mode ÌÜ†Í∏Ä(ÏñëÏ™Ω Ï§ÑÎßûÏ∂§, Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞Ìôî, Ìé∏Ïßë Î∂àÍ∞Ä)
- SHIFT-F2 - scroll sync ÌÜ†Í∏Ä(ÏïΩÍ∞ÑÏùò Ï§ÑÎßûÏ∂§, ÏïΩÍ∞ÑÏùò Ïä§ÌÅ¨Î°§ ÎèôÍ∏∞Ìôî, Ìé∏Ïßë Í∞ÄÎä•)
- ctrl-1/ctrl-2 Ìé∏ÏßëÍ∏∞Ïóê Ìè¨Ïª§Ïä§
- Ìé∏Ïßë Ï§ëÏóê ctrl-space - Î∞òÎåÄÏ™Ω Ìé∏ÏßëÍ∏∞Ïùò Ïä§ÌÅ¨Î°§ ÏúÑÏπòÎ•º ÌòÑÏû¨ Ìé∏ÏßëÍ∏∞Ïóê ÎßûÏ∂§(Í∞ÄÎä•Ìïú Í≤ΩÏö∞)

### copy mode?
- Ïù¥Í±¥ ÏïÑÏßÅ ÌîÑÎ°úÌÜ†ÌÉÄÏûÖ Îã®Í≥Ñ
- raw: Í∑∏ÎÉ• Î≥¥ÌÜµÏùò ctrl-c
- formatted: - ÏïΩÍ∞ÑÏùò diff ÌïòÏù¥ÎùºÏù¥Ìä∏. ÎìúÎûòÍ∑∏ Î≤îÏúÑÍ∞Ä Ïñ¥ÏÑ§ÌîÑÍ≤å Îã®Ïñ¥ Ï§ëÍ∞ÑÏóêÏÑú ÏãúÏûëÎêòÍ±∞ÎÇò ÎÅùÎÇòÎäî Í≤ΩÏö∞ÏóêÎäî Îã®Ïñ¥Ïùò Í≤ΩÍ≥Ñ(Ï†ïÌôïÌûàÎäî ÌÜ†ÌÅ∞Ïùò Í≤ΩÍ≥Ñ)Î°ú ÎßûÏ∂§
- compare: ÌïúÏ™ΩÏùò ÌÖçÏä§Ìä∏Î•º Î≥µÏÇ¨ÌñàÏùÑ Îïå ÎåÄÏùëÎêòÎäî Î∞òÎåÄÏ™Ω ÌÖçÏä§Ìä∏ÍπåÏßÄ Í∞ôÏù¥ Î≥µÏÇ¨Ìï¥ÏÑú Ìè¨Îß∑Ìï®(*Ï¢å:Í∑∏Îã®Ïñ¥, Ïö∞:Ï†ÄÎã®Ïñ¥*)

### histogram ÏïåÍ≥†Î¶¨Ï¶ò
- Í∞ÄÏû• ÎÑêÎ¶¨ Ïì∞Ïù¥Îäî ÏïåÍ≥†Î¶¨Ï¶ò Ï§ë ÌïòÎÇòÏù∏ Í≤É Í∞ôÏùå...?
- Ïù¥ ÏïåÍ≥†Î¶¨Ï¶òÏóêÏÑú Í∞ÄÏû• Ï§ëÏöîÌïúÍ±¥ ÏïµÏª§(ÏùºÏπòÎêòÎäî Í∏∞Ï§ÄÏ†ê)Î•º Í∑∏Í≤ÉÎèÑ ÏïÑÏ£º Ï¢ãÏùÄÎÜàÏúºÎ°ú Ï∞æÎäî Î∂ÄÎ∂ÑÏù∏ Í≤É Í∞ôÏùÄÎç∞ ÏÉùÍ∞ÅÌï† Í≤ÉÏù¥ ÎßéÏùå. Í∞Å ÏÑπÏÖòÏùò Ï†úÎ™©(1. Í∞úÏöî, 2. ÏóÖÎ¨¥Ï≤òÎ¶¨ ÏàúÏÑú, ...)Ïóê Í∞ÄÏ§ëÏπòÎ•º Ï£ºÎ†§ÌñàÏßÄÎßå Ìï¥Îãπ Ï†úÎ™©Îì§ÏùÄ ÏóÖÎ¨¥Îß§Îâ¥Ïñº ÏõåÎìúÌååÏùºÏóêÏÑú Îß® ÏïûÏóê Ïè†Î†§ÏûàÎäî Í≤ΩÏö∞(Ï†úÎ™©ÏùÑ ÏôºÏ™Ω Ïª¨ÎüºÏóê ÎÑ£Í≥† ÏóîÌÑ∞ÌÇ§ ÏàòÏã≠Î≤à ÎàåÎü¨ÏÑú ÏÑπÏÖòÏùÑ ÎÇòÎàà Í≤ΩÏö∞)Í∞Ä ÎßéÏïÑÏÑú ÏùòÎØ∏ ÏóÜÏùå. (1), (Í∞Ä), 1), Í∞Ä)ÏóêÎäî Ï†ÅÏö©ÌñàÏßÄÎßå ÏñºÎßàÎÇò Ï†ïÌôïÌïòÍ≥† Ìö®Ïú®Ï†ÅÏùºÏßÄ Í∞êÏù¥ ÏïàÏôÄÏÑú Í∞ÄÏ§ëÏπòÎ•º ÎÜíÍ≤å Ï£ºÏßÄ ÏïäÏïòÏùå.
- Í∑∏Ïô∏ Ï§ÑÏùò ÏãúÏûë/ÎÅù Î∂ÄÎ∂ÑÏóê Í∞ÄÏ§ëÏπò, Ìù¨Í∑ÄÎèÑÏóê Í∞ÄÏ§ëÏπò, ÏïµÏª§ Î¨∏ÏûêÏó¥ Í∏∏Ïù¥Ïóê Í∞ÄÏ§ëÏπò.
- ÏµúÏö∞ÏÑ†ÏàúÏúÑ ÏïµÏª§ `@@@`, `###` (Î∞úÍ≤¨Ïãú Î¨¥Ï°∞Í±¥ ÏñëÏ™Ω ÌÖçÏä§Ìä∏Ïóê ÎÇòÏò§Îäî Ïù¥ ÏïµÏª§Îì§ÏùÑ ÏàúÏÑúÎåÄÎ°ú Îß§ÏπòÏãúÌÇ¥). Ï¢åÏö∞ Î¨∏ÏÑúÍ∞Ä ÎÑàÎ¨¥ ÏïàÎßûÏùÑ Îïå Í∞ïÏ†úÎ°ú ÌäπÏ†ïÏúÑÏπòÎ•º Îß§ÏπòÏãúÌÇ§Í≥† Ïã∂ÏùÑ Îïå. Í∏¥ Î¨∏ÏÑú ÎπÑÍµê ÏãúÏóê ÏÑπÏÖò ÎåÄ ÏÑπÏÖòÏù¥ Îß§ÏπòÍ∞Ä Ïûò ÏïàÎê† Í≤ΩÏö∞ Ïì∞Î©¥ Ìé∏Ìï®.
- Îã®ÏàúÌûà Îã®Ïñ¥vsÎã®Ïñ¥ ÎøêÎßå ÏïÑÎãàÎùº nÍ∑∏Îû®(Î≥µÏàòÍ∞úÏùò Îã®Ïñ¥ Îß§Ïπò), nÍ∞úÏùò Îã®Ïñ¥ÏôÄ mÍ∞úÏùò Îã®Ïñ¥(Îã®Ïñ¥ ÏàòÍ∞Ä Îã§Î•¥ÏßÄÎßå Í≥µÎ∞±ÏùÑ Î¨¥ÏãúÌïòÍ≥† ÎπÑÍµêÌï† Í≤ΩÏö∞ Í∞ôÏùÄ Îã®Ïñ¥Îì§)ÎèÑ Îß§ÏπòÎêòÎäî Í≤ΩÏö∞ÏóêÎèÑ ÏïµÏª§Î°ú ÏÇ¨Ïö©ÌïòÎ†§Í≥† ÎÖ∏Î†•...ÏùÄ Ìï®.
- ÎÇ¥ ÏÉùÍ∞ÅÏóê Í≥µÌÜµprefix/suffixÎ•º Ïä§ÌÇµÌïòÎäî Î∂ÄÎ∂Ñ ÎïåÎ¨∏Ïóê ÏµúÍ≥†Î°ú Ï¢ãÏùÄ ÏïµÏª§Î•º Ï∞æÏùÑ Í∏∞ÌöåÎ•º ÎÜìÏπòÎäî Í≤ΩÏö∞ÎèÑ ÏÉùÍ∏∏ Ïàò ÏûàÏùÑ Í≤É Í∞ôÏßÄÎßå Ïä§ÌÇµ ÏïàÌïòÎ©¥ ÏÑ±Îä• Í∞úÌåê Îê®. Ï†àÎåÄÏ†ÅÏúºÎ°ú ÌïÑÏöî.
- ÏùºÏπòÎêòÎäî Îã®Ïñ¥Í∞Ä Îã§Î•¥Îã§Í≥† ÌëúÏãúÎêòÎäî Í≤ΩÏö∞Îäî ÏûàÏùÑ Ïàò ÏûàÏùå(Î¨∏ÏÑú ÎÇ¥Ïóê Í∞ôÏùÄ Îã®Ïñ¥Í∞Ä Ïó¨Îü¨Î≤à ÎÇòÏò§Îäî Í≤ΩÏö∞ Í∑∏ Ï§ë Ïñ¥Îäê Í≤ÉÏóê Îß§ÏπòÏãúÌÇ¨ Í≤ÉÏù∏Í∞ÄÎäî ÏïåÍ≥†Î¶¨Ï¶ò ÎèôÏûëÏóê Îã¨Î†§ÏûàÏùå).
- ÏùºÏπòÎêòÏßÄ ÏïäÎäî Îã®Ïñ¥Í∞Ä Í∞ôÎã§Í≥† ÌëúÏãúÎêòÎäî Í≤ΩÏö∞Îäî ÎãπÏó∞Ìûà ÏóÜÏñ¥ÏïºÌï®(ÏóÜÏùå!).

### DiffSeek.diffOptions
Ï†ïÎßêÎ°ú Ï†ïÎßêÎ°ú really really ÏõêÌïúÎã§Î©¥ Î∏åÎùºÏö∞Ï†Ä devtools ÏΩòÏÜîÏóêÏÑú...
```
DiffSeek.diffOptions = {
    algorithm: "histogram" | "lcs"; // ("histogram")
	tokenization: "char" | "word" | "line"; // ("word")
	whitespace: "ignore" | "normalize"; //("ignore")
	useLengthBias: true | false; //(true)
	maxGram: 4; // 1~5Ï†ïÎèÑÎßå...
	lengthBiasFactor: 0.7; // ÏïµÏª§ Í∏∏Ïù¥Ïóê ÎåÄÌïú Í∞ÄÏ§ëÏπò Ï°∞Ï†ï
	sectionHeadingMultiplier: 1.3333; // 1 / 0.75
	lineStartMultiplier: 1.1764;  // 1 / 0.85
	lineEndMultiplier: 1.1111;  // 1 / 0.9
	uniqueMultiplier: 1.4999; // 1/ 0.6667
}
```
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script>"use strict";
// DIFF ÏÉâ(HUE). 0(Îπ®)ÏùÄ DIFF Î∞∞Í≤ΩÏÉâÏúºÎ°ú Ïì∞Ïù¥Îãà Ìå®Ïä§
// ÏôÑÏ†ÑÌïú ÏÉâÏÉÅ ÏΩîÎìúÎ≥¥Îã§ HUEÎßå ÏÇ¨Ïö©ÌïòÎ©¥ Ïö©ÎèÑÏóê Îî∞Îùº ÏÉâÏùÑ Ï°∞Ï†àÌïòÍ∏∞ Ïâ¨ÏõÄ.
// Ïù∏Ï†ëÌïú ÏÉâÏÉÅÍ≥º ÎÑàÎ¨¥ Í∞ÄÍπùÏßÄ ÏïäÎèÑÎ°ù ÏïÑÏ£º CAREFULÌïòÍ≤å Í≥†Î•∏ ÏàúÏÑú. Í≥ºÌïôÏù¥Îã§.
const DIFF_COLOR_HUES = [
    30, // Ï£ºÌô©?
    180, // cyan
    300, // ÌïëÌÅ¨?
    120, // Ï¥àÎ°ù
    240, // ÌååÎûë
    60, // ÎÖ∏Îûë
    270, // Î≥¥Îùº?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;
const COMPUTE_DEBOUNCE_TIME = 200; // ms
const FORCE_RENDER_TIMEOUT = 100; // ms
const PROCESSING_MESSAGES = [
    "ÌïúÎïÄÌïúÎïÄ ÎπÑÍµê Ï§ë...",
    "Ïù∏ÎÇ¥Ïã¨ ÌÖåÏä§Ìä∏ Ï§ë...",
    "ÏÉùÍ∞Å Ï§ë...",
    "Ïû¨Î∂ÄÌåÖ Ï§ÄÎπÑ Ï§ë...",
    "Î¨¥Ìïú Î£®ÌîÑ Ï§ë...",
    "Î®∏Î¶¨ Í∏ÅÎäî Ï§ë...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "Ìá¥Í∑º Ï§ÄÎπÑ Ï§ë...",
];
const HANGUL_ORDER = "Í∞ÄÎÇòÎã§ÎùºÎßàÎ∞îÏÇ¨ÏïÑÏûêÏ∞®Ïπ¥ÌÉÄÌååÌïòÍ±∞ÎÑàÎçîÎü¨Î®∏Î≤ÑÏÑúÏñ¥Ï†ÄÏ≤òÏª§ÌÑ∞ÌçºÌóà";
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
function findIndexByPos(arr, pos) {
    // binary search
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const item = arr[mid];
        const start = item.pos, end = item.pos + item.len;
        if (start <= pos && pos < end) {
            return mid;
        }
        else if (start > pos) {
            high = mid - 1;
        }
        else if (end <= pos) {
            low = mid + 1;
        }
    }
    return ~low;
}
function getSelectedTokenRange(tokens, startOffset, endOffset) {
    function findTokenIndex(offset, low) {
        let isStart;
        if (low === undefined) {
            isStart = true;
            low = 0;
        }
        else {
            isStart = false;
        }
        let high = tokens.length - 1;
        let result = isStart ? tokens.length : -1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = tokens[mid];
            const tokenEnd = token.pos + token.len;
            if (isStart) {
                const prevEnd = mid > 0 ? tokens[mid - 1].pos + tokens[mid - 1].len : 0;
                if (offset > prevEnd && offset < tokenEnd) {
                    return mid;
                }
                if (mid === 0 && offset >= token.pos && offset < tokenEnd) {
                    return 0;
                }
            }
            else {
                const nextStart = mid + 1 < tokens.length ? tokens[mid + 1].pos : Infinity;
                if (offset >= token.pos && offset < nextStart) {
                    return mid;
                }
            }
            if (isStart) {
                if (token.pos >= offset) {
                    result = mid;
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            else {
                if (tokenEnd < offset) {
                    result = mid;
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
        }
        return result;
    }
    const startIndex = findTokenIndex(startOffset);
    const endIndex = findTokenIndex(endOffset - 1, startIndex);
    return [startIndex, endIndex + 1]; // [inclusive, exclusive]
}
function findDiffEntryRangeByPos(entries, side, pos, endPos) {
    console.log("findDiffEntryRangeByPos", { entries, side, pos, endPos });
    let low = 0;
    let high = entries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (pos < s.pos) {
            high = mid - 1;
        }
        else if (pos >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = mid;
            break;
        }
    }
    low = mappedStart;
    high = entries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (endPos - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endPos - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = mid + 1;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function mapTokenRangeToOtherSide(rawEntries, side, startIndex, endIndex) {
    const otherSide = side === "left" ? "right" : "left";
    let low = 0;
    let high = rawEntries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (startIndex < s.pos) {
            high = mid - 1;
        }
        else if (startIndex >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = rawEntries[mid][otherSide].pos;
            low = mid; // reuse for mappedEnd search
            break;
        }
    }
    high = rawEntries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (endIndex - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endIndex - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function buildOutputHTMLFromRuns(text, textRuns, options) {
    let inDiff = false;
    let result = options.htmlPre ? "<pre>" : "";
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            const diffIndex = run.dataIndex;
            // result += "<mark>";
            const color = DIFF_COLOR_HUES[diffIndex % DIFF_COLOR_HUES.length];
            result += `<mark style="background-color: hsl(${color}, 100%, 80%);">`;
            inDiff = true;
        }
        else if (run.type === "DIFF_END") {
            if (inDiff) {
                // result += "</mark>";
                result += "</mark>";
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += escapeHTML(text.slice(run.pos, run.pos + run.len));
        }
        else if (run.type === "LINEBREAK") {
            result += "<br/>";
        }
    }
    if (inDiff)
        result += "</mark>";
    if (options.htmlPre)
        result += "</pre>";
    // result += "<br/>";
    return result;
}
function buildOutputPlainText(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const leftBody = buildOutputPlainTextFromRuns(leftText, leftRuns, options);
    const rightBody = buildOutputPlainTextFromRuns(rightText, rightRuns, options);
    return `${leftLabel}: ${leftBody}\n${rightLabel}: ${rightBody}\n`;
}
function buildOutputPlainTextFromRuns(text, textRuns, options) {
    const format = options.textFormat ?? 0;
    let result = "";
    let inDiff = false;
    let markStart;
    let markEnd;
    if (format === 1) {
        markStart = "**";
        markEnd = "**";
    }
    else if (format === 2) {
        markStart = "[[ ";
        markEnd = " ]]";
    }
    else {
        markStart = "";
        markEnd = "";
    }
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            if (format !== 0 && !inDiff) {
                result += markStart;
                inDiff = true;
            }
        }
        else if (run.type === "DIFF_END") {
            if (format !== 0 && inDiff) {
                result += markEnd;
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += text.slice(run.pos, run.pos + run.len);
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inDiff && format !== 0)
        result += markEnd;
    return result;
}
function buildOutputHTML(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const htmlFormat = options.htmlFormat ?? "div";
    if (htmlFormat === "table") {
        // Default: table format
        return `<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr><th>${escapeHTML(leftLabel)}</th><th>${escapeHTML(rightLabel)}</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></td>
      <td><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></td>
    </tr>
  </tbody>
</table>`.trim();
    }
    if (htmlFormat === "dl") {
        return `<dl>
  <dt>${escapeHTML(leftLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></dd>
  <dt>${escapeHTML(rightLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></dd>
</dl>`.trim();
    }
    return `<div>
<div><strong>${escapeHTML(leftLabel)}:</strong> ${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</div>
<div><strong>${escapeHTML(rightLabel)}:</strong> ${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</div>
</div>`.trim();
}
function escapeHTML(str) {
    return str.replace(/[&<>"]|'/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#039;";
            default:
                return char;
        }
    });
}
function parseOrdinalNumber(ordinalText) {
    const norm = ordinalText.replace(/[\(\)\.]/g, "");
    if (/^\d+$/.test(norm)) {
        return Number(norm);
    }
    const idx = HANGUL_ORDER.indexOf(norm);
    if (idx !== -1) {
        return idx + 1;
    }
    return NaN;
}
function findFirstNodeAfter(root, after) {
    let current = after;
    while (current && current !== root) {
        if (current.nextSibling) {
            return current.nextSibling;
        }
        else {
            current = current.parentNode;
        }
    }
    return null;
}
function getTextOffsetOfNode(root, node, end = false) {
    const filter = node.nodeType === 3 ? NodeFilter.SHOW_TEXT : NodeFilter.SHOW_ALL;
    let walker = document.createTreeWalker(root, filter, null);
    let pos = 0;
    let currentNode;
    while ((currentNode = walker.nextNode())) {
        if (currentNode === node && !end) {
            break;
        }
        if (currentNode.nodeType === 3) {
            pos += currentNode.nodeValue.length;
        }
        if (currentNode === node && end) {
            break;
        }
    }
    return pos;
}
// #region by ChatGTP
function insertFragmentSmart(fragment, hasBlockElements) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
        return;
    const range = selection.getRangeAt(0);
    // Ïª§ÏÑúÍ∞Ä ÏûàÎäî Í∞ÄÏû• Í∞ÄÍπåÏö¥ p Ï∞æÍ∏∞
    const pEl = getClosestElement(range.startContainer, "p");
    if (!hasBlockElements) {
        // Î∏îÎ°ù ÏöîÏÜå ÏóÜÏúºÎ©¥ Í∑∏ÎÉ• ÏÇΩÏûÖ
        insertAtRange(range, fragment);
        return;
    }
    console.log("p???", pEl);
    if (pEl) {
        // pÍ∞Ä ÏûàÏúºÎ©¥ p Í∏∞Ï§ÄÏúºÎ°ú Ï™ºÍ∞úÍ∏∞ + Ïù∏ÎùºÏù∏ÎèÑ Ï™ºÍ∞úÍ∏∞
        splitAncestorsAtRange(range, pEl);
        // p Îã§Ïãú Ï∞æÍ∏∞ (split ÌñàÏúºÎãà)
        const newP = getClosestElement(range.startContainer, "p");
        if (!newP) {
            insertAtRange(range, fragment);
            return;
        }
        // p ÏïûÎí§ ÎÇòÎàÑÍ≥† fragment ÏÇΩÏûÖ
        splitAndInsert(range, newP, fragment);
    }
    else {
        // p ÏóÜÏúºÎ©¥ Ïù∏ÎùºÏù∏ ÏöîÏÜåÎì§Îßå Ï™ºÍ∞úÍ≥† fragment ÏÇΩÏûÖ
        splitAncestorsAtRange(range, null);
        // Í∑∏ÎÉ• ÏÇΩÏûÖ
        insertAtRange(range, fragment);
    }
}
function splitAndInsert(range, p, fragment) {
    // p ÎÇ¥Î∂Ä ÌÖçÏä§Ìä∏ÏôÄ Ïù∏ÎùºÏù∏ ÏöîÏÜåÎßå Ï™ºÍ∞úÍ∏∞
    const beforeFragment = document.createDocumentFragment();
    const afterFragment = document.createDocumentFragment();
    // p ÏûêÏãù ÎÖ∏Îìú ÏàúÌöåÌïòÎ©∞ Ïª§ÏÑú ÏúÑÏπò Í∏∞Ï§ÄÏúºÎ°ú before/after Î∂ÑÎ¶¨
    let passedCursor = false;
    p.childNodes.forEach((node) => {
        if (!passedCursor) {
            // Ïª§ÏÑú Ïù¥Ï†Ñ ÎÖ∏ÎìúÎ©¥ beforeFragmentÏóê Î≥µÏÇ¨
            if (node === range.startContainer || node.contains(range.startContainer)) {
                // Ïª§ÏÑúÍ∞Ä Ïù¥ ÎÖ∏Îìú ÏïàÏóê ÏûàÏúºÎ©¥ ÌÖçÏä§Ìä∏ Ï™ºÍ∞úÍ∏∞
                if (node.nodeType === Node.TEXT_NODE) {
                    const textNode = node;
                    const beforeText = textNode.textContent.slice(0, range.startOffset);
                    const afterText = textNode.textContent.slice(range.startOffset);
                    if (beforeText)
                        beforeFragment.appendChild(document.createTextNode(beforeText));
                    if (afterText)
                        afterFragment.appendChild(document.createTextNode(afterText));
                }
                else {
                    // Ïª§ÏÑúÍ∞Ä Ïù∏ÎùºÏù∏ ÏöîÏÜå ÏïàÏóê ÏûàÏúºÎ©¥ Î≥ÑÎèÑ Ï≤òÎ¶¨ (Ïû¨Í∑Ä Îì±)
                    // Í∞ÑÎã®Ìûà ÏùºÎã® Ï†ÑÏ≤¥ ÎÖ∏ÎìúÎäî afterFragmentÎ°ú
                    afterFragment.appendChild(node.cloneNode(true));
                }
                passedCursor = true;
            }
            else {
                beforeFragment.appendChild(node.cloneNode(true));
            }
        }
        else {
            afterFragment.appendChild(node.cloneNode(true));
        }
    });
    // ÏÉà p ÏöîÏÜå ÏÉùÏÑ± (Ï§ëÏ≤© Î∞©ÏßÄ)
    const pBefore = document.createElement("p");
    pBefore.appendChild(beforeFragment);
    const pAfter = document.createElement("p");
    pAfter.appendChild(afterFragment);
    // p ÍµêÏ≤¥
    const parent = p.parentNode;
    parent.insertBefore(pBefore, p);
    parent.insertBefore(fragment, p);
    parent.insertBefore(pAfter, p);
    parent.removeChild(p);
    moveCursorAfterNode(window.getSelection(), fragment);
}
function getClosestElement(node, tagName) {
    if (node.nodeType === Node.ELEMENT_NODE) {
        return node.closest(tagName);
    }
    if (node.parentElement) {
        return node.parentElement.closest(tagName);
    }
    return null;
}
function insertAtRange(range, fragment) {
    const selection = window.getSelection();
    range.deleteContents();
    range.insertNode(fragment);
    moveCursorAfterNode(selection, fragment);
}
function moveCursorAfterNode(selection, fragment) {
    const lastNode = fragment.lastChild;
    if (!lastNode)
        return;
    const newRange = document.createRange();
    newRange.setStartAfter(lastNode);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
}
/**
 * Ïù∏ÏûêÎ°ú Î∞õÏùÄ Î≤îÏúÑ Í∏∞Ï§ÄÏúºÎ°ú,
 * stopAtÏù¥ ÏûàÏúºÎ©¥ Í∑∏ ÏöîÏÜåÍπåÏßÄ,
 * ÏóÜÏúºÎ©¥ ÏµúÏÉÅÏúÑ Ïù∏ÎùºÏù∏ ÏöîÏÜåÍπåÏßÄ
 * Î™®Îëê Ï™ºÍ∞≠ÎãàÎã§.
 */
function splitAncestorsAtRange(range, stopAt) {
    let currentNode = range.startContainer;
    let offset = range.startOffset;
    // ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÎ©¥ splitText
    if (currentNode.nodeType === Node.TEXT_NODE) {
        const textNode = currentNode;
        if (offset > 0 && offset < textNode.length) {
            const afterText = textNode.splitText(offset);
            range.setStart(afterText, 0);
            range.setEnd(afterText, 0);
            currentNode = afterText;
            offset = 0;
        }
    }
    while (currentNode.parentNode && currentNode.parentNode !== stopAt) {
        const parent = currentNode.parentNode;
        // stopAt Ïù¥ nullÏù¥Î©¥ p ÏóÜÎäî ÏÉÅÌô©Ïù¥Îãà,
        // inline ÏöîÏÜåÎßå Ï™ºÍ∞úÏïº Ìï®
        if (BLOCK_ELEMENTS[parent.nodeName])
            break;
        // if (stopAt === null && !INLINE_ELEMENTS[parent.nodeName]) {
        // 	break;
        // }
        // console.log("not stopped", { parent, stopAt });
        const index = Array.prototype.indexOf.call(parent.childNodes, currentNode);
        const afterSiblings = Array.prototype.slice.call(parent.childNodes, index + 1);
        const newParent = parent.cloneNode(false);
        afterSiblings.forEach((node) => newParent.appendChild(node));
        // console.log(newParent)
        parent.parentNode.insertBefore(newParent, parent.nextSibling);
        currentNode = parent;
    }
}
//#endregion by ChatGTP
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
const STYLE_NONE = 0;
const STYLE_COLOR_RED = 1;
const STYLE_MASK_COLOR = STYLE_COLOR_RED;
const reddishCache = new Map([
    ["red", true],
    ["#ff0000", true],
    ["#e60000", true],
    ["#c00000", true],
    ["rgb(255,0,0)", true],
    ["rgb(230,0,0)", true],
    ["#000000", false],
    ["#333333", false],
    ["#ffffff", false],
    ["black", false],
    ["blue", false],
    ["white", false],
    ["window", false],
    ["windowtext", false],
]);
let _ctx = null;
// Ï∫îÎ≤ÑÏä§Îäî ÎßéÏù¥ ÎäêÎ¶¥ÌÖåÎãàÍπå ÏµúÎåÄÌïú Ï†ïÍ∑úÏãùÏùÑ Ïö∞ÏÑ† ÏîÄ!
// Ï†ïÍ∑úÏãùÏùÄ ÏàòÎ™ÖÎã®Ï∂ïÏùò ÏßÄÎ¶ÑÍ∏∏Ïù¥ÎØÄÎ°ú Ï†àÎåÄÏ†ÅÏúºÎ°ú chatgtpÌïúÌÖå Îß°Í∏∞Í≥† ÎààÍ∏∏ Ï°∞Ï∞® Ï£ºÏßÄ Îßê Í≤É.
function getRGB(color) {
    // #rrggbb
    const hex6 = /^#([0-9a-f]{6})$/i.exec(color);
    if (hex6) {
        const n = parseInt(hex6[1], 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    // #rgb
    const hex3 = /^#([0-9a-f]{3})$/i.exec(color);
    if (hex3) {
        const [r, g, b] = hex3[1].split("").map((c) => parseInt(c + c, 16));
        return [r, g, b];
    }
    // rgb(...) / rgba(...)
    const rgb = /^rgba?\(([^)]+)\)$/i.exec(color);
    if (rgb) {
        const parts = rgb[1].split(",").map((s) => parseInt(s.trim(), 10));
        if (parts.length >= 3)
            return [parts[0], parts[1], parts[2]];
    }
    // fallback: canvas. ÏïÑÎßàÎèÑ ÎßéÏù¥ ÎäêÎ¶¥ Í≤É...
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    try {
        _ctx.clearRect(0, 0, 1, 1);
        _ctx.fillStyle = color;
        _ctx.fillRect(0, 0, 1, 1);
        const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
        return [r, g, b];
    }
    catch {
        return null;
    }
}
function isReddish(color) {
    let isRed = reddishCache.get(color);
    if (isRed !== undefined)
        return isRed;
    console.log("no cache hit", color);
    const rgb = getRGB(color);
    isRed = rgb ? rgb[0] >= 139 && rgb[0] - Math.max(rgb[1], rgb[2]) >= 65 : false;
    reddishCache.set(color, isRed);
    return isRed;
}
const BLOCK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
    //TD: true,
    "#document-fragment": true,
};
const INLINE_ELEMENTS = {
    SPAN: true,
    A: true,
    B: true,
    I: true,
    U: true,
    EM: true,
    STRONG: true,
    S: true,
    STRIKE: true,
    SUB: true,
    SUP: true,
    SMALL: true,
    BIG: true,
    MARK: true,
    INS: true,
    DEL: true,
    CODE: true,
    KBD: true,
    SAMP: true,
    VAR: true,
    DFN: true,
    ABBR: true,
    TIME: true,
    CITE: true,
    Q: true,
    LABEL: true,
};
const LINEBREAK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
};
const TEXTLESS_ELEMENTS = {
    HR: true,
    BR: true,
    IMG: true,
    VIDEO: true,
    AUDIO: true,
    EMBED: true,
    OBJECT: true,
    CANVAS: true,
    SVG: true,
    TABLE: true,
    THEAD: true,
    TBODY: true,
    TFOOT: true,
    TR: true,
    OL: true,
    UL: true,
    DL: true,
    STYLE: true,
    HEAD: true,
    TITLE: true,
    SCRIPT: true,
    LINK: true,
    META: true,
    BASE: true,
    AREA: true,
    "#document-fragment": true,
};
const EXCLUDED_HTML_TAGS = {
    SCRIPT: 1,
    STYLE: 1,
    IFRAME: 1,
    OBJECT: 1,
    EMBED: 1,
    LINK: 1,
    META: 1,
    BASE: 1,
    APPLET: 1,
    FRAME: 1,
    FRAMESET: 1,
    NOSCRIPT: 1,
    SVG: 1,
    MATH: 1,
    TEMPLATE: 1,
    HEAD: 1,
};
const EMPTY_ATTRS = {};
const ALLOWED_CONTAINER_TAGS = {
    TABLE: EMPTY_ATTRS,
    TBODY: EMPTY_ATTRS,
    THEAD: EMPTY_ATTRS,
    TFOOT: EMPTY_ATTRS,
    CAPTION: EMPTY_ATTRS,
    TR: EMPTY_ATTRS,
    TH: { colspan: true, rowspan: true },
    TD: { colspan: true, rowspan: true },
    H1: EMPTY_ATTRS,
    H2: EMPTY_ATTRS,
    H3: EMPTY_ATTRS,
    H4: EMPTY_ATTRS,
    H5: EMPTY_ATTRS,
    H6: EMPTY_ATTRS,
    SUP: EMPTY_ATTRS,
    SUB: EMPTY_ATTRS,
    EM: EMPTY_ATTRS,
    I: EMPTY_ATTRS,
    S: EMPTY_ATTRS,
    B: EMPTY_ATTRS,
    STRONG: EMPTY_ATTRS,
    U: EMPTY_ATTRS,
    STRIKE: EMPTY_ATTRS,
    P: EMPTY_ATTRS,
    UL: EMPTY_ATTRS,
    OL: EMPTY_ATTRS,
    LI: EMPTY_ATTRS,
    DL: EMPTY_ATTRS,
    DT: EMPTY_ATTRS,
    DD: EMPTY_ATTRS,
    DIV: EMPTY_ATTRS,
    HEADER: EMPTY_ATTRS,
    FOOTER: EMPTY_ATTRS,
    SECTION: EMPTY_ATTRS,
    ARTICLE: EMPTY_ATTRS,
    ASIDE: EMPTY_ATTRS,
    BLOCKQUOTE: EMPTY_ATTRS,
    ADDRESS: EMPTY_ATTRS,
    //"#document-fragment": EMPTY_ATTRS,
};
const TEXT_FLOW_CONTAINERS = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
function customTrim(str) {
    return str.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
}
function coerceColor(color) {
    if (isReddish(color)) {
        return "red";
    }
    return undefined;
}
// Ï°∞Í±¥ ÏãúÏûë Ï†ïÍ∑úÏãù (Ï£ºÏÑù Ïú†Î¨¥ ÏÉÅÍ¥ÄÏóÜÏù¥, [if ...]> ÎòêÎäî <![if ...]> Î™®Îëê Ìè¨Í¥Ñ)
const ifRegex = /(?:<!--)?<?!?\[if\s+([^\]]+?)\]>?/gi;
// Ï°∞Í±¥ Ï¢ÖÎ£å Ï†ïÍ∑úÏãù
const endifRegex = /<!\[endif\](?:-->|\])?/i;
/**
 * input: ÌååÏã±Ìï† Ï†ÑÏ≤¥ Î¨∏ÏûêÏó¥
 * start: ÌååÏã± ÏãúÏûë ÏúÑÏπò (Î¨¥Ï°∞Í±¥ [if ...]Í∞Ä ÏãúÏûëÌïòÎäî ÏúÑÏπòÏó¨Ïïº Ìï®)
 *
 * returns: [Ï°∞Í±¥Î∂Ä Î∏îÎ°ù, Ï¢ÖÎ£å ÏúÑÏπò]
 */
function parseIfBlock(input, start) {
    ifRegex.lastIndex = start;
    const ifMatch = ifRegex.exec(input);
    if (!ifMatch || ifMatch.index !== start) {
        console.error("parseIfBlock must start at an [if] condition", { ifMatch, start, input });
        throw new Error("parseIfBlock must start at an [if] condition");
    }
    const condition = ifMatch[1].trim();
    let cursor = ifRegex.lastIndex;
    const children = [];
    while (cursor < input.length) {
        ifRegex.lastIndex = cursor;
        endifRegex.lastIndex = cursor;
        const nextIf = ifRegex.exec(input);
        const nextEndIf = endifRegex.exec(input);
        if (nextEndIf && (!nextIf || nextEndIf.index < nextIf.index)) {
            // endifÍ∞Ä Î®ºÏ†Ä ÎÇòÏò§Î©¥ ÌòÑÏû¨ Ï°∞Í±¥ Ï¢ÖÎ£å
            if (nextEndIf.index > cursor) {
                const text = input.slice(cursor, nextEndIf.index);
                if (text.trim())
                    children.push(text);
            }
            cursor = nextEndIf.index + nextEndIf[0].length;
            return [{ condition, children }, cursor];
        }
        if (nextIf && nextIf.index === cursor) {
            // Ï§ëÏ≤©Îêú if Ï°∞Í±¥ ÌååÏã± Ïû¨Í∑Ä Ìò∏Ï∂ú
            console.log("parseIfBlock called at pos:", start);
            console.log("String at start:", input.slice(start, start + 20));
            const [childBlock, newPos] = parseIfBlock(input, cursor);
            children.push(childBlock);
            cursor = newPos;
            continue;
        }
        // ÏùºÎ∞ò ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú (Îã§Ïùå Ï°∞Í±¥Î¨∏ ÌòπÏùÄ endifÍπåÏßÄ)
        let nextPos = input.length;
        if (nextIf)
            nextPos = Math.min(nextPos, nextIf.index);
        if (nextEndIf)
            nextPos = Math.min(nextPos, nextEndIf.index);
        const text = input.slice(cursor, nextPos);
        if (text.trim())
            children.push(text);
        cursor = nextPos;
    }
    throw new Error("Missing matching [endif]");
}
function sanitizeHTML(rawHTML) {
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length);
        }
    }
    const tmpl = document.createElement("template");
    tmpl.innerHTML = rawHTML;
    let flags = 0;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "üñºÔ∏è";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(tmpl.content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return result;
}
function sanitizeNode(content) {
    let hasBlockElements = false;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "üñºÔ∏è";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        else if (!hasBlockElements && BLOCK_ELEMENTS[containerNode.nodeName]) {
            hasBlockElements = true;
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return [result, hasBlockElements];
}
//# sourceMappingURL=sanitize.js.map
</script>
<script>"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const LINE_START = 1 << 0; // 1
const LINE_END = 1 << 1; // 2
const CONTAINER_START = 1 << 2; // 4
const CONTAINER_END = 1 << 3; // 8
const NO_JOIN = 1 << 4; // @@@, ### Îì±Îì± // 16
const WILD_CARD = 1 << 5;
const MANUAL_ANCHOR = 1 << 6; // 32. @@@, ### Îì±Îì±
const IMAGE = 1 << 7;
const SECTION_HEADING_BIT = 10;
const SECTION_HEADING_TYPE1 = 1 << (SECTION_HEADING_BIT + 0); // 1.
const SECTION_HEADING_TYPE2 = 1 << (SECTION_HEADING_BIT + 1); // Í∞Ä.
const SECTION_HEADING_TYPE3 = 1 << (SECTION_HEADING_BIT + 2); // (1)
const SECTION_HEADING_TYPE4 = 1 << (SECTION_HEADING_BIT + 3); // (Í∞Ä)
const SECTION_HEADING_TYPE5 = 1 << (SECTION_HEADING_BIT + 4); // 1)
const SECTION_HEADING_TYPE6 = 1 << (SECTION_HEADING_BIT + 5); // Í∞Ä)
const LINE_BOUNDARY = LINE_START | LINE_END;
const CONTAINER_BOUNDARY = CONTAINER_START | CONTAINER_END;
const SECTION_HEADING_MASK = SECTION_HEADING_TYPE1 | SECTION_HEADING_TYPE2 | SECTION_HEADING_TYPE3 | SECTION_HEADING_TYPE4 | SECTION_HEADING_TYPE5 | SECTION_HEADING_TYPE6;
// const normalizeChars: { [ch: string]: string } = {};
// text flow containers?
const containerElements = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
const spaceChars = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // Í∏ÄÏéÑ...
    "\f": true, // Ïù¥Í≤ÉÎì§ÏùÄ...
    "\v": true, // Î≥ºÏùºÏù¥ ÏóÜÏùÑÍ≤É...
    "\u00A0": true, // &nbsp; ??
};
const splitChars = {
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
};
const normalizedCharMap = ((normChars) => {
    const result = {};
    let parser;
    function htmlEntityToChar(entity) {
        const doc = (parser = parser || new DOMParser()).parseFromString(entity, "text/html");
        const char = doc.body.textContent;
        if (char.length !== 1) {
            throw new Error("htmlEntityToChar: not a single character entity: " + entity);
        }
        return char;
    }
    for (const entry of normChars) {
        const [norm, ...variants] = entry;
        for (const variant of variants) {
            if (typeof variant === "number") {
                result[String.fromCharCode(variant)] = norm;
            }
            else if (typeof variant === "string") {
                if (variant.length === 1 || (variant.length === 2 && variant.charCodeAt(0) >= 0xd800)) {
                    result[variant] = norm;
                }
                else if (variant[0] === "&") {
                    result[htmlEntityToChar(variant)] = norm;
                }
            }
        }
    }
    return result;
})([
    ['"', "‚Äú", "‚Äù", "'", "‚Äò", "‚Äô"], // ÎπÑÏ¶àÌîåÎû´Ìèº Ìé∏ÏßëÍ∏∞ÏóêÏÑú ÏûëÏùÄÎî∞Ïò¥ÌëúÎ•º ÌÅ∞Îî∞Ïò¥ÌëúÎ°ú Î∞îÍæ∏Ïñ¥Î≤ÑÎ¶º. WHY?
    ["-", "‚Äê", "‚Äë", "‚Äí", "‚Äì", "Ôπò", "‚Äî", "Ôºç"],
    [".", "‚Ä§", "Ôºé"],
    [",", "Ôºå"],
    ["‚Ä¢", "‚óè"], // Ïù¥Í±∏ Ï§ëÍ∞ÑÏ†ê Ïö©ÎèÑÎ°ú Ïì∞Îäî ÏÇ¨ÎûåÎì§ÏùÄ Ï†ïÎßê Í∞àÏïÑÎßàÏÖîÏïºÎêúÎã§. ÎèÑÏ†ÄÌûà Ïö©ÎÇ©Ìï¥Ï§Ñ Ïàò ÏóÜÍ≥† Í∞ôÏùÄ Î¨∏ÏûêÎ°ú Ïù∏ÏãùÌïòÍ≤å ÎßåÎì§Í≥† Ïã∂ÏßÄ ÏïäÎã§.
    ["‚ó¶", "‚óã", "„Öá"], // ÏûêÏùå "Ïù¥Ïùë"ÏùÑ Ïì∞Îäî ÏÇ¨ÎûåÎì§ÎèÑ Í∞úÏù∏Ï†ÅÏúºÎ°ú Ïù¥Ìï¥Í∞Ä ÏïàÎêòÏßÄÎßå ÎßéÎçîÎùº.
    ["‚ñ†", "‚ñ™", "‚óº"],
    ["‚ñ°", "‚ñ´", "‚óª", "„ÖÅ"],
    ["¬∑", "‚ãÖ", "‚àô", "„Üç", "‚Äß"], // Ïú†ÎãàÏΩîÎìúÎ•º ÎßåÎì† ÏßëÎã®ÏùÄ ÎèÑÎåÄÏ≤¥ Î¨¥Ïä® ÏÉùÍ∞ÅÏù¥ÏóàÎçòÍ±∏Íπå?...
    ["‚Ä¶", "‚ãØ"],
    ["(", "Ôºà"],
    [")", "Ôºâ"],
    ["[", "Ôºª"],
    ["]", "ÔºΩ"],
    ["{", "ÔΩõ"],
    ["}", "ÔΩù"],
    ["<", "Ôºú"],
    [">", "Ôºû"],
    ["=", "Ôºù"],
    ["+", "Ôºã"],
    ["*", "Ôºä", "‚ú±", "√ó", "‚àó"],
    ["/", "Ôºè", "√∑"],
    ["\\", "‚Ç©"], // ÏïÑÎßàÎèÑ ÏõêÌôî Í∏∞Ìò∏Î°ú ÏÇ¨Ïö©ÌñàÍ≤†ÏßÄ
    ["&", "ÔºÜ"],
    ["#", "ÔºÉ"],
    ["@", "Ôº†"],
    ["$", "ÔºÑ"],
    ["%", "ÔºÖ"],
    ["^", "Ôºæ"],
    ["~", "ÔΩû"],
    ["`", "ÔΩÄ"],
    ["|", "ÔΩú"],
    [":", "Ôºö"],
    [";", "Ôºõ"],
    ["?", "Ôºü"],
    ["!", "ÔºÅ"],
    ["_", "Ôºø"],
    ["‚Üí", "‚áí", "‚û°", "‚ûî", "‚ûû", "‚ûü"],
    ["‚Üê", "‚áê", "‚¨Ö", "‚üµ", "‚ü∏"],
    ["‚Üë", "‚áë", "‚¨Ü"],
    ["‚Üì", "‚áì", "‚¨á"],
    ["‚Üî", "‚áî"],
    ["‚Üï", "‚áï"],
]);
const TOKEN_CACHE_SIZE = 2;
const tokenCache = {
    ["char"]: [],
    ["word"]: [],
    ["line"]: [],
};
// wildcards.
// Ïù¥Í±∏ Ïñ¥ÎñªÍ≤å Íµ¨ÌòÑÌï¥ÏïºÌï†ÏßÄ Í∞êÏù¥ ÏïàÏò§ÏßÄÎßå ÏßÄÍ∏àÏúºÎ°úÏç®Îäî ÏñòÎÑ§Îì§ÏùÑ atomicÌïòÍ≤å Ï∑®Í∏â(ÏÇ¨Ïù¥Ïóê Í≥µÎ∞±Ïù¥ ÏûàÏñ¥ÎèÑ ÌïòÎÇòÏùò ÌÜ†ÌÅ∞ÏúºÎ°ú ÎßåÎì¨. '(ÌòÑÌñâÍ≥º Í∞ôÏùå)'ÏóêÏÑú ÏùºÎ∂ÄÎ∂ÑÎßå Îß§ÏπòÎêòÎäî Í≤ÉÏùÑ Î∞©ÏßÄ)
// Í∏ÄÏûêÎã®ÏúÑÎ°ú ÌÜ†ÌÅ∞ÌôîÌïòÎäî Í≤ΩÏö∞ÏóêÎèÑ ÏñòÎÑ§Îì§ÏùÄ (...) ÌÜµÏ±ÑÎ°ú ÌïòÎÇòÏùò ÌÜ†ÌÅ∞ÏúºÎ°ú Ï∑®Í∏â.
// ÏôÄÏùºÎìúÏπ¥ÎìúdiffÏù∏ Í≤ΩÏö∞ Îã§Î•∏ diffÏôÄ Î≥ëÌï©ÎêòÏßÄ ÏïäÏúºÎ©¥ Ï¢ãÏßÄÎßå ÏôÄÏùºÎìúÏπ¥ÎìúÍ∞Ä ÏñºÎßàÎÇò greedyÌïòÍ≤å Î∞òÎåÄÏ™Ω ÌÖçÏä§Ìä∏Î•º Ïû°ÏïÑÎ®πÏñ¥Ïïº Ìï†ÏßÄ
// ÏñëÏ™ΩÏóê wildcardÍ∞Ä ÎèôÏãúÏóê ÎÇòÏò§Îäî Í≤ΩÏö∞ Í≤ΩÍ≥ÑÎ•º Ïñ¥ÎîîÏÑú Ïñ¥ÎñªÍ≤å Ïß§ÎùºÏïºÌï†ÏßÄ ÏâΩÏßÄ ÏïäÏùå.
// ÎòêÌïú wildcardÎ•º Í∞ïÏ†úÎ°ú Îã§Î•∏ diffÏôÄ Î∂ÑÎ¶¨ÌïòÎäî Í≤ΩÏö∞ diffÍ∞Ä Í∞ôÏùÄ ÏúÑÏπòÏóê Îëê Í∞ú Ïù¥ÏÉÅ ÏÉùÍ∏∞Í≤å ÎêòÎäî ÏàòÍ∞Ä ÏûàÎã§. (wildcardÏôÄ wildcardÍ∞Ä ÏïÑÎãå Í≤É)
// Ïù¥ Í≤ΩÏö∞ Ï†ïÌôïÌûà Í∞ôÏùÄ ÏúÑÏπòÏóê ÎëêÍ∞úÏùò diffÎ•º Î†åÎçîÎßÅÌï¥ÏïºÌïòÍ≥† Í≤∞Íµ≠ ÎëêÍ∞úÍ∞Ä Í≤πÏ≥êÎ≥¥Ïù¥Í≤å ÎêòÎäîÎç∞ Î∂ÑÍ∞ÑÏù¥ Ïûò ÏïàÎêúÎã§.
const wildcardTrie = createTrie(true);
wildcardTrie.insert("(Ï∂îÍ∞Ä)", WILD_CARD);
wildcardTrie.insert("(ÏÇ≠Ï†ú)", WILD_CARD);
wildcardTrie.insert("(Ïã†ÏÑ§)", WILD_CARD);
wildcardTrie.insert("(ÏÉùÎûµ)", WILD_CARD);
wildcardTrie.insert("(ÌòÑÌñâÍ≥ºÍ∞ôÏùå)", WILD_CARD);
const wildcardTrieNode = wildcardTrie.root.next("(");
const sectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    sectionHeadingTrie.insert(`${i}.`, SECTION_HEADING_TYPE1);
    sectionHeadingTrie.insert(`(${i})`, SECTION_HEADING_TYPE3);
    sectionHeadingTrie.insert(`${i})`, SECTION_HEADING_TYPE5);
}
for (let i = 0; i < HANGUL_ORDER.length; i++) {
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]}.`, SECTION_HEADING_TYPE2);
    sectionHeadingTrie.insert(`(${HANGUL_ORDER[i]})`, SECTION_HEADING_TYPE4);
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]})`, SECTION_HEADING_TYPE6);
}
const SectionHeadingTrieNode = sectionHeadingTrie.root;
const sectionHeadingStartChars = extractStartCharsFromTrie(SectionHeadingTrieNode);
const manualAnchorTrie = createTrie(false);
manualAnchorTrie.insert(MANUAL_ANCHOR1, MANUAL_ANCHOR);
manualAnchorTrie.insert(MANUAL_ANCHOR2, MANUAL_ANCHOR);
const manualAnchorTrieNode = manualAnchorTrie.root;
const manualAnchorStartChars = extractStartCharsFromTrie(manualAnchorTrieNode);
function tokenizeByChar(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = LINE_START;
    const inputEnd = input.length;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (!spaceChars[ch]) {
            if (ch === "(") {
                const result = findInTrie(wildcardTrieNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= LINE_START;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (manualAnchorStartChars[ch]) {
                const nextNode = manualAnchorTrieNode.next(ch);
                const result = findInTrie(nextNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= LINE_START;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                flags |= LINE_START;
            }
            const normalized = normalizedCharMap[ch] || ch;
            tokens.push({
                text: normalized,
                pos: i,
                len: 1,
                lineNum,
                flags,
            });
            flags = 0;
        }
        if (ch === "\n") {
            lineNum++;
            flags = LINE_START;
            if (tokens.length) {
                tokens[tokens.length - 1].flags |= LINE_END;
            }
        }
    }
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LINE_END;
    }
    return tokens;
}
function tokenizeByWord(input) {
    const tokens = [];
    let currentStart = -1;
    let lineNum = 1;
    let flags = LINE_START;
    let shouldNormalize = false;
    const inputEnd = input.length;
    function emitToken(end) {
        const raw = input.slice(currentStart, end);
        const normalized = shouldNormalize ? normalize(raw) : raw;
        flags |= tokens.length === 0 || checkIfFirstOfLine(input, currentStart) ? LINE_START : 0;
        if (normalized === MANUAL_ANCHOR1 || normalized === MANUAL_ANCHOR2) {
            flags |= MANUAL_ANCHOR;
        }
        tokens.push({
            text: normalized,
            pos: currentStart,
            len: end - currentStart,
            lineNum,
            flags,
        });
        currentStart = -1;
        flags = 0;
        shouldNormalize = false;
    }
    for (let i = 0; i < inputEnd; i++) {
        let ch = input[i];
        if (spaceChars[ch]) {
            if (currentStart !== -1)
                emitToken(i);
            if (ch === "\n") {
                lineNum++;
                flags = LINE_START;
                if (tokens.length)
                    tokens[tokens.length - 1].flags |= LINE_END;
            }
            continue;
        }
        if (ch === "(") {
            const result = findInTrie(wildcardTrieNode, input, i);
            if (result) {
                if (currentStart !== -1)
                    emitToken(i);
                flags |= tokens.length === 0 || checkIfFirstOfLine(input, i) ? LINE_START : 0;
                tokens.push({
                    text: result.word,
                    pos: i,
                    len: result.end - i,
                    lineNum,
                    flags: flags | result.flags,
                });
                flags = 0;
                currentStart = -1;
                i = result.end - 1;
                continue;
            }
        }
        if (currentStart === -1 && flags & LINE_START && sectionHeadingStartChars[ch]) {
            const result = findInTrie(SectionHeadingTrieNode, input, i);
            if (result) {
                const nextChar = input[result.end];
                if (nextChar === " " || nextChar === "\t" || nextChar === "\u00A0") {
                    flags |= result.flags;
                }
                // let p = result.end;
                // while (p < inputEnd && SPACE_CHARS[input[p]]) p++;
                // if (p < inputEnd) flags |= result.flags;
            }
        }
        // if (SPLIT_CHARS[ch]) {
        // 	if (currentStart !== -1) emitToken(i);
        // 	flags |= tokens.length === 0 || checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
        // 	tokens.push({
        // 		text: ch,
        // 		pos: i,
        // 		len: 1,
        // 		lineNum,
        // 		flags,
        // 	});
        // 	flags = 0;
        // 	currentStart = -1;
        // 	continue;
        // }
        if (normalizedCharMap[ch]) {
            shouldNormalize = true;
        }
        if (currentStart === -1)
            currentStart = i;
    }
    if (currentStart !== -1)
        emitToken(inputEnd);
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LINE_END;
    }
    return tokens;
}
function tokenizeByLine(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = LINE_START | LINE_END;
    const inputEnd = input.length;
    let buffer = "";
    let started = false;
    let inSpace = false;
    let pos = -1;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (ch !== "\n") {
            if (!spaceChars[ch]) {
                if (!started) {
                    pos = i;
                    started = true;
                    const result = findInTrie(SectionHeadingTrieNode, input, i);
                    if (result) {
                        let p = result.end;
                        while (p < inputEnd && spaceChars[input[p]])
                            p++;
                        if (p < inputEnd)
                            flags |= result.flags;
                    }
                }
                if (inSpace && buffer.length > 0)
                    buffer += " ";
                buffer += ch;
                inSpace = false;
            }
            else {
                inSpace = started;
            }
        }
        else {
            if (started) {
                if (buffer === MANUAL_ANCHOR1 || buffer === MANUAL_ANCHOR2) {
                    flags |= MANUAL_ANCHOR;
                }
                tokens.push({
                    text: buffer,
                    pos,
                    len: i - pos,
                    lineNum,
                    flags,
                });
                buffer = "";
                started = false;
                inSpace = false;
                flags = LINE_START | LINE_END;
            }
            lineNum++;
        }
    }
    return tokens;
}
function tokenize(input, mode, noCache = false) {
    let cacheArr = !noCache && tokenCache[mode];
    if (cacheArr) {
        for (let i = 0; i < cacheArr.length; i++) {
            const cache = cacheArr[i];
            if (cache.text.length === input.length && cache.text === input) {
                if (i !== cacheArr.length - 1) {
                    cacheArr.splice(i, 1);
                    cacheArr.push(cache);
                }
                return cache.tokens;
            }
        }
    }
    const now = performance.now();
    let tokens;
    switch (mode) {
        case "char":
            tokens = tokenizeByChar(input);
            break;
        case "word":
            tokens = tokenizeByWord(input);
            break;
        case "line":
            tokens = tokenizeByLine(input);
            break;
        default:
            throw new Error("Unknown tokenization mode: " + mode);
    }
    console.debug("tokenize took %d ms", performance.now() - now);
    // tokens.push({
    // 	text: "",
    // 	pos: input.length,
    // 	len: 0,
    // 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
    // 	flags: FIRST_OF_LINE | LAST_OF_LINE,
    // });
    if (cacheArr) {
        if (cacheArr.length >= TOKEN_CACHE_SIZE) {
            cacheArr.shift();
        }
        cacheArr.push({ text: input, tokens: tokens });
    }
    return tokens;
}
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizedCharMap[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!spaceChars[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            node = node.addChild(word[i]);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
function createTrieNode(ignoreSpaces) {
    const children = {};
    const node = {
        children,
        word: null,
        flags: 0,
        next(char) {
            if (ignoreSpaces && char === " ")
                return node;
            return children[char] || null;
        },
        addChild(char) {
            return children[char] ?? (children[char] = createTrieNode(ignoreSpaces));
        },
    };
    return node;
}
function findInTrie(trie, input, start) {
    let node = trie;
    let i = start;
    while (i < input.length) {
        const ch = input[i++];
        node = node.next(ch);
        if (!node)
            break;
        if (node.word) {
            return { word: node.word, flags: node.flags, end: i };
        }
    }
    return null;
}
function extractStartCharsFromTrie(trie) {
    const table = {};
    for (const ch in trie.children) {
        table[ch] = 1;
    }
    return table;
}
function tokenizeNode(node) {
    const startTime = performance.now();
    let textPos = 0;
    let currentToken = null;
    const results = [];
    function processToken(text, start, length) {
        if (currentToken) {
            currentToken.text += text;
            currentToken.len = textPos - currentToken.pos;
        }
        else {
            currentToken = {
                text,
                pos: start,
                len: length,
                flags: 0,
                lineNum: 0,
            };
        }
    }
    function finalizeToken(flags = 0) {
        if (currentToken) {
            currentToken.len = textPos - currentToken.pos;
            currentToken.flags |= flags;
            results.push(currentToken);
            currentToken = null;
            return 1;
        }
        return 0;
    }
    function traverse(node) {
        if (node.nodeType === 3) {
            const text = node.nodeValue;
            if (text.length === 0)
                return;
            let nodeStart = textPos;
            let currentStart = -1;
            for (let i = 0; i < text.length; i++, textPos++) {
                const char = text[i];
                if (spaceChars[char]) {
                    if (currentStart >= 0) {
                        processToken(text.slice(currentStart, i), nodeStart + currentStart, i - currentStart);
                        currentStart = -1;
                    }
                    finalizeToken();
                }
                else {
                    if (currentStart < 0) {
                        currentStart = i;
                    }
                }
            }
            if (currentStart >= 0) {
                processToken(text.slice(currentStart), nodeStart + currentStart, text.length - currentStart);
            }
        }
        else if (node.nodeType === 1) {
            if (node.nodeName === "BR") {
                finalizeToken(LINE_END);
                return;
            }
            if (node.className === "img") {
                finalizeToken();
                results.push({
                    text: node.dataset.src || node.src || "üñºÔ∏è",
                    pos: textPos,
                    len: node.textContent.length,
                    lineNum: 0,
                    flags: IMAGE | NO_JOIN,
                });
                textPos += node.textContent.length;
                return;
            }
            node.dataset.startOffset = String(textPos);
            if (TEXT_FLOW_CONTAINERS[node.nodeName]) {
                finalizeToken(CONTAINER_END | LINE_END);
            }
            const isTextFlowContainer = TEXT_FLOW_CONTAINERS[node.nodeName];
            const numTokensBefore = results.length;
            for (const child of node.childNodes) {
                traverse(child);
            }
            if (BLOCK_ELEMENTS[node.nodeName]) {
                finalizeToken();
            }
            const firstToken = results[numTokensBefore];
            const lastToken = results[results.length - 1];
            if (isTextFlowContainer) {
                if (firstToken) {
                    firstToken.flags |= CONTAINER_START | LINE_START;
                }
                if (lastToken) {
                    lastToken.flags |= CONTAINER_END | LINE_END;
                }
            }
            else if (node.nodeName === "P") {
                if (firstToken) {
                    firstToken.flags |= LINE_START;
                }
                if (lastToken) {
                    lastToken.flags |= LINE_END;
                }
            }
            node.dataset.endOffset = String(textPos);
            // currentContainer = containerStack.pop()!;
        }
    }
    traverse(node);
    finalizeToken();
    const endTime = performance.now();
    console.log("tokenizeNode", node.nodeName, node.nodeValue, results, Math.ceil(endTime - startTime) + "ms");
    return results;
}
//# sourceMappingURL=tokenize.js.map
</script>
<script>"use strict";
function createEditor(container, editorName, callbacks) {
    const { onDiffVisibilityChanged, onTextChanged } = callbacks;
    const _lineElements = [];
    const _diffElements = [];
    const _anchorElements = [];
    const _lineHints = [];
    const _visibleAnchors = new Set();
    const _visibleDiffIndices = new Set();
    const _diffRanges = [];
    const _diffRects = [];
    const _diffLineRects = [];
    const _highlightItems = [];
    let _textHighlightItems = null;
    let _diffHighlightItems = null;
    let _updateStaticCanvasPending = false;
    let _diffRectsDirty = true;
    let _hasRenderedAny = false;
    let _editMode = false;
    const wrapper = document.createElement("div");
    wrapper.id = editorName + "EditorWrapper";
    wrapper.classList.add("editor-wrapper");
    const staticCanvas = document.createElement("canvas");
    staticCanvas.id = editorName + "Canvas";
    staticCanvas.classList.add("canvas");
    const staticCanvasCtx = staticCanvas.getContext("2d");
    const highlightCanvas = document.createElement("canvas");
    highlightCanvas.id = editorName + "HighlightCanvas";
    highlightCanvas.classList.add("canvas");
    highlightCanvas.classList.add("highlight");
    const highlightCanvasCtx = highlightCanvas.getContext("2d");
    const EDITOR_INNER_HTML = "<p><br></p>";
    const editor = document.createElement("div");
    editor.id = editorName + "Editor";
    editor.classList.add("editor");
    editor.contentEditable = "true";
    editor.spellcheck = false;
    editor.innerHTML = EDITOR_INNER_HTML;
    wrapper.appendChild(staticCanvas);
    wrapper.appendChild(highlightCanvas);
    wrapper.appendChild(editor);
    container.appendChild(wrapper);
    const resizeObserver = new ResizeObserver(() => {
        const rect = wrapper.getBoundingClientRect();
        staticCanvas.width = rect.width;
        staticCanvas.height = rect.height;
        highlightCanvas.width = rect.width;
        highlightCanvas.height = rect.height;
        _diffRectsDirty = true;
        render();
    });
    resizeObserver.observe(wrapper);
    // *** HTML Î∂ôÏó¨ÎÑ£Í∏∞Î•º ÌóàÏö©Ìï† ÎïåÎßå ÏÇ¨Ïö©Ìï† ÏΩîÎìú ***
    // ÏßÄÍ∏àÏùÄ Í¥ÄÎ†® ÏΩîÎìúÎ•º Îã§ ÏßÄÏõåÎ≤ÑÎ†∏Í≥† Î≥µÍµ¨ÌïòÎ†§Î©¥ ÍπÉÌóàÎ∏åÏóêÏÑú Ïù¥Ï†Ñ ÏΩîÎìúÎ•º Îí§Ï†∏ÏïºÌï®...
    const { observeEditor, unobserveEditor } = (() => {
        const mutationObserver = new MutationObserver((mutations) => {
            // for (const mutation of mutations) {
            // 	if (mutation.type === "childList") {
            // 		for (const node of mutation.addedNodes) {
            // 			// Î≥¥ÌÜµ Î∏åÎùºÏö∞Ï†ÄÎäî spanÏù¥ÎÇò font ÌÉúÍ∑∏Î•º ÏûÖÌòÄÏÑú Ïä§ÌÉÄÏùºÏùÑ ÎÑ£Ïñ¥Ï§ÄÎã§...
            // 			if (node.nodeName === "SPAN" || node.nodeName === "FONT") {
            // 				if (node.childNodes.length === 1 && node.firstChild?.nodeType === 3) {
            // 					node.parentNode?.replaceChild(node.firstChild, node);
            // 				}
            // 			}
            // 		}
            // 	}
            // 	// Í∏∞Ï°¥ ÌÉúÍ∑∏Ïóê styleÏùÑ Î∞îÎ°ú ÎÑ£Ïñ¥Ï£ºÎäî Í≤ΩÏö∞Í∞Ä ÏûàÎäîÏßÄÎäî Î™®Î•¥Í≤†ÏßÄÎßå ÏïàÏ†ÑÎπµÏúºÎ°ú...
            // 	if (mutation.type === "attributes" && mutation.attributeName === "style") {
            // 		(mutation.target as HTMLElement).removeAttribute("style");
            // 	}
            // }
            if (editor.childNodes.length === 0) {
                console.log("WTF??");
                editor.innerHTML = EDITOR_INNER_HTML;
            }
        });
        function observeEditor() {
            mutationObserver.observe(editor, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true,
            });
        }
        function unobserveEditor() {
            mutationObserver.disconnect();
        }
        return { observeEditor, unobserveEditor };
    })();
    observeEditor();
    let _pasteCounter = 0;
    let _sanitizeCallbackId = null;
    // function sanitize(rawHTML: string) {
    // 	const START_TAG = "<!--StartFragment-->";
    // 	const END_TAG = "<!--EndFragment-->";
    // 	const startIndex = rawHTML.indexOf(START_TAG);
    // 	if (startIndex >= 0) {
    // 		const endIndex = rawHTML.lastIndexOf(END_TAG);
    // 		if (endIndex >= 0) {
    // 			rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
    // 		} else {
    // 			rawHTML = rawHTML.slice(startIndex + START_TAG.length);
    // 		}
    // 	}
    // 	const func = sanitizer(rawHTML);
    // 	const counter = ++_pasteCounter;
    // 	const step = (idleDeadline: IdleDeadline) => {
    // 		_sanitizeCallbackId = null;
    // 		const { done, value } = func.next(idleDeadline);
    // 		if (!done && counter === _pasteCounter) {
    // 			_sanitizeCallbackId = requestIdleCallback(step, { timeout: 100 });
    // 		} else if (done) {
    // 			const selection = window.getSelection()!;
    // 			const range = selection.getRangeAt(0);
    // 			range.deleteContents();
    // 			console.log("deleted contents");
    // 			range.insertNode(value);
    // 			console.log("inserted node:", value);
    // 			// editor.replaceChildren(value);
    // 			onTextChanged();
    // 		}
    // 	};
    // 	_sanitizeCallbackId = requestIdleCallback(step, { timeout: 100 });
    // }
    function insertFragmentWithPSplit(fragment) {
        const selection = window.getSelection();
        if (!selection?.rangeCount)
            return;
        const range = selection.getRangeAt(0);
        // 1. Ïª§ÏÑúÍ∞Ä ÏúÑÏπòÌïú p ÌÉúÍ∑∏Î•º Ï∞æÍ∏∞
        let p = range.startContainer;
        while (p && p.nodeName !== "P")
            p = p.parentNode;
        if (!p) {
            // p ÏïàÏù¥ ÏïÑÎãàÎ©¥ Í∑∏ÎÉ• Î∂ôÏó¨ÎÑ£Í∏∞
            range.insertNode(fragment);
            return;
        }
        // 2. ÌÖçÏä§Ìä∏ ÎÖ∏ÎìúÎ©¥ splitText Ï≤òÎ¶¨
        if (range.startContainer.nodeType === Node.TEXT_NODE) {
            const textNode = range.startContainer;
            const offset = range.startOffset;
            const beforeText = textNode.nodeValue.slice(0, offset);
            const afterText = textNode.nodeValue.slice(offset);
            const beforeNode = document.createTextNode(beforeText);
            const afterNode = document.createTextNode(afterText);
            const parent = textNode.parentNode;
            parent.replaceChild(afterNode, textNode);
            parent.insertBefore(beforeNode, afterNode);
            range.setStartAfter(beforeNode);
            range.setEndAfter(beforeNode);
        }
        // 3. ÏïûÎ∂ÄÎ∂Ñ Ï∂îÏ∂ú (Ïª§ÏÑú Ïù¥Ï†Ñ)
        const beforeRange = range.cloneRange();
        beforeRange.setStartBefore(p);
        beforeRange.setEnd(range.startContainer, range.startOffset);
        const beforeFragment = beforeRange.cloneContents();
        // 4. Îí∑Î∂ÄÎ∂Ñ Ï∂îÏ∂ú (Ïª§ÏÑú Ïù¥ÌõÑ)
        const afterRange = range.cloneRange();
        afterRange.setStart(range.startContainer, range.startOffset);
        afterRange.setEndAfter(p);
        const afterFragment = afterRange.cloneContents();
        // 5. ÏÉàÎ°úÏö¥ <p>Îì§ ÏÉùÏÑ±
        const pBefore = document.createElement("p");
        pBefore.appendChild(beforeFragment);
        const pAfter = document.createElement("p");
        pAfter.appendChild(afterFragment);
        // 6. ÏõêÎûò <p> Ï†úÍ±∞ÌïòÍ≥† ÏÉàÍ≤ÉÎì§ ÏÇΩÏûÖ
        const parent = p.parentNode;
        parent.insertBefore(pBefore, p);
        parent.insertBefore(fragment, p);
        parent.insertBefore(pAfter, p);
        parent.removeChild(p);
        // 7. Ïª§ÏÑú Ïù¥Îèô (optional)
        const newRange = document.createRange();
        newRange.setStartAfter(fragment.lastChild || fragment);
        newRange.collapse(true);
        selection.removeAllRanges();
        selection.addRange(newRange);
    }
    editor.addEventListener("paste", (e) => {
        let t1 = performance.now();
        let rawHTML = e.clipboardData?.getData("text/html");
        let t2 = performance.now();
        console.log("get html time:", t2 - t1);
        if (!rawHTML) {
            return;
        }
        e.preventDefault();
        const START_TAG = "<!--StartFragment-->";
        const END_TAG = "<!--EndFragment-->";
        const startIndex = rawHTML.indexOf(START_TAG);
        if (startIndex >= 0) {
            const endIndex = rawHTML.lastIndexOf(END_TAG);
            if (endIndex >= 0) {
                rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
            }
            else {
                rawHTML = rawHTML.slice(startIndex + START_TAG.length);
            }
        }
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        range.deleteContents();
        const frag = range.createContextualFragment(rawHTML);
        const [sanitized, hasBlockElements] = sanitizeNode(frag);
        insertFragmentSmart(sanitized, hasBlockElements);
        // range.insertNode(sanitized);
        onTextChanged();
        // sanitize(rawHTML);
        // editor.contentEditable = "true";
        // t1 = performance.now();
        // const node = sanitizeHTML(html);
        // t2 = performance.now();
        // console.log("sanitizeHTML time:", t2 - t1);
        // t1 = performance.now();
        // editor.replaceChildren(node);
        // t2 = performance.now();
        // console.log("replaceChildren time:", t2 - t1);
        // t1 = performance.now();
        // onTextChanged();
        // t2 = performance.now();
        // console.log("onTextChanged time:", t2 - t1);
    });
    editor.addEventListener("input", () => {
        onTextChanged();
    });
    wrapper.addEventListener("scroll", () => {
        render();
    });
    function getVisibleAnchors() {
        return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
    }
    // caret(ÌÖçÏä§Ìä∏Ïª§ÏÑú '|')Í∞Ä ÏûàÎäî ÏúÑÏπòÏóê Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÏïµÏª§Î•º Í∞ÄÏ†∏Ïò¥.
    // edit Î™®ÎìúÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎäî null Î¶¨ÌÑ¥
    function getClosestAnchorToCaret() {
        if (!_editMode) {
            return null;
        }
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null;
        }
        let range = selection.getRangeAt(0);
        if (!editor.contains(range.startContainer)) {
            return null;
        }
        let rect = range.getBoundingClientRect();
        let y;
        if (rect.left === 0 && rect.top === 0) {
            y = EDITOR_PADDING + TOPBAR_HEIGHT;
        }
        else {
            y = rect.top;
        }
        let closestAnchor = null;
        let minDistance = Number.MAX_SAFE_INTEGER;
        for (const anchor of _visibleAnchors) {
            const rect = anchor.getBoundingClientRect();
            const distance = Math.abs(rect.top - y);
            if (distance < minDistance) {
                minDistance = distance;
                closestAnchor = anchor;
            }
        }
        return closestAnchor;
    }
    function getFirstVisibleLineElement() {
        const lineEls = _lineElements;
        let low = 0;
        let high = lineEls.length - 1;
        let mid;
        let lineEl = null;
        let distance = null;
        while (low <= high) {
            mid = (low + high) >>> 1;
            const thisDistance = lineEls[mid].getBoundingClientRect().top - TOPBAR_HEIGHT;
            if (thisDistance >= -LINE_HEIGHT) {
                lineEl = lineEls[mid];
                distance = thisDistance;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return [lineEl, distance];
    }
    function scrollToDiff(diffIndex) {
        const diffRects = _diffRects[diffIndex];
        if (!diffRects) {
            return;
        }
        const diffRect = diffRects.rects[0];
        if (!diffRect) {
            return;
        }
        wrapper.scrollTop = diffRect.y - SCROLL_MARGIN;
    }
    function scrollToHeading(headingIndex) {
        const id = `${editorName}Heading${headingIndex}`;
        const el = document.getElementById(id);
        if (el) {
            const offsetTop = el.offsetTop - wrapper.clientTop;
            wrapper.scrollTop = offsetTop - SCROLL_MARGIN;
        }
    }
    // ÎÇ¥Í∞Ä Î®∏Î¶¨Í∞Ä ÎÇòÏÅòÎã§Îäî Í±∏ ÌôïÏã§ÌïòÍ≤å ÏïåÍ≤å Ìï¥Ï£ºÎäî Ìï®Ïàò
    function scrollToLine(lineNum, margin = 0) {
        const lineEl = _lineElements[lineNum - 1];
        if (lineEl) {
            const scrollTop = lineEl.offsetTop - margin;
            wrapper.scrollTop = scrollTop;
        }
    }
    function getFirstVisibleAnchor() {
        let firstAnchor = null;
        let firstPos = null;
        for (const anchor of _visibleAnchors) {
            if (firstAnchor === null) {
                firstAnchor = anchor;
                firstPos = Number(anchor.dataset.pos);
            }
            else {
                const pos = Number(anchor.dataset.pos);
                if (pos < firstPos) {
                    firstAnchor = anchor;
                    firstPos = pos;
                }
            }
        }
        return firstAnchor;
    }
    function setEditMode(editMode) {
        _editMode = !!editMode;
    }
    function findLineIndexByPos(pos, low = 0, high = _lineHints.length - 1) {
        const lineHints = _lineHints;
        if (lineHints.length === 0)
            return -1;
        if (pos < 0)
            return -1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const hint = lineHints[mid];
            const start = hint.pos;
            const end = mid + 1 < lineHints.length ? lineHints[mid + 1].pos : Infinity;
            if (pos < start) {
                high = mid - 1;
            }
            else if (pos >= end) {
                low = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1; // posÍ∞Ä ÎßàÏßÄÎßâ Ï§Ñ endÎ•º ÎÑòÏñ¥Í∞Ñ Í≤ΩÏö∞
        // let mid;
        // while (low <= high) {
        // 	mid = (low + high) >> 1;
        // 	const lineEl = _lineElements[mid];
        // 	const linePos = Number(lineEl.dataset.pos);
        // 	if (linePos === pos) {
        // 		return mid;
        // 	}
        // 	if (linePos > pos) {
        // 		high = mid - 1;
        // 	} else {
        // 		low = mid + 1;
        // 	}
        // }
        // return high;
    }
    // =============================================================
    // ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù ÏòÅÏó≠ Í¥ÄÎ†®
    // ÏßÄÏ†ÄÎ∂ÑÌïòÏßÄÎßå.. ÏÑ£Î∂àÎ¶¨ Í±¥Îì§Î©¥ ÌïúÏãúÍ∞Ñ ÎÇ†ÏïÑÍ∞ÑÎã§!
    // =============================================================
    // #region
    function getTextOffset(root, node, offset) {
        let result;
        if (node.nodeType === 1) {
            let container = editor;
            let offsetBase = 0;
            if (node.childNodes.length === offset) {
                // return Number((node as HTMLElement).dataset.endOffset);
                // offsetÏù¥ node.childNode Î∞∞Ïó¥ ÌÅ¨Í∏∞Î•º ÎÑòÎäî Í≤ΩÏö∞(Ï†ïÌôïÌûàÎäî offset === childNode.length)
                // Ïù¥ Í≤ΩÏö∞ Î≤îÏúÑÏùò ÏãúÏûë(ÎòêÎäî ÎÅù)ÏùÄ nodeÏùò ÎÅùÏóê ÏûàÎã§Îäî ÏùòÎØ∏.
                // ÌòÑÏû¨ ÎÖ∏ÎìúÏùò ÎÅù ÏúÑÏπòÎ•º Í≥ÑÏÇ∞Ìï¥ÎèÑ ÎêòÏßÄÎßå Îã§Ïùå ÎÖ∏ÎìúÏùò ÏãúÏûë ÏúÑÏπòÎ•º Í≥ÑÏÇ∞Ìï¥ÎèÑ Îê† Í≤É Í∞ôÏùå.
                const nextNode = findFirstNodeAfter(root, node);
                if (nextNode === null) {
                    return -1;
                }
            }
            else {
                // node.childNodes[offset]Ïùò ÏãúÏûëÎ∂ÄÎ∂ÑÏóê Î≤îÏúÑÏùò ÏãúÏûë(ÎòêÎäî ÎÅù)Ïù¥ ÏúÑÏπòÌï®.
                node = node.childNodes[offset];
            }
            let pos = getTextOffsetOfNode(container, node);
            result = offsetBase + pos;
        }
        else {
            console.assert(node.nodeType === 3, "nodeType is not text node");
            // Îß® Ï≤òÏùåÎ∂ÄÌÑ∞ ÌÖçÏä§Ìä∏ÎÖ∏Îìú Í∏∏Ïù¥ ÎàÑÏ†Å...
            result = getTextOffsetOfNode(root, node) + offset;
        }
        return result;
    }
    function getTextRangeRects(startOffset, endOffset) {
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let currentPos = 0;
        let currentNode;
        let result = [];
        // console.log(editorName, "getTextRangeRects", { startOffset, endOffset });
        if (startOffset === 0 && endOffset === 0) {
            let firstTextNode = walker.nextNode();
            let created = false;
            if (!firstTextNode || firstTextNode.nodeValue.length === 0) {
                firstTextNode = document.createTextNode("\u200b");
                editor.insertBefore(firstTextNode, editor.firstChild);
                created = true;
            }
            const range = document.createRange();
            range.setStart(firstTextNode, 0);
            range.setEnd(firstTextNode, 0);
            const rects = range.getClientRects();
            for (const rect of rects) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
                console.log("found rects:", rect);
            }
            if (created) {
                firstTextNode.remove();
            }
        }
        else {
            let startNode = null;
            let startNodeOffset = 0;
            let endNode = null;
            let endNodeOffset = 0;
            function emit(startText, startTextOffset, endText, endTextOffset) {
                const range = document.createRange();
                range.setStart(startText, startTextOffset);
                range.setEnd(endText, endTextOffset);
                const rects = range.getClientRects();
                for (const rect of rects) {
                    // if (result.length > 0) {
                    // 	const prevRect = result[result.length - 1];
                    // 	if (prevRect.height === rect.height && prevRect.x + prevRect.width === rect.x) {
                    // 		prevRect.width += rect.width;
                    // 		continue;
                    // 	}
                    // }
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
            }
            while ((currentNode = walker.nextNode())) {
                const nodeLen = currentNode.nodeValue.length;
                const nodeEnd = currentPos + nodeLen;
                if (currentPos >= endOffset) {
                    break;
                }
                if (endOffset >= currentPos && startOffset <= nodeEnd) {
                    let start = 0;
                    let end = nodeLen;
                    if (currentPos < startOffset) {
                        start = startOffset - currentPos;
                    }
                    if (nodeEnd > endOffset) {
                        end = endOffset - currentPos;
                    }
                    if (startNode && startNode.parentNode !== currentNode.parentNode) {
                        emit(startNode, startNodeOffset, endNode, endNodeOffset);
                        startNode = endNode = null;
                        startNodeOffset = endNodeOffset = 0;
                    }
                    if (startNode === null) {
                        startNode = currentNode;
                        startNodeOffset = start;
                    }
                    endNode = currentNode;
                    endNodeOffset = end;
                    // if (start <= end) {
                    // 	let range = document.createRange();
                    // 	range.setStart(currentNode, start);
                    // 	range.setEnd(currentNode, end);
                    // 	// console.log("currentNode:", { text: currentNode.nodeValue, start, end });
                    // 	// console.log("range:", range);
                    // 	const rects = range.getClientRects();
                    // 	for (const rect of rects) {
                    // 		if (result.length > 0) {
                    // 			const prevRect = result[result.length - 1];
                    // 			if (prevRect.height === rect.height && prevRect.x + prevRect.width === rect.x) {
                    // 				prevRect.width += rect.width;
                    // 				continue;
                    // 			}
                    // 		}
                    // 		result.push({
                    // 			x: rect.x,
                    // 			y: rect.y,
                    // 			width: rect.width,
                    // 			height: rect.height,
                    // 		});
                    // 	}
                    // }
                    if (nodeEnd >= endOffset) {
                        break;
                    }
                }
                currentPos = nodeEnd;
            }
            if (startNode && endNode) {
                emit(startNode, startNodeOffset, endNode, endNodeOffset);
            }
        }
        if (result.length > 0) {
            // if (result[result.length - 1].width === 0) {
            // 	result.length--;
            // }
            // if (result.length > 0 && result[0].width === 0) {
            // 	result.shift();
            // }
        }
        console.log(editorName, "getTextRangeRects", { startOffset, endOffset, result });
        return result;
    }
    function getTextSelectionRange() {
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount) {
            // console.debug("no selection or range count is 0");
            return [null, null];
        }
        const range = selection.getRangeAt(0);
        const root = editor.contains(range.commonAncestorContainer) ? editor : null;
        if (!root) {
            //console.debug(editorName, "no root found", { commonAncestorContainer: range.commonAncestorContainer, startContainer: range.startContainer, endContainer: range.endContainer });
            return [null, null];
        }
        // console.debug(editorName, "range", {
        // 	commonAncestorContainer: range.commonAncestorContainer,
        // 	startContainer: range.startContainer,
        // 	endContainer: range.endContainer,
        // 	startOffset: range.startOffset,
        // 	endOffset: range.endOffset,
        // });
        let startOffset = getTextOffset(root, range.startContainer, range.startOffset);
        let endOffset = getTextOffset(root, range.endContainer, range.endOffset);
        // console.debug(editorName, "startOffset, endOffset", { startOffset, endOffset });
        if (isNaN(startOffset) || isNaN(endOffset)) {
            //	console.debug(editorName, "no start or end offset found", { startOffset, endOffset });
            return [null, null];
        }
        // if (startOffset === -1 || startOffset >= _text.length) {
        // 	startOffset = _text.length - 1;
        // }
        // if (endOffset === -1 || endOffset >= _text.length) {
        // 	endOffset = _text.length - 1;
        // }
        // if (startOffset > endOffset) {
        // 	[startOffset, endOffset] = [endOffset, startOffset];
        // }
        // console.debug(editorName, "getTextSelectionRange", { startOffset, endOffset });
        return [startOffset, endOffset];
    }
    function createTextRange(startOffset, endOffset, container = editor) {
        // console.debug(editorName, "selectTextRange", { startOffset, endOffset });
        // startOffset = Math.max(0, Math.min(startOffset, _text.length - 1));
        // endOffset = Math.max(0, Math.min(endOffset, _text.length - 1));
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const range = document.createRange();
        let startSet = false;
        let endSet = false;
        if (container === editor) {
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
            if (startOffset === 0 && endOffset === 0) {
                const firstTextNode = walker.nextNode();
                if (firstTextNode) {
                    range.setStart(firstTextNode, 0);
                    range.setEnd(firstTextNode, 0);
                    console.log("found rects:", range.getClientRects());
                    return range;
                }
                else {
                    console.warn("no text node found");
                    return null;
                }
            }
            let currentNode;
            let pos = 0;
            while (!endSet && (currentNode = walker.nextNode())) {
                if (!startSet && pos + currentNode.nodeValue.length >= startOffset) {
                    range.setStart(currentNode, startOffset - pos);
                    startSet = true;
                }
                if (!endSet && pos + currentNode.nodeValue.length >= endOffset) {
                    range.setEnd(currentNode, endOffset - pos);
                    endSet = true;
                }
                pos += currentNode.nodeValue.length;
            }
        }
        else {
            let startLineIndex = findLineIndexByPos(startOffset);
            let endLineIndex = findLineIndexByPos(endOffset, startLineIndex);
            let basePos = _lineHints[startLineIndex].pos;
            if (basePos === startOffset) {
                range.setStartBefore(_lineElements[startLineIndex]);
                startSet = true;
            }
            else {
                let walker = document.createTreeWalker(_lineElements[startLineIndex], NodeFilter.SHOW_TEXT, null);
                let pos = basePos;
                let currentNode;
                while ((currentNode = walker.nextNode())) {
                    const nodeLen = currentNode.nodeValue.length;
                    if (pos + nodeLen >= startOffset) {
                        range.setStart(currentNode, startOffset - pos);
                        startSet = true;
                        break;
                    }
                    pos += nodeLen;
                }
                if (!startSet) {
                    range.setStartAfter(_lineElements[startLineIndex]);
                    startSet = true;
                }
            }
            basePos = _lineHints[endLineIndex].pos;
            if (basePos === endOffset) {
                range.setEndBefore(_lineElements[endLineIndex]);
                endSet = true;
            }
            else {
                let walker = document.createTreeWalker(_lineElements[endLineIndex], NodeFilter.SHOW_TEXT, null);
                let pos = basePos;
                let currentNode;
                while ((currentNode = walker.nextNode())) {
                    const nodeLen = currentNode.nodeValue.length;
                    if (pos + nodeLen >= endOffset) {
                        range.setEnd(currentNode, endOffset - pos);
                        endSet = true;
                        break;
                    }
                    pos += nodeLen;
                }
                if (!endSet) {
                    range.setEndAfter(_lineElements[endLineIndex]);
                    endSet = true;
                }
            }
        }
        if (startSet && endSet) {
            return range;
        }
        else {
            return null;
        }
    }
    function selectTextRange(startOffset, endOffset) {
        const range = createTextRange(startOffset, endOffset);
        if (range) {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            return true;
        }
        return false;
    }
    // #endregion
    // =============================================================
    function mergeRects(rects) {
        rects.sort((a, b) => a.y + a.height - (b.y + b.height));
        const merged = [];
        const used = new Array(rects.length).fill(false);
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = 0;
        let maxY = 0;
        for (let i = 0; i < rects.length; i++) {
            if (used[i])
                continue;
            let base = rects[i];
            for (let j = i + 1; j < rects.length; j++) {
                if (used[j])
                    continue;
                const compare = rects[j];
                // Ï°∞Í∏∞ Ï¢ÖÎ£å: compare.y > base.y + base.height Ïù¥Î©¥ Îçî Ïù¥ÏÉÅ Í≤πÏπ† Ïàò ÏóÜÏùå
                if (compare.y > base.y + base.height)
                    break;
                // ÏôÑÏ†Ñ Ìè¨Ìï®: baseÍ∞Ä compareÎ•º ÏôÑÏ†ÑÌûà Ìè¨Ìï®ÌïòÎäî Í≤ΩÏö∞
                if (base.x <= compare.x &&
                    base.x + base.width >= compare.x + compare.width &&
                    base.y <= compare.y &&
                    base.y + base.height >= compare.y + compare.height) {
                    used[j] = true;
                    continue;
                }
                // ÏôÑÏ†Ñ Ìè¨Ìï®: compareÍ∞Ä baseÎ•º ÏôÑÏ†ÑÌûà Ìè¨Ìï®ÌïòÎäî Í≤ΩÏö∞
                if (compare.x <= base.x &&
                    compare.x + compare.width >= base.x + base.width &&
                    compare.y <= base.y &&
                    compare.y + compare.height >= base.y + base.height) {
                    base = compare;
                    used[j] = true;
                    continue;
                }
                // yÏ∂ï Í±∞Ïùò Í∞ôÍ≥†, xÏ∂ï Í≤πÏπòÎ©¥ Î≥ëÌï© (Ï¢åÏö∞ ÌôïÏû•)
                const sameY = Math.abs(base.y - compare.y) < 1 && Math.abs(base.height - compare.height) < 1;
                const xOverlap = base.x <= compare.x + compare.width && compare.x <= base.x + base.width;
                if (sameY && xOverlap) {
                    // ÏÉà Î≥ëÌï© ÏÇ¨Í∞ÅÌòï Í≥ÑÏÇ∞
                    const newX = Math.min(base.x, compare.x);
                    const newWidth = Math.max(base.x + base.width, compare.x + compare.width) - newX;
                    base = {
                        x: newX,
                        y: base.y,
                        width: newWidth,
                        height: base.height,
                    };
                    used[j] = true;
                }
            }
            merged.push(base);
            minX = Math.min(minX, base.x);
            minY = Math.min(minY, base.y);
            maxX = Math.max(maxX, base.x + base.width);
            maxY = Math.max(maxY, base.y + base.height);
            used[i] = true;
        }
        if (minX === Number.MAX_SAFE_INTEGER) {
            minX = 0;
        }
        if (minY === Number.MAX_SAFE_INTEGER) {
            minY = 0;
        }
        merged.sort((a, b) => (a.y !== b.y ? a.y - b.y : a.x - b.x));
        return {
            minX,
            minY,
            maxX,
            maxY,
            rects: merged,
        };
    }
    function getTextRects(startOffset, endOffset) {
        const range = createTextRange(startOffset, endOffset);
        if (range) {
            let { x: baseX, y: baseY } = wrapper.getBoundingClientRect();
            baseX = -baseX;
            baseX = wrapper.scrollLeft;
            baseY = wrapper.scrollTop;
            const diffExpandX = 1;
            const diffExpandY = 1;
            console.log(editorName, "base", { baseX, baseY });
            const rectsArr = [];
            const heightMultiplier = 1.2;
            const rects = range.getClientRects();
            for (const rect of rects) {
                if (rect) {
                    const newHeight = rect.height * heightMultiplier;
                    const heightDelta = newHeight - rect.height;
                    rect.x += baseX - diffExpandX;
                    rect.y += baseY - heightDelta / 2 - diffExpandY;
                    rect.width += diffExpandX * 2;
                    rect.height = newHeight + diffExpandY * 2;
                }
                rectsArr.push(rect);
            }
            return mergeRects(rectsArr);
        }
        return null;
    }
    function calculateDiffRects() {
        const diffExpandX = 1;
        const diffExpandY = 0;
        let { x: baseX, y: baseY } = wrapper.getBoundingClientRect();
        baseX = -baseX;
        baseX += wrapper.scrollLeft;
        baseY += wrapper.scrollTop;
        _diffRects.length = 0;
        const temp = [];
        const allRects = [];
        const heightMultiplier = 1;
        for (let diffIndex = 0; diffIndex < _diffRanges.length; diffIndex++) {
            const ranges = _diffRanges[diffIndex];
            for (const range of ranges) {
                const rects = range.getClientRects();
                for (const rect of rects) {
                    if (rect) {
                        const newHeight = rect.height * heightMultiplier;
                        const heightDelta = newHeight - rect.height;
                        rect.x += baseX - diffExpandX;
                        rect.y += baseY - heightDelta / 2 - diffExpandY;
                        rect.width += diffExpandX * 2;
                        rect.height = newHeight + diffExpandY * 2;
                    }
                    temp.push(rect);
                    allRects.push(rect);
                }
            }
            _diffRects[diffIndex] = mergeRects(temp);
            // console.log(editorName, diffIndex, "beforeMerge", Array.from(temp), "afterMerge", _diffRects[diffIndex]);
            temp.length = 0;
        }
        _diffLineRects.length = 0;
        const canvasWidth = staticCanvas.width;
        allRects.sort((a, b) => a.y - b.y);
        let lineRect = null;
        const lineExpandY = 4;
        const lineHeightMultiplier = 1.1;
        for (const rect of allRects) {
            const y = rect.y - lineExpandY;
            const height = rect.height * lineHeightMultiplier + lineExpandY * 2;
            //const height = rect.height + lineExpand * 2;
            if (lineRect === null || y > lineRect.y + lineRect.height) {
                lineRect = {
                    x: 0,
                    y: y,
                    width: canvasWidth,
                    height: height,
                };
                _diffLineRects.push(lineRect);
            }
            else {
                lineRect.height = y + height - lineRect.y;
            }
        }
    }
    function render(imediate = false) {
        if (!imediate) {
            if (_updateStaticCanvasPending) {
                return;
            }
            _updateStaticCanvasPending = true;
            requestAnimationFrame(() => {
                render(true);
                _updateStaticCanvasPending = false;
            });
            return;
        }
        if (_diffRectsDirty) {
            calculateDiffRects();
            _diffRectsDirty = false;
        }
        const visibilityChangeEntries = [];
        const ctx = staticCanvasCtx;
        const canvasWidth = staticCanvas.width, canvasHeight = staticCanvas.height;
        if (_hasRenderedAny) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            _hasRenderedAny = false;
        }
        const scrollTop = wrapper.scrollTop;
        const scrollLeft = wrapper.scrollLeft;
        ctx.fillStyle = "hsl(0 100% 95%)";
        for (const rect of _diffLineRects) {
            const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
            if (y + height < 0 || y > canvasHeight)
                continue;
            if (x + width < 0 || x > canvasWidth)
                continue;
            ctx.fillRect(x, y, width, height);
            _hasRenderedAny = true;
        }
        for (let diffIndex = 0; diffIndex < _diffRects.length; diffIndex++) {
            const diffRectSet = _diffRects[diffIndex];
            let previouslyVisible = _visibleDiffIndices.has(diffIndex);
            let isVisible = !(diffRectSet.maxY - scrollTop < 0 || diffRectSet.minY - scrollTop > canvasHeight) &&
                !(diffRectSet.maxX - scrollLeft < 0 || diffRectSet.minX - scrollLeft > canvasWidth);
            if (isVisible !== previouslyVisible) {
                if (isVisible) {
                    _visibleDiffIndices.add(diffIndex);
                }
                else {
                    _visibleDiffIndices.delete(diffIndex);
                }
                visibilityChangeEntries.push({
                    item: diffIndex,
                    isVisible,
                });
            }
            if (!isVisible) {
                continue;
            }
            const hue = DIFF_COLOR_HUES[diffIndex % NUM_DIFF_COLORS];
            ctx.fillStyle = `hsl(${hue} 100% 80%)`;
            ctx.strokeStyle = `hsl(${hue} 100% 40% / 0.5)`;
            for (const rect of diffRectSet.rects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                ctx.strokeRect(x, y, width, height);
                ctx.fillRect(x, y, width, height);
                _hasRenderedAny = true;
            }
        }
        if (visibilityChangeEntries.length > 0) {
            onDiffVisibilityChanged(visibilityChangeEntries);
        }
        renderHighlights();
    }
    function renderHighlights() {
        const ctx = highlightCanvasCtx;
        const canvasWidth = highlightCanvas.width, canvasHeight = highlightCanvas.height;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        const scrollTop = wrapper.scrollTop;
        const scrollLeft = wrapper.scrollLeft;
        function doRender(items) {
            for (const item of items) {
                const x = Math.floor(item.x - scrollLeft), y = Math.floor(item.y - scrollTop), width = Math.ceil(item.w), height = Math.ceil(item.h);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                if (item.fillStyle) {
                    ctx.fillStyle = item.fillStyle;
                    ctx.fillRect(x, y, width, height);
                }
                if (item.strokeStyle) {
                    ctx.strokeStyle = item.strokeStyle;
                    ctx.strokeRect(x, y, width, height);
                }
            }
        }
        if (_diffHighlightItems && _diffHighlightItems.length > 0) {
            ctx.save();
            ctx.lineWidth = 2; // ÏÑ† ÍµµÍ∏∞ Ï°∞Ï†à
            // Í∏ÄÎ°úÏö∞ Ìö®Í≥º ÏÑ§Ï†ï
            ctx.shadowColor = "hsl(0 100% 80%)"; // Í∑∏Î¶ºÏûê ÏÉâÍπî = ÎπõÎÇòÎäî ÏÉâÍπî
            ctx.shadowBlur = 15; // ÏñºÎßàÎÇò ÌçºÏßàÏßÄ
            doRender(_diffHighlightItems);
            ctx.restore();
        }
        if (_textHighlightItems && _textHighlightItems.length > 0) {
            doRender(_textHighlightItems);
            for (const item of _textHighlightItems) {
                const x = Math.floor(item.x - scrollLeft), y = Math.floor(item.y - scrollTop), width = Math.ceil(item.w), height = Math.ceil(item.h);
                if (y + height < 0 || y > canvasHeight)
                    continue;
                if (x + width < 0 || x > canvasWidth)
                    continue;
                ctx.fillStyle = item.fillStyle || "hsl(210 100% 80%)";
                ctx.fillRect(x, y, width, height);
            }
        }
    }
    function sliceText(startOffset, endOffset) {
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let currentNode;
        let pos = 0;
        let result = "";
        while ((currentNode = walker.nextNode())) {
            const nodeLen = currentNode.nodeValue.length;
            const nodeEnd = pos + nodeLen;
            if (nodeEnd >= startOffset && pos <= endOffset) {
                let start = 0;
                let end = nodeLen;
                if (pos < startOffset) {
                    start = startOffset - pos;
                }
                if (nodeEnd > endOffset) {
                    end = endOffset - pos;
                }
                result += currentNode.nodeValue.slice(start, end);
                if (nodeEnd >= endOffset) {
                    break;
                }
            }
            pos = nodeEnd;
        }
        return result;
    }
    function update(ctx) {
        const started = performance.now();
        _diffRanges.length = 0;
        _diffRects.length = 0;
        _diffLineRects.length = 0;
        _visibleDiffIndices.clear();
        let pos = 0; // Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏ ÏúÑÏπò ÎàÑÏ†Å
        let diffPos;
        let diffEndPos;
        const diffs = ctx.diffs;
        let currentNode = editor.firstChild;
        function advance(skipChildren = false) {
            if (!currentNode) {
                currentNode = null;
                return false;
            }
            if (!skipChildren && currentNode.firstChild) {
                currentNode = currentNode.firstChild;
                return true;
            }
            let node = currentNode;
            while (node && node !== editor) {
                if (node.nextSibling) {
                    currentNode = node.nextSibling;
                    return true;
                }
                node = node.parentNode;
            }
            currentNode = null;
            return false;
        }
        function collectRanges() {
            if (!currentNode) {
                throw new Error("currentNode is null");
            }
            const ranges = [];
            while (currentNode) {
                if (currentNode.nodeType === 3) {
                    const text = currentNode.nodeValue;
                    const nodeStart = pos;
                    let nodeEnd = nodeStart + text.length;
                    if (diffEndPos < nodeStart) {
                        console.log(1, editorName, "diffEndPos < nodeStart", { diffEndPos, nodeStart });
                        break;
                    }
                    if (diffPos <= nodeEnd) {
                        const startOffset = Math.max(0, diffPos - nodeStart);
                        const endOffset = Math.min(text.length, diffEndPos - nodeStart);
                        const range = document.createRange();
                        range.setStart(currentNode, startOffset);
                        range.setEnd(currentNode, endOffset);
                        ranges.push(range);
                    }
                    if (diffEndPos < nodeEnd) {
                        // done this diff
                        console.log(2, editorName, "diffEndPos <= nodeEnd", { diffEndPos, nodeEnd });
                        break;
                    }
                    pos = nodeEnd;
                    advance();
                }
                else if (currentNode.nodeType === 1) {
                    const nodeStart = Number(currentNode.dataset.startOffset);
                    const nodeEnd = Number(currentNode.dataset.endOffset);
                    if (!isNaN(nodeStart) && !isNaN(nodeEnd)) {
                        if (nodeStart >= diffPos && nodeEnd <= diffEndPos) {
                            console.log(3, editorName, "nodeStart, nodeEnd", { currentNode, nodeStart, nodeEnd });
                            if (currentNode.nodeName === "P" || INLINE_ELEMENTS[currentNode.nodeName]) {
                                const range = document.createRange();
                                range.selectNodeContents(currentNode);
                                ranges.push(range);
                                pos = nodeEnd;
                                advance(true);
                                if (diffEndPos <= pos) {
                                    // done this diff
                                    break;
                                }
                                continue;
                            }
                        }
                        if (diffPos > nodeEnd) {
                            console.log(4, editorName, "diffPos >= nodeEnd", { diffPos, nodeEnd });
                            pos = nodeEnd;
                            advance(true);
                            continue;
                        }
                    }
                    // console.log(editorName, "children", Array.from(currentNode.childNodes));
                    console.log(5, editorName, "advance", { currentNode });
                    advance();
                    continue;
                }
                else {
                    console.warn(editorName, "unknown node type", { currentNode });
                    advance();
                    continue;
                }
            }
            return ranges;
        }
        const result = [];
        for (let diffIndex = 0; diffIndex < diffs.length; diffIndex++) {
            const diff = diffs[diffIndex];
            const span = diff[editorName];
            diffPos = span.pos;
            diffEndPos = span.pos + span.len;
            const ranges = collectRanges();
            result[diffIndex] = ranges;
            _diffRanges[diffIndex] = ranges;
        }
        const end = performance.now();
        console.log(editorName, "update", end - started);
        _diffRectsDirty = true;
        render();
    }
    let _highlightedTextStart = null;
    let _highlightedTextEnd = null;
    function applyTextHighlight(startOffset, endOffset) {
        if (startOffset === _highlightedTextStart && endOffset === _highlightedTextEnd) {
            return;
        }
        _highlightedTextStart = startOffset;
        _highlightedTextEnd = endOffset;
        const rectSet = getTextRects(startOffset, endOffset);
        if (rectSet && rectSet.rects.length > 0) {
            _textHighlightItems = rectSet.rects.map((rect) => {
                return {
                    x: rect.x,
                    y: rect.y,
                    w: rect.width,
                    h: rect.height,
                    fillStyle: "hsl(210 100% 80%)",
                    type: "texthighlight",
                };
            });
        }
        renderHighlights();
    }
    function clearTextHighlight() {
        _highlightedTextStart = null;
        _highlightedTextEnd = null;
        _textHighlightItems = null;
        renderHighlights();
    }
    let _highlightedDiffIndex = null;
    function applyDiffHighlight(diffIndex) {
        if (diffIndex === _highlightedDiffIndex) {
            return;
        }
        _highlightedDiffIndex = diffIndex;
        if (diffIndex >= 0 && diffIndex < _diffRects.length) {
            const rectSet = _diffRects[diffIndex];
            _diffHighlightItems = rectSet.rects.map((rect) => {
                return {
                    x: rect.x,
                    y: rect.y,
                    w: rect.width,
                    h: rect.height,
                    strokeStyle: "hsl(0 100% 50%)",
                    type: "diffhighlight",
                };
            });
        }
        renderHighlights();
    }
    function clearDiffHighlight() {
        _highlightedDiffIndex = null;
        _diffHighlightItems = null;
        renderHighlights();
    }
    return {
        update,
        sliceText,
        name: editorName,
        wrapper,
        editor,
        // updateText,
        // setText,
        scrollToDiff,
        scrollToHeading,
        // saveCaret,
        // restoreCaret,
        getVisibleAnchors,
        getFirstVisibleAnchor,
        scrollToLine,
        getFirstVisibleLineElement,
        getClosestAnchorToCaret: getClosestAnchorToCaret,
        setEditMode,
        getTextSelectionRange,
        selectTextRange,
        createTextRange,
        getTextRects,
        applyTextHighlight,
        clearTextHighlight,
        applyDiffHighlight,
        clearDiffHighlight,
        // Í∑∏ÎÉ• states Í∞ùÏ≤¥Î•º ÌïòÎÇò ÎßåÎì§Ïñ¥ÏÑú Î¶¨ÌÑ¥Ìï†Íπå...
        // get text() {
        // 	return _text;
        // },
        get lineElements() {
            return _lineElements;
        },
        get diffElements() {
            return _diffElements;
        },
        get visibleAnchors() {
            return _visibleAnchors;
        },
        get anchorElements() {
            return _anchorElements;
        },
        get visibleDiffIndices() {
            return _visibleDiffIndices;
        },
    };
}
//# sourceMappingURL=editor.js.map
</script>
<script id="worker.js" type="text/plain">"use strict";
const LINE_START = 1;
const LINE_END = 2;
const CONTAINER_START = 1 << 2;
const CONTAINER_END = 1 << 3;
const NO_JOIN = 1 << 4; // @@@, ### Îì±Îì±
const WILD_CARD = 1 << 5;
const MANUAL_ANCHOR = 1 << 6; // 32. @@@, ### Îì±Îì±
const IMAGE = 1 << 7;
const SECTION_HEADING_BIT = 10;
const SECTION_HEADING_TYPE1 = 1 << (SECTION_HEADING_BIT + 0); // 1.
const SECTION_HEADING_TYPE2 = 1 << (SECTION_HEADING_BIT + 1); // Í∞Ä.
const SECTION_HEADING_TYPE3 = 1 << (SECTION_HEADING_BIT + 2); // (1)
const SECTION_HEADING_TYPE4 = 1 << (SECTION_HEADING_BIT + 3); // (Í∞Ä)
const SECTION_HEADING_TYPE5 = 1 << (SECTION_HEADING_BIT + 4); // 1)
const SECTION_HEADING_TYPE6 = 1 << (SECTION_HEADING_BIT + 5); // Í∞Ä)
const LINE_BOUNDARY = LINE_START | LINE_END;
const CONTAINER_BOUNDARY = CONTAINER_START | CONTAINER_END;
const SECTION_HEADING_MASK = SECTION_HEADING_TYPE1 | SECTION_HEADING_TYPE2 | SECTION_HEADING_TYPE3 | SECTION_HEADING_TYPE4 | SECTION_HEADING_TYPE5 | SECTION_HEADING_TYPE6;
let _nextCtx = null;
let _currentCtx = null;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            diffs: result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhsTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    // return postProcess(ctx, rawResult, lhsTokens, rhsTokens);
    return rawResult;
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // ÌÖçÏä§Ìä∏Í∞Ä Í∏∏Ïñ¥ÏßÄÎäî Í≤ΩÏö∞(ÌÜ†ÌÅ∞Ïù¥ ÎßéÏùÄ Í≤ΩÏö∞) ÎÅîÏ∞çÌïòÍ≤å ÎßéÏùÄ Î∞òÎ≥µÏùÑ ÏàòÌñâÌïòÍ≤åÎêúÎã§.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú yield Ìï¥ÏÑú Ï∑®ÏÜåÏöîÏ≤≠ÏùÑ Î∞õÏïÑÏïºÌï®.
            // performance.now()Îäî ÎØ∏ÏπúÍ≤å ÏïÑÎãåÍ∞Ä Ïã∂ÏùÑ Ï†ïÎèÑÎ°ú Î¨¥Í±∞Ïö¥ Ìï®ÏàòÏù¥Í∏∞ ÎïåÎ¨∏Ïóê ÎêòÎèÑÎ°ù ÏûêÏ†ú.
            // await new Promise(...) Ïó≠Ïãú ÏûêÏ£º ÏÇ¨Ïö©ÌïòÎ©¥ ÏïàÎê®
            // (i+j) % 0x4000 === 0 Ïùº ÎïåÎßå ÏÇ¨Ïö©ÌïòÍ∏∞Î°ú. Î∏åÎùºÏö∞Ï†Ä jsÏóîÏßÑÏùò ÎπÑÌä∏Ïó∞ÏÇ∞ ÏÜçÎèÑÎ•º ÎØøÏñ¥Î≥∏Îã§ „Öã
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 50) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// Ï†ïÎì§ÏóàÎçò diff Ìï®Ïàò. ÌèêÍ∏∞Ï≤òÎ∂Ñ ÏòàÏ†ï.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                // empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                // empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞ index
                (!lcsEntry || // Í≥µÌÜµ sequenceÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞
                    (!greedyMatch && i < lcsEntry.leftIndex) || // Ï†ïÌôïÌïú lcsIndexÏóêÎßå Îß§Ïπ≠ÏãúÌÇ§Îäî Í≤ΩÏö∞
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or ÌÖçÏä§Ìä∏Í∞Ä Í∞ôÏúºÎ©¥ Î∞îÎ°ú Ï§ëÎã®
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞ index
                (!lcsEntry || // Í≥µÌÜµ sequenceÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞
                    (!greedyMatch && j < lcsEntry.rightIndex) || // Ï†ïÌôïÌïú lcsIndexÏóêÎßå Îß§Ïπ≠ÏãúÌÇ§Îäî Í≤ΩÏö∞
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or ÌÖçÏä§Ìä∏Í∞Ä Í∞ôÏúºÎ©¥ Î∞îÎ°ú Ï§ëÎã®
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Histogram Algorithm
// ÏùºÎã® ÏßÄÍ∏àÏùÄ Ïù¥ÎÜàÏù¥ ÎîîÌè¥Ìä∏
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    // ctx.entries = [] as DiffEntry[];
    let leftAnchors = [];
    let rightAnchors = [];
    for (let i = 0; i < lhsTokens.length; i++) {
        if (lhsTokens[i].flags & MANUAL_ANCHOR) {
            leftAnchors.push(i);
        }
    }
    if (leftAnchors.length > 0) {
        for (let i = 0; i < rhsTokens.length; i++) {
            if (rhsTokens[i].flags & MANUAL_ANCHOR) {
                rightAnchors.push(i);
            }
        }
    }
    const matches = [];
    if (rightAnchors.length > 0) {
        let rightPos = 0;
        for (let l = 0; l < leftAnchors.length; l++) {
            const leftTokenIndex = leftAnchors[l];
            for (let r = rightPos; r < rightAnchors.length; r++) {
                const rightTokenIndex = rightAnchors[r];
                if (lhsTokens[leftTokenIndex].text === rhsTokens[rightTokenIndex].text) {
                    matches.push({ lhsIndex: leftTokenIndex, rhsIndex: rightTokenIndex });
                    rightPos = r + 1;
                    break;
                }
            }
        }
    }
    let prevLhs = 0;
    let prevRhs = 0;
    for (const match of matches) {
        const lhsAnchor = match.lhsIndex;
        const rhsAnchor = match.rhsIndex;
        if (prevLhs < lhsAnchor || prevRhs < rhsAnchor) {
            // console.log("diffCore", {
            // 	lhsTokens,
            // 	lhsLower: prevLhs,
            // 	lhsUpper: lhsAnchor,
            // 	rhsTokens,
            // 	rhsLower: prevRhs,
            // 	rhsUpper: rhsAnchor,
            // });
            await diffCore(ctx, lhsTokens, prevLhs, lhsAnchor, rhsTokens, prevRhs, rhsAnchor, findBestHistogramAnchor);
        }
        ctx.entries.push({
            type: 0,
            left: {
                pos: lhsAnchor,
                len: 1,
            },
            right: {
                pos: rhsAnchor,
                len: 1,
            },
        });
        prevLhs = lhsAnchor + 1;
        prevRhs = rhsAnchor + 1;
    }
    if (prevLhs < lhsTokens.length || prevRhs < rhsTokens.length) {
        // console.log("diffCore", {
        // 	lhsTokens,
        // 	lhsLower: prevLhs,
        // 	lhsUpper: lhsTokens.length,
        // 	rhsTokens,
        // 	rhsLower: prevRhs,
        // 	rhsUpper: rhsTokens.length,
        // });
        await diffCore(ctx, lhsTokens, prevLhs, lhsTokens.length, rhsTokens, prevRhs, rhsTokens.length, findBestHistogramAnchor);
    }
    // const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findBestHistogramAnchor);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return ctx.entries;
}
// histogram diffÏóêÏÑú Í∞ÄÏû• Ï§ëÏöîÌïú Ìï®Ïàò
// ÏñºÎßàÎÇò Í∞íÏñ¥Ïπò ÏûàÎäî Í≥µÌÜµ ÏïµÏª§Î•º Ï∞æÎäêÎÉêÍ∞Ä Îß§Ïö∞ Ï§ëÏöîÌïòÍ≥† Í≥†Î°ú Í∑∏ Í∞íÏñ¥ÏπòÎ•º Îß§Í∏∞Îäî Í∏∞Ï§ÄÍ≥º Î∞©Î≤ïÏù¥ Îòê Îß§Ïö∞ Ï§ëÏöîÌï®
// Ïó¨Îü¨Í∞ÄÏßÄ ÏÉùÍ∞ÅÌï¥Î≥º Í≤ÉÎì§Ïù¥ ÎßéÏßÄÎßå...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // Í∏∏Ïù¥Í∞Ä ÎÑàÎ¨¥ ÌÅ¨Í≤å ÏòÅÌñ•ÏùÑ Ï£ºÎäî Í≤ΩÌñ•Ïù¥ ÏûàÏñ¥ÏÑú Ïù¥Í±∏Î°ú Ï°∞Ï†à
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.sectionHeadingMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; nÍ∑∏Îû®ÏùÑ ÏÇ¨Ïö©Ïãú Ïó¨Îü¨Îã®Ïñ¥Í∞Ä Îß§ÏπòÎêòÎäî Í≤ΩÏö∞ Ïò§ÌûàÎ†§ ÎßàÏßÄÎßâ Îã®Ïñ¥Í∞Ä Îã§Ïùå Ï§ÑÎ°ú ÎÑòÏñ¥Í∞ÄÏÑú Î≥¥ÎÑàÏä§Î•º Î™ª Î∞õÏùÑ ÏàòÍ∞Ä ÏûàÎã§
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + lhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + rhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // ÌäπÏàò ÏºÄÏù¥Ïä§
        // Í∞ïÏ†úÎ°ú Î¨∏ÏÑúÏùò ÌäπÏ†ï ÏßÄÏ†êÎÅºÎ¶¨ Îß§Ïπ≠ÏãúÌÇ¥. Î¨∏ÏÑú Íµ¨Ï°∞Í∞Ä Ìï≠ÏÉÅ ÎÇ¥ Îßò Í∞ôÏùÄ Í≤ÉÏù¥ ÏïÑÎãàÏïº. „Ö†
        // if (lhsTokens[i].flags & MANUAL_ANCHOR) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			console.log("manual anchor", ltext1, i, j);
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    // if (lhsTokens[li].flags & rhsTokens[ri].flags & MANUAL_ANCHOR) {
                    // 	return {
                    // 		lhsIndex: li,
                    // 		lhsLength: 1,
                    // 		rhsIndex: ri,
                    // 		rhsLength: 1,
                    // 	};
                    // }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext.length !== rtext.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & LINE_START) {
                    // if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LAST_OF_LINE) {
                    // 	score *= FULL_LINE_BONUS;
                    // } else {
                    // }
                    score *= LINE_START_BONUS;
                }
                else if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LINE_END) {
                    score *= LINE_END_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING_MASK) {
                    // if ((lhsTokens[i].flags & SECTION_HEADING_MASK) !== 0) {
                    // 	// LEVEL1ÏùÄ Î¨¥Ïãú. Î¨∏ÏÑú Íµ¨Ï°∞Í∞Ä ÏòÅÍµ¨Í∞ôÏùÄ Í≤ΩÏö∞Í∞Ä ÎßéÏùå.
                    // } else {
                    // }
                    score *= SECTION_HEADING_BONUS;
                }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience ÏïåÍ≥†Î¶¨Ï¶òÏóê Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎäî Ïû¨Í∑ÄÌï®Ïàò
// 1. Ïñë ÌÖçÏä§Ìä∏Î•º Í≥µÌÜµÎêòÎäî Î∂ÄÎ∂Ñ(ÏïµÏª§)ÏúºÎ°ú Î∂ÑÌï†
// 2. Î∂ÑÌï†Îêú ÏòÅÏó≠Ïóê ÎåÄÌï¥ÏÑú Ïû¨Í∑ÄÌò∏Ï∂ú
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor, consumeDirections = 3) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // ÏÇ¨Ïã§ Ïù¥Í±∏ Ïì∞Î©¥ Î¶¨ÌÑ¥Í∞íÏù¥ ÌïÑÏöî ÏóÜÎäîÎç∞...
    // Ìï®Ïàò ÏãúÍ∑∏ÎãàÏ≤òÎ•º Í≥†ÏπòÍ∏∞ Í∑ÄÏ∞ÆÏïÑÏÑú ÏùºÎã® ÎÇ¥ÎπÑÎë†.
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // Í≥µÌÜµ Î∂ÄÎ∂ÑÏùÑ Ïä§ÌÇµÌïòÎäîÍ±¥Îç∞ Î¨∏Ï†úÎäî Ïó¨Í∏∞ÏóêÏÑú HEAD, TAILÏùÑ Ïä§ÌÇµÌïòÍ≥†
    // Ïù¥ÌõÑÏóê diffCoreÎ•º Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Ìò∏Ï∂úÌï† Îïå ÏïûÏ™Ω Ï†àÎ∞òÏóê ÎåÄÌï¥ÏÑú HEADÎ∂ÄÎ∂Ñ, Îí§Ï™Ω Ï†àÎ∞òÏóê ÎåÄÌï¥ÏÑú TAILÎ∂ÄÎ∂ÑÏùÑ Îã§Ïãú ÌïúÎ≤à Ïä§ÌÇµÏùÑ ÏãúÎèÑÌïòÍ≤å ÎêúÎã§.
    // Îçî Ïù¥ÏÉÅ Ïä§ÌÇµÌï† Í≤å ÏóÜÏúºÎãà Í≤∞Í≥ºÏóêÎäî Ï∞®Ïù¥Í∞Ä ÏóÜÍ≤†ÏßÄÎßå Î∂àÌïÑÏöîÌïú ÏãúÎèÑÎ•º ÏïàÌïòÎäî Ï™ΩÏúºÎ°ú Í∞úÏÑ†Ìï¥ Î≥º ÌïÑÏöîÍ∞Ä ÏûàÏùå!
    // ÏÉùÍ∞ÅÌï¥Î≥º Í≤É: Í≥µÌÜµ prefix,suffixÎ•º Ïä§ÌÇµÌïòÏßÄ ÏïäÏïòÏùÑ Í≤ΩÏö∞ Ïä§ÌÇµÎêòÏßÄ ÏïäÏùÄ Î∂ÄÎ∂ÑÏóêÏÑú Îçî ÎÇòÏùÄ ÏïµÏª§Í∞Ä ÎÇòÏò¨ ÌôïÎ•†Ïù¥ ÏûàÎã§.
    // Í∑∏Î†áÏßÄÎßå Ïä§ÌÇµÌïòÏßÄ ÏïäÏúºÎ©¥ ÏÑ±Îä• ÏÉÅ ÏïÑÏ£º ÌÅ∞ Î¨∏Ï†úÍ∞Ä ÏÉùÍπÄ!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize", consumeDirections);
    // 	entries.push(...skippedHead); Ïù¥Î†áÍ≤å ÎÑ£ÏúºÎ©¥ Ìè≠Î∞úÌï®.
    for (const item of skippedHead) {
        entries.push(item);
    }
    // ÏñëÏ™Ω Î™®Îëê ÎÇ®ÏïÑÏûàÎäî ÏòÅÏó≠Ïù¥ ÏûàÎäî Í≤ΩÏö∞ Í≥µÌÜµ ÏïµÏª§Î•º Ï∞æÏïÑÎ≥∏Îã§!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! Ï†ÅÏñ¥ÎèÑ ÌïúÏ™ΩÏù¥ÎùºÎèÑ ÏòÅÏó≠ÏùÑ Ï§ÑÏó¨Ïïº Î¨¥ÌïúÎ£®ÌîÑ Ïïà ÏÉùÍ∏∏ ÎìØ?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        // console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor, 2);
        // ÏùòÎèÑÏ†ÅÏúºÎ°ú ÏïµÏª§ ÏòÅÏó≠ÍπåÏßÄ Ìè¨Ìï®Ìï¥ÏÑú Ìò∏Ï∂úÌï®
        await diffCore(ctx, leftTokens, anchor.lhsIndex, lhsUpper, rightTokens, anchor.rhsIndex, rhsUpper, findAnchor, 1);
        // await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor, 1);
    }
    else {
        // Ïú†Ìö®Ìïú ÏïµÏª§Îäî Î™ªÏ∞æÏïòÏßÄÎßå ÎÇ®ÏïÑÏûàÎäî ÌÜ†ÌÅ∞Îì§Ïù¥ ÏûàÎã§Î©¥ diffÎ°ú Ï≤òÎ¶¨
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    for (const item of skippedTail) {
        entries.push(item);
    }
    return entries;
}
// function appendEqualEntriesFromAnchor(
// 	leftTokens: Token[],
// 	lhsIndex: number,
// 	lhsLength: number,
// 	rightTokens: Token[],
// 	rhsIndex: number,
// 	rhsLength: number,
// 	whitespace: WhitespaceHandling = "ignore",
// 	entries: DiffEntry[]
// ) {
// 	let li = lhsIndex;
// 	let ri = rhsIndex;
// 	while (li < lhsIndex + lhsLength && ri < rhsIndex + rhsLength) {
// 		const lt = leftTokens[li];
// 		const rt = rightTokens[ri];
// 		if (lt.text === rt.text) {
// 			entries.push({
// 				type: 0,
// 				left: { pos: li, len: 1 },
// 				right: { pos: ri, len: 1 },
// 			});
// 			li++;
// 			ri++;
// 		} else if (whitespace === "ignore" && lt.text.length !== rt.text.length && lt.text[0] === rt.text[0]) {
// 			// 1:N, N:1 or N:M ‚Üí custom matching (e.g. matchPrefixTokens)
// 			const match = matchPrefixTokens(leftTokens, li, lhsIndex + lhsLength, rightTokens, ri, rhsIndex + rhsLength);
// 			if (!match) break;
// 			entries.push({
// 				type: 0,
// 				left: { pos: li, len: match[0] },
// 				right: { pos: ri, len: match[1] },
// 			});
// 			li += match[0];
// 			ri += match[1];
// 		} else {
// 			break;
// 		}
// 	}
// }
// Í≥µÎ∞±ÏùÑ ÏôÑÏ†ÑÌûà Î¨¥ÏãúÌïòÎäî Í≤ΩÏö∞ "ÏïàÎÖï ÌïòÏÑ∏Ïöî" vs "ÏïàÎÖïÌïòÏÑ∏Ïöî"Îäî Í∞ôÎã§Í≥† Ï≤òÎ¶¨Ìï¥ÏïºÌïòÏßÄÎßå
// Îã®Ïñ¥Îã®ÏúÑ ÌÜ†ÌÅ∞Ïù∏ Í≤ΩÏö∞ ÌÜ†ÌÅ∞ ÎåÄ ÌÜ†ÌÅ∞ ÎπÑÍµêÎäî Ïã§Ìå®Ìï† Ïàò Î∞ñÏóê ÏóÜÎã§.
// Îî∞ÎùºÏÑú Í∞Å ÌÜ†ÌÅ∞Ïùò Í∏ÄÏûêÎ•º ÌïúÎïÄÌïúÎïÄ Îß§ÏπòÏãúÏºúÎ¥êÏïºÌïòÍ≥† ÏñëÏ™ΩÏóêÏÑú ÌÜ†ÌÅ∞Ïù¥ ÎÅùÎÇòÎäî ÏãúÏ†êÍπåÏßÄ Î™®Îì† Í∏ÄÏûêÍ∞Ä Îß§ÏπòÎêòÏóàÎã§Î©¥
// Í∑∏ ÎÅùÎÇòÎäî ÏãúÏ†êÍπåÏßÄÏùò ÌÜ†ÌÅ∞ ÏàòÎßåÌÅº consumeÏùÑ Ìï®.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore", consumeDirections = 3) {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    if (consumeDirections & 1) {
        while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
            if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
                head.push({
                    type: 0,
                    left: { pos: lhsLower, len: 1 },
                    right: { pos: rhsLower, len: 1 },
                });
                lhsLower++;
                rhsLower++;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
                lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
                (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                head.push({
                    type: 0,
                    left: {
                        pos: lhsLower,
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsLower,
                        len: matchedCount[1],
                    },
                });
                lhsLower += matchedCount[0];
                rhsLower += matchedCount[1];
            }
            else {
                break;
            }
        }
    }
    // Suffix
    if (consumeDirections & 2) {
        while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
            if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
                tail.push({
                    type: 0,
                    left: { pos: lhsUpper - 1, len: 1 },
                    right: { pos: rhsUpper - 1, len: 1 },
                });
                lhsUpper--;
                rhsUpper--;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
                lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
                (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                tail.push({
                    type: 0,
                    left: {
                        pos: lhsUpper - matchedCount[0],
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsUpper - matchedCount[1],
                        len: matchedCount[1],
                    },
                });
                lhsUpper -= matchedCount[0];
                rhsUpper -= matchedCount[1];
            }
            else {
                break;
            }
        }
        tail.reverse();
    }
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    let lhsToken = leftTokens[i++], ltext = lhsToken.text, lhsLen = ltext.length;
    let rhsToken = rightTokens[j++], rtext = rhsToken.text, rhsLen = rtext.length;
    while (true) {
        while (ci < lhsLen && cj < rhsLen) {
            if (ltext[ci++] !== rtext[cj++]) {
                return false;
            }
        }
        // Î¨∏Ïûê Î∂àÏùºÏπò ÏóÜÏù¥ ÏñëÏ™Ω ÌÜ†ÌÅ∞Ïù¥ ÎèôÏãúÏóê ÎÅùÎÇú Í≤ΩÏö∞
        if (ci === lhsLen && cj === rhsLen)
            return [i - lhsLower, j - rhsLower];
        if (ci === lhsLen) {
            if (i === lhsUpper)
                return false;
            if (lhsToken.flags & CONTAINER_END)
                return false;
            lhsToken = leftTokens[i++];
            if (!lhsToken || lhsToken.flags & CONTAINER_START)
                return false;
            ltext = lhsToken.text;
            lhsLen = ltext.length;
            ci = 0;
        }
        if (cj === rhsLen) {
            if (j === rhsUpper)
                return false;
            if (rhsToken.flags & CONTAINER_END)
                return false;
            rhsToken = rightTokens[j++];
            if (!rhsToken || rhsToken.flags & CONTAINER_START)
                return false;
            rtext = rhsToken.text;
            rhsLen = rtext.length;
            cj = 0;
        }
    }
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let lhsToken = leftTokens[i--], ltext = lhsToken.text, rhsToken = rightTokens[j--], rtext = rhsToken.text;
    let ci = ltext.length - 1, cj = rtext.length - 1;
    while (true) {
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                return false;
            }
        }
        if (ci < 0 && cj < 0)
            return [lhsUpper - i - 1, rhsUpper - j - 1];
        if (ci < 0) {
            if (i < lhsLower)
                return false;
            if (lhsToken.flags & CONTAINER_START)
                return false;
            lhsToken = leftTokens[i--];
            if (lhsToken.flags & CONTAINER_END)
                return false;
            ltext = lhsToken.text;
            ci = lhsToken.text.length - 1;
        }
        if (cj < 0) {
            if (j < rhsLower)
                return false;
            if (rhsToken.flags & CONTAINER_START)
                return false;
            rhsToken = rightTokens[j--];
            if (rhsToken.flags & CONTAINER_END)
                return false;
            rtext = rhsToken.text;
            cj = rhsToken.text.length - 1;
        }
    }
}
//# sourceMappingURL=worker.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 22px;
	font-size: 16px;
	--container-gap: 8px;
	--sidebar-width: 250px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "ÎèãÏùå"; /*monospaceÍ∞Ä ÌïÑÏöîÌï† Îïå 'ÎèãÏùåÏ≤¥'Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÍ∏∞ ÎïåÎ¨∏!*/
	/* font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; */
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr var(--sidebar-width);
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 var(--container-gap, 0px);
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: "ÎèãÏõÄÏ≤¥", monospace;
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	/* white-space: pre-wrap; */
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.has-html .mirror,
.has-html .editor {
	white-space: normal;
	word-break: normal;
	overflow-wrap: normal;
	overflow-y: scroll;
}

.has-html table {
	border-spacing: 0;
	border-collapse: collapse;
	width: 100%;
}

.has-html td,
.has-html th {
	border: 1px solid #000;
	border-collapse: collapse;
	padding: 0.25rem;
	vertical-align: top;
}

.has-html img {
	border: 2px solid transparent;
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

#main > canvas {
	position: fixed;
	top: 0;
	left: 0;
	bottom: var(--status-bar-height, 0px);
	width: calc(100vw - var(--sidebar-width) - var(--container-gap, 0px));
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -1;
	will-change: transform;/* Ï†ïÌôïÌûà Î≠òÌïòÎäî ÎÜàÏù∏ÏßÄ ÏïåÏïÑÎ¥êÏïºÌï® */
}

.editor-wrapper canvas {
	position: fixed;
	bottom: var(--status-bar-height, 0px);
	width: calc((100vw - var(--sidebar-width) - var(--container-gap, 0px)) / 2);
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -2;
	will-change: transform;/* Ï†ïÌôïÌûà Î≠òÌïòÎäî ÎÜàÏù∏ÏßÄ ÏïåÏïÑÎ¥êÏïºÌï® */
}

.editor-wrapper canvas.highlight {
	z-index: -1;
}


.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -99;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: transparent;
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: #ccc;
	background-color: #000;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
	display: contents;
}

mark {
	background-color: inherit;
	color: inherit;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
}

mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-blockÏúºÎ°ú ÏïàÌï¥ÎëêÎ©¥ ÎÜíÏù¥ 1pxÏù¥ Î™®ÏûêÎ•¥Í≤å ÎêúÎã§. Î¨ªÏßÄÎßà... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
Í≥µÍ∞ÑÏùÑ Ï†ÑÌòÄ Ï∞®ÏßÄÌïòÏßÄ ÏïäÏúºÎ©¥ÏÑúÎèÑ visualÏù¥ ÏûàÏñ¥ÏïºÌï®
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
Ï§Ñ(div)ÏïàÏóê Î∏îÎü≠ ÏóòÎü¨Î®ºÌä∏Î•º ÎÑ£Ïñ¥ÏÑú Í∞ïÏ†úÎ°ú Ï§ÑÎ∞îÍøà Ìö®Í≥ºÎ•º Ï£ºÏóàÏùÑ Îïå
diffÍ∞Ä ÏóÜÎäî Í∞ÄÏÉÅÏùò Ï§ÑÎèÑ diffÍ∞Ä ÏûàÎäî Ï§ÑÏ≤òÎüº ÌëúÏãúÎêòÎäî Î¨∏Ï†ú.
ÎãπÏó∞ÌïúÍ±∞Í∏¥ ÌïúÎç∞... Ïâ¨Ïö¥ Ìï¥Í≤∞Î∞©Î≤ïÏù¥ Îñ†Ïò§Î•¥Ïßà ÏïäÎäîÎã§!
Í≥†ÎØº ÌïÑÏöî
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

#diffList .heading {
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	display: block;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "üë¨";
	font-size: 128px;
	font-weight: bold;
	font-family: monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "üí≠";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "‚óÄÔ∏è"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "‚ñ∂Ô∏è" !important; */
}

.edit hr {
	height: 0 !important;
}

/* ÏùòÎØ∏ÏóÜÎã§
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: -98;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.edit .mirror {
	display: none !important;
}

.aligned canvas {
	display: none !important;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}

.editor-wrapper h6 {
	all: unset;
}

.edit .editor-wrapper h6 {
	all: unset;
	text-decoration-color: #000;
}

.aligned .editor-wrapper h6 {
	color: #fff;
	font-weight: bold;
}

/* .edit .mirror br {
	display: none;
}

.aligned .mirror {
	white-space: normal;
}

.aligned .mirror div {
	display: contents;;
} */

.editor table {
	border-collapse: collapse;
	border-spacing: 0;
}

.editor th,
.editor td {
	vertical-align: top;
	border: 1px solid #000;
	padding: 2px 4px;
	user-select: none;
}

.editor p:empty::before {
	content: "\00a0";
}

.color-red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
}
</style>
</head>

<body>
    <div class="container">
        <main id="main">
            <div id="scrollSyncIndicator">üîó</div>
            <!--leftEditor will be here -->
            <!-- rightEditor will be here -->
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>
    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT}px;\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script>"use strict";
// Ïù¥Í≤ÉÏ†ÄÍ≤É Ïù¥Ïñ¥Î∂ôÏù¥Îäî ÏΩîÎìú ÏßëÌï©
const DiffSeek = (function () {
    let _activeEditor = null;
    let _lastFocusedEditor = null;
    let _lastScrolledEditor = null;
    let _currentlyScrollingEditor = null;
    let _preventScrollSync = false;
    let _currentDiffIndex = -1;
    let _syncEditor = false;
    let _resetCurrentlyScrollingEditorId = null;
    // let _diffResult: DiffResponse | null = null;
    let _diffContext = { done: false, reqId: 0 };
    let _outputOptions = {
        // Ïñ¥Ï∞®Ìîº ÎÇòÎßå Ïì∞Îäî Í∏∞Îä•ÏùºÌÖåÎãà
        leftLabel: "ÎåÄÎπÑÌëú",
        rightLabel: "Ï†ÑÎ¨∏",
        htmlFormat: "div",
        textFormat: 0,
    };
    let _copyMode = "raw";
    let _lastNonRawCopyMode = "compare";
    let _diffListItemElements = [];
    let _selectionHighlight = null;
    // Ï†ïÎßê ÏßÄÏ†ÄÎ∂ÑÌïú ÏΩîÎìú ÏãúÏûë
    const _diffOptions = (function (defaultValues) {
        let _diffOptions = { ...defaultValues };
        function setValue(key, value) {
            if (_diffOptions[key] !== value) {
                _diffOptions[key] = value;
                computeDiff();
            }
        }
        return {
            get algorithm() {
                return _diffOptions.algorithm;
            },
            set algorithm(value) {
                if (value !== "histogram" && value !== "lcs") {
                    throw new Error("Invalid algorithm: " + value);
                }
                setValue("algorithm", value);
            },
            get tokenization() {
                return _diffOptions.tokenization;
            },
            set tokenization(value) {
                if (value !== "char" && value !== "word" && value !== "line") {
                    throw new Error("Invalid tokenization: " + value);
                }
                setValue("tokenization", value);
            },
            get whitespace() {
                return _diffOptions.whitespace;
            },
            set whitespace(value) {
                if (value !== "ignore" && value !== "normalize") {
                    throw new Error("Invalid whitespace handling: " + value);
                }
                setValue("whitespace", value);
            },
            get greedyMatch() {
                return !!_diffOptions.greedyMatch;
            },
            set greedyMatch(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid greedyMatch: " + value);
                }
                setValue("greedyMatch", !!value);
            },
            get useLengthBias() {
                return !!_diffOptions.useLengthBias;
            },
            set useLengthBias(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid useLengthBias: " + value);
                }
                setValue("useLengthBias", !!value);
            },
            get maxGram() {
                return _diffOptions.maxGram;
            },
            set maxGram(value) {
                if (value < 1) {
                    throw new Error("Invalid maxGram: " + value);
                }
                setValue("maxGram", value);
            },
            get lengthBiasFactor() {
                return _diffOptions.lengthBiasFactor;
            },
            set lengthBiasFactor(value) {
                if (value <= 0) {
                    throw new Error("Invalid lengthBiasFactor: " + value);
                }
                setValue("lengthBiasFactor", value);
            },
            get sectionHeadingMultiplier() {
                return _diffOptions.sectionHeadingMultiplier;
            },
            set sectionHeadingMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid sectionHeadingMultiplier: " + value);
                }
                setValue("sectionHeadingMultiplier", value);
            },
            get lineStartMultiplier() {
                return _diffOptions.lineStartMultiplier;
            },
            set lineStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineStartMultiplier: " + value);
                }
                setValue("lineStartMultiplier", value);
            },
            get lineEndMultiplier() {
                return _diffOptions.lineEndMultiplier;
            },
            set lineEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineEndMultiplier: " + value);
                }
                setValue("lineEndMultiplier", value);
            },
            get uniqueMultiplier() {
                return _diffOptions.uniqueMultiplier;
            },
            set uniqueMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid uniqueMultiplier: " + value);
                }
                setValue("uniqueMultiplier", value);
            },
        };
    })({
        algorithm: "histogram",
        tokenization: "word",
        whitespace: "ignore",
        greedyMatch: false,
        useLengthBias: true,
        maxGram: 4,
        lengthBiasFactor: 0.7,
        sectionHeadingMultiplier: 1 / 0.75,
        lineStartMultiplier: 1 / 0.85,
        lineEndMultiplier: 1 / 0.9,
        uniqueMultiplier: 1 / 0.6667,
    });
    const editorContainer = document.getElementById("main");
    const leftEditor = createEditor(editorContainer, "left", getEditorCallbacks("left"));
    const rightEditor = createEditor(editorContainer, "right", getEditorCallbacks("right"));
    const canvas = document.createElement("canvas");
    canvas.id = "highlightCanvas";
    editorContainer.appendChild(canvas);
    const canvasCtx = canvas.getContext("2d");
    leftEditor.wrapper.tabIndex = 100;
    rightEditor.wrapper.tabIndex = 101;
    const body = document.querySelector("body");
    const diffList = document.getElementById("diffList");
    const highlightStyle = document.getElementById("highlightStyle");
    const progress = document.getElementById("progress");
    const scrollSyncIndicator = document.getElementById("scrollSyncIndicator");
    const alignmentStyleElement = document.createElement("style");
    document.head.appendChild(alignmentStyleElement);
    const resizeObserver = new ResizeObserver(() => {
        canvas.width = editorContainer.offsetWidth;
        canvas.height = editorContainer.offsetHeight;
    });
    resizeObserver.observe(editorContainer);
    function onSelectionChanged() {
        if (_diffContext.done === false) {
            _selectionHighlight = null;
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
            _selectionHighlight = null;
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const range = selection.getRangeAt(0);
        const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
            ? leftEditor
            : rightEditor.wrapper.contains(range.commonAncestorContainer)
                ? rightEditor
                : null;
        if (editor === null) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        _selectionHighlight = null;
        const [startOffset, endOffset] = editor.getTextSelectionRange();
        console.log("Selection:", startOffset, endOffset);
        if (startOffset === null || endOffset === null) {
            leftEditor.clearTextHighlight();
            rightEditor.clearTextHighlight();
            return;
        }
        const rawEntries = _diffContext.rawEntries;
        const tokens = editor === leftEditor ? _diffContext.leftTokens : _diffContext.rightTokens;
        const otherTokens = editor === leftEditor ? _diffContext.rightTokens : _diffContext.leftTokens;
        const sideKey = editor === leftEditor ? "left" : "right";
        const otherEditor = editor === leftEditor ? rightEditor : leftEditor;
        const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        console.log("Selected tokens:", startIndex, endIndex);
        const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
        console.log("Mapped tokens:", mappedStartIndex, mappedEndIndex);
        const otherStartToken = otherTokens[mappedStartIndex];
        const otherEndToken = otherTokens[mappedEndIndex - 1];
        if (otherStartToken && otherEndToken) {
            const otherStartPos = otherStartToken.pos;
            const otherEndPos = otherEndToken.pos + otherEndToken.len;
            otherEditor.applyTextHighlight(otherStartPos, otherEndPos);
            // const rectSet = otherEditor.getTextRects(otherStartPos, otherEndPos);
            // console.log("Rect set:", rectSet);
            // if (rectSet && rectSet.rects.length > 0) {
            // 	_selectionHighlight = {
            // 		editor: otherEditor,
            // 		rects: rectSet!.rects,
            // 	};
            // }
            // updateHighlightCanvas();
        }
    }
    function getEditorCallbacks(editorName) {
        const pendingDiffVisibilities = new Map();
        let updateDiffVisilitiesPending = false;
        return {
            onTextChanged: function () {
                onSelectionChanged();
                computeDiff();
            },
            // ÌòÑÏû¨ ÌôîÎ©¥ ÏÉÅÏóê Î≥¥Ïù¥Îäî diff ÏïÑÏù¥ÌÖúÎì§.
            onDiffVisibilityChanged: (entries) => {
                for (const entry of entries) {
                    const diffIndex = entry.item;
                    pendingDiffVisibilities.set(diffIndex, entry.isVisible);
                }
                if (!updateDiffVisilitiesPending) {
                    updateDiffVisilitiesPending = true;
                    requestAnimationFrame(() => {
                        updateDiffVisilitiesPending = false;
                        for (const [diffIndex, visible] of pendingDiffVisibilities) {
                            const listItem = _diffListItemElements[diffIndex];
                            if (listItem) {
                                const button = listItem.firstElementChild;
                                button.classList.toggle(editorName + "-visible", visible);
                            }
                        }
                        pendingDiffVisibilities.clear();
                    });
                }
            },
        };
    }
    function createWorker() {
        // Î≥¥Ïïà ÏÉÅ new Worker("worker.js")Îäî Ïã§Ìñâ ÏïàÎê®.
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerURL);
        return worker;
    }
    const { computeDiff } = (function () {
        const worker = createWorker();
        let _reqId = 0;
        let computeDiffTimeoutId = null;
        function* computeDiffGenerator(ctx) {
            let idleDeadline = yield ctx;
            ctx.leftTokens = tokenizeNode(leftEditor.editor);
            if (idleDeadline.timeRemaining() <= 1) {
                idleDeadline = yield;
            }
            ctx.rightTokens = tokenizeNode(rightEditor.editor);
            if (idleDeadline.timeRemaining() <= 1) {
                idleDeadline = yield;
            }
            const request = {
                type: "diff",
                reqId: ctx.reqId,
                options: ctx.diffOptions,
                leftTokens: ctx.leftTokens,
                rightTokens: ctx.rightTokens,
            };
            worker.postMessage(request);
        }
        function computeDiff() {
            if (computeDiffTimeoutId) {
                cancelIdleCallback(computeDiffTimeoutId);
                //clearTimeout(computeDiffTimeoutId);
            }
            _currentDiffIndex = -1;
            // const leftText = leftEditor.text;
            // const rightText = rightEditor.text;
            body.classList.add("computing");
            progress.textContent = "...";
            const ctx = (_diffContext = {
                reqId: ++_reqId, //overflow ÎêòÎäî ÏàúÍ∞Ñ ÏßÄÍµ¨ Î©∏Îßù
                // leftText: leftText,
                // rightText: rightText,
                diffOptions: { ..._diffOptions },
                done: false,
                processTime: 0,
            });
            const generator = computeDiffGenerator(ctx);
            const step = (idleDeadline) => {
                computeDiffTimeoutId = null;
                const { done } = generator.next(idleDeadline);
                if (!done && ctx === _diffContext) {
                    computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
                }
            };
            computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
        }
        worker.onmessage = function (e) {
            const data = e.data;
            if (data.type === "diff") {
                if (data.reqId === _reqId) {
                    // console.debug("diff response:", data);
                    body.classList.remove("computing");
                    _diffContext.rawEntries = data.diffs;
                    postProcess(_diffContext);
                    _diffContext.done = true;
                    _diffContext.processTime = data.processTime;
                    onDiffComputed(_diffContext);
                }
            }
            else if (data.type === "start") {
                progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
            }
        };
        function onDiffComputed(diffContext) {
            leftEditor.update(diffContext);
            rightEditor.update(diffContext);
            // calculateDiffRects();
            // leftEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            // rightEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            updateDiffList();
        }
        return { computeDiff };
    })();
    function restoreSelectionRange({ editor, startOffset, endOffset }) {
        if (editor) {
            editor.selectTextRange(startOffset, endOffset);
        }
    }
    function getSelectionRange() {
        let editor = null;
        let [startOffset, endOffset] = leftEditor.getTextSelectionRange();
        if (startOffset !== null) {
            editor = leftEditor;
        }
        else {
            [startOffset, endOffset] = rightEditor.getTextSelectionRange();
            if (startOffset !== null) {
                editor = rightEditor;
            }
        }
        if (editor) {
            return {
                editor,
                startOffset: startOffset,
                endOffset: endOffset,
            };
        }
        else {
            return null;
        }
    }
    function syncScrollPosition(sourceEditor) {
        if (_preventScrollSync) {
            return;
        }
        if (!sourceEditor) {
            sourceEditor = _currentlyScrollingEditor || _activeEditor || _lastFocusedEditor;
            if (!sourceEditor) {
                return;
            }
        }
        if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
            return;
        }
        _preventScrollSync = true;
        const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
        let sourceAnchor = null;
        let targetAnchor = null;
        sourceAnchor = sourceEditor.getClosestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
        if (sourceAnchor) {
            const anchorIndex = Number(sourceAnchor.dataset.anchor);
            targetAnchor = targetEditor.anchorElements[anchorIndex];
        }
        if (sourceAnchor && targetAnchor) {
            const prevLastScrolledEditor = _lastScrolledEditor;
            const sourceWrapper = sourceEditor.wrapper;
            const targetWrapper = targetEditor.wrapper;
            targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
            _lastScrolledEditor = prevLastScrolledEditor;
        }
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    let resetHighlightId = null;
    function highlightDiff(diffIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
	box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
	animation: highlightAnimation 0.3s linear 3; 
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 3000);
    }
    function highlightHeading(headingIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `[data-heading="${headingIndex}"] { 
	text-decoration-line: underline !important;
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 2000);
    }
    document.addEventListener("mouseover", (e) => {
        if (e.target.dataset.diff !== undefined) {
            const diff = Number(e.target.dataset.diff);
            leftEditor.applyDiffHighlight(diff);
            rightEditor.applyDiffHighlight(diff);
            // highlightDiff(diff);
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            const heading = Number(e.target.dataset.heading);
            highlightHeading(heading);
        }
    });
    document.addEventListener("mouseout", (e) => {
        if (e.target.dataset.diff !== undefined) {
            // const diff = Number((e.target as HTMLElement).dataset.diff);
            leftEditor.clearDiffHighlight();
            rightEditor.clearDiffHighlight();
            // highlightStyle.textContent = "";
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            highlightStyle.textContent = "";
            if (resetHighlightId !== null) {
                clearTimeout(resetHighlightId);
            }
        }
    });
    document.addEventListener("selectionchange", (e) => {
        onSelectionChanged();
    });
    // syncScrollToggle.addEventListener("click", () => {
    // 	toggleSyncScroll();
    // });
    // alignedModeToggle.addEventListener("click", () => {
    // 	if (_alignedMode) {
    // 		disableAlignedMode();
    // 	} else {
    // 		enableAlignedMode();
    // 	}
    // });
    function updateHighlightCanvas() {
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        if (_selectionHighlight) {
            const scrollTop = _selectionHighlight.editor.wrapper.scrollTop;
            const scrollLeft = _selectionHighlight.editor.wrapper.scrollLeft;
            // canvasCtx.fillStyle = "hsl(240 100% 90%)";
            canvasCtx.fillStyle = "hsl(210 100% 80%)";
            for (const rect of _selectionHighlight.rects) {
                const x = rect.x - scrollLeft;
                const y = rect.y - scrollTop;
                canvasCtx.fillRect(x, y, rect.width, rect.height);
            }
        }
    }
    function toggleSyncScroll() {
        _syncEditor = !_syncEditor;
    }
    function updateDiffList() {
        if (!_diffContext.done) {
            return;
        }
        const diffs = _diffContext.diffs;
        const headings = _diffContext.headings ?? [];
        _diffListItemElements.length = 0;
        const fragment = document.createDocumentFragment();
        let headingIndex = 0;
        let leftPos = 0;
        for (let i = 0; i < diffs.length; i++) {
            const diff = diffs[i];
            const thisLeftPos = diff.left.pos;
            // Í∑ÄÏ∞ÆÏùåÏùò Ï†ïÏ†ê. ÎåÄÏ∂© ÎèåÏïÑÍ∞ÄÍ≤åÎßå... Îî± Í±∞Í∏∞ÍπåÏßÄÎßå...
            for (let j = leftPos; j < thisLeftPos; j++) {
                for (; headingIndex < headings.length; headingIndex++) {
                    const heading = headings[headingIndex];
                    if (heading.left.pos > thisLeftPos) {
                        break;
                    }
                    const li = document.createElement("LI");
                    const hd = document.createElement("A");
                    hd.className = "heading";
                    hd.dataset.heading = headingIndex.toString();
                    hd.textContent = heading.ordinalText + " " + heading.title;
                    li.appendChild(hd);
                    fragment.appendChild(li);
                }
            }
            const li = document.createElement("LI");
            const button = document.createElement("MARK");
            button.draggable = true;
            button.dataset.diff = i.toString();
            button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
            li.appendChild(button);
            const leftText = leftEditor.sliceText(diff.left.pos, diff.left.pos + diff.left.len);
            const leftSpan = document.createElement("SPAN");
            leftSpan.textContent = leftText;
            leftSpan.classList.add("left");
            button.appendChild(leftSpan);
            const rightText = rightEditor.sliceText(diff.right.pos, diff.right.pos + diff.right.len);
            const rightSpan = document.createElement("SPAN");
            rightSpan.textContent = rightText;
            rightSpan.classList.add("right");
            button.appendChild(rightSpan);
            fragment.appendChild(li);
            _diffListItemElements[i] = li;
            leftPos = thisLeftPos;
        }
        for (; headingIndex < headings.length; headingIndex++) {
            const heading = headings[headingIndex];
            const li = document.createElement("LI");
            const hd = document.createElement("A");
            hd.className = "heading";
            hd.dataset.heading = headingIndex.toString();
            hd.textContent = heading.ordinalText + " " + heading.title;
            li.appendChild(hd);
            fragment.appendChild(li);
        }
        diffList.innerHTML = "";
        diffList.appendChild(fragment);
    }
    document.addEventListener("copy", (e) => {
        if (_diffContext.done === false) {
            return;
        }
        if (true) {
            return;
        }
        // const selection = window.getSelection();
        // if (!selection || selection.isCollapsed) return;
        // const range = selection.getRangeAt(0);
        // const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? leftEditor
        // 	: rightEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? rightEditor
        // 	: null;
        // if (editor === null) {
        // 	return;
        // }
        // const [startOffset, endOffset] = editor.getTextSelectionRange();
        // if (startOffset === null || endOffset === null) return;
        // if (_copyMode === "raw" && !_alignedMode) {
        // 	return;
        // }
        // e.preventDefault();
        // const text = editor.text;
        // const tokens = editor === leftEditor ? _diffContext.leftTokens! : _diffContext.rightTokens!;
        // const otherTokens = editor === leftEditor ? _diffContext.rightTokens! : _diffContext.leftTokens!;
        // const rawEntries = _diffContext.rawEntries!;
        // const sideKey = editor === leftEditor ? "left" : "right";
        // const otherSideKey = sideKey === "left" ? "right" : "left";
        // const diffs = _diffContext.diffs!;
        // if (_copyMode === "raw") {
        // 	const plain = editor.text.slice(startOffset, endOffset);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else if (_copyMode === "compare") {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const otherStartToken = otherTokens[mappedStartIndex];
        // 	const otherEndToken = otherTokens[mappedEndIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const otherStartPos = otherStartToken?.pos ?? 0;
        // 	const otherEndPos = otherEndToken ? otherEndToken.pos + otherEndToken.len : otherStartPos;
        // 	const leftRuns = getTextRuns(
        // 		"left",
        // 		leftEditor.text,
        // 		{ diffs },
        // 		sideKey === "left" ? startPos : otherStartPos,
        // 		sideKey === "left" ? endPos : otherEndPos
        // 	);
        // 	const rightRuns = getTextRuns(
        // 		"right",
        // 		rightEditor.text,
        // 		{ diffs },
        // 		sideKey === "right" ? startPos : otherStartPos,
        // 		sideKey === "right" ? endPos : otherEndPos
        // 	);
        // 	const html = buildOutputHTML(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	const plain = buildOutputPlainText(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const textRuns = getTextRuns(sideKey, leftEditor.text, { diffs }, startPos, endPos);
        // 	const html = buildOutputHTMLFromRuns(text, textRuns, _outputOptions);
        // 	const plain = buildOutputPlainTextFromRuns(text, textRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // }
    });
    document.addEventListener("keydown", (e) => {
        // Ïñ¥Îäê Îã®Ï∂ïÌÇ§Î•º Ïç®Ïïº ÏûòÏçºÎã§Í≥† ÏÜåÎ¨∏ÎÇòÎÉê?
        if (e.key === "F2") {
            e.preventDefault();
            if (e.shiftKey) {
                toggleSyncScroll();
                return;
            }
            return;
        }
        if (e.key === "F4") {
            e.preventDefault();
            if (_copyMode === "raw") {
                _copyMode = _lastNonRawCopyMode;
            }
            else {
                _lastNonRawCopyMode = _copyMode;
                _copyMode = "raw";
            }
            return;
        }
        if (e.key === "F8") {
            _diffOptions.whitespace = _diffOptions.whitespace === "ignore" ? "normalize" : "ignore";
        }
        // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Î∏åÎùºÏö∞Ï†ÄÏùò Ï≤´Î≤àÏß∏ ÌÉ≠, ÎëêÎ≤àÏß∏ ÌÉ≠ÏùÑ ÏÑ†ÌÉùÌïòÎäî Îã®Ï∂ïÌÇ§Ïù∏Îç∞...
        // Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎäî Îã®Ï∂ïÌÇ§Î•º ÎçÆÏñ¥Ïì∞Îäî Í±¥ Ï†ïÎßê Î™ªÎêú ÏßìÏù¥Í∏¥ ÌïúÎç∞...
        // ÏÇ¨Ïö©ÏûêÏùò ÏùòÎèÑÎ•º Î¨¥ÏãúÌï¥Î≤ÑÎ¶¥ Ïàò ÏûàÎäî ÏïÑÏ£º ÎÇòÏÅú Îã®Ï∂ïÌÇ§ÏßÄÎßå... Ïù∏ÌÑ∞ÎÑ∑ÎèÑ ÏïàÎêòÎäî Ïª¥ÏóêÏÑú ÎàÑÍ∞Ä Ïó£ÏßÄÏóê ÌÉ≠ÏùÑ Ïó¨Îü¨Í∞ú Ïó¥Ïñ¥ÎÜìÍ≥† Ïì∏Íπå Ïã∂Îã§.
        if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
            e.preventDefault();
            const editor = e.key === "1" ? leftEditor : rightEditor;
            editor.editor.focus();
            return;
        }
        // diff cycling
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            e.preventDefault();
            if (_diffContext.done) {
                const diffs = _diffContext.diffs;
                if (!diffs || diffs.length === 0) {
                    return;
                }
                _currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
                if (_currentDiffIndex < 0) {
                    _currentDiffIndex = diffs.length - 1;
                }
                if (_currentDiffIndex >= diffs.length) {
                    _currentDiffIndex = 0;
                }
                scrollToDiff(_currentDiffIndex);
                highlightDiff(_currentDiffIndex);
            }
        }
    });
    diffList.addEventListener("click", (e) => {
        const diffIndex = Number(e.target.dataset.diff);
        if (!isNaN(diffIndex)) {
            _currentDiffIndex = diffIndex;
            scrollToDiff(diffIndex);
            return;
        }
        const headingIndex = Number(e.target.dataset.heading);
        if (!isNaN(headingIndex)) {
            scrollToHeading(headingIndex);
            return;
        }
    });
    function scrollToDiff(diffIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToDiff(diffIndex);
        rightEditor.scrollToDiff(diffIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    function scrollToHeading(headingIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToHeading(headingIndex);
        rightEditor.scrollToHeading(headingIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    for (const editor of [leftEditor, rightEditor]) {
        editor.wrapper.addEventListener("scroll", (e) => {
            // updateCanvas();
            if (_currentlyScrollingEditor !== null || _preventScrollSync) {
                return;
            }
            _lastScrolledEditor = _currentlyScrollingEditor = editor;
            if (_syncEditor) {
                syncScrollPosition(editor);
            }
            if (_resetCurrentlyScrollingEditorId) {
                cancelAnimationFrame(_resetCurrentlyScrollingEditorId);
            }
            _resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
                _currentlyScrollingEditor = null;
            });
            // updateHighlightCanvas();
        });
        function onFocus() {
            _activeEditor = _lastFocusedEditor = editor;
        }
        function onBlur() {
            _activeEditor = null;
        }
        editor.editor.addEventListener("focus", onFocus);
        editor.editor.addEventListener("blur", onBlur);
        editor.editor.addEventListener("keydown", (e) => {
            if (e.key === " " && e.ctrlKey) {
                // ÏóêÎîîÌÑ∞ÏóêÏÑú Ìé∏Ïßë Ï§ë Î∞òÎåÄÏ™Ω ÏóêÎîîÌÑ∞Ïùò Ïä§ÌÅ¨Î°§ ÏúÑÏπòÎ•º ÌòÑÏû¨ ÏóêÎîîÌÑ∞Ïùò ÎÇ¥Ïö©Ïóê ÎßûÏ∂î...Î†§Í≥† ÏãúÎèÑÎßå Ìï¥ Î¥Ñ.
                syncScrollPosition(editor);
                return;
            }
            if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
                // Ïù¥Ï†ïÎèÑ Ïä§ÌÅ¨Î°§ÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎêòÏñ¥ÎêòÎäîÍ±∞ ÏïÑÎãàÏïº?? Ïù¥ Í∏∞Îä• ÎÇòÎßå Ïì∞ÎÇò?
                // Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ Î∞ñÏùò Îî± ÌïúÎëêÏ§Ñ! Îî± Í∑∏Ï†ïÎèÑÎßå Î≥¥Î©¥ ÎêúÎã§ Ïã∂ÏùÑ Îïå?
                // ÌÖçÏä§Ìä∏Ïª§ÏÑúÍ∞Ä Ï§ëÏïô Î∂ÄÎ∂ÑÏóê ÏúÑÏπòÌïòÏßÄ ÏïäÏúºÎ©¥ ÎßàÏùåÏù¥ ÎÜìÏù¥ÏßÄ ÏïäÏïÑÏÑú ÏßÄÍ∏à ÎãπÏû• ÏúÑÏïÑÎûòÎ°ú Ï°∞Í∏à Ïä§ÌÅ¨Î°§ Ìï¥ÏïºÎßå Ìï† Îïå!!!!
                const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2;
                editor.wrapper.scrollTop += delta;
                e.preventDefault();
            }
            if (e.key === "Escape") {
                const sel = window.getSelection();
                if (sel)
                    sel.removeAllRanges(); // ÏÑ†ÌÉù Ìï¥Ï†ú
            }
        });
        // editor.editor.addEventListener("click", (e) => {
        // 	if (e.ctrlKey) {
        // 		enableAlignedMode(true);
        // 	}
        // });
        function onClick(e) {
            if (e.altKey) {
                // const [start, end] = editor.getTextSelectionRange();
                // if (start !== null && end !== null && start === end) {
                // 	_activeEditor = editor;
                // 	disableAlignedMode();
                // 	setTimeout(() => {
                // 		//syncScrollPosition(editor);
                // 		document.execCommand("insertText", false, " " + MANUAL_ANCHOR1 + " ");
                // 		requestAnimationFrame(() => {
                // 			editor.updateText();
                // 		});
                // 	}, 0);
                // 	return;
                // }
            }
        }
        editor.editor.addEventListener("click", onClick);
    }
    // Î¨¥ÏãùÌïòÍ≤å ÌÅ∞ Ìï®Ïàò
    // Ï∞ùÏ∞ùÌïúÎç∞... Ïû¨ÎØ∏ ÏóÜÎäî Î∂ÄÎ∂ÑÏù¥Îùº...
    function postProcess(diffContext) {
        let prevEntry = null;
        // const leftText = diffContext.leftText!;
        // const rightText = diffContext.rightText!;
        const leftTokens = diffContext.leftTokens;
        const rightTokens = diffContext.rightTokens;
        const rawEntries = diffContext.rawEntries;
        const diffs = [];
        const anchors = [];
        const sectionHeadings = [];
        const headingStack = [];
        const MAX_ANCHOR_SKIP = 5;
        let anchorSkipCount = 0;
        for (let i = 0; i < rawEntries.length; i++) {
            const entry = rawEntries[i];
            if (entry.type) {
                // diff entry
                if (prevEntry) {
                    console.assert(prevEntry.left.pos + prevEntry.left.len === entry.left.pos, prevEntry, entry);
                    console.assert(prevEntry.right.pos + prevEntry.right.len === entry.right.pos, prevEntry, entry);
                    prevEntry.type |= entry.type;
                    prevEntry.left.len += entry.left.len;
                    prevEntry.right.len += entry.right.len;
                }
                else {
                    prevEntry = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
                    //prevEntry = entry;
                }
            }
            else {
                // common entry
                if (prevEntry) {
                    addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
                    // mappings.push(prevEntry);
                }
                prevEntry = null;
                const leftToken = leftTokens[entry.left.pos];
                const rightToken = rightTokens[entry.right.pos];
                if (leftToken.flags & rightToken.flags & LINE_START) {
                    // ÏïµÏª§ Ï∂îÍ∞Ä
                    addAnchor("before", leftToken.pos, rightToken.pos, null);
                    if (leftToken.flags & rightToken.flags & SECTION_HEADING_MASK) {
                        addHeading(i);
                    }
                }
                // mappings.push(entry);
            }
        }
        //addAnchor("before", leftText.length, -1, rightText.length, -1, null);
        if (prevEntry) {
            addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
            // mappings.push(prevEntry);
        }
        function addHeading(entryIndex) {
            if (true) {
                return;
            }
            // const entry = rawEntries[entryIndex];
            // if (entry.type !== 0) {
            // 	console.warn("uncommon entry", entry.type, entry);
            // 	return;
            // }
            // const leftToken = leftTokens[entry.left.pos];
            // const rightToken = rightTokens[entry.right.pos];
            // const type = leftToken.flags & SECTION_HEADING_MASK;
            // // console.debug("addHeading", { entryIndex, entry, leftToken, rightToken });
            // // ÏßÄÍ∏àÏùÄ ÏùºÏπòÎêòÎäî ÌÜ†ÌÅ∞ÏúºÎ°úÎ∂ÄÌÑ∞ Ìó§Îî©ÏùÑ Ï∂îÏ∂úÌïòÎØÄÎ°ú ÌÉÄÏûÖÎèÑ ÎãπÏó∞Ìûà Í∞ôÍ≤†ÏßÄÎßå
            // // ÎÇòÏ§ëÏóê ÏùºÏπòÎêòÏßÄ ÏïäÎäî ÌÜ†ÌÅ∞ÏúºÎ°úÎ∂ÄÌÑ∞ Ìó§Îî©ÏùÑ Ï∂îÏ∂úÌïòÍ≤å Îê† ÏàòÎèÑ ÏûàÏúºÎãà ÎßàÏùåÏù¥ Ìé∏ÌïòÍ≤å Ïó¨Í∏∞ÏÑú ÌïúÎ≤à Îçî ÌôïÏù∏.
            // if (!type || (rightToken.flags & SECTION_HEADING_MASK) !== type) {
            // 	console.warn("type mismatch", entry.type, entry);
            // 	return;
            // }
            // const ordinalText = leftToken.text;
            // const ordinalNum = parseOrdinalNumber(ordinalText);
            // if (Number.isNaN(ordinalNum)) {
            // 	console.warn("Invalid ordinal number", ordinalText);
            // 	return;
            // }
            // // Ìó§Îî© Ï§Ñ ÎÅù Ï∞æÍ∏∞
            // // Ïù¥ Í∞íÎì§ÏùÄ ÌÖçÏä§Ìä∏ ÎÇ¥Ïùò Î¨∏ÏûêÏúÑÏπòÍ∞Ä ÏïÑÎãàÎùº ÌÜ†ÌÅ∞ Î∞∞Ïó¥ ÏïàÏùò ÌÜ†ÌÅ∞ Ïù∏Îç±Ïä§ÏôÄ Í∞úÏàòÏûÑ!
            // let hasDiff = false;
            // let leftTokenCount = 0;
            // let rightTokenCount = 0;
            // for (let j = entryIndex; j < rawEntries.length; j++) {
            // 	const entry2 = rawEntries[j];
            // 	leftTokenCount += entry2.left.len;
            // 	if (!hasDiff && entry2.type === 0) {
            // 		rightTokenCount += entry2.right.len;
            // 	} else {
            // 		hasDiff = true;
            // 	}
            // 	if (leftTokens[entry2.left.pos + entry2.left.len - 1].flags & LAST_OF_LINE) {
            // 		break;
            // 	}
            // }
            // if (leftTokenCount < 2) {
            // 	console.warn("Invalid heading", leftTokenCount, rightTokenCount, entry);
            // 	return;
            // }
            // const lefTokenEnd = entry.left.pos + leftTokenCount;
            // const title = leftText.slice(leftTokens[entry.left.pos + 1].pos, leftTokens[lefTokenEnd - 1].pos + leftTokens[lefTokenEnd - 1].len);
            // let prevSibling: SectionHeading | null = null;
            // let parent: SectionHeading | null = null;
            // for (let i = headingStack.length - 1; i >= 0; i--) {
            // 	const candidate = headingStack[i];
            // 	if (candidate.type === type) {
            // 		prevSibling = candidate;
            // 		headingStack.length = i;
            // 		break;
            // 	}
            // }
            // if (!prevSibling) {
            // 	parent = headingStack[headingStack.length - 1] ?? null;
            // } else {
            // 	parent = prevSibling.parent;
            // }
            // const current: SectionHeading = {
            // 	ordinalText,
            // 	ordinalNum,
            // 	title,
            // 	type,
            // 	left: {
            // 		pos: leftTokens[entry.left.pos].pos,
            // 		len: leftTokens[lefTokenEnd - 1].pos + leftTokens[lefTokenEnd - 1].len - leftTokens[entry.left.pos].pos,
            // 	},
            // 	right: {
            // 		pos: rightTokens[entry.right.pos].pos,
            // 		len:
            // 			rightTokens[entry.right.pos + rightTokenCount - 1].pos +
            // 			rightTokens[entry.right.pos + rightTokenCount - 1].len -
            // 			rightTokens[entry.right.pos].pos,
            // 		// len: rightTokens[rightEndPos - 1].pos + rightTokens[rightEndPos - 1].len - rightTokens[entry.right.pos].pos,
            // 	},
            // 	parent,
            // 	firstChild: null,
            // 	nextSibling: null,
            // 	level: headingStack.length + 1,
            // 	outOfOrder: false,
            // 	hasDiff,
            // };
            // if (prevSibling) {
            // 	prevSibling.nextSibling = current;
            // 	if (current.ordinalNum <= prevSibling.ordinalNum) {
            // 		current.outOfOrder = true;
            // 	}
            // } else if (parent) {
            // 	parent.firstChild = current;
            // }
            // headingStack.push(current);
            // sectionHeadings.push(current);
        }
        function addAnchor(type, leftPos, rightPos, diffIndex) {
            if (leftPos === undefined || rightPos === undefined) {
                console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
            }
            if (true) {
                return;
            }
            //ÏïµÏª§Í∞Ä ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎäî Í±∏ Î∞©ÏßÄ! section headingÏù∏ Í≤ΩÏö∞ Ïä§ÌÇµÌïòÎ©¥ ÏïàÎêòÍ≥† Í∑∏Í±∏ ÌåêÎã®ÌïòÎ†§Î©¥ tokenÏù¥ ÌïÑÏöîÌï®... Í∑ÄÏ∞ÆÏïÑ
            // if (diffIndex === null && anchorSkipCount < MAX_ANCHOR_SKIP && anchors.length > 0) {
            // 	const lastAnchor = anchors[anchors.length - 1];
            // 	if (lastAnchor.type === type && lastAnchor.diffIndex === null && leftLine - lastAnchor.leftLine <= 1 && rightLine - lastAnchor.rightLine <= 1) {
            // 		anchorSkipCount++;
            // 		return;
            // 	}
            // }
            // anchorSkipCount = 0;
            // if (type === "before") {
            // 	// before ÏïµÏª§Îäî Ìï≠ÏÉÅ Ï§ÑÏùò ÏãúÏûëÏúÑÏπòÏùº ÎïåÎßå Ï∂îÍ∞ÄÌïòÎØÄÎ°ú Ï§ÑÎ∞îÍøà Î¨∏ÏûêÎßå ÌôïÏù∏ÌïòÎ©¥ ÎêúÎã§!
            // 	while (leftPos > 0 && leftText[leftPos - 1] !== "\n") {
            // 		leftPos--;
            // 	}
            // 	while (rightPos > 0 && rightText[rightPos - 1] !== "\n") {
            // 		rightPos--;
            // 	}
            // } else if (type === "after") {
            // 	// empty diffÏùò afterÏïµÏª§Îäî Ïù¥ÌõÑÏóê Îã§Î•∏ ÌÜ†ÌÅ∞Ïù¥ Ï°¥Ïû¨Ìï† Ïàò ÏûàÏùå.
            // 	// Í≥µÎ∞±Ïù¥ ÏïÑÎãå Î¨∏ÏûêÍ∞Ä ÎÇòÏò§Î©¥ Î©àÏ∂îÍ≥† Í∏∞Î≥∏ ÏúÑÏπò ÏÇ¨Ïö©.
            // 	let p;
            // 	p = leftPos;
            // 	while (p < leftText.length) {
            // 		const ch = leftText[p++];
            // 		if (ch === "\n") {
            // 			leftPos = p - 1;
            // 			break;
            // 		} else if (!spaceChars[ch]) {
            // 			break;
            // 		}
            // 	}
            // 	p = rightPos;
            // 	while (p < rightText.length) {
            // 		const ch = rightText[p++];
            // 		if (ch === "\n") {
            // 			rightPos = p - 1;
            // 			break;
            // 		} else if (!spaceChars[ch]) {
            // 			break;
            // 		}
            // 	}
            // }
            // if (anchors.length > 0) {
            // 	let lastAnchor = anchors[anchors.length - 1];
            // 	if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
            // 		return;
            // 	}
            // 	if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
            // 		if (type === lastAnchor.type || type === "before") {
            // 			return;
            // 		}
            // 	}
            // }
            // // anchors.push({ type, left: leftPos, leftLine, right: rightPos, rightLine, diffIndex });
            // anchors.push({ type, left: leftPos, right: rightPos, diffIndex });
        }
        function addDiff(leftIndex, leftCount, rightIndex, rightCount) {
            let leftPos, leftLen, rightPos, rightLen;
            let leftBeforeAnchorPos, rightBeforeAnchorPos, leftAfterAnchorPos, rightAfterAnchorPos, leftEmpty, rightEmpty;
            let type;
            let asBlock = false;
            // ÏñëÏ™ΩÏóê ÎåÄÏùëÌïòÎäî ÌÜ†ÌÅ∞Ïù¥ Î™®Îëê Ï°¥Ïû¨ÌïòÎäî Í≤ΩÏö∞. Ïâ¨Ïö¥ ÏºÄÏù¥Ïä§
            if (leftCount > 0 && rightCount > 0) {
                type = 3;
                let leftTokenStart = leftTokens[leftIndex];
                let leftTokenEnd = leftTokens[leftIndex + leftCount - 1];
                let rightTokenEnd = rightTokens[rightIndex + rightCount - 1];
                let rightTokenStart = rightTokens[rightIndex];
                leftPos = leftTokenStart.pos;
                leftLen = leftTokenEnd.pos + leftTokenEnd.len - leftPos;
                leftEmpty = false;
                rightPos = rightTokenStart.pos;
                rightLen = rightTokenEnd.pos + rightTokenEnd.len - rightPos;
                rightEmpty = false;
                // ÏÉùÍ∞Å: ÌïúÏ™ΩÎßå Ï§ÑÏùò Ï≤´ ÌÜ†ÌÅ∞Ïùº ÎïåÏóêÎèÑ ÏïµÏª§Î•º ÎÑ£ÏùÑÍπå? ÏïµÏª§Ïóê display:blockÏùÑ Ï§òÏÑú Í∞ïÏ†úÎ°ú Ï§ÑÎ∞îÍøà ÏãúÌÇ® ÌõÑÏóêÏóê
                // Ï¢åÏö∞ Ï†ïÎ†¨ÏùÑ Ìï† Ïàò ÏûàÏùÑ Í≤É Í∞ôÍ∏∞ÎèÑ ÌïúÎç∞...
                if (leftTokenStart.flags & rightTokenStart.flags & LINE_START) {
                    leftBeforeAnchorPos = leftPos;
                    rightBeforeAnchorPos = rightPos;
                    // while (leftBeforeAnchorPos > 0 && leftText[leftBeforeAnchorPos - 1] !== "\n") {
                    // 	leftBeforeAnchorPos--;
                    // }
                    // while (rightBeforeAnchorPos > 0 && rightText[rightBeforeAnchorPos - 1] !== "\n") {
                    // 	rightBeforeAnchorPos--;
                    // }
                    // // addAnchor("before", leftAnchorPos, rightAnchorPos, null);
                    // if (leftTokenEnd.flags & rightTokenEnd.flags & LAST_OF_LINE) {
                    // 	asBlock = true;
                    // 	leftAfterAnchorPos = leftPos + leftLen;
                    // 	rightAfterAnchorPos = rightPos + rightLen;
                    // 	if (leftText[leftAfterAnchorPos] !== "\n") {
                    // 		do {
                    // 			leftAfterAnchorPos++;
                    // 		} while (leftAfterAnchorPos < leftText.length && leftText[leftAfterAnchorPos] !== "\n");
                    // 	}
                    // 	if (rightText[rightAfterAnchorPos] !== "\n") {
                    // 		do {
                    // 			rightAfterAnchorPos++;
                    // 		} while (rightAfterAnchorPos < rightText.length && rightText[rightAfterAnchorPos] !== "\n");
                    // 	}
                    // 	// while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
                    // 	// 	leftAnchorPos++;
                    // 	// }
                    // 	// while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
                    // 	// 	rightAnchorPos++;
                    // 	// }
                    // 	// addAnchor("after", leftBeforeAnchorPos, rightBeforeAnchorPos, null);
                    // }
                }
            }
            else {
                // ÌïúÏ™ΩÏù¥ ÎπÑÏñ¥ÏûàÏùå.
                // Îã®ÏàúÌïòÍ≤å ÌÜ†ÌÅ∞ ÏÇ¨Ïù¥Ïóê ÏúÑÏπòÏãúÏºúÎèÑ ÎêòÏßÄÎßå ÎêòÎèÑÎ°ùÏù¥Î©¥ ÎåÄÏùëÌïòÎäî Ï™ΩÍ≥º Ïú†ÏÇ¨Ìïú ÏúÑÏπò(Ï§ÑÏãúÏûë/Ï§ÑÎÅù)Ïóê ÏúÑÏπòÏãúÌÇ§Í∏∞ ÏúÑÌï¥...
                // ÏûêÍæ∏ Ïù¥Îü∞Ï†ÄÎü∞ ÏãúÎèÑÎ•º ÌïòÎã§Î≥¥Îãà ÎÇúÏû•ÌåêÏù∏Îç∞ ÎßåÏßÄÍ∏∞ Ïã´Ïùå...
                let longSideText, shortSideText;
                let longSideIndex, longSideCount, longSideTokens;
                let shortSideIndex, shortSideTokens;
                let longSidePos, longSideLen;
                let shortSidePos, shortSideLen;
                let longSideBeforeAnchorPos, shortSideBeforeAnchorPos;
                let longSideAfterAnchorPos, shortSideAfterAnchorPos;
                let longSideTokenStart, longSideTokenEnd;
                let shortSideBeforeToken, shortSideAfterToken;
                if (leftCount > 0) {
                    type = 1; // 1: left
                    longSideTokens = leftTokens;
                    longSideIndex = leftIndex;
                    longSideCount = leftCount;
                    shortSideTokens = rightTokens;
                    shortSideIndex = rightIndex;
                    leftEmpty = false;
                    rightEmpty = true;
                }
                else {
                    type = 2; // 2: right
                    longSideTokens = rightTokens;
                    longSideIndex = rightIndex;
                    longSideCount = rightCount;
                    shortSideTokens = leftTokens;
                    shortSideIndex = leftIndex;
                    leftEmpty = true;
                    rightEmpty = false;
                }
                longSideTokenStart = longSideTokens[longSideIndex];
                longSideTokenEnd = longSideTokens[longSideIndex + longSideCount - 1];
                shortSideBeforeToken = shortSideTokens[shortSideIndex - 1];
                shortSideAfterToken = shortSideTokens[shortSideIndex];
                longSidePos = longSideTokenStart.pos;
                longSideLen = longSideTokenEnd.pos + longSideTokenEnd.len - longSidePos;
                shortSidePos = shortSideBeforeToken ? shortSideBeforeToken.pos + shortSideBeforeToken.len : 0;
                shortSideLen = 0;
                const longSideIsFirstWord = longSideTokenStart.flags & LINE_START;
                const longSideIsLastWord = longSideTokenEnd.flags & LINE_END;
                const shortSideIsOnLineEdge = shortSideTokens.length === 0 ||
                    (shortSideBeforeToken && shortSideBeforeToken.flags & LINE_END) ||
                    (shortSideAfterToken && shortSideAfterToken.flags & LINE_START);
                let shortSidePushedToNextLine = false;
                // base posÎäî ÎêòÎèÑÎ°ùÏù¥Î©¥ ÏïûÏ™ΩÏúºÎ°ú Ïû°Ïûê. ÎÇúÎç∞ÏóÜÏù¥ ÎπàÏ§Ñ 10Í∞ú Ïä§ÌÇµÌïòÍ≥† diffÍ∞Ä ÏãúÏûëÎêòÎ©¥ Ïù¥ÏÉÅÌïòÏûêÎÇò.
                if (shortSideIsOnLineEdge) {
                    // Ï§ÑÏùò Í≤ΩÍ≥ÑÏóê empty diffÎ•º ÌëúÏãúÌïòÎäî Í≤ΩÏö∞ ÌòÑÏû¨ Ï§ÑÏùò ÎÅùÏù¥ÎÇò Îã§Ïùå Ï§ÑÏùò ÏãúÏûë Ï§ë "Ï†ÅÏ†àÌïòÍ≤å" ÏÑ†ÌÉù. ÌòÑÏû¨ Ï§ÑÏùò ÎÅù(Ïù¥Ï†Ñ ÌÜ†ÌÅ∞Ïùò Îí§)Ïóê ÏúÑÏπò Ï§ëÏûÑ.
                    if (longSideIsFirstWord) {
                        // if (shortSidePos !== 0) {
                        // 	// posÍ∞Ä 0Ïù¥ ÏïÑÎãå Í≤ΩÏö∞Îäî Ïù¥Ï†Ñ ÌÜ†ÌÅ∞Ïùò Îí§Î°ú ÏúÑÏπòÎ•º Ïû°ÏùÄ Í≤ΩÏö∞ÎãàÍπå Îã§Ïùå Ï§ÑÎ∞îÍøàÏùÑ Ï∞æÏïÑÏÑú Í∑∏ Ï§ÑÎ∞îÍøà Îí§Î°ú Î∞ÄÏñ¥Ï§å
                        // 	// Ï£ºÏùò: ÌòÑÏû¨ ÏúÑÏπò Ïù¥ÌõÑÏóê Ï§ÑÎ∞îÍøàÏù¥ ÏûàÎäîÏßÄ ÏóÜÎäîÏßÄ ÌôïÏù∏ÌïòÍ∏∞Î≥¥Îã§Îäî ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Ïùò ÎßàÏßÄÎßâÏóê Ï§ÑÎ∞îÍøàÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Í∞ïÏ†úÎ°ú Ï§ÑÎ∞îÍøàÏùÑ Î∂ôÏó¨Ï£ºÎäîÍ≤å Ìé∏Ìï®.
                        // 	// ÏûäÏßÄÎßêÍ≥† Íº≠ ÏõêÎ≥∏ÌÖçÏä§Ìä∏Ïùò ÎÅùÏóê Ï§ÑÎ∞îÍøà ÌïòÎÇò Î∂ôÏùº Í≤É.
                        // 	// const maxPos = shortSideAfterToken ? shortSideAfterToken.pos - 1 : shortSideText.length - 1;
                        // 	// while (shortSidePos < maxPos && shortSideText[shortSidePos++] !== "\n");
                        // 	while (shortSideText[shortSidePos++] !== "\n");
                        // 	shortSidePushedToNextLine = true;
                        // }
                        // ÏñëÏ™Ω Î™®Îëê Ï§ÑÏùò ÏãúÏûë Î∂ÄÎ∂ÑÏóê ÏúÑÏπòÌïòÎØÄÎ°ú ÏïµÏª§ Ï∂îÍ∞Ä.
                        // Îπà diffÍ∞Ä Ï§Ñ ÏãúÏûëÏù¥ÎÇò Ï§Ñ ÎÅù ÏúÑÏπòÏóê ÏûàÎã§Î©¥ ÌïòÎÇòÏùò Ï§ÑÎ°ú ÌëúÏãúÎêòÍ≤å Ìï† Ïàò ÏûàÏùå(css ÏÇ¨Ïö©)
                        longSideBeforeAnchorPos = longSidePos;
                        shortSideBeforeAnchorPos = shortSidePos;
                    }
                    if (longSideIsLastWord
                    // && !shortSideAfterToken || (shortSideBeforeToken && shortSideAfterToken.lineNum - shortSideBeforeToken.lineNum > 1)
                    ) {
                        asBlock = !!longSideIsFirstWord;
                        longSideAfterAnchorPos = longSidePos + longSideLen;
                        shortSideAfterAnchorPos = shortSidePos;
                    }
                }
                if (leftCount > 0) {
                    leftPos = longSidePos;
                    leftLen = longSideLen;
                    leftEmpty = false;
                    leftBeforeAnchorPos = longSideBeforeAnchorPos;
                    leftAfterAnchorPos = longSideAfterAnchorPos;
                    rightPos = shortSidePos;
                    rightLen = shortSideLen;
                    rightEmpty = true;
                    rightBeforeAnchorPos = shortSideBeforeAnchorPos;
                    rightAfterAnchorPos = shortSideAfterAnchorPos;
                }
                else {
                    leftPos = shortSidePos;
                    leftLen = shortSideLen;
                    leftEmpty = true;
                    leftBeforeAnchorPos = shortSideBeforeAnchorPos;
                    leftAfterAnchorPos = shortSideAfterAnchorPos;
                    rightPos = longSidePos;
                    rightLen = longSideLen;
                    rightEmpty = false;
                    rightBeforeAnchorPos = longSideBeforeAnchorPos;
                    rightAfterAnchorPos = longSideAfterAnchorPos;
                }
            }
            if (leftBeforeAnchorPos !== undefined && rightBeforeAnchorPos !== undefined) {
                addAnchor("before", leftBeforeAnchorPos, rightBeforeAnchorPos, diffs.length);
            }
            if (leftAfterAnchorPos !== undefined && rightAfterAnchorPos !== undefined) {
                addAnchor("after", leftAfterAnchorPos, rightAfterAnchorPos, diffs.length);
            }
            const newEntry = {
                type: type,
                left: {
                    pos: leftPos,
                    len: leftLen,
                    // empty: leftEmpty,
                },
                right: {
                    pos: rightPos,
                    len: rightLen,
                    // empty: rightEmpty,
                },
                asBlock,
            };
            diffs.push(newEntry);
        }
        diffContext.diffs = diffs;
        diffContext.anchors = anchors;
        diffContext.headings = sectionHeadings;
        // return { diffs, anchors, leftTokenCount: leftTokens.length, rightTokenCount: rightTokens.length, sectionHeadings };
    }
    _diffContext = {
        reqId: 0,
        // leftText: leftEditor.text,
        // rightText: rightEditor.text,
        diffOptions: { ..._diffOptions },
        done: false,
    };
    computeDiff();
    return {
        get dump() {
            // ÎîîÎ≤ÑÍπÖ Ìï† Îïå...
            return {
                _diffContext: _diffContext,
                // diffs: _diffResult?.diffs,
                // anchors: _diffResult?.anchors,
                diffOptions: _diffOptions,
                leftEditor,
                rightEditor,
                activeEditor: _activeEditor,
            };
        },
        compute: computeDiff,
        diffOptions: _diffOptions,
        get outputOptions() {
            return _outputOptions;
        },
    };
})();
//# sourceMappingURL=main.js.map
</script>
</body>

</html>
