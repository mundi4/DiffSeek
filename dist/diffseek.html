<!DOCTYPE html>
<!--
# DiffSeek 
#### 개요
- 정말 센스만점 이름. 중국산 DeepSeek 아님.
- 업무매뉴얼 비교의 압박 때문에 개발...이라고 하면 너무 거창하고 그냥 한번 짜봤음.
- 기본적으로 Histogram 알고리즘 사용. 브라우저 개발툴 콘솔에서 `DiffSeek.diffOptions.algorithm = "histogram|lcs|myers"` 뭐 이렇게 다른 알고리즘도 사용 가능하지만... `myers` 알고리즘은 아직 제대로 완성 못시켰고(살짝 어려움) `lcs`는 조금 느림.
- 공백 무시. 공백을 완전히 무시하는건 완전히 의도된 것임. **업무매뉴얼의 줄바꿈 위치는 절대로 문장의 끝 혹은 단락의 끝과 일치하지 않음!**(`DiffSeek.diffOptions.whitespace = "ignore|normalize"`). 참고로 공백을 전혀 무시하지 않거나 정규화(여러개의 연속된 공백을 하나로 인식)해서 비교하는 코드를 짜는게 100만배 쉬움.
- 단어 단위 diff. 글자 단위 diff는 성능도 성능이지만 사람의 눈에 오히려 더 피곤하기만 함. 줄 단위의 경우도 문서마다 줄바꿈의 위치가 지멋대로라 비효율적임(`DiffSeek.diffOptions.tokenization = "char|word|line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

#### 구현 의도? 참고사항?
- 양쪽에 텍스트 붙여넣고 실행버튼 딱~ 누르면 diff들이 표시되.... *왜???? 버튼을 뭐하러 눌러?* **diff는 텍스트 변경시 실시간으로, 입력한 텍스트 바로 그 자리에서 보여줘야 함!!**(사실 입력과 결과view를 분리하면 결과view는 더 자유롭게 기능도 빵빵하게 그리고 더 쉽게 만들 수는 있음).
- 실시간으로 업데이트가 일어나는 도중에도 편집을 방해하면 안됨. 미세한 딜레이라든지 의도하지 않은 커서위치 변경, 한글입력상태 복원 등등(한글입력상태 복원 방법은 없다 보면 됨. 우회하는 방법은 업데이트를 안하는것, 최소한 커서가 있는 노드에 대해서는 업데이트를 안하고 미루는 방법이 거의 유일함).
- 업데이트마다 DOM을 완전히 싹 갈아엎지 말고 가능한 경우 기존 노드들을 재사용 할 것.
- 편집기(사실 그냥 텍스트 입력창ㅋ)의 기본적인 기능(복붙,undo/redo,...)들은 되도록 브라우저에게 넘길 것. 이런 기능들은 숨쉬기와 같아서 예상대로 작동 안하는 순간 짜증 솟구침. 또한 나처럼 깐깐한 사람에게 어색함이 안느껴질만큼 제대로 구현하기는 쉽지 않음(커서위치, 텍스트선택범위, 스크롤 위치, 얼마나 많은 편집을 하나의 히스토리 엔트리로 묶을 것인가, 양쪽 편집기를 왔다갔다 했을 때, ...).
- 위와 같은 이유로 편집기와 실제로 diff가 하이라이트되는 영역(mirror)을 분리시킴.
- 크기가 큰 텍스트(5만글자 이상)를 비교할 때에도 편집기가 충분히(아주 충분히) 반응적일 것. 딜레이 최소화! 단순 debouncing이 아니라 그 이상이 필요.
- 다른 문자(문자code가 다른 경우)지만 같다고 여겨질 수 있는 경우도 처리하였지만 이건 이러한 문자들을 직접 추가해줘야함(`constants.ts/NORMALIZE_CHARS`).
- (추가),(신설),(현행과 같음),(삭제) 등은 wildcard로 처리. 이 토큰들은 괄호 안 공백을 무시하고 절대로 중간에서 안잘리게('(현행과','같음)'이 되지 않게) 만들어놨지만 아직은 딱 거기까지임.
- diff 하이라이트 색들은 정말 세심하게 고른 것들임. 절대 불만을 가져서는 안됨. 빨간색 계통은 배경과 확실히 대비되지 않을 수 있기 때문에 의도적으로 제외(`constants.ts/DIFF_COLOR_HUES`).
- 큰 워드문서에서 복붙을 할 때에 복사가 바로 되지 않는 문제가 있는데 절대적으로 MS워드의 문제임. 될때까지 붙여넣기 하면 언젠가는 된다(기다리는 동안 워드는 먹통됨).
- 개정대비표vs전문, 전문vs전문 **전체를 한번**에 복/붙해서 비교할 수 있어야함(수십번씩 드래그,복/붙을 하는 것보다는 무조건 편함!!). 그래서 만든게  Aligned Mode
- 엣지(혹은 크롬) 전용. 인간적으로 2025년에 ie를 왜 써야하지?

#### Aligned Mode
- 이름은 맘에 안들지만 암튼 양쪽 텍스트에서 서로 대비되는 줄들의 위치를 같게 맞춰주는 기능. `F2`로 토글.
- 양쪽 스크롤 동기화됨.
- readonly 모드임(텍스트를 선택하고 간단한 수정을 시도하면 기본 모드로 전환되면서 수정이 되게는 해놨음).
- Aligned Mode는 까만 배경임(기본 모드와 확실히 대비되는 느낌이 있어야 했음).
- 두 모드를 전환할때 선택된 텍스트의 범위를 유지하려고 노력한 부분은 칭찬 받아야 함(수고했어~).
- 컨트롤 키를 누른채로 텍스트를 클릭하면 기본 모드로 전환되면서 클릭한 위치로 커서를 옮김(수고했어~).
- 양쪽 diff부분을 블럭단위로 표시할 수 있는 경우는 그러려고 노력(!)했음.
- 양쪽 대비(매치)되는 부분의 위치의 차이는 padding요소를 넣어서 메꿈. TODO: 여러개의 빈줄로 인해 발생하는 위치 차이는 padding이 아니라 빈줄들을 collapse하는 쪽으로 해야 더 보기 좋을 것 같음.

#### 인터넷도 안되고 아무것도 없는... 있는 거라곤 브라우저, 메모장 밖에 없는 회사 pc에서 돌려야함.
- html + css + js는 어쩔 수 없는 선택. 리액트 같은건 상상도 못함. html css js로 구현
- 섬세하고 이쁜 UI요소가 부족한 것은 절대적으로 이 때문임. 요새 누가 UI요소를 하나하나 손수 만드나...
- 타입스크립트로 작성하고 컴파일된 js를 옮기는 건 가능.
- 닷넷, java 런타임은 깔려있는 것 같지만 그 뿐임. sdk가 없음.
- 인간적으로 vscode정도는 깔아주면 안되나...

#### 집에서 만든 코드를 회사로 옮기는 방법?
- 워크비 쪽지/내부메일로 보내고 회사에서 열어서 메모장에 붙여넣기. 고로 코드가 너무 커지면 안됨. 외부 라이브러리? 어림도 없음.
- 다행히도 휴대폰 워크비 앱에서 복사/붙여넣기를 사용할 방법이 있더라(비밀 유지 필요..ㅋ 이거 막히면 더이상의 업데이트는 불가능함).
- 옮기기 전에 하나의 파일(diffseek.html)로 합친 후에 그 파일의 내용을 옮겨야함. 지금쯤 빌드된 파일이 4000줄이 넘을지도 모르니 두어번에 걸쳐 나눠서 복붙 필요.
- build, dist폴더를 모두 git에 포함한 것은 이러한 이유임(나눠서 복붙하다가 한줄 빼먹은 경우에 휴대폰으로 github의 코드와 비교해봐야함).
- 컴파일된 .js파일에 주석을 남기는 것도 회사에서 디버깅을 해야되는 경우가 있기 때문. 회사에서 수정한 걸 집으로 가져가는건 쉽지 않음. 어느 부분을 어떻게 수정했는지 기억해야함. 오늘 먹은 반찬도 기억 안남.

#### 브라우저에서 웹 주소가 아닌 파일을 여는 것이기 때문에 보안상 제약이 많음.
- 쿠키? localStorage? ... 그게 되겠니? 상태/옵션 저장하는건 불가능.
- new Worker(url) - 파일 url을 열 수 없음(그래서 worker를 쓰려면 약간의 트릭 필요)
- 그 외 '이게 될까?' 싶은 것들은 안된다고 보면 됨
- 스크립트로 복사/붙여넣기를 실행할 때의 경고는 엣지 설정-whitelist에 등록해서 피할 수 있기는 함. 지금은 관련 기능들을 다 지워버렸으니까 필요 없지만 다시 넣을까함(단축키로 왼쪽창/오른쪽창 선택없이 바로 붙여넣기 등)

#### 단축키?
- F2 - aligned mode 토글(양쪽 줄맞춤, 스크롤 동기화, 편집 불가)
- SHIFT-F2 - scroll sync 토글(약간의 줄맞춤, 약간의 스크롤 동기화, 편집 가능)
- ctrl-1/ctrl-2 편집기에 포커스
- 편집 중에 ctrl-space - 반대쪽 편집기의 스크롤 위치를 현재 편집기에 맞춤(가능한 경우)

#### histogram 알고리즘
- 가장 많이 쓰이는 알고리즘 중 하나인 것 같음.
- 이 알고리즘에서 가장 중요한건 공통 앵커를 그것도 아주 좋은놈으로 찾는 부분인 것 같은데 생각할 것이 많음. 각 섹션의 제목(1. 개요, 2. 업무처리 순서, ...)에 가중치를 주려했지만 해당 제목들은 업무매뉴얼 워드파일에서 맨 앞에 쏠려있는 경우(제목을 왼쪽 컬럼에 넣고 엔터키 수십번 눌러서 섹션을 나눈 경우)가 많아서 의미 없음. (1), (가), 1), 가)에는 적용했지만 얼마나 정확하고 효율적일지 감이 안와서 가중치를 높게 주지 않았음.
- 최우선순위 앵커 `@@@`, `###` (발견시 무조건 양쪽 텍스트에 나오는 이 앵커들을 순서대로 매치시킴). 감이 안오면 양쪽에 같은 텍스트를 복붙해놓고 왼쪽에는 맨윗줄에 `@@@`, 오른쪽은 맨아랫줄에 `@@@`를 입력해보기. 당연히 공백이나 줄바꿈으로 다른 글자와 분리가 되어야함.
- 그외  줄의 시작/끝 부분에 가중치, 희귀도에 가중치, 문자열 길이에 가중치.
- 단순히 단어vs단어 뿐만 아니라 n그램(복수개의 단어 매치), n개의 단어와 m개의 단어(단어 수가 다르지만 공백을 무시하고 비교할 경우 같은 단어들)도 매치되는 경우에도 앵커로 사용하려고 노력...은 함.
- 내 생각에 공통prefix/suffix를 스킵하는 부분 때문에 최고로 좋은 앵커를 찾을 기회를 놓치는 경우도 생길 수 있을 것 같지만 스킵 안하면 성능 개판 됨. 절대적으로 필요.

-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script>"use strict";
// DIFF 색(HUE). 0(빨)은 DIFF 배경색으로 쓰이니 패스
// 완전한 색상 코드보다 HUE만 사용하면 용도에 따라 색을 조절하기 쉬움.
// 인접한 색상과 너무 가깝지 않도록 아주 CAREFUL하게 고른 순서. 과학이다.
const DIFF_COLOR_HUES = [
    30, // 주황?
    180, // cyan
    300, // 핑크?
    120, // 초록
    240, // 파랑
    60, // 노랑
    270, // 보라?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;
// 어차피 백그라운드에서 처리되고 기존 작업이 취소시킨 후에 시작되니 너무 크게 잡을 필요는 없을 듯
const COMPUTE_DEBOUNCE_TIME = 100; // ms
const FORCE_RENDER_TIMEOUT = 300; // ms
// 문장부호나 특수문자를 정규화 하기 위해서...
// 따옴표, 중간점 등등등 문자코드는 다르지만 같다고 처리해야 될 문자들이 많음.
// length===1인 문자는 그냥 문자
// 숫자는 charCode
// &로 시작하면 html 엔티티
// TODO: 각종 화살표 특수문자들...
const NORMALIZE_CHARS = [
    ['"', "“", "”"],
    ["'", "‘", "’"],
    ["-", "–", "—"],
    [".", "․"],
    ["⋅", "·", "•"], // &middot;과 &bullet;(&bull;)은 다른 걸로 여겨야하지 않을까? middot대신 bullet을 쓰면 점이 너무 왕점이라 보기 흉한데...
    ["…", "⋯"],
    ["(", "（"], // 이런 걸 굳이 특수문자로 사용하는 사람이 있다고?? 믿기 힘들지만 있더라...
    [")", "）"],
    ["[", "［"],
    ["]", "］"],
    ["{", "｛"],
    ["}", "｝"],
    ["<", "＜"],
    [">", "＞"],
    ["-", "－"], // 왜 굳이... 이런 문자를...? 수식편집기 같은 것에서 이런 문자를 뱉어내는 건가...?
    ["=", "＝"],
    ["+", "＋"],
    ["*", "＊", "✱", "x"], // x와 *을 같은 문자로 취급하는 건 조금 위험하지만 같은 위치에 이 문자가 각각 사용된다면 곱셈 기호로 사용하려는 의도는 뻔하지 않은가?
    ["/", "／", "÷"], // 마찬가지
    ["\\", "＼", "₩"], // 역시 마찬가지. 고정폭이 아닌 대부분의 한글 폰트에서는 원화 마크로 표시되고 아마 문서에서도 그 의도로 사용됐을 것임!
    ["&", "＆"],
    ["#", "＃"],
    ["@", "＠"],
    ["$", "＄"],
    ["%", "％"],
    ["^", "＾"],
    ["~", "～"],
    ["`", "｀"],
    ["|", "｜"],
];
const PROCESSING_MESSAGES = [
    "한땀한땀 비교 중...",
    "인내심 테스트 중...",
    "생각 중...",
    "재부팅 준비 중...",
    "무한 루프 중...",
    "머리 긁는 중...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "퇴근 준비 중...",
];
const DIFF_ALGORITHM = {
    myers: "myers",
    lcs: "lcs",
};
const TOKENIZATION = {
    char: 1,
    word: 2,
    line: 3,
};
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
/*
지금은 딱히 사용되지 않는 utility 함수들.
편집기에 약간의 html을 허용할 때 사용.
*/
const colorCache = new Map();
function isReddish(color) {
    const rgb = parseColorFast(color);
    if (!rgb)
        return false;
    const [r, g, b] = rgb;
    return r > 150 && r - (g > b ? g : b) >= 60;
}
let _ctx = null;
function parseColorFast(color) {
    if (colorCache.has(color))
        return colorCache.get(color);
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    if (!_ctx)
        return null;
    _ctx.clearRect(0, 0, 1, 1);
    _ctx.fillStyle = color;
    _ctx.fillRect(0, 0, 1, 1);
    const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
    const rgb = [r, g, b];
    colorCache.set(color, rgb);
    // _ctx.fillStyle = "#000";
    // _ctx.fillStyle = color;
    // const computed = _ctx.fillStyle;
    // console.log("computed", computed);
    // const match = computed.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    // if (!match) return null;
    // const rgb: [number, number, number] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    // colorCache.set(color, rgb);
    return rgb;
}
function escapeHTML(str) {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function insertHTMLAtCursor(html) {
    const selection = window.getSelection();
    if (!selection || !selection.rangeCount)
        return;
    const range = selection.getRangeAt(0);
    range.deleteContents();
    const fragment = range.createContextualFragment(html);
    range.insertNode(fragment);
    // 커서 맨 뒤로 이동
    selection.collapseToEnd();
}
const LINEBREAK_ELEMENTS = {
    P: true,
    DIV: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    TR: true,
    BR: true,
    HR: true,
};
function flattenHTML(rawHTML) {
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.substring(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.substring(startIndex + START_TAG.length);
        }
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(rawHTML, "text/html");
    const body = doc.body;
    // console.log("body", body.innerHTML);
    const textProps = [];
    let currentTextProps = { pos: 0, color: null, supsub: null };
    let textPropsStack = [];
    textProps.push(currentTextProps);
    textPropsStack.push(currentTextProps);
    let finalHTML = "";
    let finalText = "";
    function extractFlattenedHTML(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.nodeValue || "";
            finalHTML += escapeHTML(text);
            finalText += text;
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node;
            let newTextProps = null;
            let prevTextProps = currentTextProps;
            let spanAppended = false;
            let color = null;
            let colorChanged = false;
            if (el.classList.contains("red")) {
                color = "red";
                colorChanged = true;
            }
            else if (el.style?.color) {
                color = el.style?.color || null;
                if (color && isReddish(color)) {
                    color = "red";
                }
                else {
                    color = null;
                }
                colorChanged = true;
            }
            if (colorChanged && currentTextProps.color !== color) {
                if (!newTextProps) {
                    currentTextProps = newTextProps = { ...currentTextProps, pos: finalText.length };
                    textProps.push(newTextProps);
                    textPropsStack.push(currentTextProps);
                }
                newTextProps.color = color;
            }
            // if (el.style?.color) {
            // 	console.log(el.style.color, isColorRedLike(el.style.color));
            // 	let color = el.style?.color || null;
            // 	if (color && isColorRedLike(color)) {
            // 		color = "red";
            // 	} else {
            // 		color = null;
            // 	}
            // 	if (currentTextProps.color !== color) {
            // 		if (!newTextProps) {
            // 			currentTextProps = newTextProps = { ...currentTextProps, pos: finalText.length };
            // 			textProps.push(newTextProps);
            // 			textPropsStack.push(currentTextProps);
            // 		}
            // 		newTextProps.color = color;
            // 	}
            // }
            if (el.nodeName === "SUP" || el.nodeName === "SUB") {
                if (currentTextProps.supsub !== el.nodeName) {
                    if (!newTextProps) {
                        currentTextProps = newTextProps = { ...currentTextProps, pos: finalText.length };
                        textProps.push(newTextProps);
                        textPropsStack.push(currentTextProps);
                    }
                    newTextProps.supsub = el.nodeName;
                }
                finalHTML += `<${el.nodeName} class="${currentTextProps.color || ""}">`;
            }
            else if (prevTextProps.color !== currentTextProps.color) {
                if (currentTextProps.color) {
                    finalHTML += `<span class="${currentTextProps.color}">`;
                    spanAppended = true;
                }
            }
            for (const child of el.childNodes) {
                extractFlattenedHTML(child);
            }
            if (el.nodeName === "SUP" || el.nodeName === "SUB") {
                finalHTML += `</${el.nodeName}>`;
            }
            else if (spanAppended) {
                finalHTML += "</span>";
            }
            if (LINEBREAK_ELEMENTS[el.nodeName]) {
                finalHTML += "<br>";
                finalText += "\n";
            }
            if (newTextProps) {
                textPropsStack.pop();
                console.assert(textPropsStack.length > 0, "textPropsStack is empty!");
                currentTextProps = { ...textPropsStack[textPropsStack.length - 1], pos: finalText.length };
                textProps.push(currentTextProps);
            }
        }
    }
    extractFlattenedHTML(body);
    // flatten된 HTML 생성
    console.log("flattened", { finalHTML, finalText, textProps });
    return [finalHTML, finalText, textProps];
}
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
// 개정대비표에서 복붙 했을때 빨간색 텍스트를 그대로 보여줄 방법이 있을까?
// 텍스트 색과 diff 범위는 완전히 별개라서 서로 완전히 겹칠 수도 있고 안겹칠 수도 있고 일부분만 겹칠 수도 있다
// 일부분만 겹칠 경우가 까다로워지는 부분인데 textrun은 만들더라도 update때에도 일일히 속성 별로 다른 요소를 써서 DOM을 만들어야한다.
// 또.. 색상데이터를 어떻게 관리할 것인가?
// 텍스트의 어느 위치 어느 범위에 색이 들어가있는지 뭐 그런 data가 필요하다. 붙여넣기 때 그런 데이터를 추출하는건 어렵지 않지만(??)
// 이후에 텍스트가 변경되면 그에 따라 범위의 pos,len값도 조정되어야하니 결국 원본 텍스트 자체에 색상정보가 포함되어야 한다.
// 그럼 원본텍스트를 html로 저장하고 변경될 때마다 매번 parsing? 미쳤다.
// 원본 텍스트에 marker문자(zero-width space 등)를 넣고 그걸로 빨간색 범위 파악? nope!
function getTextRuns(textKey, text, textProps, diffs, anchors) {
    let pos = 0;
    let textLen = text.length;
    let nextPropsPos = null;
    let nextProps = null;
    let nextDiffPos = null;
    let nextDiffEndPos = null;
    let nextDiff = null;
    let nextAnchorPos = null;
    let nextAnchor = null;
    let nextNewLinePos = null;
    let nextNewLineIsEndOfString = false;
    let textPropsIndex = -1;
    let diffIndex = -1;
    let anchorIndex = -1;
    let lastSupSubPos = null;
    const textruns = [];
    // let counter = 0;
    // pos < textLen 조건을 쓰면 text의 끝에 위치한 이벤트가 무시될 수 있음.
    while (true) {
        // if (counter++ > 100000) {
        // 	console.error("Infinite loop detected", {
        // 		textruns,
        // 		pos: pos,
        // 		textLen: textLen,
        // 		nextDiffPos: nextDiffPos,
        // 		nextDiffEndPos: nextDiffEndPos,
        // 		nextAnchorPos: nextAnchorPos,
        // 		nextNewLinePos: nextNewLinePos,
        // 		diffIndex: diffIndex,
        // 		anchorIndex: anchorIndex,
        // 		nextDiff: nextDiff,
        // 		nextAnchor: nextAnchor,
        // 		diffs,
        // 		anchors,
        // 	});
        // 	throw new Error("Infinite loop detected");
        // }
        let nextEventPos = textLen;
        // 빨간글자색(개정대비표)나 <sup> <sub> 같은 속성을 렌더링
        // 거의 다 만들었고 지금 다듬으면 되는데 살짝 귀찮다. 사용할 경우 editor에 mutationObserver 설치(?)해서
        // 원치 않는 style태그가 붙는 경우 잽싸게 제거해 줄 필요가 있음.
        // if (nextPropsPos === null) {
        // 	textPropsIndex++;
        // 	if (textPropsIndex < textProps.length) {
        // 		nextProps = textProps[textPropsIndex];
        // 		nextPropsPos = nextProps.pos;
        // 		if (nextPropsPos < pos) {
        // 			// skipped text property. this should not happen.
        // 			console.warn("Skipped text property", { textProps: nextProps, textPropsIndex: textPropsIndex, pos: pos, propsPos: nextPropsPos });
        // 			nextPropsPos = nextProps = null;
        // 		}
        // 	} else {
        // 		nextPropsPos = Number.MAX_SAFE_INTEGER;
        // 	}
        // }
        // if (nextPropsPos !== null && nextPropsPos < nextEventPos) {
        // 	nextEventPos = nextPropsPos;
        // }
        if (nextAnchorPos === null) {
            anchorIndex++;
            if (anchorIndex < anchors.length) {
                nextAnchor = anchors[anchorIndex];
                nextAnchorPos = nextAnchor[textKey];
                if (nextAnchorPos < pos) {
                    // anchor 위치를 조절할 때 문제가 생긴 경우인데... 앵커를 못 박으면 줄맞춤 정렬이 깨진다. 딱 그뿐... 
                    console.warn("Skipped anchor", { anchor: nextAnchor, anchorIndex: anchorIndex, pos: pos, anchorPos: nextAnchorPos });
                    nextAnchorPos = nextAnchor = null;
                    // continue;
                }
            }
            else {
                nextAnchorPos = Number.MAX_SAFE_INTEGER;
            }
        }
        if (nextAnchorPos !== null && nextAnchorPos < nextEventPos) {
            nextEventPos = nextAnchorPos;
        }
        if (nextDiffEndPos === null) {
            diffIndex++;
            if (diffIndex < diffs.length) {
                nextDiff = diffs[diffIndex][textKey];
                nextDiffPos = nextDiff.pos;
                nextDiffEndPos = nextDiff.pos + nextDiff.len;
                if (nextDiffPos < pos) {
                    console.warn("Skipped diff", { diff: nextDiff, diffIndex: diffIndex, pos: pos, diffPos: nextDiffPos });
                    nextDiffPos = nextDiffEndPos = nextDiff = null;
                }
            }
            else {
                nextDiffPos = Number.MAX_SAFE_INTEGER;
                nextDiffEndPos = Number.MAX_SAFE_INTEGER;
            }
        }
        if (nextDiffPos !== null && nextDiffPos < nextEventPos) {
            nextEventPos = nextDiffPos;
        }
        else if (nextDiffEndPos !== null && nextDiffEndPos < nextEventPos) {
            nextEventPos = nextDiffEndPos;
        }
        if (nextNewLinePos === null) {
            nextNewLinePos = text.indexOf("\n", pos);
            if (nextNewLinePos === -1) {
                nextNewLinePos = textLen;
                nextNewLineIsEndOfString = true;
            }
        }
        if (nextNewLinePos !== null && nextNewLinePos < nextEventPos) {
            nextEventPos = nextNewLinePos;
        }
        if (pos < nextEventPos) {
            // chars
            textruns.push({
                type: "CHARS",
                pos: pos,
                len: nextEventPos - pos,
                diffIndex: null,
                anchorIndex: null,
                props: null,
            });
            pos = nextEventPos;
        }
        else if (pos === lastSupSubPos) {
            // 비어있는 sub나 sup도 렌더링 되면 줄 높이가 바뀌기 때문에 mirror에서도 렌더링 해줘야함.
            // 으... 정말 지저분하고 끔찍한데 일단 이렇게 대충...
            textruns.push({
                type: "CHARS",
                pos: pos,
                len: 0,
                diffIndex: null,
                anchorIndex: null,
                props: null,
            });
            lastSupSubPos = null;
        }
        // if (nextEventPos === nextPropsPos) {
        // 	textruns.push({
        // 		type: "MODIFIER",
        // 		pos: nextPropsPos,
        // 		len: 0,
        // 		diffIndex: null,
        // 		anchorIndex: null,
        // 		props: nextProps,
        // 	});
        // 	lastSupSubPos = !!nextProps?.supsub ? nextPropsPos : null;
        // 	nextPropsPos = null;
        // 	continue;
        // }
        // 이벤트 처리 후 반드시 continue로 다음 반복으로 넘어가야 함. (혹은 else if else if else if...)
        if (nextEventPos === nextAnchorPos && nextAnchor.type === "before") {
            textruns.push({
                type: "ANCHOR",
                pos: nextAnchorPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: anchorIndex,
                props: null,
            });
            nextAnchorPos = nextAnchor = null;
            continue;
        }
        if (nextEventPos === nextDiffPos) {
            textruns.push({
                type: "DIFF",
                pos: nextDiffPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: null,
                props: null,
            });
            nextDiffPos = Number.MAX_SAFE_INTEGER;
            continue;
        }
        if (nextEventPos === nextDiffEndPos) {
            // diff end
            textruns.push({
                type: "DIFF_END",
                pos: nextDiffEndPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: null,
                props: null,
            });
            nextDiffPos = nextDiffEndPos = nextDiff = null;
            continue;
        }
        if (nextEventPos === nextAnchorPos && nextAnchor.type === "after") {
            textruns.push({
                type: "ANCHOR",
                pos: nextAnchorPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: anchorIndex,
                props: null,
            });
            nextAnchorPos = null;
            continue;
        }
        if (nextEventPos === nextNewLinePos) {
            if (nextNewLineIsEndOfString) {
                break;
            }
            else {
                textruns.push({
                    type: "LINEBREAK",
                    pos: nextNewLinePos,
                    len: 1,
                    diffIndex: null,
                    anchorIndex: null,
                    props: null,
                });
                pos = nextEventPos + 1;
                nextNewLinePos = null;
                continue;
            }
        }
    }
    textruns.push({
        type: "END_OF_STRING",
        pos: textLen,
        len: 0,
        diffIndex: null,
        anchorIndex: null,
        props: null,
    });
    return textruns;
}
//# sourceMappingURL=textrun.js.map
</script>
<script>"use strict";
function createEditor(container, editorName, callbacks) {
    const { onDiffVisibilityChanged, onTextChanged, onMirrorUpdated } = callbacks;
    const _lineElements = [];
    const _diffElements = [];
    const _anchorElements = [];
    const _visibleAnchors = new Set();
    const _visibleDiffIndices = new Set();
    // 편집기 내에 약간의 html을 허용할지 말지.
    // 일단 금지. browser에서 계산하는 텍스트와 내가 만드는 텍스트를 완전히 일치시키기 힘들다. 한글자한글자 문자 인덱스까지 완전히 일치시켜야 됨...
    // 게다가 contenteditable 내에 브라우저가 뜸금없이 넣는 style(스타일 클래스가 지정된 텍스트를 지우고 바로 이어서 텍스트를 입력할 경우)이나 <br> 등등도 처리를 해줘야 하고
    // 여하튼 신경 쓸게 많음
    const _allowHTML = false;
    let _text = "";
    let _textProps = [];
    let _savedCaret = null;
    let _observingAnchors = false;
    let _editMode = false;
    let _textruns = []; // 변경된 부분만 업데이트 가능하게 이전 textruns 보관???
    const wrapper = document.createElement("div");
    wrapper.id = editorName + "EditorWrapper";
    wrapper.classList.add("editor-wrapper");
    // 어쩔 수 없는 선택.
    // dom 업데이트가 텍스트 입력을 방해하는 건 원치 않고 undo,redo 히스토리를 망쳐버리는 것도 싫음
    // undo, redo를 어설프게 구현하느니 안하는 게 낫다. (커서위치, 스크롤 위치, 선택 범위, throttling 등등 생각할 게 많음)
    const mirror = document.createElement("div");
    mirror.id = editorName + "Mirror";
    mirror.classList.add("mirror");
    mirror.spellcheck = false;
    const editor = document.createElement("div");
    editor.id = editorName + "Editor";
    editor.classList.add("editor");
    editor.contentEditable = "plaintext-only";
    editor.spellcheck = false;
    editor.appendChild(document.createTextNode(""));
    wrapper.appendChild(mirror);
    wrapper.appendChild(editor);
    container.appendChild(wrapper);
    function updateText() {
        // if (_allowHTML) {
        // 	/// 약간의 html을 포함해서 style="color:..."와 sup, sub 태그를 가져오려는 게 목적인데
        // 	/// contentEditable에 html을 넣으면 브라우저가 종종 스타일과 태그를 살짝 바꿔버린다
        // 	/// 예를 들어 <sup>주)</sup>가 있을때 이 부분을 삭제하는 경우 브라우저는 무슨 심보인지 font-size를 style를 추가해버린다(커서가 해당 부분을 빠져나오면 추가 안됨)
        // 	/// mutationObserver로 style attr이 붙는 경우 도로 삭제해버리면 되지만 mutationObserver는 이제 보기만 해도 짜증난다.
        // 	const [_, text, props] = flattenHTML(editor.innerHTML);
        // 	_text = text;
        // 	_textProps = props;
        // } else {
        // }
        _text = editor.textContent || "";
        if (_text.length === 0 || _text[_text.length - 1] !== "\n") {
            _text += "\n"; // 텍스트의 끝은 항상 \n으로 끝나야 인생이 편해진다.
        }
        onTextChanged(_text);
    }
    editor.addEventListener("input", updateText);
    // if (_allowHTML) {
    // 	editor.addEventListener("paste", (e) => {
    // 		const html = e.clipboardData?.getData("text/html");
    // 		if (!html) return;
    // 		e.preventDefault();
    // 		const [cleanedHTML, text, textProps] = flattenHTML(html);
    // 		_text = text;
    // 		_textProps = textProps;
    // 		// 현재 커서 위치에 삽입
    // 		insertHTMLAtCursor(cleanedHTML);
    // 		// console.log("paste", performance.now() - now, cleanedHTML);
    // 		// (e.target as HTMLElement).contentEditable = "plaintext-only";
    // 		updateText();
    // 	});
    // }
    const intersectionObserver = new IntersectionObserver((entries) => {
        for (const entry of entries) {
            if (entry.isIntersecting) {
                if (entry.target.nodeName === ANCHOR_TAG) {
                    _visibleAnchors.add(entry.target);
                }
                else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
                    const diffIndex = Number(entry.target.dataset.diff);
                    _visibleDiffIndices.add(diffIndex);
                    onDiffVisibilityChanged(diffIndex, true);
                }
            }
            else {
                if (entry.target.nodeName === ANCHOR_TAG) {
                    _visibleAnchors.delete(entry.target);
                }
                else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
                    const diffIndex = Number(entry.target.dataset.diff);
                    _visibleDiffIndices.delete(diffIndex);
                    onDiffVisibilityChanged(diffIndex, false);
                }
            }
        }
    }, { threshold: 1, root: wrapper });
    function getVisibleAnchors() {
        return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
    }
    function getClosestAnchorToCaret() {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null;
        }
        let range = selection.getRangeAt(0);
        if (!editor.contains(range.startContainer)) {
            return null;
        }
        let rect = range.getBoundingClientRect();
        let y;
        if (rect.left === 0 && rect.top === 0) {
            y = EDITOR_PADDING + TOPBAR_HEIGHT;
        }
        else {
            y = rect.top;
        }
        let closestAnchor = null;
        let minDistance = Number.MAX_SAFE_INTEGER;
        for (const anchor of _visibleAnchors) {
            const rect = anchor.getBoundingClientRect();
            const distance = Math.abs(rect.top - y);
            if (distance < minDistance) {
                minDistance = distance;
                closestAnchor = anchor;
            }
        }
        return closestAnchor;
    }
    function getFirstVisibleLineElement() {
        const lineEls = _lineElements;
        let low = 0;
        let high = lineEls.length - 1;
        let mid;
        let lineEl = null;
        let distance = null;
        while (low <= high) {
            mid = (low + high) >>> 1;
            const thisDistance = lineEls[mid].getBoundingClientRect().top - TOPBAR_HEIGHT;
            if (thisDistance >= -LINE_HEIGHT) {
                lineEl = lineEls[mid];
                distance = thisDistance;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return [lineEl, distance]; //null일 수도 있지만 의도적으로 느낌표 때려박음
    }
    function scrollToDiff(diffIndex) {
        const offsetTop = _diffElements[diffIndex][0].offsetTop - wrapper.clientTop;
        wrapper.scrollTop = offsetTop - SCROLL_MARGIN;
    }
    // 내가 머리가 나쁘다는 걸 확실하게 알게 해주는 함수
    function scrollToLine(lineNum, distance = 0) {
        const lineEl = _lineElements[lineNum - 1];
        if (lineEl) {
            const scrollTop = lineEl.offsetTop - distance;
            wrapper.scrollTop = scrollTop;
        }
    }
    // generator함수 사용. 왜? 그냥 써보려고!!
    let _renderId = 0;
    let _cancelRenderId = null;
    function update({ diffs, anchors }) {
        if (_cancelRenderId) {
            cancelIdleCallback(_cancelRenderId);
            _cancelRenderId = null;
        }
        if (_renderId === Number.MAX_SAFE_INTEGER) {
            // 그런일은... 절대로... 없을거라...
            // 솔직히 절대 없음
            _renderId = 0;
        }
        const startTime = performance.now();
        const renderId = ++_renderId;
        const generator = updateGenerator({ renderId, diffs, anchors });
        // 일단 start!
        generator.next();
        const step = (idleDeadline) => {
            _cancelRenderId = null;
            const { done } = generator.next(idleDeadline);
            if (!done) {
                if (renderId === _renderId) {
                    _cancelRenderId = requestIdleCallback(step, { timeout: FORCE_RENDER_TIMEOUT });
                }
            }
            else {
                console.debug("[%s] update(#%d) took %d ms", editorName, renderId, performance.now() - startTime);
            }
        };
        _cancelRenderId = requestIdleCallback(step, { timeout: FORCE_RENDER_TIMEOUT });
    }
    function* updateGenerator({ renderId, diffs, anchors }) {
        if (!diffs) {
            return;
        }
        // const startTime = performance.now();
        // console.debug("update");
        untrackIntersections();
        _lineElements.length = 0;
        _diffElements.length = 0;
        _anchorElements.length = 0; // anchors.length; 혹시 모르니 그냥 0으로 초기화 해서 기존 요소들을 지워버리는게 속편함.
        // 여기서 일단 한번 yield 해줘야 idleDeadline을 받을 수 있음.
        let idleDeadline = yield;
        const textruns = getTextRuns(editorName, _text, _textProps, diffs, anchors);
        console.debug(editorName, "textruns", textruns);
        const text = _text;
        const view = mirror;
        let lineEl = null;
        let nextInlineNode = null;
        let currentDiffIndex = null;
        let currentTextProps = { pos: 0, color: null, supsub: null };
        let lineNum;
        let textPos;
        let textProps = { pos: 0, color: null, supsub: null };
        let currentContainer;
        const containerStack = [];
        function appendAnchor(pos, anchorIndex) {
            // diff 범위 안 anchor를 허용하면 코드가 복잡해짐. diff를 닫고 lineEl이 currentContainer가 될때까지 pop한 후
            // anchor 넣고 다시 이전 container 스택을 새로 만들어줘야함.
            // 회사에서 사용하면서 이 메시지를 눈여겨 보고 발견 시 바로 해결할 것.
            console.assert(currentContainer === lineEl, "currentContainer should be lineEl when appending anchor");
            const anchor = anchors[anchorIndex];
            let anchorEl;
            if (nextInlineNode === null || nextInlineNode.nodeName !== ANCHOR_TAG) {
                anchorEl = document.createElement(ANCHOR_TAG);
                anchorEl.contentEditable = "false"; // 만약에 mirror를 contentEditable로 만들경우에...
                currentContainer.insertBefore(anchorEl, nextInlineNode);
            }
            else {
                anchorEl = nextInlineNode;
                nextInlineNode = anchorEl.nextSibling;
            }
            anchorEl.id = `${editorName}Anchor${anchorIndex}`;
            anchorEl.dataset.type = anchor.type;
            anchorEl.dataset.anchor = anchorIndex.toString();
            anchorEl.dataset.pos = pos.toString();
            if (anchor.diffIndex !== null) {
                anchorEl.dataset.diff = anchor.diffIndex.toString();
            }
            else {
                delete anchorEl.dataset.diff;
            }
            // push가 아닌 index로 넣는 이유는 textruns을 만들 때 앵커가 스킵될 수 있기 때문.
            // diff 계산 때 앵커위치를 잘못 잡은 경우인데 그쪽 코드를 찬찬히 뜯어볼 필요가 있다.
            _anchorElements[anchorIndex] = anchorEl;
        }
        function appendChars(chars) {
            let el;
            const nodeName = currentTextProps.supsub ?? "SPAN";
            if (!nextInlineNode || nextInlineNode.nodeName !== nodeName) {
                el = document.createElement(nodeName);
                currentContainer.insertBefore(el, nextInlineNode);
            }
            else {
                el = nextInlineNode;
                nextInlineNode = el.nextSibling;
            }
            if (el.textContent !== chars) {
                el.textContent = chars;
            }
            // el.className = currentTextProps.color || "";
        }
        // lineEl = view.firstElementChild as HTMLElement;
        // if (lineEl === null) {
        // 	lineEl = document.createElement(LINE_TAG);
        // 	view.appendChild(lineEl);
        // 	lineEl.dataset.lineNum = lineNum.toString();
        // 	lineEl.dataset.pos = textPos.toString();
        // 	lineNum++;
        // }
        // _lineElements.push(lineEl);
        // nextInlineNode = lineEl.firstChild;
        // console.log("textruns:", textruns);
        let diffEl = null;
        function openDiff(diffIndex) {
            if (nextInlineNode === null || nextInlineNode.nodeName !== DIFF_ELEMENT_NAME) {
                diffEl = document.createElement(DIFF_ELEMENT_NAME);
                const parent = currentContainer ?? lineEl;
                parent.insertBefore(diffEl, nextInlineNode);
                currentContainer = diffEl;
            }
            else {
                diffEl = currentContainer = nextInlineNode;
            }
            nextInlineNode = diffEl.firstChild;
            diffEl.dataset.diff = diffIndex.toString();
            diffEl.className = `diff-color${(diffIndex % NUM_DIFF_COLORS) + 1}`;
            _diffElements[diffIndex] = _diffElements[diffIndex] || [];
            _diffElements[diffIndex].push(diffEl);
        }
        function closeDiff() {
            if (diffEl) {
                while (currentContainer !== diffEl) {
                    popContainer();
                }
                popContainer();
            }
        }
        function popContainer() {
            while (nextInlineNode) {
                const nextnext = nextInlineNode.nextSibling;
                nextInlineNode.remove();
                nextInlineNode = nextnext;
            }
            if (containerStack.length > 0) {
                nextInlineNode = currentContainer.nextSibling;
                currentContainer = containerStack.pop();
                return currentContainer;
            }
            else {
                if (currentContainer !== lineEl) {
                    const ret = currentContainer;
                    nextInlineNode = currentContainer.nextSibling;
                    currentContainer = lineEl;
                    return ret;
                }
            }
            return null;
        }
        textPos = 0;
        lineNum = 1;
        lineEl = view.firstElementChild;
        let textRunIndex = 0;
        let textrunBuffer = [];
        let shouldUpdate = true;
        while (textRunIndex < textruns.length) {
            // 취소!
            if (renderId !== _renderId) {
                return;
            }
            if (idleDeadline && idleDeadline.timeRemaining() <= 0) {
                // console.warn("YIELDING", idleDeadline.timeRemaining(), textRunIndex, textruns.length);
                idleDeadline = yield;
            }
            textrunBuffer.length = 0;
            for (; textRunIndex < textruns.length; textRunIndex++) {
                const textrun = textruns[textRunIndex];
                textrunBuffer.push(textrun);
                // 이걸 사용해서 변경된 줄만 부분적으로 업데이트 하려면
                // diff를 추적해서 개수를 새고 diffElements의 어느 부분부터 시작하는지 계산해놔야함. 앵커도 마찬가지
                // 할 수는 있지만.. 해야할까 싶다.
                // if (!shouldUpdate) {
                // 	const oldRun = _textruns[textRunIndex];
                // 	if (
                // 		oldRun &&
                // 		oldRun.type === textrun.type &&
                // 		oldRun.pos === textrun.pos &&
                // 		oldRun.len === textrun.len &&
                // 		oldRun.diffIndex === textrun.diffIndex &&
                // 		oldRun.anchorIndex === textrun.anchorIndex
                // 	) {
                // 		if (oldRun.type === "MODIFIER") {
                // 			if (
                // 				oldRun.props!.pos !== textrun.props!.pos ||
                // 				oldRun.props!.color !== textrun.props!.color ||
                // 				oldRun.props!.supsub !== textrun.props!.supsub
                // 			) {
                // 				shouldUpdate = true;
                // 			}
                // 		}
                // 	} else {
                // 	}
                // }
                if (textrun.type === "LINEBREAK" || textrun.type === "END_OF_STRING") {
                    textRunIndex++;
                    break;
                }
            }
            let textrun;
            if (lineEl === null) {
                lineEl = document.createElement(LINE_TAG);
                view.appendChild(lineEl);
            }
            lineEl.dataset.lineNum = lineNum.toString();
            lineEl.dataset.pos = textPos.toString();
            _lineElements[lineNum - 1] = lineEl;
            if (shouldUpdate) {
                currentContainer = lineEl;
                nextInlineNode = currentContainer.firstChild;
                if (currentDiffIndex !== null) {
                    openDiff(currentDiffIndex);
                }
                for (textrun of textrunBuffer) {
                    const type = textrun.type;
                    if (type === "CHARS") {
                        const { pos, len } = textrun;
                        appendChars(text.substring(pos, pos + len));
                    }
                    else if (type === "ANCHOR") {
                        appendAnchor(textrun.pos, textrun.anchorIndex);
                    }
                    else if (type === "MODIFIER") {
                        // not implemented yet
                        currentTextProps = textrun.props;
                    }
                    else if (type === "DIFF") {
                        currentDiffIndex = textrun.diffIndex;
                        openDiff(currentDiffIndex);
                    }
                    else if (type === "DIFF_END") {
                        closeDiff();
                        currentDiffIndex = null;
                    }
                }
                while (popContainer())
                    ;
            }
            else {
                textrun = textrunBuffer[textrunBuffer.length - 1];
            }
            lineEl = lineEl.nextElementSibling;
            lineNum++;
            textPos = textrun.pos + textrun.len;
            if (textrun.type === "LINEBREAK") {
                //
            }
            else {
                // 안해도 textrunIndex === textruns.length가 되서 while문이 끝나긴 하지만... 나를 못믿겠어.
                break;
            }
        }
        // 남은 줄들은 모조리 제거
        // 생각해보기: elements들을 완전히 버리지말고 배열에 계속 저장해두고 lineNum-1로 재사용??
        while (lineEl) {
            const nextnext = lineEl.nextElementSibling;
            lineEl.remove();
            lineEl = nextnext;
        }
        _textruns = textruns;
        trackIntersections();
        onMirrorUpdated();
    }
    function trackIntersections() {
        if (!_observingAnchors) {
            for (const anchor of _anchorElements) {
                if (anchor)
                    intersectionObserver.observe(anchor);
            }
            for (const diff of _diffElements.flat()) {
                intersectionObserver.observe(diff);
            }
            _observingAnchors = true;
        }
    }
    function untrackIntersections() {
        _observingAnchors = false;
        _visibleAnchors.clear();
        _visibleDiffIndices.clear();
        intersectionObserver.disconnect();
    }
    function getFirstVisibleAnchor() {
        let firstAnchor = null;
        let firstPos = null;
        for (const anchor of _visibleAnchors) {
            if (firstAnchor === null) {
                firstAnchor = anchor;
                firstPos = Number(anchor.dataset.pos);
            }
            else {
                const pos = Number(anchor.dataset.pos);
                if (pos < firstPos) {
                    firstAnchor = anchor;
                    firstPos = pos;
                }
            }
        }
        return firstAnchor;
    }
    function setEditMode(editMode) {
        _editMode = !!editMode;
    }
    function getTextOffsetFromRoot(root, textNode, textNodeOffset) {
        let offset = 0;
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
        while (walker.nextNode()) {
            if (walker.currentNode === textNode) {
                return offset + textNodeOffset;
            }
            offset += walker.currentNode.nodeValue.length;
        }
        return null;
    }
    function findLineIndexByPos(pos, low = 0, high = _lineElements.length - 1) {
        let mid;
        while (low <= high) {
            mid = (low + high) >>> 1;
            const lineEl = _lineElements[mid];
            const linePos = Number(lineEl.dataset.pos);
            if (linePos === pos) {
                return mid;
            }
            if (linePos > pos) {
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return high;
    }
    // selectTextRange, getTextSelectionRange 이 둘은 다음날 보면 다시 깜깜해진다.
    // 손대려면 정말 각 잡고 해야함.
    function selectTextRange(startOffset, endOffset) {
        if (startOffset >= _text.length) {
            startOffset = _text.length - 1;
        }
        if (endOffset >= _text.length) {
            endOffset = _text.length - 1;
        }
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const range = document.createRange();
        let startSet = false;
        let endSet = false;
        if (_editMode) {
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
            let currentNode;
            let pos = 0;
            while (!endSet && (currentNode = walker.nextNode())) {
                if (!startSet && pos + currentNode.nodeValue.length >= startOffset) {
                    range.setStart(currentNode, startOffset - pos);
                    startSet = true;
                }
                if (!endSet && pos + currentNode.nodeValue.length >= endOffset) {
                    range.setEnd(currentNode, endOffset - pos);
                    endSet = true;
                }
                pos += currentNode.nodeValue.length;
            }
        }
        else {
            let startLineIndex = findLineIndexByPos(startOffset);
            let endLineIndex = findLineIndexByPos(endOffset, startLineIndex);
            let currentNode;
            let walker = document.createTreeWalker(_lineElements[startLineIndex], NodeFilter.SHOW_TEXT, null);
            let pos = Number(_lineElements[startLineIndex].dataset.pos);
            while ((currentNode = walker.nextNode())) {
                const nodeLen = currentNode.nodeValue.length;
                if (pos + nodeLen >= startOffset) {
                    range.setStart(currentNode, startOffset - pos);
                    startSet = true;
                    break;
                }
                pos += nodeLen;
            }
            walker = document.createTreeWalker(_lineElements[endLineIndex], NodeFilter.SHOW_TEXT, null);
            pos = Number(_lineElements[endLineIndex].dataset.pos);
            while ((currentNode = walker.nextNode())) {
                const nodeLen = currentNode.nodeValue.length;
                if (pos + nodeLen >= endOffset) {
                    range.setEnd(currentNode, endOffset - pos);
                    endSet = true;
                    break;
                }
                pos += nodeLen;
            }
        }
        if (startSet && endSet) {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
    function getTextSelectionRange() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            return [null, null];
        }
        const range = selection.getRangeAt(0);
        if (!wrapper.contains(range.commonAncestorContainer)) {
            return [null, null];
        }
        let startOffset = Number.NaN;
        let endOffset = Number.NaN;
        if (_editMode) {
            // edit 모드에서 contenteditable은 그냥 textNode 집합임. textNode 하나가 한 줄일 수도 있고
            // 하나의 textNode에 여러줄이 들어가 있을 수도 있다. 고로 그냥 글자 수를 새어보는 수 밖에 없음.
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
            let currentNode;
            let pos = 0;
            while ((currentNode = walker.nextNode())) {
                if (currentNode === range.startContainer) {
                    startOffset = pos + range.startOffset;
                }
                if (currentNode === range.endContainer) {
                    endOffset = pos + range.endOffset;
                    break;
                }
                pos += currentNode.textContent.length;
            }
        }
        else {
            // aligned mode.
            // 이 경우 조금 최적화가 가능. 실제로 이게 얼마나 효율적인지는 테스트해 볼 필요가 있겠지만...
            // 몇 천 라인의 텍스트에 diff, anchor가 많은 경우 당연히 시작줄, 끝줄을 먼저 찾고 그 줄에 대해서만
            // offset을 계산하는 것이 더 빠르겠지!
            let startLineEl = range.startContainer; //사실 textNode일 수도 있는데 그런 경우 가까운 부모 엘러먼트로 교체
            if (startLineEl.nodeType === 3) {
                startLineEl = startLineEl.parentElement.closest("div[data-pos]");
            }
            else {
                // startLineEl = startLineEl.closest("div[data-pos]") as HTMLElement;
                startOffset = Number(startLineEl.dataset.pos);
            }
            let endLineEl = range.endContainer;
            if (endLineEl.nodeType === 3) {
                endLineEl = endLineEl.parentElement.closest("div[data-pos]");
            }
            else {
                // endLineEl = endLineEl.closest("div[data-pos]") as HTMLElement;
                endOffset = Number(endLineEl.dataset.pos) + endLineEl.textContent.length;
            }
            if (isNaN(startOffset) || isNaN(endOffset)) {
                if (startLineEl && endLineEl) {
                    if (isNaN(startOffset)) {
                        startOffset = getTextOffsetFromRoot(startLineEl, range.startContainer, range.startOffset) + Number(startLineEl.dataset.pos);
                    }
                    if (isNaN(endOffset)) {
                        endOffset = getTextOffsetFromRoot(endLineEl, range.endContainer, range.endOffset) + Number(endLineEl.dataset.pos);
                    }
                }
                else {
                    const walker = document.createTreeWalker(mirror, NodeFilter.SHOW_TEXT, null);
                    let currentNode;
                    let pos = 0;
                    while (isNaN(startOffset) && isNaN(endOffset) && (currentNode = walker.nextNode())) {
                        if (currentNode === range.startContainer && isNaN(startOffset)) {
                            startOffset = pos + range.startOffset;
                        }
                        if (currentNode === range.endContainer && isNaN(endOffset)) {
                            endOffset = pos + range.endOffset;
                            break;
                        }
                        pos += currentNode.textContent.length;
                    }
                }
            }
        }
        if (isNaN(startOffset) || isNaN(endOffset)) {
            return [null, null];
        }
        // 원본텍스트의 끝에 하나의 "\n"이 더 붙어있으니 원본텍스트 크기보다 offset이 더 커질 수 있음!!
        if (startOffset >= _text.length) {
            startOffset = _text.length - 1;
        }
        if (endOffset >= _text.length) {
            endOffset = _text.length - 1;
        }
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        return [startOffset, endOffset];
    }
    //updateText();
    return {
        name: editorName,
        wrapper,
        editor,
        mirror,
        updateText,
        update,
        scrollToDiff,
        // saveCaret,
        // restoreCaret,
        getVisibleAnchors,
        trackIntersections,
        untrackIntersections,
        getFirstVisibleAnchor,
        scrollToLine,
        getFirstVisibleLineElement,
        getClosestAnchorToCaret: getClosestAnchorToCaret,
        setEditMode,
        getTextSelectionRange,
        selectTextRange,
        // 그냥 states 객체를 하나 만들어서 리턴할까...
        get text() {
            return _text;
        },
        get lineElements() {
            return _lineElements;
        },
        get diffElements() {
            return _diffElements;
        },
        get visibleAnchors() {
            return _visibleAnchors;
        },
        get anchorElements() {
            return _anchorElements;
        },
        get visibleDiffIndices() {
            return _visibleDiffIndices;
        },
    };
}
//# sourceMappingURL=editor.js.map
</script>
<script>"use strict";
// 어설프고 엉성하고 못생김.
// 나도 ui라이브러리 쓸 수 있으면면 이쁘게 잘 만들 수 있다!
function InitializeStatusBar(items) {
    const statusBarElement = document.getElementById("statusbar");
    const popup = document.getElementById("settingsPopup");
    const leftContainer = document.createElement("div");
    leftContainer.classList.add("status-bar-left");
    statusBarElement.appendChild(leftContainer);
    const centerContainer = document.createElement("div");
    centerContainer.classList.add("status-bar-center");
    statusBarElement.appendChild(centerContainer);
    const rightContainer = document.createElement("div");
    rightContainer.classList.add("status-bar-right");
    statusBarElement.appendChild(rightContainer);
    function init() {
        items.forEach(createStatusItem);
    }
    function createStatusItem(item) {
        const statusItem = document.createElement("div");
        statusItem.classList.add("status-item");
        statusItem.setAttribute("data-popup", item.key);
        if (item.options) {
            statusItem.classList.add("clickable");
            statusItem.innerHTML = `${item.label} <span></span> ▼`;
            statusItem.addEventListener("click", () => {
                togglePopup(item.key, statusItem, item);
            });
        }
        else if (item.toggle) {
            statusItem.classList.add("clickable");
            statusItem.innerHTML = `${item.label} <span></span>`;
            statusItem.addEventListener("click", () => {
                item.toggle();
            });
        }
        else {
            statusItem.innerHTML = `${item.label} <span></span>`;
        }
        if (item.side === "left") {
            leftContainer.appendChild(statusItem);
        }
        else if (item.side === "right") {
            rightContainer.appendChild(statusItem);
        }
        else if (item.side === "center") {
            centerContainer.appendChild(statusItem);
        }
        else {
            console.error(`Unknown side: ${item.side}`);
            return;
        }
    }
    function togglePopup(key, targetElement, item) {
        const currentOpenPopup = document.querySelector("[data-popup].open");
        if (currentOpenPopup && currentOpenPopup !== targetElement) {
            currentOpenPopup.classList.remove("open");
            currentOpenPopup.style.display = "none";
        }
        const isOpen = targetElement.classList.contains("open");
        if (!isOpen && item.options) {
            showPopup(key, targetElement, item);
        }
        else {
            closePopup();
        }
    }
    function showPopup(key, targetElement, item) {
        if (item.visible && !item.visible()) {
            return;
        }
        popup.innerHTML = "";
        const options = item.options;
        const value = item.get();
        options.forEach((option) => {
            const div = document.createElement("div");
            div.textContent = option.label;
            if (option.value === value) {
                div.classList.add("selected");
            }
            div.onclick = () => {
                item.set(option.value);
                updateItem(item);
                closePopup();
            };
            popup.appendChild(div);
        });
        popup.style.display = "block";
        targetElement.classList.add("open");
        requestAnimationFrame(() => setPopupPosition(key, targetElement));
    }
    function setPopupPosition(key, targetElement) {
        const rect = targetElement.getBoundingClientRect();
        const popupHeight = popup.offsetHeight;
        const popupWidth = popup.offsetWidth;
        const offset = 5;
        let topPosition = rect.top - popupHeight - offset;
        if (topPosition < 0) {
            topPosition = rect.bottom + offset;
        }
        let leftPosition = rect.left;
        if (leftPosition + popupWidth > window.innerWidth) {
            leftPosition = window.innerWidth - popupWidth - offset;
        }
        if (leftPosition < 0) {
            leftPosition = offset;
        }
        popup.style.top = `${topPosition}px`;
        popup.style.left = `${leftPosition}px`;
    }
    function updateItem(item) {
        const element = statusBarElement.querySelector(`[data-popup="${item.key}"] span`);
        if (!element)
            return;
        if (item.visible && !item.visible()) {
            // element.parentElement!.classList.toggle("disabled", true);
            element.parentElement.style.display = "none";
        }
        else {
            // element.parentElement!.classList.toggle("disabled", false);
            element.parentElement.style.removeProperty("display");
            const value = item.get();
            const text = (item.options && item.options.find((opt) => opt.value === value)) || value || "";
            element.textContent = text?.label || value.toString();
        }
    }
    function closePopup() {
        popup.style.display = "none";
        const openElements = document.querySelectorAll("[data-popup].open");
        openElements.forEach((el) => el.classList.remove("open"));
    }
    function update() {
        for (const item of items) {
            updateItem(item);
            // const value = item.get();
            // if (item.visible && !item.visible()) {
            // 	const element = statusBarElement.querySelector(`[data-popup="${item.key}"] span`) as HTMLElement;
            // 	if (element) {
            // 		element.style.display = "none";
            // 	}
            // }
            // updateOption(item.key, value);
        }
    }
    init();
    document.addEventListener("click", (event) => {
        if (!popup.contains(event.target) && !statusBarElement.contains(event.target)) {
            closePopup();
        }
    });
    document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
            closePopup();
        }
    });
    return {
        update,
        closePopup,
    };
}
//# sourceMappingURL=statusbar.js.map
</script>
<script id="worker.js" type="text/plain">"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const TOKEN_CACHE_SIZE = 2;
// token flags
// tokenize.ts과 같은 값 사용 필수
const FIRST_OF_LINE = 1;
const LAST_OF_LINE = 2;
const WILD_CARD = 16;
const NORMALIZE = 32; // &middot;, 따옴표 -, 말머리문자 등등 실제로 문자 코드는 다르지만 같다고 처리해야 할 문자들이 있다.
const SECTION_HEADING = 64;
const MANUAL_ANCHOR = 128; // @@@, ### 등등
const SPACE_CHARS = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // 글쎄...
    "\f": true, // 이것들은...
    "\v": true, // 볼일이 없을것...
};
const normalizeChars = {};
let _nextCtx = null;
let _currentCtx = null;
function registerNormalizeChar(chars) {
    const norm = chars[0];
    normalizeChars[norm] = norm;
    for (let i = 1; i < chars.length; i++) {
        normalizeChars[chars[i]] = norm;
    }
}
const tokenCache = {
    ["char"]: [],
    ["word"]: [],
    ["line"]: [],
};
function createTrieNode(ignoreSpaces) {
    const children = {};
    function next(char) {
        return ignoreSpaces && char === " " ? this : children[char] || null;
    }
    function addChild(char) {
        if (!children[char]) {
            children[char] = createTrieNode(ignoreSpaces);
        }
        return children[char];
    }
    return { next, addChild, word: null, flags: null };
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (const char of word) {
            node = node.addChild(char);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
// wildcards.
// 이걸 어떻게 구현해야할지 감이 안오지만 지금으로써는 얘네들을 atomic하게 취급(사이에 공백이 있어도 하나의 토큰으로 만듬. '(현행과 같음)'에서 일부분만 매치되는 것을 방지)
// 글자단위로 토큰화하는 경우에도 얘네들은 (...) 통채로 하나의 토큰으로 취급.
// 와일드카드diff인 경우 다른 diff와 병합되지 않으면 좋지만 와일드카드가 얼마나 greedy하게 반대쪽 텍스트를 잡아먹어야 할지
// 양쪽에 wildcard가 동시에 나오는 경우 경계를 어디서 어떻게 짤라야할지 쉽지 않음.
// 또한 wildcard를 강제로 다른 diff와 분리하는 경우 diff가 같은 위치에 두 개 이상 생기게 되는 수가 있다. (wildcard와 wildcard가 아닌 것)
// 이 경우 정확히 같은 위치에 두개의 diff를 렌더링해야하고 결국 두개가 겹쳐보이게 되는데 분간이 잘 안된다.
const WildcardTrie = createTrie(true);
WildcardTrie.insert("(추가)", WILD_CARD);
WildcardTrie.insert("(삭제)", WILD_CARD);
WildcardTrie.insert("(신설)", WILD_CARD);
WildcardTrie.insert("(생략)", WILD_CARD);
WildcardTrie.insert("(현행과같음)", WILD_CARD);
const TrieRoot = WildcardTrie.root;
const WildcardTrieNode = WildcardTrie.root.next("(");
const SectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    // 1. 제목 ==> 이 패턴은 무시. 보통 이 제목들은 왼쪽 문서 전체 테이블의 맨 왼쪽 컬럼에 들어가 있는데
    // 많은 문서들이 섹션을 테이블 행으로 분리하지 않고 그냥 엔터키를 열심히 눌러서 분리해두었기 때문에
    // 이런 경우 복사붙여넣기 하면 1. 제목, 2. 제목2, ...이 모두 문서의 첫 부분에 나와버림. 영구같다!
    SectionHeadingTrie.insert(`(${i}) `);
    SectionHeadingTrie.insert(`${i}) `);
}
const syllables = "가나다라마바사아자차카타파하";
for (let i = 0; i < syllables.length; i++) {
    SectionHeadingTrie.insert(`(${syllables[i]}) `);
    SectionHeadingTrie.insert(`${syllables[i]}) `);
    SectionHeadingTrie.insert(`(${String.fromCharCode(syllables.charCodeAt(i) + 112)}) `);
    SectionHeadingTrie.insert(`${String.fromCharCode(syllables.charCodeAt(i) + 112)}) `);
}
const SectionHeadingTrieNode = SectionHeadingTrie.root;
const ManualAnchorTrie = createTrie(false);
ManualAnchorTrie.insert(MANUAL_ANCHOR1, MANUAL_ANCHOR);
ManualAnchorTrie.insert(MANUAL_ANCHOR2, MANUAL_ANCHOR);
const ManualAnchorTrieNode = ManualAnchorTrie.root;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
    else if (e.data.type === "normalizeChars") {
        // TODO 이런 요상한 방법을 쓰지말고 UI쓰레드에서 Worker 생성 후 initialize 메시지를 한번 보내기.
        registerNormalizeChar(e.data.chars);
        // } else if (e.data.type === "option") {
        // 	if (e.data.key === "greedyMatch") {
        // 		greedyMatch = e.data.value;
        // 	}
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "myers") {
            result = await runMyersDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            ...result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// ============================================================
// Tokenization
// tokenize를 ui쓰레드에서 실행하는 것으로 바꿔봤지만
// editor에서 물흐르듯 자연스러운 편집이 안되는 느낌. 불쾌함!
// 그래도 UI쓰레드에서 토큰을 직접 가지고 있으면 편리한 부분이 있긴 있음.
// ============================================================
// #region Tokenization
function tokenizeByChar(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = FIRST_OF_LINE;
    let node = null;
    const inputPos = 0;
    const inputEnd = input.length;
    for (let i = inputPos; i < inputEnd; i++) {
        const char = input[i];
        if (!SPACE_CHARS[char]) {
            if (char === "(") {
                let p = i + 1;
                let found = null;
                for (node = WildcardTrieNode; p < inputEnd && (node = node.next(input[p++])) !== null;) {
                    if (node.word !== null) {
                        found = node;
                        break;
                    }
                }
                if (found) {
                    flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
                    tokens.push({
                        text: found.word,
                        pos: i,
                        len: p - i,
                        lineNum: lineNum,
                        flags: flags | (found.flags || 0),
                    });
                    flags = 0;
                    i = p - 1;
                    continue;
                }
            }
            if ((node = ManualAnchorTrieNode.next(char))) {
                let p = i + 1;
                let found = null;
                for (; p < inputEnd && (node = node.next(input[p++])) !== null;) {
                    if (node.word !== null) {
                        found = node;
                        break;
                    }
                }
                if (found) {
                    flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
                    tokens.push({
                        text: found.word,
                        pos: i,
                        len: p - i,
                        lineNum: lineNum,
                        flags: flags | (found.flags || 0),
                    });
                    flags = 0;
                    i = p - 1;
                    continue;
                }
            }
            flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
            tokens.push({
                text: char,
                pos: i,
                len: 1,
                lineNum: lineNum,
                flags,
            });
            flags = 0;
        }
        if (char === "\n") {
            lineNum++;
            flags = FIRST_OF_LINE;
            if (tokens.length > 0) {
                tokens[tokens.length - 1].flags |= LAST_OF_LINE;
            }
        }
    }
    if (tokens.length > 0) {
        let p = inputEnd;
        while (p <= input.length) {
            if (p === input.length || input[p] === "\n") {
                tokens[tokens.length - 1].flags |= LAST_OF_LINE;
                break;
            }
            else if (!SPACE_CHARS[input[p]]) {
                break;
            }
            p++;
        }
    }
    //console.debug("tokenizeByChar", tokens);
    return tokens;
}
function tokenizeByWord(input) {
    const tokens = [];
    let currentStart = -1;
    let lineNum = 1;
    let flags = FIRST_OF_LINE;
    const inputPos = 0;
    const inputEnd = input.length;
    for (let i = inputPos; i < inputEnd; i++) {
        let char = input[i];
        // 문장부호를 별개로 단어로 분리하는 방법도 생각해볼 필요가 있음.
        // 문제는 (hello)와 (world)에서 '('만 매치되면 눈이 피곤해진다. 괄호안의 문자들이 여러줄이면 더더욱..
        if (SPACE_CHARS[char]) {
            if (currentStart !== -1) {
                flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
                const text = flags & NORMALIZE ? normalize(input.substring(currentStart, i)) : input.substring(currentStart, i);
                if (text === MANUAL_ANCHOR1 || text === MANUAL_ANCHOR2) {
                    flags |= MANUAL_ANCHOR;
                }
                tokens.push({
                    text: text,
                    pos: currentStart,
                    len: i - currentStart,
                    lineNum: lineNum,
                    flags,
                });
                flags = 0;
                currentStart = -1;
            }
            if (char === "\n") {
                lineNum++;
                flags = FIRST_OF_LINE;
                if (tokens.length > 0) {
                    tokens[tokens.length - 1].flags |= LAST_OF_LINE;
                }
            }
        }
        else {
            if (normalizeChars[char]) {
                flags |= NORMALIZE;
                char = normalizeChars[char];
            }
            if (char === "(") {
                let p = i + 1;
                let found = null;
                for (let node = WildcardTrieNode; p < inputEnd && (node = node.next(input[p++])) !== null;) {
                    if (node.word !== null) {
                        found = node;
                        break;
                    }
                }
                if (found) {
                    if (currentStart !== -1) {
                        flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
                        tokens.push({
                            text: input.substring(currentStart, i),
                            pos: currentStart,
                            len: i - currentStart,
                            lineNum: lineNum,
                            flags,
                        });
                        flags = 0;
                        currentStart = -1;
                    }
                    flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
                    tokens.push({
                        text: found.word,
                        pos: i,
                        len: p - i,
                        lineNum: lineNum,
                        flags: flags | (found.flags || 0),
                    });
                    flags = 0;
                    i = p - 1;
                    continue;
                }
            }
            if (flags & FIRST_OF_LINE) {
                let p = i;
                let found = null;
                for (let node = SectionHeadingTrieNode; p < inputEnd && (node = node.next(input[p++])) !== null;) {
                    if (node.word !== null) {
                        found = node;
                        break;
                    }
                }
                if (found) {
                    while (p < inputEnd && SPACE_CHARS[input[p]]) {
                        p++;
                    }
                    if (p < inputEnd) {
                        flags |= SECTION_HEADING;
                    }
                }
            }
            if (currentStart === -1) {
                currentStart = i;
            }
        }
    }
    if (currentStart !== -1) {
        const text = flags & NORMALIZE ? normalize(input.substring(currentStart)) : input.substring(currentStart);
        if (text === MANUAL_ANCHOR1 || text === MANUAL_ANCHOR2) {
            flags |= MANUAL_ANCHOR;
        }
        flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
        tokens.push({
            text: text,
            pos: currentStart,
            len: inputEnd - currentStart,
            lineNum: lineNum,
            flags: flags,
        });
    }
    if (tokens.length > 0) {
        let p = inputEnd;
        while (p <= input.length) {
            if (p === input.length || input[p] === "\n") {
                tokens[tokens.length - 1].flags |= LAST_OF_LINE;
                break;
            }
            else if (!SPACE_CHARS[input[p]]) {
                break;
            }
            p++;
        }
    }
    //console.debug("tokenizeByWord", tokens);
    return tokens;
}
function tokenizeByLine(input) {
    const tokens = [];
    let currentStart = -1;
    let currentEnd = -1;
    let lineNum = 1;
    let flags = FIRST_OF_LINE | LAST_OF_LINE;
    const inputPos = 0;
    const inputEnd = input.length;
    for (let i = inputPos; i < inputEnd; i++) {
        const char = input[i];
        if (char !== "\n") {
            if (!SPACE_CHARS[char]) {
                if (currentStart === -1) {
                    currentStart = i;
                    let p = i;
                    let found = null;
                    for (let node = SectionHeadingTrieNode; p < inputEnd && (node = node.next(input[p++])) !== null;) {
                        if (node.word !== null) {
                            found = node;
                            break;
                        }
                    }
                    if (found) {
                        while (p < inputEnd && SPACE_CHARS[input[p]]) {
                            p++;
                        }
                        if (p < inputEnd) {
                            flags |= SECTION_HEADING;
                        }
                    }
                }
                currentEnd = i + 1;
            }
        }
        else {
            if (currentStart !== -1) {
                const text = input.substring(currentStart, currentEnd).replace(/\s+/g, " ");
                if (text === MANUAL_ANCHOR1 || text === MANUAL_ANCHOR2) {
                    flags |= MANUAL_ANCHOR;
                }
                tokens.push({
                    text: text,
                    pos: currentStart,
                    len: i - currentStart,
                    lineNum: lineNum,
                    flags: flags,
                });
                flags = FIRST_OF_LINE | LAST_OF_LINE;
                currentStart = currentEnd = -1;
            }
            lineNum++;
        }
    }
    if (currentStart !== -1) {
        const text = input.substring(currentStart, currentEnd).replace(/\s+/g, " ");
        if (text === MANUAL_ANCHOR1 || text === MANUAL_ANCHOR2) {
            flags |= MANUAL_ANCHOR;
        }
        tokens.push({
            text: text,
            pos: currentStart,
            len: currentEnd - currentStart,
            lineNum: lineNum,
            flags: flags,
        });
    }
    //console.debug("tokenizeByLine", tokens);
    return tokens;
}
function tokenize(input, mode, noCache = false) {
    let cacheArr = !noCache && tokenCache[mode];
    if (cacheArr) {
        for (let i = 0; i < cacheArr.length; i++) {
            const cache = cacheArr[i];
            if (cache.text === input) {
                if (i !== cacheArr.length - 1) {
                    cacheArr.splice(i, 1);
                    cacheArr.push(cache);
                }
                return cache.tokens;
            }
        }
    }
    let tokens;
    switch (mode) {
        case "char":
            tokens = tokenizeByChar(input);
            break;
        case "word":
            tokens = tokenizeByWord(input);
            break;
        case "line":
            tokens = tokenizeByLine(input);
            break;
        default:
            throw new Error("Unknown tokenization mode: " + mode);
    }
    // tokens.push({
    // 	text: "",
    // 	pos: input.length,
    // 	len: 0,
    // 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
    // 	flags: FIRST_OF_LINE | LAST_OF_LINE,
    // });
    if (cacheArr) {
        if (cacheArr.length >= TOKEN_CACHE_SIZE) {
            cacheArr.shift();
        }
        cacheArr.push({ text: input, tokens: tokens });
    }
    return tokens;
}
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizeChars[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!SPACE_CHARS[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhrTokens = tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhrTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    return postProcess(ctx, rawResult, lhrTokens, rhsTokens);
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // 텍스트가 길어지는 경우(토큰이 많은 경우) 끔찍하게 많은 반복을 수행하게된다.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // 주기적으로 yield 해서 취소요청을 받아야함.
            // performance.now()는 미친게 아닌가 싶을 정도로 무거운 함수이기 때문에 되도록 자제.
            // await new Promise(...) 역시 자주 사용하면 안됨
            // (i+j) % 0x4000 === 0 일 때만 사용하기로. 브라우저 js엔진의 비트연산 속도를 믿어본다 ㅋ
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// 정들었던 diff 함수. 폐기처분 예정.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && i < lcsEntry.leftIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // 유효한 토큰 index
                (!lcsEntry || // 공통 sequence가 없는 경우
                    (!greedyMatch && j < lcsEntry.rightIndex) || // 정확한 lcsIndex에만 매칭시키는 경우
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or 텍스트가 같으면 바로 중단
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Myers Algorithm
// ============================================================
// not fully working yet! 생각보다 이해가 안되는 알고리즘...
async function runMyersDiff(ctx) {
    const lhsTokens = tokenize(ctx.leftText, ctx.options.tokenization, false);
    const rhsTokens = tokenize(ctx.rightText, ctx.options.tokenization, false);
    const vectorSize = (lhsTokens.length + rhsTokens.length + 1) * 2;
    const vectorDown = new Array(vectorSize);
    const vectorUp = new Array(vectorSize);
    ctx.states.vectorDown = vectorDown;
    ctx.states.vectorUp = vectorUp;
    const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findMiddleSnake);
    return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
}
// 알쏭달쏭.
function findMiddleSnake(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const max = lhsTokens.length + rhsTokens.length + 1;
    const width = lhsUpper - lhsLower;
    const height = rhsUpper - rhsLower;
    const delta = width - height;
    const kdown = lhsLower - rhsLower;
    const kup = lhsUpper - rhsUpper;
    const offset_down = max - kdown;
    const offset_up = max - kup;
    const maxD = (lhsUpper - lhsLower + rhsUpper - rhsLower) / 2 + 1;
    const odd = (delta & 1) != 0;
    // const ret = { x: 0, y: 0 };
    // console.log("getShortestMiddleSnake", {
    // 	lhsLower,
    // 	lhsUpper,
    // 	rhsLower,
    // 	rhsUpper,
    // 	width,
    // 	height,
    // 	delta,
    // 	kDown: kdown,
    // 	kUp: kup,
    // 	offsetDown: offset_down,
    // 	offsetUp: offset_up,
    // 	maxD,
    // 	odd,
    // });
    const { vectorDown, vectorUp } = ctx.states;
    vectorDown[offset_down + kdown + 1] = lhsLower;
    vectorUp[offset_up + kup - 1] = lhsUpper;
    // console.log("offsetDown", offset_down, kdown, vectorD[offset_down + kdown + 1]);
    let d, k, x, y;
    for (d = 0; d <= maxD; d++) {
        for (k = kdown - d; k <= kdown + d; k += 2) {
            if (k === kdown - d) {
                x = vectorDown[offset_down + k + 1]; //down
            }
            else {
                x = vectorDown[offset_down + k - 1] + 1; //right
                if (k < kdown + d && vectorDown[offset_down + k + 1] >= x) {
                    x = vectorDown[offset_down + k + 1]; //down
                }
            }
            y = x - k;
            // console.log("BEFORE \\", x, y);
            while (x < lhsUpper && y < rhsUpper && lhsTokens[x].text === rhsTokens[y].text) {
                x++;
                y++;
            }
            vectorDown[offset_down + k] = x;
            // console.log("FORWARD", {
            // 	x,
            // 	y,
            // 	k,
            // 	d,
            // 	kDown: kdown,
            // 	vectorD,
            // 	vectorU,
            // 	"vectorDown[offsetDown + k + 1]": vectorD[offset_down + k + 1],
            // 	"vectorDown[offsetDown + k - 1]": vectorD[offset_down + k - 1],
            // });
            if (odd && kup - d < k && k < kup + d) {
                //if (vectorUp[offset_up + k] <= vectorDown[offset_down + k]) {
                if (vectorDown[offset_down + k] >= vectorUp[offset_up + k]) {
                    return {
                        lhsIndex: vectorDown[offset_down + k],
                        lhsLength: 1,
                        rhsIndex: vectorDown[offset_down + k] - k,
                        rhsLength: 1,
                    };
                    // ret.x = vectorDown[offset_down + k];
                    // ret.y = vectorDown[offset_down + k] - k;
                    // return ret;
                }
            }
        }
        for (k = kup - d; k <= kup + d; k += 2) {
            // find the only or better starting point
            if (k === kup + d) {
                x = vectorUp[offset_up + k - 1]; // up
            }
            else {
                x = vectorUp[offset_up + k + 1] - 1; // left
                if (k > kup - d && vectorUp[offset_up + k - 1] < x)
                    x = vectorUp[offset_up + k - 1]; // up
            }
            y = x - k;
            while (x > lhsLower && y > rhsLower && lhsTokens[x - 1].text === rhsTokens[y - 1].text) {
                // diagonal
                x--;
                y--;
            }
            vectorUp[offset_up + k] = x;
            // console.log("BACKWARD", {
            // 	x,
            // 	y,
            // 	k,
            // 	d,
            // 	kUp: kup,
            // 	vectorD,
            // 	vectorU,
            // 	"vectorD[offset_down + k]": vectorD[offset_down + k],
            // 	"vectorU[offset_up + k]": vectorU[offset_up + k],
            // });
            // overlap ?
            if (!odd && kdown - d <= k && k <= kdown + d) {
                // if (vectorUp[offset_up + k] <= vectorDown[offset_down + k]) {
                if (vectorDown[offset_down + k] >= vectorUp[offset_up + k]) {
                    return {
                        lhsIndex: vectorDown[offset_down + k],
                        lhsLength: 1,
                        rhsIndex: vectorDown[offset_down + k] - k,
                        rhsLength: 1,
                    };
                }
            }
        }
    }
    return null;
    // throw new Error("No middle snake found");
    // return { x: lhsLower - 1, y: rhsLower - 1 };
    // return { x: -1, y: -1 }; // No snake found
}
// ============================================================
// Histogram Algorithm
// 일단 지금은 이놈이 디폴트
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = tokenize(ctx.leftText, ctx.options.tokenization, false);
    const rightTokens = tokenize(ctx.rightText, ctx.options.tokenization, false);
    ctx.states.entries = [];
    const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rightTokens, 0, rightTokens.length, findBestHistogramAnchor);
    return postProcess(ctx, rawEntries, lhsTokens, rightTokens);
}
// histogram diff에서 가장 중요한 함수
// 얼마나 값어치 있는 공통 앵커를 찾느냐가 매우 중요하고 고로 그 값어치를 매기는 기준과 방법이 또 매우 중요함
// 여러가지 생각해볼 것들이 많지만...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // 길이가 너무 크게 영향을 주는 경향이 있어서 이걸로 조절
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; n그램을 사용시 여러단어가 매치되는 경우 오히려 마지막 단어가 다음 줄로 넘어가서 보너스를 못 받을 수가 있다
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + lhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + rhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // 특수 케이스
        // 강제로 문서의 특정 지점끼리 매칭시킴. 문서 구조가 항상 내 맘 같은 것이 아니야. ㅠ
        // if (ltext1 === MANUAL_ANCHOR1 || ltext1 === MANUAL_ANCHOR2) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            const rtext1 = rhsTokens[j].text;
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    if (ltext === MANUAL_ANCHOR1 || ltext === MANUAL_ANCHOR2) {
                        // 강제로 문서의 특정 지점끼리 매칭시킴. 문서 구조가 항상 내 맘 같은 것이 아니야. ㅠ
                        return {
                            lhsIndex: li,
                            lhsLength: 1,
                            rhsIndex: ri,
                            rhsLength: 1,
                        };
                    }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext1.length !== rtext1.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & FIRST_OF_LINE) {
                    // if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LAST_OF_LINE) {
                    // 	score *= FULL_LINE_BONUS;
                    // } else {
                    // }
                    score *= LINE_START_BONUS;
                }
                else if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LAST_OF_LINE) {
                    score *= LINE_END_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING) {
                    score *= SECTION_HEADING_BONUS;
                }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience 알고리즘에 공통으로 사용되는 재귀함수
// 1. 양 텍스트를 공통되는 부분(앵커)으로 분할
// 2. 분할된 영역에 대해서 재귀호출
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // 사실 이걸 쓰면 리턴값이 필요 없는데...
    // 함수 시그니처를 고치기 귀찮아서 일단 내비둠.
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // 공통 부분을 스킵하는건데 문제는 여기에서 HEAD, TAIL을 스킵하고
    // 이후에 diffCore를 재귀적으로 호출할 때 앞쪽 절반에 대해서 HEAD부분, 뒤쪽 절반에 대해서 TAIL부분을 다시 한번 스킵을 시도하게 된다.
    // 더 이상 스킵할 게 없으니 결과에는 차이가 없겠지만 불필요한 시도를 안하는 쪽으로 개선해 볼 필요가 있음!
    // 생각해볼 것: 공통 prefix,suffix를 스킵하지 않았을 경우 스킵되지 않은 부분에서 더 나은 앵커가 나올 확률이 있다.
    // 그렇지만 스킵하지 않으면 성능 상 아주 큰 문제가 생김!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize" // consumeCommonEdges 함수에 글자단위 매치를 시도할지를 가르키는 인자를 추가해야 맞지만 지금은 좀 귀찮네!
    );
    entries.push(...skippedHead);
    // 양쪽 모두 남아있는 영역이 있는 경우 공통 앵커를 찾아본다!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! 적어도 한쪽이라도 영역을 줄여야 무한루프 안 생길 듯?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor);
        // 앵커는 common sequence임!
        entries.push({
            type: 0,
            left: {
                pos: anchor.lhsIndex,
                len: anchor.lhsLength,
            },
            right: {
                pos: anchor.rhsIndex,
                len: anchor.rhsLength,
            },
        });
        await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor);
    }
    else {
        // 유효한 앵커는 못찾았지만 남아있는 토큰들이 있다면 diff로 처리
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    entries.push(...skippedTail);
    return entries;
}
// 공백을 완전히 무시하는 경우 "안녕 하세요" vs "안녕하세요"는 같다고 처리해야하지만
// 단어단위 토큰인 경우 토큰 대 토큰 비교는 실패할 수 밖에 없다.
// 따라서 각 토큰의 글자를 한땀한땀 매치시켜봐야하고 양쪽에서 토큰이 끝나는 시점까지 모든 글자가 매치되었다면
// 그 끝나는 시점까지의 토큰 수만큼 consume을 함.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore") {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
        if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
            head.push({
                type: 0,
                left: { pos: lhsLower, len: 1 },
                right: { pos: rhsLower, len: 1 },
            });
            lhsLower++;
            rhsLower++;
        }
        else if (whitespace === "ignore" &&
            lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
            lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
            (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
            head.push({
                type: 0,
                left: {
                    pos: lhsLower,
                    len: matchedCount[0],
                },
                right: {
                    pos: rhsLower,
                    len: matchedCount[1],
                },
            });
            lhsLower += matchedCount[0];
            rhsLower += matchedCount[1];
        }
        else {
            break;
        }
    }
    // Suffix
    while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
        if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
            tail.push({
                type: 0,
                left: { pos: lhsUpper - 1, len: 1 },
                right: { pos: rhsUpper - 1, len: 1 },
            });
            lhsUpper--;
            rhsUpper--;
        }
        else if (whitespace === "ignore" &&
            lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
            lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
            (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
            tail.push({
                type: 0,
                left: {
                    pos: lhsUpper - matchedCount[0],
                    len: matchedCount[0],
                },
                right: {
                    pos: rhsUpper - matchedCount[1],
                    len: matchedCount[1],
                },
            });
            lhsUpper -= matchedCount[0];
            rhsUpper -= matchedCount[1];
        }
        else {
            break;
        }
    }
    tail.reverse();
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    const llen = lhsUpper;
    const rlen = rhsUpper;
    while (i < llen && j < rlen) {
        const ltext = leftTokens[i].text;
        const rtext = rightTokens[j].text;
        const llen2 = ltext.length;
        const rlen2 = rtext.length;
        while (ci < llen2 && cj < rlen2) {
            if (ltext[ci++] !== rtext[cj++])
                return false;
        }
        if (ci >= ltext.length) {
            i++;
            ci = 0;
        }
        if (cj >= rtext.length) {
            j++;
            cj = 0;
        }
        if (ci === 0 && cj === 0)
            return [i - lhsLower, j - rhsLower];
    }
    return false;
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let ci = leftTokens[i].text.length - 1, cj = rightTokens[j].text.length - 1;
    const llen = lhsLower;
    const rlen = rhsLower;
    OUTER: while (i >= llen && j >= rlen) {
        const ltext = leftTokens[i].text;
        const rtext = rightTokens[j].text;
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                break OUTER;
            }
        }
        if (ci === -1 && cj === -1) {
            return [lhsUpper - i, rhsUpper - j];
        }
        if (ci < 0) {
            i--;
            if (i >= llen)
                ci = leftTokens[i].text.length - 1;
        }
        if (cj < 0) {
            j--;
            if (j >= rlen)
                cj = rightTokens[j].text.length - 1;
        }
    }
    return false;
}
// 무식하게 긴 함수지만 괜히 여러 함수로 쪼개서 오버헤드를 추가하고 싶진 않아서 그런거임. 귀찮은거 아님.
function postProcess(ctx, rawEntries, leftTokens, rightTokens) {
    //console.log("postProcess", "raw entries:", Array.from(rawEntries), leftTokens, rightTokens);
    const leftText = ctx.leftText;
    const rightText = ctx.rightText;
    let prevEntry = null;
    const diffs = [];
    const anchors = [];
    // const mappings: DiffEntry[] = [];
    for (let i = 0; i < rawEntries.length; i++) {
        const entry = rawEntries[i];
        if (entry.type) {
            if (prevEntry) {
                console.assert(prevEntry.left.pos + prevEntry.left.len === entry.left.pos, prevEntry, entry);
                console.assert(prevEntry.right.pos + prevEntry.right.len === entry.right.pos, prevEntry, entry);
                prevEntry.type |= entry.type;
                prevEntry.left.len += entry.left.len;
                prevEntry.right.len += entry.right.len;
            }
            else {
                prevEntry = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
                //prevEntry = entry;
            }
        }
        else {
            if (prevEntry) {
                addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
                // mappings.push(prevEntry);
            }
            prevEntry = null;
            const leftToken = leftTokens[entry.left.pos];
            const rightToken = rightTokens[entry.right.pos];
            if (leftToken.flags & rightToken.flags & FIRST_OF_LINE) {
                // 앵커 추가
                addAnchor("before", leftToken.pos, rightToken.pos, null);
            }
            // mappings.push(entry);
        }
    }
    if (prevEntry) {
        addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
        // mappings.push(prevEntry);
    }
    function addAnchor(type, leftPos, rightPos, diffIndex) {
        if (leftPos === undefined || rightPos === undefined) {
            console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
        }
        if (type === "before") {
            // before 앵커는 항상 줄의 시작위치일 때만 추가하므로 줄바꿈 문자만 확인하면 된다!
            while (leftPos > 0 && leftText[leftPos - 1] !== "\n") {
                leftPos--;
            }
            while (rightPos > 0 && rightText[rightPos - 1] !== "\n") {
                rightPos--;
            }
        }
        else if (type === "after") {
            // empty diff의 after앵커는 이후에 다른 토큰이 존재할 수 있음.
            // 공백이 아닌 문자가 나오면 멈추고 기본 위치 사용.
            let p;
            p = leftPos;
            while (p < leftText.length) {
                const ch = leftText[p++];
                if (ch === "\n") {
                    leftPos = p - 1;
                    break;
                }
                else if (!SPACE_CHARS[ch]) {
                    break;
                }
            }
            p = rightPos;
            while (p < rightText.length) {
                const ch = rightText[p++];
                if (ch === "\n") {
                    rightPos = p - 1;
                    break;
                }
                else if (!SPACE_CHARS[ch]) {
                    break;
                }
            }
        }
        if (anchors.length > 0) {
            let lastAnchor = anchors[anchors.length - 1];
            if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
                return;
            }
            if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
                if (type === lastAnchor.type || type === "before") {
                    return;
                }
            }
        }
        anchors.push({ type, left: leftPos, right: rightPos, diffIndex });
    }
    function addDiff(leftIndex, leftCount, rightIndex, rightCount) {
        let leftPos, leftLen, rightPos, rightLen;
        let leftBeforeAnchorPos, rightBeforeAnchorPos, leftAfterAnchorPos, rightAfterAnchorPos;
        let leftEmpty, rightEmpty;
        let type;
        // 양쪽에 대응하는 토큰이 모두 존재하는 경우. 쉬운 케이스
        if (leftCount > 0 && rightCount > 0) {
            type = 3;
            let leftTokenStart = leftTokens[leftIndex];
            let leftTokenEnd = leftTokens[leftIndex + leftCount - 1];
            let rightTokenEnd = rightTokens[rightIndex + rightCount - 1];
            let rightTokenStart = rightTokens[rightIndex];
            leftPos = leftTokenStart.pos;
            leftLen = leftTokenEnd.pos + leftTokenEnd.len - leftPos;
            leftEmpty = false;
            rightPos = rightTokenStart.pos;
            rightLen = rightTokenEnd.pos + rightTokenEnd.len - rightPos;
            rightEmpty = false;
            // 생각: 한쪽만 줄의 첫 토큰일 때에도 앵커를 넣을까? 앵커에 display:block을 줘서 강제로 줄바꿈 시킨 후에에
            // 좌우 정렬을 할 수 있을 것 같기도 한데...
            if (leftTokenStart.flags & rightTokenStart.flags & FIRST_OF_LINE) {
                leftBeforeAnchorPos = leftPos;
                rightBeforeAnchorPos = rightPos;
                while (leftBeforeAnchorPos > 0 && leftText[leftBeforeAnchorPos - 1] !== "\n") {
                    leftBeforeAnchorPos--;
                }
                while (rightBeforeAnchorPos > 0 && rightText[rightBeforeAnchorPos - 1] !== "\n") {
                    rightBeforeAnchorPos--;
                }
                // addAnchor("before", leftAnchorPos, rightAnchorPos, null);
                if (leftTokenEnd.flags & rightTokenEnd.flags & LAST_OF_LINE) {
                    leftAfterAnchorPos = leftPos + leftLen;
                    rightAfterAnchorPos = rightPos + rightLen;
                    if (leftText[leftAfterAnchorPos] !== "\n") {
                        do {
                            leftAfterAnchorPos++;
                        } while (leftAfterAnchorPos < leftText.length && leftText[leftAfterAnchorPos] !== "\n");
                    }
                    if (rightText[rightAfterAnchorPos] !== "\n") {
                        do {
                            rightAfterAnchorPos++;
                        } while (rightAfterAnchorPos < rightText.length && rightText[rightAfterAnchorPos] !== "\n");
                    }
                    // while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
                    // 	leftAnchorPos++;
                    // }
                    // while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
                    // 	rightAnchorPos++;
                    // }
                    // addAnchor("after", leftBeforeAnchorPos, rightBeforeAnchorPos, null);
                }
            }
        }
        else {
            // 한쪽이 비어있음.
            // 단순하게 토큰 사이에 위치시켜도 되지만 되도록이면 대응하는 쪽과 유사한 위치(줄시작/줄끝)에 위치시키기 위해...
            // 자꾸 이런저런 시도를 하다보니 난장판인데 만지기 싫음...
            let longSideText, shortSideText;
            let longSideIndex, longSideCount, longSideTokens;
            let shortSideIndex, shortSideTokens;
            let longSidePos, longSideLen;
            let shortSidePos, shortSideLen;
            let longSideBeforeAnchorPos, shortSideBeforeAnchorPos;
            let longSideAfterAnchorPos, shortSideAfterAnchorPos;
            let longSideTokenStart, longSideTokenEnd;
            let shortSideBeforeToken, shortSideAfterToken;
            if (leftCount > 0) {
                type = 1; // 1: left
                longSideText = leftText;
                longSideTokens = leftTokens;
                longSideIndex = leftIndex;
                longSideCount = leftCount;
                shortSideText = rightText;
                shortSideTokens = rightTokens;
                shortSideIndex = rightIndex;
                leftEmpty = false;
                rightEmpty = true;
            }
            else {
                type = 2; // 2: right
                longSideText = rightText;
                longSideTokens = rightTokens;
                longSideIndex = rightIndex;
                longSideCount = rightCount;
                shortSideText = leftText;
                shortSideTokens = leftTokens;
                shortSideIndex = leftIndex;
                leftEmpty = true;
                rightEmpty = false;
            }
            longSideTokenStart = longSideTokens[longSideIndex];
            longSideTokenEnd = longSideTokens[longSideIndex + longSideCount - 1];
            shortSideBeforeToken = shortSideTokens[shortSideIndex - 1];
            shortSideAfterToken = shortSideTokens[shortSideIndex];
            longSidePos = longSideTokenStart.pos;
            longSideLen = longSideTokenEnd.pos + longSideTokenEnd.len - longSidePos;
            shortSidePos = shortSideBeforeToken ? shortSideBeforeToken.pos + shortSideBeforeToken.len : 0;
            shortSideLen = 0;
            const longSideIsFirstWord = longSideTokenStart.flags & FIRST_OF_LINE;
            const longSideIsLastWord = longSideTokenEnd.flags & LAST_OF_LINE;
            const shortSideIsOnLineEdge = shortSideTokens.length === 0 ||
                (shortSideBeforeToken && shortSideBeforeToken.flags & LAST_OF_LINE) ||
                (shortSideAfterToken && shortSideAfterToken.flags & FIRST_OF_LINE);
            // base pos는 되도록이면 앞쪽으로 잡자. 난데없이 빈줄 10개 스킵하고 diff가 시작되면 이상하자나.
            if (shortSideIsOnLineEdge) {
                // 줄의 경계에 empty diff를 표시하는 경우 현재 줄의 끝이나 다음 줄의 시작 중 "적절하게" 선택. 현재 줄의 끝(이전 토큰의 뒤)에 위치 중임.
                if (longSideIsFirstWord) {
                    if (shortSidePos !== 0) {
                        // pos가 0이 아닌 경우는 이전 토큰의 뒤로 위치를 잡은 경우니까 다음 줄바꿈을 찾아서 그 줄바꿈 뒤로 밀어줌
                        // 주의: 현재 위치 이후에 줄바꿈이 있는지 없는지 확인하기보다는 원본 텍스트의 마지막에 줄바꿈이 없는 경우 강제로 줄바꿈을 붙여주는게 편함.
                        // 잊지말고 꼭 원본텍스트의 끝에 줄바꿈 하나 붙일 것.
                        // const maxPos = shortSideAfterToken ? shortSideAfterToken.pos - 1 : shortSideText.length - 1;
                        // while (shortSidePos < maxPos && shortSideText[shortSidePos++] !== "\n");
                        while (shortSideText[shortSidePos++] !== "\n")
                            ;
                    }
                    // 양쪽 모두 줄의 시작 부분에 위치하므로 앵커 추가.
                    // 빈 diff가 줄 시작이나 줄 끝 위치에 있다면 하나의 줄로 표시되게 할 수 있음(css 사용)
                    longSideBeforeAnchorPos = longSidePos;
                    shortSideBeforeAnchorPos = shortSidePos;
                    if (longSideIsLastWord) {
                        longSideAfterAnchorPos = longSidePos + longSideLen;
                        shortSideAfterAnchorPos = shortSidePos;
                    }
                }
            }
            if (leftCount > 0) {
                leftPos = longSidePos;
                leftLen = longSideLen;
                leftEmpty = false;
                leftBeforeAnchorPos = longSideBeforeAnchorPos;
                leftAfterAnchorPos = longSideAfterAnchorPos;
                rightPos = shortSidePos;
                rightLen = shortSideLen;
                rightEmpty = true;
                rightBeforeAnchorPos = shortSideBeforeAnchorPos;
                rightAfterAnchorPos = shortSideAfterAnchorPos;
            }
            else {
                leftPos = shortSidePos;
                leftLen = shortSideLen;
                leftEmpty = true;
                leftBeforeAnchorPos = shortSideBeforeAnchorPos;
                leftAfterAnchorPos = shortSideAfterAnchorPos;
                rightPos = longSidePos;
                rightLen = longSideLen;
                rightEmpty = false;
                rightBeforeAnchorPos = longSideBeforeAnchorPos;
                rightAfterAnchorPos = longSideAfterAnchorPos;
            }
        }
        if (leftBeforeAnchorPos !== undefined && rightBeforeAnchorPos !== undefined) {
            addAnchor("before", leftBeforeAnchorPos, rightBeforeAnchorPos, diffs.length);
        }
        if (leftAfterAnchorPos !== undefined && rightAfterAnchorPos !== undefined) {
            addAnchor("after", leftAfterAnchorPos, rightAfterAnchorPos, diffs.length);
        }
        const newEntry = {
            type: type,
            left: {
                pos: leftPos,
                len: leftLen,
                empty: leftEmpty,
            },
            right: {
                pos: rightPos,
                len: rightLen,
                empty: rightEmpty,
            },
        };
        diffs.push(newEntry);
    }
    // console.log("postProcess", "final diffs:", diffs, anchors);
    return { diffs, anchors, leftTokenCount: leftTokens.length, rightTokenCount: rightTokens.length };
}
//# sourceMappingURL=worker.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 22px;
	font-size: 16px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr 250px;
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 8px;
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: "돋움체", monospace;
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	white-space: pre-wrap;
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -1;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: rgba(0, 0, 0, 0.1);
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: inherit;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
	color: inherit;
}
mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-block으로 안해두면 높이 1px이 모자르게 된다. 묻지마... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
공간을 전혀 차지하지 않으면서도 visual이 있어야함
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror {
	color: #fff;
	background-color: #000;
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
줄(div)안에 블럭 엘러먼트를 넣어서 강제로 줄바꿈 효과를 주었을 때
diff가 없는 가상의 줄도 diff가 있는 줄처럼 표시되는 문제.
당연한거긴 한데... 쉬운 해결방법이 떠오르질 않는다!
고민 필요
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "👬";
	font-size: 128px;
	font-weight: bold;
	font-family: "Consolas", Courier, monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "💭";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: "Consolas", "Courier New", monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "◀️"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "▶️" !important; */
}

.edit hr {
	height: 0 !important;
}

/* 의미없다
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
	font-weight: bold;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	font-family: "Segoe UI", sans-serif;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: 1000;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}

</style>
</head>

<body>
    <div class="container">
        <main id="main">
            <div id="scrollSyncIndicator">🔗</div>
            <!--leftEditor will be here -->
            <!-- rightEditor will be here -->
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="statusbar"></div>
    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>

    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT}px;\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script>"use strict";
// 이것저것 이어붙이는 코드 집합
const DiffSeek = (function () {
    let _alignedMode = false;
    let _alignedDirty = false;
    let _activeEditor = null;
    let _lastFocusedEditor = null;
    let _lastScrolledEditor = null;
    let _currentlyScrollingEditor = null;
    let _preventScrollSync = false;
    let _currentDiffIndex = -1;
    let _syncEditor = false;
    let _resetCurrentlyScrollingEditorId = null;
    let _diffResult = null;
    // devtools 콘솔에서 설정 값을 바꿨을때 바로 업데이트 시키기 위해...
    const _diffOptions = (function (defaultValues) {
        let _diffOptions = { ...defaultValues };
        function setValue(key, value) {
            if (_diffOptions[key] !== value) {
                _diffOptions[key] = value;
                computeDiff();
            }
        }
        return {
            get algorithm() {
                return _diffOptions.algorithm;
            },
            set algorithm(value) {
                if (value !== "histogram" && value !== "myers" && value !== "lcs") {
                    throw new Error("Invalid algorithm: " + value);
                }
                setValue("algorithm", value);
            },
            get tokenization() {
                return _diffOptions.tokenization;
            },
            set tokenization(value) {
                if (value !== "char" && value !== "word" && value !== "line") {
                    throw new Error("Invalid tokenization: " + value);
                }
                setValue("tokenization", value);
            },
            get whitespace() {
                return _diffOptions.whitespace;
            },
            set whitespace(value) {
                if (value !== "ignore" && value !== "normalize") {
                    throw new Error("Invalid whitespace handling: " + value);
                }
                setValue("whitespace", value);
            },
            get greedyMatch() {
                return !!_diffOptions.greedyMatch;
            },
            set greedyMatch(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid greedyMatch: " + value);
                }
                setValue("greedyMatch", !!value);
            },
            get useLengthBias() {
                return !!_diffOptions.useLengthBias;
            },
            set useLengthBias(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid useLengthBias: " + value);
                }
                setValue("useLengthBias", !!value);
            },
            get maxGram() {
                return _diffOptions.maxGram;
            },
            set maxGram(value) {
                if (value < 1) {
                    throw new Error("Invalid maxGram: " + value);
                }
                setValue("maxGram", value);
            },
            get lengthBiasFactor() {
                return _diffOptions.lengthBiasFactor;
            },
            set lengthBiasFactor(value) {
                if (value <= 0) {
                    throw new Error("Invalid lengthBiasFactor: " + value);
                }
                setValue("lengthBiasFactor", value);
            },
            get sectionHeadingMultiplier() {
                return _diffOptions.sectionHeadingMultiplier;
            },
            set sectionHeadingMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid sectionHeadingMultiplier: " + value);
                }
                setValue("sectionHeadingMultiplier", value);
            },
            get lineStartMultiplier() {
                return _diffOptions.lineStartMultiplier;
            },
            set lineStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineStartMultiplier: " + value);
                }
                setValue("lineStartMultiplier", value);
            },
            get lineEndMultiplier() {
                return _diffOptions.lineEndMultiplier;
            },
            set lineEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineEndMultiplier: " + value);
                }
                setValue("lineEndMultiplier", value);
            },
            get uniqueMultiplier() {
                return _diffOptions.uniqueMultiplier;
            },
            set uniqueMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid uniqueMultiplier: " + value);
                }
                setValue("uniqueMultiplier", value);
            },
        };
    })({
        algorithm: "histogram",
        tokenization: "word",
        whitespace: "ignore",
        greedyMatch: false,
        useLengthBias: true,
        maxGram: 5,
        lengthBiasFactor: 0.7,
        sectionHeadingMultiplier: 1 / 0.75,
        lineStartMultiplier: 1 / 0.85,
        lineEndMultiplier: 1 / 0.9,
        uniqueMultiplier: 1 / 0.6667,
    });
    const useEditableMirror = false;
    const container = document.getElementById("main");
    const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
    const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
    leftEditor.wrapper.tabIndex = 100;
    rightEditor.wrapper.tabIndex = 101;
    // 지저분의 끝
    const statusBar = InitializeStatusBar([
        {
            side: "center",
            key: "mode",
            label: "",
            get: () => (_alignedMode ? "📖" : "✏️"),
            toggle: () => {
                if (_alignedMode) {
                    disableAlignedMode();
                }
                else {
                    enableAlignedMode();
                }
            },
        },
        {
            side: "left",
            key: "tokenization",
            label: "단위",
            get: () => _diffOptions.tokenization,
            set: (value) => (_diffOptions.tokenization = value),
            options: [
                { label: "글자", value: "char" },
                { label: "단어", value: "word" },
                { label: "줄", value: "line" },
            ],
        },
        {
            side: "left",
            key: "algorithm",
            label: "알고리즘",
            get: () => _diffOptions.algorithm,
            set: (value) => (_diffOptions.algorithm = value),
            options: [
                { label: "Histogram", value: "histogram" },
                { label: "⚠️ Myers ❌", value: "myers" },
                { label: "LCS DP", value: "lcs" },
            ],
        },
        {
            side: "left",
            key: "whitespace",
            label: "공백",
            get: () => _diffOptions.whitespace,
            set: (value) => (_diffOptions.whitespace = value),
            visible: () => _diffOptions.algorithm === "histogram" && _diffOptions.tokenization === "word",
            options: [
                { label: "정규화", value: "normalize" },
                { label: "무시", value: "ignore" },
            ],
        },
        // {
        // 	side: "right",
        // 	key: "greedyMatch",
        // 	label: "Greedy Match",
        // 	get: () => _diffOptions.greedyMatch,
        // 	set: (value: boolean) => (_diffOptions.greedyMatch = value),
        // 	disabled: () => _diffOptions.algorithm === "lcs",
        // 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
        // },
        // {
        // 	side: "right",
        // 	key: "useLengthBias",
        // 	label: "Length Bias",
        // 	get: () => _diffOptions.useLengthBias,
        // 	set: (value: boolean) => (_diffOptions.useLengthBias = value),
        // 	disabled: () => _diffOptions.algorithm === "histogram",
        // 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
        // },
        // {
        // 	side: "right",
        // 	key: "maxGram",
        // 	label: "Max Gram",
        // 	get: () => _diffOptions.maxGram,
        // 	set: (value: number) => (_diffOptions.maxGram = value),
        // 	disabled: () => _diffOptions.algorithm === "histogram",
        // 	options: [1, 2, 3, 4, 5, 6, 7].reverse().map((v) => ({ label: v.toString(), value: v })),
        // },
        {
            side: "right",
            key: "diffs",
            label: "≠",
            get: () => {
                if (_diffResult === null) {
                    return "...";
                }
                return `${_diffResult.diffs.length}`;
            },
        },
        {
            side: "right",
            key: "tokenCount",
            label: "#",
            get: () => {
                if (_diffResult === null) {
                    return "...";
                }
                return `${_diffResult.leftTokenCount} / ${_diffResult.rightTokenCount}`;
            },
        },
        {
            side: "right",
            key: "processTime",
            label: "⏱",
            get: () => {
                if (_diffResult === null) {
                    return "...";
                }
                return `${Math.ceil(_diffResult.processTime)}ms`;
            },
        },
    ]);
    const body = document.querySelector("body");
    const diffList = document.getElementById("diffList");
    const highlightStyle = document.getElementById("highlightStyle");
    const progress = document.getElementById("progress");
    const scrollSyncIndicator = document.getElementById("scrollSyncIndicator");
    // aligned mode용 style 컨테이너. 필요한 경우 한번에 기존의 모든 스타일을 날려버리기 위해 요소마다 style값을 직접 지정하지 않고
    // .alinged #rightAnchor32 { height: 200px; } 이런식으로 스타일 추가함.
    const alignmentStyleElement = document.createElement("style");
    document.head.appendChild(alignmentStyleElement);
    const resizeObserver = new ResizeObserver(() => {
        _alignedDirty = true;
        if (_alignedMode) {
            recalculateAlignmentPaddingAndPositionsDebounced();
        }
        else if (_syncEditor) {
            // 어느 에디터를 기준으로 싱크를 하냐?
            // 기준이 단순하고 명확하지 않으면 오히려 더 혼란스러움.
            // 1. 포커스를 가진 에디터?...
            // 2. 마우스커서가 올려진 에디터?...
            // 3. 최근에 스크롤된 에디터?...
        }
    });
    resizeObserver.observe(container);
    const recalculateAlignmentPaddingAndPositionsDebounced = debounce(recalculateAlignmentPaddingAndPositions, 200);
    function getEditorCallbacks(editorName) {
        const pendingDiffVisibilities = new Map();
        let updateDiffVisilitiesPending = false;
        return {
            onTextChanged: function () {
                computeDiff();
            },
            onMirrorUpdated: function () {
                _alignedDirty = true;
                if (_alignedMode) {
                    recalculateAlignmentPaddingAndPositions();
                }
            },
            // 현재 화면 상에 보이는 diff 아이템들.
            onDiffVisibilityChanged: (diffIndex, visible) => {
                pendingDiffVisibilities.set(diffIndex, visible);
                if (!updateDiffVisilitiesPending) {
                    updateDiffVisilitiesPending = true;
                    requestAnimationFrame(() => {
                        updateDiffVisilitiesPending = false;
                        for (const [diffIndex, visible] of pendingDiffVisibilities) {
                            const listItem = diffList.children[diffIndex];
                            if (listItem) {
                                const button = listItem.firstElementChild;
                                button.classList.toggle(editorName + "-visible", visible);
                            }
                        }
                        pendingDiffVisibilities.clear();
                    });
                }
            },
        };
    }
    function createWorker() {
        // 보안 상 new Worker("worker.js")는 실행 안됨.
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerURL);
        function htmlEntityToChar(entity) {
            const doc = new DOMParser().parseFromString(entity, "text/html");
            const char = doc.body.textContent;
            if (char.length !== 1) {
                throw new Error("htmlEntityToChar: not a single character entity: " + entity);
            }
            return char;
        }
        // TODO
        // 그냥 { type: "init? config?", normalizeChars: {...}, ... } 이런 식으로 보내는게 더 나을듯.
        for (var entry of NORMALIZE_CHARS) {
            // entry[0] = encoder.encode(entry[0]);
            let chars = "";
            for (var i = 0; i < entry.length; i++) {
                const char = entry[i];
                if (char.length === 1) {
                    chars += char;
                }
                else if (typeof char === "number") {
                    chars += String.fromCharCode(char);
                }
                else if (char[0] === "&") {
                    chars += htmlEntityToChar(char);
                }
                else {
                    throw new Error("normalizeChars: not a single character: " + char);
                }
            }
            worker.postMessage({
                type: "normalizeChars",
                chars: chars,
            });
        }
        return worker;
    }
    const { computeDiff } = (function () {
        const worker = createWorker();
        let reqId = 0;
        let computeDiffTimeoutId = null;
        function computeDiff() {
            if (computeDiffTimeoutId) {
                clearTimeout(computeDiffTimeoutId);
            }
            computeDiffTimeoutId = setTimeout(() => {
                _diffResult = null;
                _currentDiffIndex = -1;
                _alignedDirty = true;
                // 토큰화를 UI 쓰레드에서도 해봤지만 텍스트 수정 시에 살짝 거슬리는 느낌.
                // _leftTokens = tokenize(leftEditor.text, _diffOptions.tokenization);
                // _rightTokens = tokenize(rightEditor.text, _diffOptions.tokenization);
                progress.textContent = "...";
                // 좌우 텍스트가 완전히 똑.같.은. 경우 쌍둥이 이모지 표시 ㅋ
                // 나만 그런가? ctrl-c는 믿을 수 없어서 3-4번씩 눌러줘야한다. 쌍둥이가 보여질 경우 복붙이 제대로 안되었다는 경고의 뜻으로 받아들이기.
                body.classList.toggle("identical", leftEditor.text === rightEditor.text);
                body.classList.add("computing");
                if (reqId === Number.MAX_SAFE_INTEGER) {
                    // 여기까지 왔다면 지구가 멸망함.
                    reqId = 1;
                }
                else {
                    reqId++;
                }
                const request = {
                    type: "diff",
                    reqId: reqId,
                    leftText: leftEditor.text,
                    rightText: rightEditor.text,
                    options: _diffOptions,
                };
                worker.postMessage(request);
                updateButtons();
            }, COMPUTE_DEBOUNCE_TIME);
        }
        worker.onmessage = function (e) {
            const data = e.data;
            if (data.type === "diff") {
                if (data.reqId === reqId) {
                    console.debug("diff response:", data);
                    document.querySelector("body").classList.remove("computing");
                    onDiffComputed(data);
                }
            }
            else if (data.type === "start") {
                progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
            }
        };
        function onDiffComputed(data) {
            _diffResult = data;
            _alignedDirty = true;
            leftEditor.update(data);
            rightEditor.update(data);
            updateDiffList();
            updateButtons();
        }
        return { computeDiff };
    })();
    // 손 볼 여지가 많은데... 으...
    // 스크롤 위치 계산하는게 좀.. 음...
    function enableAlignedMode() {
        // 스크롤 위치는 어디쪽 에디터에 맞추나?
        // 역시 명확한 기준이 필요.
        if (!_alignedMode) {
            const currentSelectionRange = getSelectionRange();
            const currentEditor = _activeEditor || _lastFocusedEditor || rightEditor;
            const [firstVisibleLineEl, firstVisibleLineDistance] = currentEditor.getFirstVisibleLineElement();
            _alignedMode = true;
            leftEditor.mirror.tabIndex = 100;
            rightEditor.mirror.tabIndex = 101;
            if (useEditableMirror) {
                leftEditor.mirror.contentEditable = "plaintext-only";
                rightEditor.mirror.contentEditable = "plaintext-only";
            }
            leftEditor.setEditMode(false);
            rightEditor.setEditMode(false);
            body.classList.toggle("aligned", true);
            body.classList.toggle("edit", false);
            recalculateAlignmentPaddingAndPositions();
            if (currentSelectionRange) {
                restoreSelectionRange(currentSelectionRange);
            }
            updateButtons();
            requestAnimationFrame(() => {
                // 레이아웃이 끝난 후 미리 찾아뒀던 줄 위치로 스크롤.
                let lineNum = Number(firstVisibleLineEl?.dataset?.lineNum) || 1;
                let distance = firstVisibleLineDistance || 0;
                currentEditor.scrollToLine(lineNum, distance);
                const theOtherEditor = currentEditor === leftEditor ? rightEditor : leftEditor;
                theOtherEditor.wrapper.scrollTop = currentEditor.wrapper.scrollTop;
                // 포커스를 가져야 aligned mode 진입 후 바로 키보드로 스크롤 할 수 있음.
                // 스크롤이 동기화되니 사실 어느쪽이 포커스를 가지든 상관 무.
                currentEditor.mirror.focus();
            });
        }
    }
    function disableAlignedMode() {
        const currentSelectionRange = getSelectionRange();
        // 일단 editmode로 가기 전에 현재 화면 상 첫줄을 보존
        const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElement();
        const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElement();
        _alignedMode = false;
        leftEditor.setEditMode(true);
        rightEditor.setEditMode(true);
        leftEditor.mirror.removeAttribute("tabindex");
        rightEditor.mirror.removeAttribute("tabindex");
        leftEditor.mirror.contentEditable = "false";
        rightEditor.mirror.contentEditable = "false";
        body.classList.toggle("aligned", false);
        body.classList.toggle("edit", true);
        updateButtons();
        _preventScrollSync = true;
        requestAnimationFrame(() => {
            if (leftFirstLine) {
                leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
            }
            if (rightFirstLine) {
                rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
            }
            requestAnimationFrame(() => {
                _preventScrollSync = false;
            });
        });
        if (currentSelectionRange) {
            restoreSelectionRange(currentSelectionRange);
        }
    }
    function recalculateAlignmentPaddingAndPositions() {
        if (!_alignedDirty) {
            return;
        }
        if (!_diffResult) {
            return;
        }
        const { anchors } = _diffResult;
        // 얘네들은 알아서 스스로 쑥쑥 자라게 auto로
        leftEditor.mirror.style.height = "auto";
        rightEditor.mirror.style.height = "auto";
        // 기존 스타일 한번에 날려버리기
        alignmentStyleElement.textContent = "";
        const leftAnchorEls = leftEditor.anchorElements, rightAnchorEls = rightEditor.anchorElements, leftTops = new Array(anchors.length), rightTops = new Array(anchors.length), leftHeights = new Array(anchors.length), rightHeights = new Array(anchors.length);
        for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
            leftTops[anchorIndex] = leftAnchorEls[anchorIndex]?.offsetTop;
            rightTops[anchorIndex] = rightAnchorEls[anchorIndex]?.offsetTop;
            if (anchors[anchorIndex].type === "after") {
                leftHeights[anchorIndex] = leftAnchorEls[anchorIndex]?.offsetHeight;
                rightHeights[anchorIndex] = rightAnchorEls[anchorIndex]?.offsetHeight;
            }
        }
        let styleText = "";
        let leftDelta = 0, rightDelta = 0;
        for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
            const anchor = anchors[anchorIndex];
            if (leftTops[anchorIndex] === undefined || rightTops[anchorIndex] === undefined) {
                continue;
            }
            const leftY = leftTops[anchorIndex] + leftDelta, rightY = rightTops[anchorIndex] + rightDelta;
            let delta;
            if (anchor.type === "before") {
                delta = leftY - rightY;
            }
            else if (anchor.type === "after") {
                const leftB = leftY + leftHeights[anchorIndex], rightB = rightY + rightHeights[anchorIndex];
                delta = leftB - rightB;
            }
            else {
                console.warn("unknown anchor type", anchor.type);
                continue;
            }
            if (delta > 0) {
                styleText += `.aligned #rightAnchor${anchorIndex} { display:block; height:${delta}px; }\n`;
                rightDelta += delta;
            }
            else {
                styleText += `.aligned #leftAnchor${anchorIndex} { display:block; height:${-delta}px; }\n`;
                leftDelta += -delta;
            }
        }
        alignmentStyleElement.textContent = styleText;
        _alignedDirty = false;
        requestAnimationFrame(() => {
            // 레이아웃이 끝난 후 mirror 높이 조정
            const height = Math.max(leftEditor.mirror.offsetHeight, rightEditor.mirror.offsetHeight);
            leftEditor.mirror.style.height = `${height}px`;
            rightEditor.mirror.style.height = `${height}px`;
        });
    }
    function restoreSelectionRange({ editor, startOffset, endOffset }) {
        if (editor) {
            editor.selectTextRange(startOffset, endOffset);
        }
    }
    function getSelectionRange() {
        let editor = null;
        let [startOffset, endOffset] = leftEditor.getTextSelectionRange();
        if (startOffset !== null) {
            editor = leftEditor;
        }
        else {
            [startOffset, endOffset] = rightEditor.getTextSelectionRange();
            if (startOffset !== null) {
                editor = rightEditor;
            }
        }
        if (editor) {
            return {
                editor,
                startOffset: startOffset,
                endOffset: endOffset,
            };
        }
        else {
            return null;
        }
    }
    function syncScrollPosition(sourceEditor) {
        if (_preventScrollSync) {
            return;
        }
        if (!sourceEditor) {
            sourceEditor = _currentlyScrollingEditor || _activeEditor || _lastFocusedEditor;
            if (!sourceEditor) {
                return;
            }
        }
        if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
            return;
        }
        _preventScrollSync = true;
        const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
        let sourceAnchor = null;
        let targetAnchor = null;
        sourceAnchor = sourceEditor.getClosestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
        if (sourceAnchor) {
            const anchorIndex = Number(sourceAnchor.dataset.anchor);
            targetAnchor = targetEditor.anchorElements[anchorIndex];
        }
        if (sourceAnchor && targetAnchor) {
            const prevLastScrolledEditor = _lastScrolledEditor;
            const sourceWrapper = sourceEditor.wrapper;
            const targetWrapper = targetEditor.wrapper;
            targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
            _lastScrolledEditor = prevLastScrolledEditor;
        }
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    function highlightDiff(diffIndex) {
        highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
animation: highlightAnimation 0.3s linear 3; 
}`;
    }
    document.addEventListener("mouseover", (e) => {
        if (e.target.dataset.diff !== undefined) {
            const diff = Number(e.target.dataset.diff);
            highlightDiff(diff);
        }
    });
    document.addEventListener("mouseout", (e) => {
        if (e.target.dataset.diff !== undefined) {
            highlightStyle.textContent = "";
        }
    });
    // syncScrollToggle.addEventListener("click", () => {
    // 	toggleSyncScroll();
    // });
    // alignedModeToggle.addEventListener("click", () => {
    // 	if (_alignedMode) {
    // 		disableAlignedMode();
    // 	} else {
    // 		enableAlignedMode();
    // 	}
    // });
    function toggleSyncScroll() {
        _syncEditor = !_syncEditor;
        updateButtons();
    }
    function updateButtons() {
        if (_syncEditor && !_alignedMode) {
            scrollSyncIndicator.style.display = "block";
        }
        else {
            scrollSyncIndicator.style.display = "none";
        }
        statusBar.update();
    }
    function updateDiffList() {
        if (!_diffResult) {
            return;
        }
        const diffs = _diffResult.diffs;
        const leftWholeText = leftEditor.text;
        const rightWholeText = rightEditor.text;
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < diffs.length; i++) {
            const diff = diffs[i];
            const li = document.createElement("LI");
            const button = document.createElement("MARK");
            button.draggable = true;
            button.dataset.diff = i.toString();
            button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
            li.appendChild(button);
            const leftText = leftWholeText.substring(diff.left.pos, diff.left.pos + diff.left.len);
            const leftSpan = document.createElement("SPAN");
            leftSpan.textContent = leftText;
            leftSpan.classList.add("left");
            button.appendChild(leftSpan);
            const rightText = rightWholeText.substring(diff.right.pos, diff.right.pos + diff.right.len);
            const rightSpan = document.createElement("SPAN");
            rightSpan.textContent = rightText;
            rightSpan.classList.add("right");
            button.appendChild(rightSpan);
            fragment.appendChild(li);
        }
        diffList.innerHTML = "";
        diffList.appendChild(fragment);
    }
    document.addEventListener("keydown", (e) => {
        // 어느 단축키를 써야 잘썼다고 소문나냐?
        if (e.key === "F2") {
            e.preventDefault();
            if (e.shiftKey) {
                toggleSyncScroll();
                return;
            }
            if (_alignedMode) {
                disableAlignedMode();
            }
            else {
                enableAlignedMode();
            }
            return;
        }
        // 기본적으로 브라우저의 첫번째 탭, 두번째 탭을 선택하는 단축키인데...
        // 브라우저에서 기본적으로 사용되는 단축키를 덮어쓰는 건 정말 못된 짓이긴 한데...
        // 사용자의 의도를 무시해버릴 수 있는 아주 나쁜 단축키지만... 인터넷도 안되는 컴에서 누가 엣지에 탭을 여러개 열어놓고 쓸까 싶다.
        if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
            e.preventDefault();
            if (_alignedMode) {
                disableAlignedMode();
            }
            const editor = e.key === "1" ? leftEditor : rightEditor;
            editor.editor.focus();
            return;
        }
        // mirror로 이벤트핸들러 옮김. 테스트 해봐야함함
        // if ((_alignedMode && !e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
        // 	disableAlignedMode();
        // 	return;
        // }
        // diff cycling
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            e.preventDefault();
            const diffs = _diffResult?.diffs;
            if (!diffs || diffs.length === 0) {
                return;
            }
            _currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
            if (_currentDiffIndex < 0) {
                _currentDiffIndex = diffs.length - 1;
            }
            if (_currentDiffIndex >= diffs.length) {
                _currentDiffIndex = 0;
            }
            scrollToDiff(_currentDiffIndex);
            highlightDiff(_currentDiffIndex);
            return;
        }
    });
    diffList.addEventListener("click", (e) => {
        const diffIndex = Number(e.target.dataset.diff);
        if (!isNaN(diffIndex)) {
            _currentDiffIndex = diffIndex;
            scrollToDiff(diffIndex);
        }
    });
    function scrollToDiff(diffIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToDiff(diffIndex);
        rightEditor.scrollToDiff(diffIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    for (const editor of [leftEditor, rightEditor]) {
        editor.wrapper.addEventListener("scroll", (e) => {
            if (_currentlyScrollingEditor !== null || _preventScrollSync) {
                return;
            }
            _lastScrolledEditor = _currentlyScrollingEditor = editor;
            if (_alignedMode) {
                // aligned mode일 때는 양쪽 에디터의 높이가 같게 유지되니 둘 다 overflow:visible로 해두고
                // 부모에서 스크롤하면 둘 다 스크롤이 되지만(딜레이 전혀 없이 완전 자연스럽게!) 그렇게 만들면 스크롤바가 하나만 보이는게 생각보다 어색하고 불편하다.
                // 그래서 그냥 강제로 스크롤 동기화 시킴.
                if (editor === leftEditor) {
                    rightEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
                }
                else {
                    leftEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
                }
            }
            else if (_syncEditor) {
                syncScrollPosition(editor);
            }
            if (_resetCurrentlyScrollingEditorId) {
                cancelAnimationFrame(_resetCurrentlyScrollingEditorId);
            }
            _resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
                _currentlyScrollingEditor = null;
            });
        });
        function onFocus() {
            _activeEditor = _lastFocusedEditor = editor;
        }
        function onBlur() {
            _activeEditor = null;
        }
        editor.editor.addEventListener("focus", onFocus);
        editor.mirror.addEventListener("focus", onFocus);
        editor.editor.addEventListener("blur", onBlur);
        editor.mirror.addEventListener("blur", onBlur);
        editor.editor.addEventListener("keydown", (e) => {
            if (e.key === " " && e.ctrlKey) {
                // 에디터에서 편집 중 반대쪽 에디터의 스크롤 위치를 현재 에디터의 내용에 맞추...려고 시도만 해 봄.
                syncScrollPosition(editor);
                return;
            }
            if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
                // 이정도 스크롤은 기본적으로 되어되는거 아니야?? 이 기능 나만 쓰나?
                // 스크롤 영역 밖의 딱 한두줄! 딱 그정도만 보면 된다 싶을 때?
                // 텍스트커서가 중앙 부분에 위치하지 않으면 마음이 놓이지 않아서 지금 당장 위아래로 조금 스크롤 해야만 할 때!!!!
                const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2;
                editor.wrapper.scrollTop += delta;
                e.preventDefault();
            }
        });
        editor.mirror.addEventListener("paste", (e) => {
            disableAlignedMode();
        });
        editor.mirror.addEventListener("cut", (e) => {
            disableAlignedMode();
        });
        editor.mirror.addEventListener("keydown", (e) => {
            // aligned 모드에서 간단한 편집을 시도할 때 잽싸게 aligned 모드에서 나가기!
            // aligned 모드에서 나갈때 mirror에서 선택되어있던 텍스트 영역이 contenteditable 내에서 복원이 되므로
            // 그 이후는 복원된 텍스트 영역을 브라우저가 key에 맞게 처리해줌. 조금 얍삽?
            if ((!e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
                disableAlignedMode();
                return;
            }
            // mirror에서 전체 텍스트 선택 시에 창 전체의 텍스트가 아닌 현재 에디터의 텍스트만 선택되도록.
            if (e.ctrlKey && (e.key === "A" || e.key === "a")) {
                e.preventDefault();
                editor.selectTextRange(0, editor.text.length);
                return;
            }
        });
        // editor.editor.addEventListener("click", (e) => {
        // 	if (e.ctrlKey) {
        // 		enableAlignedMode(true);
        // 	}
        // });
        editor.mirror.addEventListener("click", (e) => {
            if (e.ctrlKey) {
                _activeEditor = editor;
                disableAlignedMode();
            }
        });
        if (useEditableMirror) {
            // editor.mirror.addEventListener("paste", (e) => {
            // 	disableAlignedMode();
            // });
            // editor.mirror.addEventListener("paste", (e) => {
            // 	disableAlignedMode();
            // });
            // editor.mirror.addEventListener("cut", (e) => {
            // 	disableAlignedMode();
            // });
            editor.mirror.addEventListener("drop", (e) => {
                e.preventDefault();
            });
        }
    }
    disableAlignedMode();
    leftEditor.updateText();
    rightEditor.updateText();
    statusBar.update();
    return {
        get alignedMode() {
            return _alignedMode;
        },
        set alignedMode(value) {
            if (!!value) {
                enableAlignedMode();
            }
            else {
                disableAlignedMode();
            }
        },
        get dump() {
            // 디버깅 할 때...
            return {
                diffResult: _diffResult,
                diffs: _diffResult?.diffs,
                anchors: _diffResult?.anchors,
                diffOptions: _diffOptions,
                leftEditor,
                rightEditor,
                activeEditor: _activeEditor,
            };
        },
        compute: computeDiff,
        diffOptions: _diffOptions,
    };
})();
//# sourceMappingURL=main.js.map
</script>
</body>

</html>
