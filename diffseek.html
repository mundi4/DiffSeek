<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiffSeek</title>
<style>:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--editor-padding: 8px;
	--line-height: 20px;
	--scroll-margin: 1rem;
	font-size: 16px;
	--topbar-height: 32px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

#topbar {
	grid-column: span 2;
	display: flex;
	align-items: center;
	padding: 5px 10px;
	background: #444;
	color: white;
	align-items: center;
	justify-content: space-between; /* 왼쪽: .title / 오른쪽: .buttons */
}

.buttons {
	display: flex;
	gap: 10px;
	margin-left: auto;
}

button.toggle {
	background: none;
	border: 2px solid transparent;
	cursor: pointer;
	padding: 2px 4px;
	transition: all 0.2s ease-in-out;
	opacity: 0.3;
	font-size: 14px;
	outline: none;
}

button.toggle[aria-pressed="true"] {
	opacity: 1;
	transform: scale(1.2);
}

.container {
	display: grid;
	grid-template-rows: var(--topbar-height) 1fr; /* 상단 바 (40px) + 나머지 공간 */
	grid-template-columns: 1fr 300px;
	height: 100vh;
	overflow: hidden;
	gap: 0 8px;
	position: relative;
}

#progress {
	display: none;
	position: fixed;
	bottom: 20px;
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

/* .line-break {
	display: block;
}
.line-break::before {
	content: " ";
	display: block;
	height: 1rem;
} */

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
}

.mirror,
.editor {
	z-index: -1;
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: monospace;
	font-size: 1rem;
	margin: 0;
	overflow-y: visible;
	/* height: 100%; */
	white-space: pre-wrap;
	word-break: break-all;
	overflow-wrap: anywhere;
	z-index: 0;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	border: 1px solid #ccc;
	border-radius: 4px;
}

.mirror {
	z-index: -1;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: rgba(0, 0, 0, 0.1);
	border: 1px solid transparent;
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.aligned .editor {
	display: none;
}
.aligned .mirror {
	pointer-events: auto;
	position: static;
	color: inherit;
	background-color: transparent;
	/* cursor: default; */
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
}

.aligned [data-pad-top]::before {
	content: "";
	display: block;
	height: var(--pad-top);
	background: #efefef
		repeating-linear-gradient(
			135deg,
			rgba(200, 200, 200, 0.15) 0px,
			rgba(200, 200, 200, 0.15) 3px,
			rgba(255, 255, 255, 0.05) 3px,
			rgba(255, 255, 255, 0.05) 6px
		);
}

.aligned [data-pad-diff]::after {
	content: "";
	display: block;
	height: var(--pad-diff);
	background-color: #f7d4d4;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);

	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), -1px 1px hsl(var(--diff-hue) 100% 40%); */
	/* outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	outline-offset: 0px 3px; */
	color: inherit;
}
mark:not(:empty) {
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-block으로 안해두면 높이 1px이 모자르게 된다. 묻지마... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	right: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
공간을 전혀 차지하지 않으면서도 visual이 있어야함
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

/*
줄맞춤 용 marker element
*/

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror {
	color: #fff;
	background-color: #000;
}

.aligned .mirror > div:has(mark),
.aligned hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 25%);
}

.edit .mirror > div:has(mark),
.edit hr[data-type="diffEnd"] {
	background-color: hsl(0 100% 90%);
}

/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

.aligned #main {
	overflow-y: scroll;
}

.aligned .editor-wrapper {
	overflow: visible;
	padding-right: 7px;
}

.aligned .editor-wrapper:last-child {
	margin-left: 8px;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: "Consolas", "Courier New", monospace;
	content: "L";
	margin-right: 4px;
	/* content: "◀️"; */
}

#diffList .right::before {
	content: "R" !important;
	/* content: "▶️" !important; */
}

.edit hr {
	height: 0 !important;
}

/* 의미없다
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}
</style>
<script id='constants.js'>// 인접한 색과 60이상 차이나게
const DIFF_COLOR_HUES = [30, 180, 300, 120, 240, 60, 270]; //[60, 240, 120, 300, 180];//[60, 120, 180, 240, 300];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;

const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 20;
const COMPUTE_DEBOUNCE_TIME = 200;

const PROCESSING_MESSAGES = [
	"한땀한땀 비교 중...",
	"인내심 테스트 중...",
	"생각 중...",
	"COME ON, TARS!",
	"재부팅 준비 중...",
	"무한 루프 중...",
	"머리 긁는 중...",
	"흰머리 뽑는 중...",
    "DIFFSEEKING...",
    "시스템 침투 중...",
    "ANALYZING...",
    "3... 2... 1...",
    "SYSTEM MALFUNCTION...",
];

</script>
<script id='editor.js'>"use strict";

function createEditor(container, name, callbacks) {
	const { onTextChanged, onMirrorUpdated } = callbacks;
	const _lineElements = [];
	const _diffElements = [];
	const _anchorElements = [];
	const _visibleAnchors = new Set();
	let _text = "";
	let _savedCaret = null;
	let _observingAnchors = false;

	const wrapper = document.createElement("div");
	wrapper.id = name + "EditorWrapper";
	wrapper.classList.add("editor-wrapper");

	const mirror = document.createElement("div");
	mirror.id = name + "Mirror";
	mirror.classList.add("mirror");

	const editor = document.createElement("div");
	editor.id = name + "Editor";
	editor.classList.add("editor");
	editor.contentEditable = "plaintext-only";
	editor.spellcheck = false;

	editor.appendChild(document.createTextNode(""));

	wrapper.appendChild(mirror);
	wrapper.appendChild(editor);
	container.appendChild(wrapper);

	function updateText() {
		_text = editor.textContent;
		let p = _text.length - 1;
		let endsWithNewline = false;
		while (p >= 0) {
			if (!/\s/.test(_text[p])) {
				break;
			}
			if (_text[p] === "\n") {
				endsWithNewline = true;
				break;
			}
			p--;
		}
		if (!endsWithNewline) {
			_text += "\n";
		}
		onTextChanged(_text);
	}

	editor.addEventListener("input", updateText);
	editor.addEventListener("focus", callbacks.onFocus);
	editor.addEventListener("blur", callbacks.onBlur);
	wrapper.addEventListener("scroll", callbacks.onScroll);
	wrapper.addEventListener("mouseenter", callbacks.onEnter);
	wrapper.addEventListener("mouseleave", callbacks.onLeave);

	const anchorIntersectionObserver = new IntersectionObserver(
		(entries) => {
			for (const entry of entries) {
				if (entry.isIntersecting) {
					_visibleAnchors.add(entry.target);
				} else {
					_visibleAnchors.delete(entry.target);
				}
			}
		},

		{ threshold: 1, root: document.getElementById("main") }
	);

	function saveCaret() {
		const sel = window.getSelection();
		if (sel.rangeCount > 0) {
			const range = sel.getRangeAt(0);
			if (editor.contains(range.commonAncestorContainer)) {
				_savedCaret = range.cloneRange();
			}
		}
	}

	function restoreCaret() {
		if (_savedCaret && editor.contains(_savedCaret.commonAncestorContainer)) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(_savedCaret);
		}
		_savedCaret = null;
	}

	function getVisibleAnchors() {
		return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
	}

	let mouseX;
	let mouseY;
	document.addEventListener("mousemove", (event) => {
		mouseX = event.clientX;
		mouseY = event.clientY;
	});

	const EDITOR_PADDING = 9; // FIXME constant에서 설정하고 그 값으로 css를 만들기
	function getNearestAnchorToCaret() {
		const selection = window.getSelection();
		if (!selection || selection.rangeCount === 0) {
			return null;
		}
		let range = selection.getRangeAt(0);
		if (!editor.contains(range.startContainer)) {
			return null;
		}
		let rect = range.getBoundingClientRect();
		let y;
		if (rect.left === 0 && rect.top === 0) {
			y = EDITOR_PADDING + wrapper.scrollTop;
		} else {
			y = rect.top + wrapper.scrollTop;
		}

		let nearestAnchor = null;
		let minDistance = Number.MAX_SAFE_INTEGER;
		for (const anchor of _visibleAnchors) {
			const distance = Math.abs(Number(anchor.dataset.pos) - y);
			if (distance < minDistance) {
				minDistance = distance;
				nearestAnchor = anchor;
				if (distance < LINE_HEIGHT / 2) {
					break;
				}
			}
		}
		return nearestAnchor;
	}

	function getFirstVisibleLineElementInEditor() {
		const lineEls = _lineElements;
		// 이진 검색으로 현재 화면에 보이는 줄 엘러먼트 중 첫번째 찾기
		// 모든 픽셀이 화면에 다 보이는 경우만! 윗부분 1px만 짤려도 가차 없다.
		let low = 0;
		let high = lineEls.length - 1;
		let mid;
		let lineEl = null;
		let lineTop = null;
		while (low <= high) {
			mid = (low + high) >>> 1;
			const top = lineEls[mid].getBoundingClientRect().top;
			if (top >= 0) {
				lineEl = lineEls[mid];
				if (top < 10) {
					// 이정도면 안전하게 "찾았다"라고 말할 수 있지 않을까?
					// 변태같이 화면 스케일을 1/2로 줄이지 않는 이상...
					break;
				}
				lineTop = top;
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return [lineEl, lineTop];
	}

	// 현재 화면에 보이는 editor의 문자 인덱스를 찾음.
	function getFirstVisiblePosInEditor() {
		const rect = editor.getBoundingClientRect();
		let x = rect.left + 10;
		let y = rect.top + 10;
		let parentEl = editor.parentElement;
		while (parentEl) {
			x += parentEl.scrollLeft;
			y += parentEl.scrollTop;
			parentEl = parentEl.parentElement;
		}

		const caretPos = document.caretPositionFromPoint(x, y);
		if (caretPos !== null) {
			const offsetNode = caretPos.offsetNode;
			let offset = caretPos.offset;
			if (offsetNode.nodeType === 3 && editor.contains(offsetNode)) {
				// 찾았다. 그대로 리턴... 하면 인생 참 편하지?
				// editor 안에 여러개의 text node가 있을 수 있기 때문에 offsetNode보다 앞에 위치한 text node들의 text length를 모두 더해야함.
				// previous sibling으로 찾으면 훨씬 간단하고 빠를테지만 나중에 editor를 구조를 바꿀지도 모르니 일단 안정빵으로
				const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
				let node;
				while ((node = walker.nextNode())) {
					if (node === offsetNode) {
						return offset;
					}
					offset += node.nodeValue.length;
				}
			}
		}

		return null;
	}

	function scrollToDiff(diffIndex) {
		_diffElements[diffIndex][0].scrollIntoView({});
	}

	function scrollToLine(lineNum, offset = 0) {
		const lineEl = _lineElements[lineNum - 1];
		if (lineEl) {
			// 아! 1px이 왜 어긋나는지 몰겠는데... 나 바쁜 사람이야
			wrapper.scrollTop = lineEl.offsetTop;
		}
	}

	function scrollToTextPosition(pos) {
		if (window.getComputedStyle(editor).display === "none") {
			for (let i = 0; i < _lineElements.length; i++) {
				const linePos = Number(_lineElements[i].dataset.pos);
				if (linePos > pos) {
					if (i > 0) {
						_lineElements[i - 1].scrollIntoView();
					} else {
						mirror.scrollHeight = 0;
					}
					break;
				}
			}
		} else {
			const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
			let node;
			while ((node = walker.nextNode())) {
				const nodeLen = node.nodeValue.length;
				if (pos < nodeLen) {
					// TODO
					// const range = document.createRange();
					// const sel = window.getSelection();
					// range.setStart(node, pos);
					// range.setEnd(node, pos);
					// sel.removeAllRanges();
					// sel.addRange(range);
					break;
				}
				pos -= nodeLen;
			}
		}
	}

	function update({ diffs, anchors }) {
		if (!diffs) {
			return;
		}
		console.debug("update");

		_lineElements.length = 0;
		_diffElements.length = 0;
		_anchorElements.length = 0;
		untrackVisibleAnchors();

		const textrunz = getTextRuns(name, _text, diffs, anchors);
		console.log(name, "textrunz", textrunz);

		// editor.style.removeProperty("min-height");
		// mirror.style.removeProperty("min-height");
		// wrapper.style.removeProperty("min-height");

		const text = _text;
		const view = mirror;
		const textruns = textrunGenerator(name, text, diffs, anchors);
		let lineEl = null;
		let inlineNode = null;
		let currentDiffIndex = null;
		let lineNum = 0;
		let unwrittenDiff = false;
		let lineHasNonSpaceChar = false;
		let lineHasNonSpaceNonDiffChar = false;
		let diffAnchorIndex = null;
		let _pos = 0;

		function appendAnchor(pos, anchorIndex, diffIndex = null) {
			const anchor = anchors[anchorIndex];
			if (inlineNode === null || inlineNode.nodeName !== ANCHOR_TAG) {
				const el = document.createElement(ANCHOR_TAG);
				lineEl.insertBefore(el, inlineNode);
				inlineNode = el;
			}
			inlineNode.id = `${name}Anchor${anchorIndex}`;
			inlineNode.dataset.anchor = anchorIndex;
			inlineNode.dataset.type = anchor.type;
			inlineNode.dataset.pos = pos;
			if (diffIndex !== null) {
				inlineNode.dataset.diff = diffIndex;
			} else {
				delete inlineNode.dataset.diff;
			}
			_anchorElements.push(inlineNode);
			inlineNode = inlineNode.nextSibling;
		}

		function appendChars(chars) {
			if (currentDiffIndex !== null) {
				const diff = diffs[currentDiffIndex];
				if (inlineNode === null || inlineNode.nodeName !== DIFF_ELEMENT_NAME) {
					const el = document.createElement(DIFF_ELEMENT_NAME);
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
				inlineNode.dataset.diff = currentDiffIndex;
				inlineNode.className = "diff-color" + ((currentDiffIndex % NUM_DIFF_COLORS) + 1);
				//inlineNode.classList.toggle("block", diff.align && diff[name].empty);
				_diffElements[currentDiffIndex] = _diffElements[currentDiffIndex] || [];
				_diffElements[currentDiffIndex].push(inlineNode);
				unwrittenDiff = false;
			} else {
				if (inlineNode === null || inlineNode.nodeName !== "SPAN") {
					//console.log("new text node");
					const el = document.createElement("SPAN");
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
			}
			inlineNode = inlineNode.nextSibling;
		}


		lineEl = view.firstElementChild;
		if (lineEl === null) {
			lineEl = document.createElement(LINE_TAG);
			view.appendChild(lineEl);
			lineEl.dataset.lineNum = lineNum;
			lineEl.dataset.pos = _pos;
			lineNum++;
			_lineElements.push(lineEl);
		}
		inlineNode = lineEl.firstChild;

		for (const textrun of textrunz) {
			if (textrun.type === "CHARS") {
				const { pos, len } = textrun;
				appendChars(text.substring(pos, pos + len));
			} else if (textrun.type === "ANCHOR") {
				const { pos, anchorIndex } = textrun;
				appendAnchor(pos, anchorIndex, currentDiffIndex);
				unwrittenDiff = false;
			} else if (textrun.type === "DIFF") {
				currentDiffIndex = textrun.diffIndex;
				unwrittenDiff = true;
			} else if (textrun.type === "DIFF_END") {
				if (unwrittenDiff) {
					appendChars("");
				}
				currentDiffIndex = null;
			} else if (textrun.type === "LINEBREAK" || textrun.type === "END_OF_STRING") {
				if (unwrittenDiff) {
					appendChars("");
				}

				while (inlineNode) {
					const nextInlineNode = inlineNode.nextSibling;
					inlineNode.remove();
					inlineNode = nextInlineNode;
				}
				if (textrun.type === "LINEBREAK") {
					lineNum++;
					lineEl = lineEl.nextElementSibling;
					if (lineEl === null) {
						lineEl = document.createElement(LINE_TAG);
						view.appendChild(lineEl);
					}
					lineEl.dataset.lineNum = lineNum;
					_lineElements.push(lineEl);
					inlineNode = lineEl.firstChild;

					_pos = textrun.pos + 1;
					if (currentDiffIndex !== null) {
						unwrittenDiff = true;
					}

				} else {
					_lineElements.length = lineNum;
					while (lineEl) {
						const nextLineEl = lineEl.nextElementSibling;
						lineEl.remove();
						lineEl = nextLineEl;
					}
					break;
				}
			}
		}
		// let textRunResult;
		// do {
		// 	lineHasNonSpaceChar = false;
		// 	lineHasNonSpaceNonDiffChar = false;
		// 	if (currentDiffIndex !== null) {
		// 		unwrittenDiff = true;
		// 	}
		// 	if (lineEl === null) {
		// 		lineEl = document.createElement(LINE_TAG);
		// 		view.appendChild(lineEl);
		// 		lineEl.dataset.lineNum = lineNum;
		// 		lineEl.dataset.pos = _pos;
		// 	}
		// 	_lineElements[lineNum - 1] = lineEl;
		// 	inlineNode = lineEl.firstChild;

		// 	while (!(textRunResult = textruns.next()).done) {
		// 		const { type, pos, len, diffIndex, anchorIndex, hasNonSpaceChar } = textRunResult.value;
		// 		// if (name === "right") {
		// 		// 	console.log(lineNum, { type, pos, len, diffIndex, anchorIndex, hasNonSpaceChar });
		// 		// }
		// 		_pos = pos;
		// 		if (type === DIFF) {
		// 			currentDiffIndex = diffIndex;
		// 			unwrittenDiff = true;
		// 		} else if (type === DIFF_END) {
		// 			if (unwrittenDiff) {
		// 				appendChars("", hasNonSpaceChar);
		// 			}
		// 			currentDiffIndex = null;
		// 		} else if (type === CHARS) {
		// 			lineHasNonSpaceChar = lineHasNonSpaceChar || hasNonSpaceChar;
		// 			if (currentDiffIndex === null) {
		// 				lineHasNonSpaceNonDiffChar = lineHasNonSpaceNonDiffChar || hasNonSpaceChar;
		// 			}
		// 			appendChars(text.substring(pos, pos + len), hasNonSpaceChar);
		// 		} else if (type === LINEBREAK || type === END_OF_STRING) {
		// 			//console.log("linebreak", { type, pos, len });
		// 			break;
		// 		} else if (type === ANCHOR) {
		// 			appendAnchor(pos, anchorIndex, diffIndex);
		// 		}
		// 	}

		// 	if (unwrittenDiff) {
		// 		appendChars("", false);
		// 	}

		// 	while (inlineNode) {
		// 		const nextInlineNode = inlineNode.nextSibling;
		// 		inlineNode.remove();
		// 		inlineNode = nextInlineNode;
		// 	}

		// 	lineEl = lineEl.nextElementSibling;
		// 	if (textRunResult.value.type === END_OF_STRING) {
		// 		break;
		// 	}
		// 	lineNum++;
		// } while (!textRunResult.done);

		// _lineElements.length = lineNum;

		// while (lineEl) {
		// 	const nextLineEl = lineEl.nextElementSibling;
		// 	lineEl.remove();
		// 	lineEl = nextLineEl;
		// }

		requestAnimationFrame(() => {
			// const height = view.scrollHeight;
			// editor.style.minHeight = height + "px";
			// mirror.style.minHeight = height + "px";
			// wrapper.style.minHeight = height + "px";
		});
		console.debug("update done");
		trackVisibleAnchors();
		onMirrorUpdated();
	}

	function trackVisibleAnchors() {
		if (!_observingAnchors) {
			for (const anchor of _anchorElements) {
				//if (!anchor.id.endsWith("-after")) {
				anchorIntersectionObserver.observe(anchor);
				//}
			}
			_observingAnchors = true;
		}
	}

	function untrackVisibleAnchors() {
		_observingAnchors = false;
		_visibleAnchors.clear();
		anchorIntersectionObserver.disconnect();
	}

	function getFirstVisibleAnchor() {
		let firstAnchor = null;
		let firstPos = null;
		for (const anchor of _visibleAnchors) {
			if (firstAnchor === null) {
				firstAnchor = anchor;
				firstPos = Number(anchor.dataset.pos);
			} else {
				const pos = Number(anchor.dataset.pos);
				if (pos < firstPos) {
					firstAnchor = anchor;
					firstPos = pos;
				}
			}
		}
		return firstAnchor;
	}

	function setEditMode(editMode) {
		// editmode인 경우 mirror와 editor를 둘 다 보여주고 높이도 동기화 해야한다.
		// 둘의 높이는 무조건 같다. 왜냐면 editor에 따라 wrapper 크기가 결정되고 wrapper에 따라 mirror크기 결정되니까.
		// 자바스크립트 쓸 필요가 없어야 한다.
	}

	updateText();

	return {
		name: name,
		wrapper,
		editor,
		mirror,
		update,
		getFirstVisiblePosInEditor,
		scrollToDiff,
		scrollToTextPosition,
		saveCaret,
		restoreCaret,
		getVisibleAnchors,
		trackVisibleAnchors,
		untrackVisibleAnchors,
		getFirstVisibleAnchor,
		scrollToLine,
		getFirstVisibleLineElementInEditor,
		getNearestAnchorToCaret,
		get text() {
			return _text;
		},
		get lineElements() {
			return _lineElements;
		},
		get diffElements() {
			return _diffElements;
		},
		get visibleAnchors() {
			return _visibleAnchors;
		},
		get anchorElements() {
			return _anchorElements;
		},
	};
}
</script>
<script id='textrun.js'>"use strict";

const ANCHOR = "ANCHOR";
const CHARS = "CHARS";
const DIFF = "DIFF";
const DIFF_END = "DIFF_END";
const LINEBREAK = "LINEBREAK";
const END_OF_STRING = "END_OF_STRING";

// 최적화의 여지가 많음
// textrun 배열을 만들면 나중에 변경된 부분만 업데이트 하거나 특정 줄만 업데이트 하기 수월함.
// mirror를 안쓰고 editor 자체를 dom으로 만들 경우 현재 커서가 있는 줄을 수정하는 게 상당히 거슬리는데(특히 한글 입력 중이면)
// 특정 줄만 업데이트를 미뤄둘 수 있으면 그런 상황에서 특정 줄만 업데이트 미뤄두고 상황 봐서 나중에 그 줄만 업데이트 할 수 있음.
function* textrunGenerator(textKey, text, diffs, anchors) {
	const _textLen = text.length;
	let _pos = 0;
	let _textPos = 0;
	let _diffIndex = -1;
	let _anchorIndex = -1;
	let _anchorPos;
	let _diffPos;
	let _inDiff = false;
	let _diffEnd;
	let _hasNonSpaceChar = false;
	let _lineNum = 1;

	const current = {
		pos: 0,
		len: 0,
		diffIndex: null,
		anchorIndex: null,
		hasNonSpaceChar: false,
	};

	// anchor위치는 diff의 시작위치
	// diff 범위 밖일때는 어디에서든 올 수 있다

	function nextAnchor() {
		_anchorIndex++;
		if (_anchorIndex < anchors.length) {
			const data = anchors[_anchorIndex];
			_anchorPos = data[textKey];
			if (_anchorPos < _pos) {
				console.warn("Anchor skipped", { anchor: data, anchorIndex: _anchorIndex, pos: _pos, anchorPos: _anchorPos });
				nextAnchor();
			}
		} else {
			_anchorIndex = anchors.length;
			_anchorPos = Number.MAX_SAFE_INTEGER;
		}
	}

	function nextDiff() {
		_diffIndex++;
		if (_diffIndex < diffs.length) {
			const data = diffs[_diffIndex][textKey];
			_diffPos = data.pos;
			_diffEnd = data.pos + data.len;
		} else {
			_diffIndex = diffs.length;
			_diffPos = Number.MAX_SAFE_INTEGER;
			_diffEnd = Number.MAX_SAFE_INTEGER;
		}
	}

	// 일단 줄번호++
	// 해당 줄번호에 해당하는 ling mapping를 찾아서 그 index를 _lineMapIndex로 저장.
	// 못찾으면 그 이후 maping index에 ~를 씌운 값
	//
	nextDiff();
	nextAnchor();

	function chars() {
		current.type = CHARS;
		current.pos = _textPos;
		current.len = _pos - _textPos;
		current.diffIndex = _inDiff ? _diffIndex : null;
		current.hasNonSpaceChar = _hasNonSpaceChar;
		_hasNonSpaceChar = false;
		_textPos = _pos;
		return current;
	}

	// 주의:
	// 같은 pos를 가진 anchor가 두개가 있을 수 있다. 길이가 0인 diff에 대한 anchor와 그 위치에 시작되는 common anchor
	// 반대의 순서는 없음.

	while (true) {
		if (_pos === _anchorPos) {
			let anchor = anchors[_anchorIndex];
			if (anchor.type === "before") {
				current.type = ANCHOR;
				current.pos = _pos;
				current.len = 0;
				current.diffIndex = _diffIndex;
				current.anchorIndex = _anchorIndex;
				yield current;
				nextAnchor();
			}
			while (_pos < _textLen && _pos !== _diffPos && _pos !== _diffEnd && _pos !== _anchorPos && text[_pos] !== "\n") {
				_hasNonSpaceChar = _hasNonSpaceChar || (text[_pos] !== " " && text[_pos] !== "\t");
				_pos++;
			}
			if (_textPos < _pos) {
				yield chars();
			}
		}

		if (_pos === _diffPos) {
			// 현재 위치 이전까지의 문자열들.
			if (_textPos < _pos) {
				yield chars();
			}
			_inDiff = true;
			_diffPos = Number.MAX_SAFE_INTEGER;
			current.type = DIFF;
			current.pos = _pos;
			current.len = 0;
			current.diffIndex = _diffIndex;
			yield current;
		}

		while (_pos < _textLen && _pos !== _diffPos && _pos !== _diffEnd && _pos !== _anchorPos && text[_pos] !== "\n") {
			_hasNonSpaceChar = _hasNonSpaceChar || (text[_pos] !== " " && text[_pos] !== "\t");
			_pos++;
		}
		if (_textPos < _pos) {
			yield chars();
		}

		if (_pos === _diffEnd) {
			current.type = DIFF_END;
			current.pos = _pos;
			current.len = 0;
			current.diffIndex = _diffIndex;
			yield current;
			_inDiff = false;
			nextDiff();
			while (_pos < _textLen && _pos !== _diffPos && _pos !== _diffEnd && _pos !== _anchorPos && text[_pos] !== "\n") {
				_hasNonSpaceChar = _hasNonSpaceChar || (text[_pos] !== " " && text[_pos] !== "\t");
				_pos++;
			}
			if (_textPos < _pos) {
				yield chars();
			}
		}

		if (_pos === _anchorPos) {
			const anchor = anchors[_anchorIndex];
			if (anchor.type === "after") {
				current.type = ANCHOR;
				current.pos = _pos;
				current.len = 0;
				current.diffIndex = _diffIndex;
				current.anchorIndex = _anchorIndex;
				yield current;
				nextAnchor();
			}
			// type이 after가 아니더라도 이미 이 시점에서는 before 타입 앵커를 리턴할 수 없다.

			while (_pos < _textLen && _pos !== _diffPos && _pos !== _diffEnd && _pos !== _anchorPos && text[_pos] !== "\n") {
				_hasNonSpaceChar = _hasNonSpaceChar || (text[_pos] !== " " && text[_pos] !== "\t");
				_pos++;
			}
			if (_textPos < _pos) {
				yield chars();
			}
		}

		if (text[_pos] === "\n") {
			current.type = LINEBREAK;
			current.pos = _pos;
			current.len = 1;
			current.diffIndex = _inDiff ? _diffIndex : null;
			yield current;
			_lineNum++;
			_textPos = ++_pos;

			while (_anchorPos < _pos) {
				console.warn("Anchor skipped", { anchor: anchors[_anchorIndex], anchorIndex: _anchorIndex, pos: _pos, anchorPos: _anchorPos });
				nextAnchor();
			}

			continue;
		}

		if (_pos >= _textLen) {
			current.type = END_OF_STRING;
			current.pos = _textLen;
			current.len = 0;
			current.diffIndex = null;
			return current;
		}
	}

	// current.type = END_OF_STRING;
	// current.pos = _textLen;
	// current.len = 0;
	// current.diffIndex = null;
	// yield current;
	//yield [END_OF_STRING, _textLen, 0, null];
}

// generator함수보다 이 방법을 쓰면 
// 뒷부분의 textrun만 변경되었을 경우를 감지해서 그 부분만 업데이트 할 수 있다
function getTextRuns(textKey, text, diffs, anchors) {
	let pos = 0;
	let textLen = text.length;
	let nextDiffPos = null;
	let nextDiffEndPos = null;
	let nextDiff = null;
	let nextAnchorPos = null;
	let nextAnchor = null;
	let nextNewLinePos = null;
	let nextNewLineIsEndOfString = false;
	let diffIndex = -1;
	let anchorIndex = -1;
	const textruns = [];

	// let counter = 0;
	while (pos < textLen) {
		// if (counter++ > 100000) {
		// 	console.error("Infinite loop detected", {
		// 		textruns,
		// 		pos: pos,
		// 		textLen: textLen,
		// 		nextDiffPos: nextDiffPos,
		// 		nextDiffEndPos: nextDiffEndPos,
		// 		nextAnchorPos: nextAnchorPos,
		// 		nextNewLinePos: nextNewLinePos,
		// 		diffIndex: diffIndex,
		// 		anchorIndex: anchorIndex,
		// 		nextDiff: nextDiff,
		// 		nextAnchor: nextAnchor,
		// 		diffs,
		// 		anchors,
		// 	});
		// 	throw new Error("Infinite loop detected");
		// }
		let nextEventPos = textLen;

		if (nextAnchorPos === null) {
			anchorIndex++;
			if (anchorIndex < anchors.length) {
				nextAnchor = anchors[anchorIndex];
				nextAnchorPos = nextAnchor[textKey];
				if (nextAnchorPos < pos) {
					// skipped anchor. this should not happen.
					console.warn("Skipped anchor", { anchor: nextAnchor, anchorIndex: anchorIndex, pos: pos, anchorPos: nextAnchorPos });
					nextAnchorPos = nextAnchor = null;
					continue;
				}
			} else {
				nextAnchorPos = Number.MAX_SAFE_INTEGER;
			}
		}
		if (nextAnchorPos < nextEventPos) {
			nextEventPos = nextAnchorPos;
		}

		if (nextDiffEndPos === null) {
			diffIndex++;
			if (diffIndex < diffs.length) {
				nextDiff = diffs[diffIndex][textKey];
				nextDiffPos = nextDiff.pos;
				nextDiffEndPos = nextDiff.pos + nextDiff.len;
				if (nextDiffPos < pos) {
					console.warn("Skipped diff", { diff: nextDiff, diffIndex: diffIndex, pos: pos, diffPos: nextDiffPos });
					nextDiffPos = nextDiffEndPos = nextDiff = null;
				}
			} else {
				nextDiffPos = Number.MAX_SAFE_INTEGER;
				nextDiffEndPos = Number.MAX_SAFE_INTEGER;
			}
		}

		if (nextDiffPos < nextEventPos) {
			nextEventPos = nextDiffPos;
		} else if (nextDiffEndPos < nextEventPos) {
			nextEventPos = nextDiffEndPos;
		}

		if (nextNewLinePos === null) {
			nextNewLinePos = text.indexOf("\n", pos);
			if (nextNewLinePos === -1) {
				nextNewLinePos = textLen;
				nextNewLineIsEndOfString = true;
			}
		}
		if (nextNewLinePos < nextEventPos) {
			nextEventPos = nextNewLinePos;
		}

		if (pos < nextEventPos) {
			// chars
			textruns.push({
				type: "CHARS",
				pos: pos,
				len: nextEventPos - pos,
			});
			pos = nextEventPos;
		}

		if (nextEventPos === nextAnchorPos && nextAnchor.type === "before") {
			textruns.push({
				type: "ANCHOR",
				pos: nextAnchorPos,
				len: 0,
				diffIndex: diffIndex,
				anchorIndex: anchorIndex,
			});
			nextAnchorPos = nextAnchor = null;
			continue;
		}

		if (nextEventPos === nextDiffPos) {
			textruns.push({
				type: "DIFF",
				pos: nextDiffPos,
				len: 0,
				diffIndex: diffIndex,
			});
			nextDiffPos = Number.MAX_SAFE_INTEGER;
		}

		if (nextEventPos === nextDiffEndPos) {
			// diff end
			textruns.push({
				type: "DIFF_END",
				pos: nextDiffEndPos,
				len: 0,
				diffIndex: diffIndex,
			});
			nextDiffPos = nextDiffEndPos = nextDiff = null;
		}

		if (nextEventPos === nextAnchorPos && nextAnchor.type === "after") {
			textruns.push({
				type: "ANCHOR",
				pos: nextAnchorPos,
				len: 0,
				diffIndex: diffIndex,
				anchorIndex: anchorIndex,
			});
			nextAnchorPos = null;
			continue;
		}

		if (nextEventPos === nextNewLinePos) {
			if (nextNewLineIsEndOfString) {
                console.warn("!!!!!!!!!!!!!!!!!!")

				break;
			} else {
				textruns.push({
					type: "LINEBREAK",
					pos: nextNewLinePos,
					len: 1,
				});
				pos = nextEventPos + 1;
				nextNewLinePos = null;
			}
		}
	}
    
    textruns.push({
        type: "END_OF_STRING",
        pos: textLen,
        len: 0,
    });

	return textruns;
}
</script>
<script id='worker.js'>"use strict";

const DIFF_BY_CHAR = 1;
const DIFF_BY_WORD = 2;
const DIFF_BY_LINE = 3;
const DIFF_BY_PARAGRAPH = 4;

const TOKEN_CACHE_SIZE = 4;
const MIN_PARAGRAPH_GAP = 1;

const FIRST_OF_LINE = 1; // PRECEDED_BY_NEWLINE ?
const LAST_OF_LINE = 2; // FOLLOWED_BY_NEWLINE ?
const WILD_CARD = 16;

const decoder = new TextDecoder();
let _nextWork = null;
let _currentWork = null;

const tokenCache = {
	[DIFF_BY_CHAR]: [],
	[DIFF_BY_WORD]: [],
	[DIFF_BY_LINE]: [],
	[DIFF_BY_PARAGRAPH]: [],
};

// #region trie
function createTrieNode() {
	const children = {};
	function next(char) {
		return char === " " ? this : children[char] || null;
	}

	function addChild(char) {
		if (!children[char]) {
			children[char] = createTrieNode();
		}
		return children[char];
	}
	return { next, addChild, word: null, flags: null };
}

function createTrie() {
	const root = createTrieNode();

	function insert(word, flags = 0) {
		let node = root;
		for (const char of word) {
			node = node.addChild(char);
		}
		node.word = word;
		node.flags = flags;
	}

	return { insert, root };
}
// #endregion

const SPACE_CHARS = {
	" ": true, // 공백
	"\t": true, // 탭
	"\n": true, // 줄 바꿈
	"\r": true, // 캐리지 리턴
	"\f": true, // 폼 피드
	"\v": true, // 수평 탭
};

const Trie = createTrie();
Trie.insert("(추가)", WILD_CARD);
Trie.insert("(삭제)", WILD_CARD);
Trie.insert("(신설)", WILD_CARD);
Trie.insert("(생략)", WILD_CARD);
Trie.insert("(현행과같음)", WILD_CARD);

const TrieRoot = Trie.root;
const WildcardNode = Trie.root.next("(");

self.onmessage = (e) => {
	if (e.data.type === "diff") {
		const work = {
			reqId: e.data.reqId,
			left: e.data.left,
			right: e.data.right,
			method: e.data.method,
			cancel: false,
		};
		if (_currentWork) {
			_currentWork.cancel = true;
			_nextWork = work;
			return;
		}
		runDiff(work);
	}
};

async function runDiff(work) {
	_currentWork = work;
	const leftText = decoder.decode(work.left);
	const rightText = decoder.decode(work.right);
	try {
		work.lastYield = work.start = performance.now();
		const results = await computeDiff({ leftText, rightText, method: work.method || DIFF_BY_WORD, ctx: work });
		work.finish = performance.now();
		//console.log("Elapsed time:", work.finish - work.start);
		_currentWork = null;
		if (results) {
			self.postMessage({
				reqId: work.reqId,
				type: "diffs",
				diffs: results.diffs,
				anchors: results.anchors,
			});
		} else {
			console.debug("Diff canceled");
		}
	} catch (e) {
		if (e.message === "cancelled") {
			console.debug("Diff canceled");
		} else {
			console.error(e);
		}
	}
	[work, _nextWork] = [_nextWork, null];
	if (work) {
		return await runDiff(work);
	}
}

function normalizeText(input) {
	return input.replace(/\s{2,}/g, " ").trim();
}

function checkIfFirstOfLine(input, pos) {
	pos--;
	while (pos >= 0) {
		if (input[pos] === "\n") {
			break;
		} else if (!SPACE_CHARS[input[pos]]) {
			return false;
		}
		pos--;
	}
	return true;
}

function tokenizeByChar(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let lineCount = 0;
	let flags = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (!SPACE_CHARS[char]) {
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}
			flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
			tokens.push({
				text: char,
				pos: i,
				len: 1,
				lineNum: baseLineNum + lineCount,
				flags,
			});
			flags = 0;
		}
		if (char === "\n") {
			lineCount++;
			flags = FIRST_OF_LINE;
			if (tokens.length > 0) {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
			}
		}
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByChar", tokens);
	return tokens;
}

function tokenizeByWord(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let currentStart = -1;
	let lineCount = 0;
	let flags = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		//if (/[\w\u3131-\uD79D]+/.test(char)) {
		// 문장부호를 별개로 단어로 분리하는 방법도 생각해볼 필요가 있음.
		// but!! "(현행과 같음)"의 여는 괄호가 별개로 매치되는 건 원하지 않음.

		if (SPACE_CHARS[char]) {
			if (currentStart !== -1) {
				flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
				tokens.push({
					text: input.substring(currentStart, i),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags,
				});
				flags = 0;
				currentStart = -1;
			}
			if (char === "\n") {
				lineCount++;
				flags = FIRST_OF_LINE;
				if (tokens.length > 0) {
					tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				}
			}
		} else {
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					if (currentStart !== -1) {
						flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
						tokens.push({
							text: input.substring(currentStart, i),
							pos: currentStart,
							len: i - currentStart,
							lineNum: baseLineNum + lineCount,
							flags,
						});
						flags = 0;
						currentStart = -1;
					}

					flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}

			if (currentStart === -1) {
				currentStart = i;
			}
		}
	}

	if (currentStart !== -1) {
		flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
		tokens.push({
			text: input.substring(currentStart),
			pos: currentStart,
			len: inputEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: flags,
		});
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByWord", tokens);
	return tokens;
}

function tokenizeByLine(input, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	const tokens = [];
	let currentStart = -1;
	let currentEnd = -1;
	let lineCount = 0;
	if (inputPos === undefined) {
		inputPos = 0;
	}
	if (inputEnd === undefined) {
		inputEnd = input.length;
	}
	if (baseLineNum === undefined) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (char !== "\n") {
			if (!SPACE_CHARS[char]) {
				if (currentStart === -1) {
					currentStart = i;
				}
				currentEnd = i + 1;
			}
		} else {
			if (currentStart !== -1) {
				tokens.push({
					text: input.substring(currentStart, currentEnd),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags: FIRST_OF_LINE | LAST_OF_LINE,
				});
				currentStart = currentEnd = -1;
			}
			lineCount++;
		}
	}

	if (currentStart !== -1) {
		tokens.push({
			text: input.substring(currentStart, currentEnd),
			pos: currentStart,
			len: currentEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: FIRST_OF_LINE | LAST_OF_LINE,
		});
	}

	return tokens;
}

function tokenize(input, method, inputPos = undefined, inputEnd = undefined, baseLineNum = undefined) {
	let cacheArr;
	if ((inputPos === undefined || inputPos === 0) && (inputEnd === undefined || inputEnd === input.length)) {
		cacheArr = tokenCache[method];
		if (cacheArr) {
			for (let i = 0; i < cacheArr.length; i++) {
				const token = cacheArr[i];
				if (token.text === input) {
					if (i !== cacheArr.length - 1) {
						cacheArr.splice(i, 1);
						cacheArr.push(token);
					}
					return token.tokens;
				}
			}
		}
	}

	const tokens =
		method === DIFF_BY_CHAR
			? tokenizeByChar(input, inputPos, inputEnd, baseLineNum)
			: method === DIFF_BY_LINE
			? tokenizeByLine(input, inputPos, inputEnd, baseLineNum)
			: tokenizeByWord(input, inputPos, inputEnd, baseLineNum);

	// tokens.push({
	// 	text: "",
	// 	pos: input.length,
	// 	len: 0,
	// 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
	// 	flags: FIRST_OF_LINE | LAST_OF_LINE,
	// });

	if (cacheArr) {
		if (cacheArr.length >= TOKEN_CACHE_SIZE) {
			cacheArr.shift();
		}
		cacheArr.push({ text: input, tokens });
	}
	return tokens;
}

// function computeLCS(leftTokens, rightTokens) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;
// 	const dp = new Array(m + 1);
// 	const blockLength = new Array(m + 1);
// 	const lcsIndices = [];

// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 		blockLength[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		for (let j = 1; j <= n; j++) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				let weight = 1;
// 				// 연속된 매치 토큰에 가중치 부여
// 				if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 					weight += dp[i - 1][j - 1];
// 				}
// 				// dp 테이블 갱신
// 				dp[i][j] = dp[i - 1][j - 1] + weight;
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 			}
// 		}
// 	}

// 	// for (let i = 1; i <= m; i++) {
// 	// 	for (let j = 1; j <= n; j++) {
// 	// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 	// 			let weight = 1;
// 	// 			if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 	// 				weight += blockLength[i - 1][j - 1];
// 	// 			}
// 	// 			dp[i][j] = dp[i - 1][j - 1] + weight;
// 	// 			blockLength[i][j] = blockLength[i - 1][j - 1] + 1;
// 	// 		} else {
// 	// 			dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 	// 			blockLength[i][j] = 0;
// 	// 		}
// 	// 	}
// 	// }

// 	let i = m;
// 	let j = n;
// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			}
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}
// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

// function backtrackLCS(dp, leftTokens, rightTokens) {
// 	let i = leftTokens.length;
// 	let j = rightTokens.length;
// 	const lcsIndices = [];

// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			if (dp[i][j] === dp[i - 1][j - 1] + 1) {
// 				lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 				i--;
// 				j--;
// 			} else {
// 				if (dp[i - 1][j] > dp[i][j - 1]) {
// 					i--;
// 				} else if (dp[i - 1][j] < dp[i][j - 1]) {
// 					j--;
// 				} else {
// 					i--;
// 				}
// 			}
// 		} else {
// 			if (dp[i - 1][j] > dp[i][j - 1]) {
// 				i--;
// 			} else {
// 				j--;
// 			}
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

//
// WEIGHTED LCS! meticulous하게 테스트 해볼 필요 있음.
//
// function computeLCS(leftTokens, rightTokens) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;
// 	const dp = new Array(m + 1);
// 	const lcsIndices = [];

// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		for (let j = 1; j <= n; j++) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				let weight = 1;
// 				if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 					weight += dp[i - 1][j - 1];
// 				}
// 				dp[i][j] = dp[i - 1][j - 1] + weight;
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 			}
// 		}
// 	}

// 	let i = m;
// 	let j = n;
// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

async function computeLCS(leftTokens, rightTokens, ctx) {
	const m = leftTokens.length;
	const n = rightTokens.length;

	const dp = new Array(m + 1);
	//const consecutive = new Array(m + 1);
	for (let i = 0; i <= m; i++) {
		dp[i] = new Array(n + 1).fill(0);
		//consecutive[i] = new Array(n + 1).fill(0);
	}
	for (let i = 1; i <= m; i++) {
		const leftText = leftTokens[i - 1].text;
		for (let j = 1; j <= n; j++) {
			if (ctx && ((i + j) & 16383) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}

			const rightText = rightTokens[j - 1].text;
			if (leftText === rightText) {
				//consecutive[i][j] = consecutive[i - 1][j - 1] + 1;
				dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				//consecutive[i][j] = 0;
			}
		}
	}

	let i = m;
	let j = n;
	const lcsIndices = [];
	while (i > 0 && j > 0) {
		// if (ctx && ((i + j) & 511) === 0) {
		// 	const now = performance.now();
		// 	if (now - ctx.lastYield > 100) {
		// 		ctx.lastYield = now;
		// 		await new Promise((resolve) => setTimeout(resolve, 0));
		// 		if (ctx.cancel) {
		// 			throw new Error("cancelled");
		// 		}
		// 	}
		// }
		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
			lcsIndices.push({
				leftIndex: i - 1,
				rightIndex: j - 1,
				//text: leftTokens[i - 1].text, // 필요하면 leftTokens[leftIndex]로 얻을 수 있음!
			});
			i--;
			j--;
		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
			i--;
		} else {
			j--;
		}
	}
	lcsIndices.reverse();
	return lcsIndices;
}

// async function computeLCS(leftTokens, rightTokens, ctx) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;

// 	const dp = new Array(m + 1);
// 	const consecutive = new Array(m + 1);
// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 		consecutive[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		const leftText = leftTokens[i - 1].text;
// 		for (let j = 1; j <= n; j++) {
// 			if (j % 1023 === 0) {
// 				if (ctx && performance.now() - ctx.lastYield > 100) {
// 					ctx.lastYield = performance.now();
// 					await new Promise((resolve) => setTimeout(resolve, 0));
// 					if (ctx.cancel) {
// 						return null;
// 					}
// 				}
// 			}

// 			const rightText = rightTokens[j - 1].text;

// 			if (leftText === rightText) {
// 				consecutive[i][j] = consecutive[i - 1][j - 1] + 1; // 연속 매치 횟수 증가
// 				dp[i][j] = dp[i - 1][j - 1] + 1 + consecutive[i][j]; // 연속 매치에 가중치 부여
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 				consecutive[i][j] = 0;
// 			}
// 		}
// 	}

// 	let i = m;
// 	let j = n;
// 	const lcsIndices = [];
// 	while (i > 0 && j > 0) {
// 		if ((i + j) % 1023 === 0 && ctx && performance.now() - ctx.lastYield > 100) {
// 			ctx.lastYield = performance.now();
// 			await new Promise((resolve) => setTimeout(resolve, 0));
// 			if (ctx.cancel) {
// 				return null;
// 			}
// 		}
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

// function findLineEndPos(text, pos, maxPos, numLines = 1){
// 	while (pos < maxPos && numLines > 0) {
// 		if (text[pos] === "\n") {
// 			numLines--;
// 			if (numLines === 0) {
// 				break;
// 			}
// 		}
// 		pos++;
// 	}
// 	return pos;
// }

function skipCommonChars(leftTokens, leftTokenIndex, leftTokenCount, rightTokens, rightTokenIndex, rightTokenCount) {
	let i = leftTokenIndex;
	let j = rightTokenIndex;
	// 각 토큰의 text의 한글자 한글자를 비교

	let leftToken = leftTokens[i];
	let rightToken = rightTokens[j];
	let leftCharIndex = 0;
	let rightCharIndex = 0;
	let leftSkipped = 0;
	let rightSkipped = 0;
	while (leftToken && rightToken) {
		const leftText = leftToken.text[leftCharIndex];
		const rightText = rightToken.text[rightCharIndex];
		while (leftCharIndex < leftToken.text.length && rightCharIndex < rightToken.text.length) {
			if (leftText[leftCharIndex] !== rightText[rightCharIndex]) {
				break;
			}
			if (++leftCharIndex >= leftToken.text.length) {
				leftToken = leftTokens[++i];
				leftCharIndex = 0;
			}
		}
	}

	return { leftIndex: i, rightIndex: j };
}

async function computeDiff({
	leftText,
	rightText,
	leftInputPos = undefined,
	leftInputEnd = undefined,
	rightInputPos = undefined,
	rightInputEnd = undefined,
	leftTokens = undefined,
	rightTokens = undefined,
	method = DIFF_BY_WORD,
	ctx,
	skipFallback = false,
}) {
	const diffs = [],
		anchors = [];

	let now = performance.now();

	if (leftInputPos === undefined) {
		leftInputPos = 0;
	}
	if (leftInputEnd === undefined) {
		leftInputEnd = leftText.length;
	}
	if (rightInputPos === undefined) {
		rightInputPos = 0;
	}
	if (rightInputEnd === undefined) {
		rightInputEnd = rightText.length;
	}

	if (!leftTokens) {
		leftTokens = tokenize(leftText, method, leftInputPos, leftInputEnd);
	}
	if (!rightTokens) {
		rightTokens = tokenize(rightText, method, rightInputPos, rightInputEnd);
	}
	let elapsed = performance.now() - now;
	console.debug("Tokenize elapsed time:", elapsed, { leftTokens, rightTokens });

	now = performance.now();
	const lcs = await computeLCS(leftTokens, rightTokens, ctx);
	elapsed = performance.now() - now;
	console.debug("LCS elapsed time:", elapsed);

	if (ctx && ctx.cancel) {
		throw new Error("cancelled");
	}
	const lcsLength = lcs.length;
	const leftTokensLength = leftTokens.length;
	const rightTokensLength = rightTokens.length;
	// LCS에 비해 나머지 부분은 성능에 큰 영향을 미치지 않음.

	function addAnchor(type, leftPos, rightPos, diffIndex = null) {
		if (leftPos === undefined || rightPos === undefined) {
			console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
		}
		if (anchors.length > 0) {
			let lastAnchor = anchors[anchors.length - 1];
			if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
				return;
			}
			if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
				if (type === lastAnchor.type || type === "before") {
					return;
				}
			}
		}
		anchors.push({ type, diffIndex, left: leftPos, right: rightPos });
	}

	if (leftTokensLength === 0 && rightTokensLength === 0) {
		//
	} else if (leftTokensLength === 0) {
		diffs.push({
			left: {
				pos: 0,
				len: 0,
				line: 1,
				lineEnd: 1,
				entireLines: true,
				empty: true,
			},
			right: {
				pos: rightTokens[0].pos,
				len: rightTokens[rightTokensLength - 1].pos + rightTokens[rightTokensLength - 1].len - rightTokens[0].pos,
				line: rightTokens[0].lineNum,
				lineEnd: rightTokens[rightTokensLength - 1].lineNum,
				entireLines: true,
			},
		});
	} else if (rightTokensLength === 0) {
		diffs.push({
			left: {
				pos: leftTokens[0].pos,
				len: leftTokens[leftTokensLength - 1].pos + leftTokens[leftTokensLength - 1].len - leftTokens[0].pos,
				line: leftTokens[0].lineNum,
				lineEnd: leftTokens[leftTokensLength - 1].lineNum,
				entireLines: true,
			},
			right: {
				pos: 0,
				len: 0,
				line: 1,
				lineEnd: 1,
				entireLines: true,
				empty: true,
			},
		});
	} else {
		let i = 0;
		let j = 0;
		let lcsIndex = 0;
		let lastYield = 0;
		let iteration = 0;

		while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
			if (ctx && (iteration & 1023) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}
			if (lcsIndex < lcsLength && i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex) {
				// if (lcsIndex < lcsLength && leftTokens[i].text === leftTokens[lcs[lcsIndex].leftIndex].text && rightTokens[j].text === rightTokens[lcs[lcsIndex].rightIndex].text) {
				const leftToken = leftTokens[i];
				const rightToken = rightTokens[j];
				if ((leftToken.flags & rightToken.flags & FIRST_OF_LINE) === FIRST_OF_LINE) {
					let leftAnchorPos = leftToken.pos;
					let rightAnchorPos = rightToken.pos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
					addAnchor("before", leftAnchorPos, rightAnchorPos);
				}
				i++;
				j++;
				lcsIndex++;
				continue; // 다음 순회로 건너뜀
			}

			let leftIndex = i;
			let leftCount = 0;
			let rightIndex = j;
			let rightCount = 0;

			while (i < leftTokensLength && (lcsIndex >= lcsLength || i < lcs[lcsIndex].leftIndex)) {
				// while (i < leftTokensLength && (lcsIndex >= lcsLength || leftTokens[i].text !== leftTokens[lcs[lcsIndex].leftIndex].text)) {
				leftCount++;
				i++;
			}

			while (j < rightTokensLength && (lcsIndex >= lcsLength || j < lcs[lcsIndex].rightIndex)) {
				// while (j < rightTokensLength && (lcsIndex >= lcsLength || rightTokens[j].text !== rightTokens[lcs[lcsIndex].rightIndex].text)) {
				rightCount++;
				j++;
			}

			let anchorBefore = false,
				anchorAfter = false;
			let leftPos, leftLen, rightPos, rightLen;
			let leftEmpty;
			let rightEmpty;
			let leftAnchorPos = null;
			let rightAnchorPos = null;

			if (leftCount > 0 && rightCount > 0) {
				leftPos = leftTokens[leftIndex].pos;
				leftLen = leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len - leftPos;
				leftEmpty = false;
				rightPos = rightTokens[rightIndex].pos;
				rightLen = rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len - rightPos;
				rightEmpty = false;
				anchorBefore = !!(leftTokens[leftIndex].flags & rightTokens[rightIndex].flags & FIRST_OF_LINE);
				anchorAfter = !!(leftTokens[leftIndex + leftCount - 1].flags & rightTokens[rightIndex + rightCount - 1].flags & LAST_OF_LINE);

				if (method > DIFF_BY_CHAR) {
					// console.log("try fallback", {
					// 	leftPos,
					// 	leftEnd: leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len,
					// 	rightPos,
					// 	rightEnd: rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len,
					// });
					const result = await computeDiff({
						leftText,
						rightText,
						leftInputPos: leftPos,
						leftInputEnd: leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len,
						rightInputPos: rightPos,
						rightInputEnd: rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len,
						method: method - 1,
						ctx,
						skipFallback: true,
					});

					// console.log("fallback result ", { result });

					// diff 결과가 1개 이하일 때에만 결과를 사용하고 그렇지 않은 경우는 무시하고 현재 method로 diff 생성.

					if (result.diffs.length <= 1) {
						const leftEnd = leftPos + leftLen;
						const rightEnd = rightPos + rightLen;
						for (const anchor of result.anchors) {
							if (anchor.left < leftEnd && anchor.right < rightEnd) {
								if (anchor.diffIndex !== null) {
									anchor.diffIndex += diffs.length;
								}
								addAnchor(anchor.type, anchor.left, anchor.right, anchor.diffIndex);
							}
						}
						for (const diff of result.diffs) {
							diffs.push(diff);
						}
						continue;
					}

					// for (const diff of result.diffs) {
					// 	diffs.push(diff);
					// }

					// console.log("fallback done");
					// continue;
				}
				// if (method !== DIFF_BY_CHAR) {
				// 	if (leftLen <= 40 && rightLen <= 40) {
				// 		let leftFragment = leftText.substring(leftPos, leftPos + leftLen).replace(/\s/g, "");
				// 		let rightFragment = rightText.substring(rightPos, rightPos + rightLen).replace(/\s/g, "");
				// 		if (leftFragment === rightFragment) {
				// 			leftIndex = rightIndex = 0;
				// 			leftCount = rightCount = 0;
				// 			continue;
				// 		}
				// 	}
				// }

				if (anchorBefore) {
					leftAnchorPos = leftPos;
					rightAnchorPos = rightPos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
				}

				if ((leftTokens[leftIndex].flags | rightTokens[rightIndex].flags) & FIRST_OF_LINE) {
					leftAnchorPos = leftPos;
					rightAnchorPos = rightPos;
					while (leftAnchorPos > 0 && leftText[leftAnchorPos - 1] !== "\n") {
						leftAnchorPos--;
					}
					while (rightAnchorPos > 0 && rightText[rightAnchorPos - 1] !== "\n") {
						rightAnchorPos--;
					}
					addAnchor("before", leftAnchorPos, rightAnchorPos);
					if (leftTokens[leftIndex].flags & rightTokens[rightIndex].flags & FIRST_OF_LINE) {
						if (leftTokens[leftIndex + leftCount - 1].flags & rightTokens[rightIndex + rightCount - 1].flags & LAST_OF_LINE) {
							leftAnchorPos = leftPos + leftLen;
							rightAnchorPos = rightPos + rightLen;
							// 줄바꿈 문자 위치까지 스킵

							if (leftText[leftAnchorPos] !== "\n") {
								do {
									leftAnchorPos++;
								} while (leftAnchorPos < leftText.length && leftText[leftAnchorPos] !== "\n");
							}
							if (rightText[rightAnchorPos] !== "\n") {
								do {
									rightAnchorPos++;
								} while (rightAnchorPos < rightText.length && rightText[rightAnchorPos] !== "\n");
							}

							// while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
							// 	leftAnchorPos++;
							// }
							// while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
							// 	rightAnchorPos++;
							// }
							addAnchor("after", leftAnchorPos, rightAnchorPos);
						}
					}
				}
			} else if (leftCount > 0 || rightCount > 0) {
				let longSideText, shortSideText;
				let longSideIndex, longSideCount, longSideTokens;
				let shortSideIndex, shortSideCount, shortSideTokens;
				let longSidePos, longSideLen;
				let shortSidePos, shortSideLen;
				let longSideStartPos, shortSideStart;
				let longSideEndPos, shortSideEnd;
				let longSideAnchorPos, shortSideAnchorPos;

				if (leftCount > 0) {
					longSideText = leftText;
					longSideTokens = leftTokens;
					longSideIndex = leftIndex;
					longSideCount = leftCount;
					shortSideText = rightText;
					shortSideTokens = rightTokens;
					shortSideIndex = rightIndex;
					shortSideCount = rightCount;
					longSideStartPos = leftInputPos;
					shortSideStart = rightInputPos;
					longSideEndPos = leftInputEnd;
					shortSideEnd = rightInputEnd;
				} else {
					longSideText = rightText;
					longSideTokens = rightTokens;
					longSideIndex = rightIndex;
					longSideCount = rightCount;
					shortSideText = leftText;
					shortSideTokens = leftTokens;
					shortSideIndex = leftIndex;
					shortSideCount = leftCount;
					longSideStartPos = rightInputPos;
					shortSideStart = leftInputPos;
					longSideEndPos = rightInputEnd;
					shortSideEnd = leftInputEnd;
				}

				longSidePos = longSideTokens[longSideIndex].pos;
				longSideLen = longSideTokens[longSideIndex + longSideCount - 1].pos + longSideTokens[longSideIndex + longSideCount - 1].len - longSidePos;
				shortSideLen = 0;
				const longSideIsFirstWord = longSideTokens[longSideIndex].flags & FIRST_OF_LINE;
				const longSideIsLastWord = longSideTokens[longSideIndex + longSideCount - 1].flags & LAST_OF_LINE;
				const shortSideIsOnLineEdge =
					shortSideTokens.length === 0 ||
					(shortSideIndex > 0 && shortSideTokens[shortSideIndex - 1].flags & FIRST_OF_LINE) ||
					(shortSideIndex < shortSideTokens.length && shortSideTokens[shortSideIndex].flags & FIRST_OF_LINE);
				anchorBefore = longSideIsFirstWord && shortSideIsOnLineEdge;
				anchorAfter = longSideIsLastWord && shortSideIsOnLineEdge;

				// base pos는 되도록이면 앞쪽으로 잡자. 난데없이 빈줄 10개 스킵하고 diff가 시작되면 이상하자나.
				shortSidePos = shortSideIndex > 0 ? shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len : shortSideStart;

				// 참고:
				// 만약 shortSidePos가 줄의 시작 위치로 정해진다면(\n 위치의 +1) shortSideAnchorPos도 같은 값을 사용할 수 있다.
				// 그렇지 않은 경우에는 앞쪽 공백을 다 스킵해서 shortSideAnchorPos를 찾아야 한다.
				if (shortSideIsOnLineEdge) {
					if (longSideIsFirstWord) {
						// longside는 블럭 diff다. shortside도 가능하다면 빈줄을 찾아서 찾아서 독식하자.
						// 현재 shortsidepos는 이전 블럭의 끝이므로 이후에 줄바꿈이 두개 나오면 된다

						if (shortSideIndex > 0 && shortSideIndex < shortSideTokens.length) {
							// 이전 토큰과 다음 토큰 사이에 있으므로 lineNum을 확인하면 된다.
							if (shortSideTokens[shortSideIndex].lineNum > shortSideTokens[shortSideIndex - 1].lineNum) {
								// 이전 토큰과 다음 토큰 사이에 빈줄이 있다.
								while (shortSideText[shortSidePos++] !== "\n") {}
								shortSideAnchorPos = shortSidePos;
							} else {
								// do not even try
							}
						} else if (shortSideIndex > 0) {
							// 현재 pos는 이전 토큰의 끝이므로 그 이후 첫번째 줄바꿈 위치를 찾아서 +1한 자리로.
							// 줄바꿈은 무조건 있다. 내가 텍스트를 그렇게 만들거니까.
							while (shortSideText[shortSidePos++] !== "\n") {}
						} else {
							// 이전 토큰은 없지만 이게 텍스트의 시작은 아닐 수도 있다. - 텍스트 중간 부분에서 diff를 구하는 경우.
							// 일단 현재 pos이전에 첫번째 줄바꿈을 찾되 도중에 공백이 아닌 문자를 만나면 포기
							// 첫번째 줄바꿈에서 끝내지말고고 계속 찾아서 최대한 위로 끌어올리기.
							if (shortSidePos === 0) {
								shortSideAnchorPos = shortSidePos;
							} else {
								let p = shortSidePos;
								let success = false;
								while (p > 0) {
									const ch = shortSideText[p - 1];
									if (ch === "\n") {
										shortSidePos = shortSideAnchorPos = p;
										success = true;
									} else if (!SPACE_CHARS[ch]) {
										break;
									}
									p--;
								}
								if (p === 0) {
									shortSidePos = shortSideAnchorPos = 0;
									success = true;
								}
								if (!success) {
									p = shortSidePos;
									while (p < shortSideText.length) {
										if (shortSideText[p] === "\n") {
											shortSidePos = p + 1;
											shortSideAnchorPos = shortSidePos;
											break;
										}
										if (!SPACE_CHARS[shortSideText[p++]]) {
											break;
										}
									}
								}
								// while (p >= 0) {
								// 	if (shortSideText[p] === "\n") {
								// 		console.log(7);
								// 		shortSidePos = p + 1;
								// 		shortSideAnchorPos = shortSidePos;
								// 		success = true;
								// 		p--;
								// 		continue;
								// 		// keep going.
								// 	}
								// 	if (!SPACE_CHARS[shortSideText[p--]]) {
								// 		break;
								// 	}
								// }
								// if (!success) {
								// 	p = shortSidePos;
								// 	while (p < shortSideEnd) {
								// 		if (shortSideText[p] === "\n") {
								// 			console.log(8);
								// 			shortSidePos = p + 1;
								// 			shortSideAnchorPos = shortSidePos;
								// 			break;
								// 		}
								// 		if (!SPACE_CHARS[shortSideText[p++]]) {
								// 			break;
								// 		}
								// 	}
								// }
							}
						}
					}
				}

				if (longSideIsFirstWord) {
			
					if (shortSideAnchorPos !== undefined) {
						shortSideAnchorPos = shortSidePos;
						while (shortSideAnchorPos > 0 && shortSideText[shortSideAnchorPos - 1] !== "\n") {
							shortSideAnchorPos--;
						}

						longSideAnchorPos = longSidePos;
						while (longSideAnchorPos > 0 && longSideText[longSideAnchorPos - 1] !== "\n") {
							longSideAnchorPos--;
						}

						if (leftCount > 0) {
							[leftAnchorPos, rightAnchorPos] = [longSideAnchorPos, shortSideAnchorPos];
						} else {
							[leftAnchorPos, rightAnchorPos] = [shortSideAnchorPos, longSideAnchorPos];
						}
						addAnchor("before", leftAnchorPos, rightAnchorPos);

						if (longSideIsLastWord && shortSideIsOnLineEdge) {
							longSideAnchorPos = longSidePos + longSideLen;
							while (longSideAnchorPos < longSideEndPos && longSideText[longSideAnchorPos] !== "\n") {
								longSideAnchorPos++;
							}
							shortSideAnchorPos = shortSidePos + shortSideLen;
							// 이후 이어지는 공백 문자 중 마지막 공백 문자 자리에서 AFTER 앵커
	
							while (shortSideAnchorPos < shortSideEnd) {
								if (shortSideText[shortSideAnchorPos] === "\n") {
									break;
								}
								if (!SPACE_CHARS[shortSideText[shortSideAnchorPos]]) {
									break;
								}
								shortSideAnchorPos++;
							}
							if (leftCount > 0) {
								[leftAnchorPos, rightAnchorPos] = [longSideAnchorPos, shortSideAnchorPos];
							} else {
								[leftAnchorPos, rightAnchorPos] = [shortSideAnchorPos, longSideAnchorPos];
							}
							addAnchor("after", leftAnchorPos, rightAnchorPos);
						}
					}
					

					
				}
				if (leftCount > 0) {
					leftPos = longSidePos;
					leftLen = longSideLen;
					leftEmpty = false;
					rightPos = shortSidePos;
					rightLen = shortSideLen;
					rightEmpty = true;
				} else {
					leftPos = shortSidePos;
					leftLen = shortSideLen;
					leftEmpty = true;
					rightPos = longSidePos;
					rightLen = longSideLen;
					rightEmpty = false;
				}
			} else {
				throw new Error("WTF? both leftCount and rightCount are 0");
			}

			// if (anchorBefore) {
			// 	anchors.push({
			// 		type: "before",
			// 		diffIndex: diffs.length,
			// 		left: leftPos,
			// 		right: rightPos,
			// 	});
			// }
			// if (anchorAfter) {
			// 	anchors.push({
			// 		type: "after",
			// 		diffIndex: diffs.length,
			// 		left: leftPos + leftLen,
			// 		right: rightPos + rightLen,
			// 	});
			// }
			diffs.push({
				left: {
					pos: leftPos,
					len: leftLen,
					empty: leftEmpty,
				},
				right: {
					pos: rightPos,
					len: rightLen,
					empty: rightEmpty,
				},
			});
		}
	}

	console.debug("computeDiff done", { diffs, anchors });
	return { diffs, anchors };
}
</script>
    <style id="highlightStyle">
    </style>
</head>

<body>
    <div class="container">
        <div id="topbar">
            <div class="">

            </div>
            <div class="buttons">
                <button id="alignedModeToggle" class="toggle" >📖</button>
                <button id="syncScrollToggle" class="toggle" data-target="strike">🔗</button>
            </div>
        </div>
        <main id="main">
            <!-- <div id="left"></div>
            <div id="right"></div> -->

        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>

    <!-- <div class="drawer" id="drawer">
        <div class="drawer-header">
            <h2></h2>

            <button class="close-btn" onclick="closeDrawer()">Close</button>
        </div>
        <div class="drawer-content">
            <h4>Diff Mode</h4>
            <radio-group>
                <ul class="drawer-menu">
                    <li><label><input type="radio" name="tokenizeMethod" value="char" checked /> Char</label></li>
                    <li><label><input type="radio" name="tokenizeMethod" value="word" /> Word</label></li>
                    <li><label><input type="radio" name="tokenizeMethod" value="word" /> Line</label></li>
                </ul>
            </radio-group>
        </div>
    </div> -->

    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script id='main.js'>"use strict";



/*
코드 증말 더럽다... 
주말에 좀 정리하고:
	1. 성능에 너무 얽매이지 말고
	2. 필요할지 말지 애매하면 그냥 다 제거
그리고 이제 신경 끄자. 시간 아깝다. 언제 짤려서 쓸일 없어질지 모르는데 ㅋ
*/

let isAltPressed = false;
document.addEventListener("keydown", (event) => {
	if (event.key === "Alt") {
		isAltPressed = true;
	}
});
document.addEventListener("keyup", (event) => {
	if (event.key === "Alt") {
		isAltPressed = false;
	}
});

const DiffSeek = (function () {
	let _diffs = [];
	let _anchors = [];
	let _alignedMode = false;
	let _alignedDirty = false;
	let _updateTimeoutId = null;
	let _activeEditor = null;
	let _lastFocusedEditor = null;
	let _lastScrolledEditor = null;
	let _syncingScroll = false;
	let _syncingScrollTimeoutId = null;
	let _mousedOverEditor = null;
	let _currentDiffIndex = -1;
	let _alignTimeoutId = null;
	let _syncEditor = false;

	const container = document.getElementById("main");
	const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
	const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
	const diffList = document.getElementById("diffList");

	const recalculateAlignmentPaddingAndPositionsDebounced = debounce(recalculateAlignmentPaddingAndPositions, 200);

	function getEditorCallbacks(key) {
		return {
			onEnter: () => {
				_mousedOverEditor = key === "left" ? leftEditor : rightEditor;
			},
			onLeave: () => {
				_mousedOverEditor = null;
			},
			onFocus: () => {
				if (key === "left") {
					_activeEditor = _lastFocusedEditor = leftEditor;
				} else {
					_activeEditor = _lastFocusedEditor = rightEditor;
				}
			},
			onBlur: () => {
				_activeEditor = null;
			},
			onScroll: function () {
				// _lastScrolledEditor = key === "left" ? leftEditor : rightEditor;
				// if (!_syncingScroll && !_alignedMode) {
				// 	syncScrollPosition(_lastScrolledEditor);
				// }
			},
			onTextChanged: function () {
				if (_updateTimeoutId) {
					clearTimeout(_updateTimeoutId);
				}
				_diffs = null;
				_anchors = null;
				_currentDiffIndex = -1;
				_alignedDirty = true;
				_updateTimeoutId = setTimeout(() => {
					_updateTimeoutId = null;
					computeDiff();
				}, COMPUTE_DEBOUNCE_TIME);
			},
			onMirrorUpdated: function () {
				_alignedDirty = true;
				if (_alignedMode) {
					recalculateAlignmentPaddingAndPositions();
				}
			},
		};
	}

	// #region WORKER STUFF
	let workerURL;
	const workerCode = document.getElementById("worker.js").textContent;
	if (workerCode.trim().length === 0) {
		workerURL = "worker.js";
	} else {
		const blob = new Blob([workerCode], { type: "application/javascript" });
		workerURL = URL.createObjectURL(blob);
	}
	const worker = new Worker(workerURL);
	const encoder = new TextEncoder();
	let reqId = 0;
	function computeDiff() {
		progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
		document.querySelector("body").classList.add("computing");
		if (reqId === Number.MAX_SAFE_INTEGER) {
			reqId = 1;
		} else {
			reqId++;
		}
		worker.postMessage({
			type: "diff",
			reqId: reqId,
			left: encoder.encode(leftEditor.text),
			right: encoder.encode(rightEditor.text),
			method: 2,
		});
	}

	worker.onmessage = function (e) {
		const data = e.data;
		if (data.type === "diffs") {
			if (data.reqId === reqId) {
				//console.log("diffs computed", data);
				document.querySelector("body").classList.remove("computing");
				onDiffComputed(data);
			}
		}
	};

	function onDiffComputed({ diffs, anchors }) {
		console.debug("diffs computed", diffs, anchors);
		_diffs = diffs;
		_anchors = anchors;
		_alignedDirty = true;
		leftEditor.update({ diffs, anchors });
		rightEditor.update({ diffs, anchors });
		updateDiffList();
	}
	// #endregion

	function enableAlignedMode() {
		if (!_alignedMode) {
			const currentEditor = _mousedOverEditor || _activeEditor || _lastFocusedEditor || _lastScrolledEditor;
			let firstVisibleLine, firstVisibleLineTop;
			let caretPos;

			if (_activeEditor) {
				_activeEditor.saveCaret();
			}

			if (currentEditor) {
				// syncScrollPosition(currentEditor);
				[firstVisibleLine, firstVisibleLineTop] = currentEditor.getFirstVisibleLineElementInEditor();
			} else {
				console.log("no active editor");
			}

			_alignedMode = true;
			updateButtons();
			const body = document.querySelector("body");
			body.classList.remove("edit");
			body.classList.add("aligned");
			recalculateAlignmentPaddingAndPositions();

			// if (caretPos) {
			// 	currentEditor.scrollToTextPosition(caretPos);
			// }

			if (firstVisibleLine) {
				const top = firstVisibleLine.offsetTop + TOPBAR_HEIGHT;
				requestAnimationFrame(() => {
					container.scrollTop = top;
				});
			}
		}
	}

	function resolveSelectionRange(range) {
		let startLine = range.startContainer;
		while (startLine && startLine.tagName !== "DIV") {
			startLine = startLine.parentElement;
		}
		let endLine = range.endContainer;
		while (endLine && endLine.tagName !== "DIV") {
			endLine = endLine.parentElement;
		}
		let startOffset = range.startOffset;
		let prevSibling = range.startContainer.previousSibling;
		while (prevSibling) {
			startOffset += prevSibling.textContent.length;
			prevSibling = prevSibling.previousSibling;
		}

		let endOffset = range.endOffset;
		prevSibling = range.endContainer.previousSibling;
		while (prevSibling) {
			endOffset += prevSibling.textContent.length;
			prevSibling = prevSibling.previousSibling;
		}
	}

	window.addEventListener("resize", () => {
		_alignedDirty = true;
		if (_alignedMode) {
			recalculateAlignmentPaddingAndPositionsDebounced();
		}
	});

	// 아 귀찮아
	for (const editor of [leftEditor, rightEditor]) {
		editor.editor.addEventListener("contextmenu", (e) => {
			e.preventDefault();
			if (_alignedMode) {
				disableAlignedMode(true);
			} else {
				enableAlignedMode();
			}
		});

		editor.mirror.addEventListener("contextmenu", (e) => {
			e.preventDefault();

			disableAlignedMode(true);
		});

		editor.mirror.addEventListener("click", (e) => {
			if (e.ctrlKey) {
				disableAlignedMode(true);
			}
		});

		editor.mirror.addEventListener("dblclick", (e) => {
			if (e.ctrlKey) {
				disableAlignedMode(true);
			}
		});

		editor.wrapper.addEventListener("scroll", (e) => {
			if (_syncingScroll) {
				return;
			}
			_lastScrolledEditor = editor;
			if (_syncEditor !== isAltPressed && !_syncingScroll && !_alignedMode) {
				syncScrollPosition(editor);
			}
		});
	}

	function selectText(range, editor, startLineNumber, startOffset, endLineNumber, endOffset) {
		const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
		let currentNode;
		let lineNum = 1;
		let startSet = false;

		while ((currentNode = walker.nextNode())) {
			const text = currentNode.textContent;
			let linePos = 0;
			if (!startSet) {
				if (lineNum < startLineNumber) {
					for (let i = linePos; i < text.length; i++) {
						if (text[i] === "\n") {
							lineNum++;
							if (lineNum === startLineNumber) {
								linePos = i + 1;
								break;
							}
						}
					}
				}
				if (lineNum !== startLineNumber) {
					continue;
				}
				range.setStart(currentNode, Math.min(linePos + startOffset, text.length));
				startSet = true;
			}

			if (lineNum !== endLineNumber) {
				for (let i = linePos; i < text.length; i++) {
					if (text[i] === "\n") {
						lineNum++;
						if (lineNum === endLineNumber) {
							linePos = i + 1;
							break;
						}
					}
				}
				if (lineNum !== endLineNumber) {
					continue;
				}
			}
			if (lineNum === endLineNumber) {
				range.setEnd(currentNode, Math.min(linePos + endOffset, text.length));
				return true;
			}
		}
		return false;
	}

	function getSelectionRange() {
		const selection = window.getSelection();
		const range = selection.rangeCount ? selection.getRangeAt(0) : null;
		let editor;
		if (range) {
			if (leftEditor.mirror.contains(range.commonAncestorContainer)) {
				editor = leftEditor.editor;
			} else if (rightEditor.mirror.contains(range.commonAncestorContainer)) {
				editor = rightEditor.editor;
			} else {
				return;
			}

			let startLineEl = range.startContainer;
			while (startLineEl && startLineEl.tagName !== "DIV") {
				startLineEl = startLineEl.parentElement;
			}
			let endLineEl = range.endContainer;
			while (endLineEl && endLineEl.tagName !== "DIV") {
				endLineEl = endLineEl.parentElement;
			}

			const startLineNumber = Number(startLineEl.dataset.lineNum);
			const endLineNumber = Number(endLineEl.dataset.lineNum);

			let currentNode;
			let startOffset = 0;
			let walker = document.createTreeWalker(startLineEl, NodeFilter.SHOW_TEXT, null, false);
			while ((currentNode = walker.nextNode())) {
				if (currentNode === range.startContainer) {
					startOffset += range.startOffset;
					break;
				} else {
					startOffset += currentNode.textContent.length;
				}
			}

			let endOffset = 0;
			walker = document.createTreeWalker(endLineEl, NodeFilter.SHOW_TEXT, null, false);
			while ((currentNode = walker.nextNode())) {
				if (currentNode === range.endContainer) {
					endOffset += range.endOffset;
					break;
				} else {
					endOffset += currentNode.textContent.length;
				}
			}

			console.log("selection", {
				editor,
				startLineNumber,
				startOffset,
				endLineNumber,
				endOffset,
			});
			return {
				editor,
				startLineNumber,
				startOffset,
				endLineNumber,
				endOffset,
			};
		}
		return null;
	}

	function disableAlignedMode(retainSelection = true) {
		const selectionRange = getSelectionRange();
		const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElementInEditor();
		const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElementInEditor();

		if (_lastFocusedEditor) {
			_lastFocusedEditor.saveCaret();
		}

		_alignedMode = false;
		updateButtons();
		const body = document.querySelector("body");
		body.classList.remove("aligned");
		body.classList.add("edit");

		_syncingScroll = true;

		requestAnimationFrame(() => {
			if (leftFirstLine) {
				leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
			}
			if (rightFirstLine) {
				rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
			}
			_syncingScroll = false;
		});

		if (_lastFocusedEditor) {
			_lastFocusedEditor.editor.focus();
			_lastFocusedEditor.restoreCaret();
		}

		// if (_lastFocusedEditor) {
		// 	console.log("restoring caret", _lastFocusedEditor.name);
		// 	_lastFocusedEditor.restoreCaret();
		// 	_lastFocusedEditor.editor.focus();
		// }

		if (selectionRange && retainSelection) {
			const range = document.createRange();
			if (
				selectText(
					range,
					selectionRange.editor,
					selectionRange.startLineNumber,
					selectionRange.startOffset,
					selectionRange.endLineNumber,
					selectionRange.endOffset
				)
			) {
				const selection = window.getSelection();
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}
	}

	function recalculateAlignmentPaddingAndPositions() {
		if (!_alignedDirty) {
			return;
		}
		const anchors = _anchors;
		if (!anchors) {
			return;
		}

		for (let i = 0; i < leftEditor.anchorElements.length; i++) {
			const anchor = leftEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}
		for (let i = 0; i < rightEditor.anchorElements.length; i++) {
			const anchor = rightEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}

		for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
			const anchor = anchors[anchorIndex];
			const leftAnchor = leftEditor.anchorElements[anchorIndex];
			const rightAnchor = rightEditor.anchorElements[anchorIndex];
			if (!leftAnchor || !rightAnchor) {
				console.warn("anchor not found", anchorIndex, leftAnchor, rightAnchor);
			}

			if (leftAnchor && rightAnchor) {
				alignAnchor(leftAnchor, rightAnchor, anchor.type);
			}
		}
		_alignedDirty = false;
	}

	function alignAnchor(leftAnchor, rightAnchor, type) {
		if (type === "before") {
			const leftTop = leftAnchor.offsetTop;
			const rightTop = rightAnchor.offsetTop;
			let topDiff = leftTop - rightTop;
			let shortSide, longSide;
			if (topDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				topDiff = -topDiff;
			} else if (topDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${topDiff}px`;
				shortSide.className = "expanded";
			}
		} else {
			const leftBottom = leftAnchor.offsetTop + leftAnchor.offsetHeight;
			const rightBottom = rightAnchor.offsetTop + rightAnchor.offsetHeight;
			let bottomDiff = leftBottom - rightBottom;
			let shortSide, longSide;
			if (bottomDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				bottomDiff = -bottomDiff;
			} else if (bottomDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${bottomDiff}px`;
				shortSide.className = "expanded";
			}
		}
	}

	function updateDiffList() {
		if (!_diffs) {
			return;
		}

		const leftWholeText = leftEditor.text;
		const rightWholeText = rightEditor.text;
		const fragment = document.createDocumentFragment();

		for (let i = 0; i < _diffs.length; i++) {
			const diff = _diffs[i];
			const li = document.createElement("LI");
			const button = document.createElement("MARK");
			button.dataset.diff = i;
			button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
			li.appendChild(button);

			const leftText = leftWholeText.substring(diff.left.pos, diff.left.pos + diff.left.len);
			const leftSpan = document.createElement("SPAN");
			leftSpan.textContent = leftText;
			leftSpan.classList.add("left");
			button.appendChild(leftSpan);

			const rightText = rightWholeText.substring(diff.right.pos, diff.right.pos + diff.right.len);
			const rightSpan = document.createElement("SPAN");
			rightSpan.textContent = rightText;
			rightSpan.classList.add("right");
			button.appendChild(rightSpan);

			fragment.appendChild(li);
		}

		diffList.innerHTML = "";
		diffList.appendChild(fragment);
	}

	window.addEventListener("keydown", (e) => {
		if (e.key === "F1") {
			e.preventDefault();
			// toggle!
			if (_alignedMode) {
				disableAlignedMode();
			} else {
				enableAlignedMode();
			}
			return;
		}

		if (e.key === "F2") {
			e.preventDefault();
			// toggle!
			if (_alignedMode) {
				disableAlignedMode();
			} else {
				enableAlignedMode();
			}
			return;
		}

		if (e.ctrlKey && (e.key === "q" || e.key === "Q")) {
			e.preventDefault();
			let source = _mousedOverEditor || _activeEditor;

			// if (!source) {
			// 	let elementAtCursor = document.elementFromPoint(cursorX, cursorY);
			// 	if (elementAtCursor) {
			// 		if (leftEditor.wrapper.contains(elementAtCursor)) {
			// 			source = leftEditor;
			// 		} else if (rightEditor.wrapper.contains(elementAtCursor)) {
			// 			source = rightEditor;
			// 		}
			// 	}
			// 	console.log("elementAtCursor", source);
			// }

			if (source) {
				syncScrollPosition(source);
			}
			return;
		}

		if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
			e.preventDefault();
			if (!_diffs || _diffs.length === 0) {
				return;
			}

			_currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
			if (_currentDiffIndex < 0) {
				_currentDiffIndex = _diffs.length - 1;
			}
			if (_currentDiffIndex >= _diffs.length) {
				_currentDiffIndex = 0;
			}
			_syncingScroll = true;
			leftEditor.scrollToDiff(_currentDiffIndex);
			rightEditor.scrollToDiff(_currentDiffIndex);
			requestAnimationFrame(() => {
				_syncingScroll = false;
				highlightDiff(_currentDiffIndex);
			});
			return;
		}
	});

	diffList.addEventListener("click", (e) => {
		const diffIndex = Number(e.target.dataset.diff);
		if (!isNaN(diffIndex)) {
			leftEditor.scrollToDiff(diffIndex);
			rightEditor.scrollToDiff(diffIndex);
		}
	});

	disableAlignedMode();

	function syncScrollPosition(sourceEditor) {
		if (_syncingScroll) {
			return;
		}
		_syncingScroll = true;

		const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
		let sourceAnchor = null;
		let targetAnchor = null;

		sourceAnchor = sourceEditor.getNearestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
		if (sourceAnchor) {
			const anchorIndex = Number(sourceAnchor.dataset.anchor);
			targetAnchor = targetEditor.anchorElements[anchorIndex];
		}

		if (sourceAnchor && targetAnchor) {
			const prevLastScrolledEditor = _lastScrolledEditor;
			const sourceWrapper = sourceEditor.wrapper;
			const targetWrapper = targetEditor.wrapper;
			targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop + TOPBAR_HEIGHT;
			_lastScrolledEditor = prevLastScrolledEditor;
		}

		requestAnimationFrame(() => {
			_syncingScroll = false;
		});
	}

	function highlightDiff(diff) {
		highlightStyle.textContent = `mark[data-diff="${diff}"], mark[data-diff="${diff}"]::after { 
box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
animation: highlightAnimation 0.3s linear 3; 
}`;
	}

	document.addEventListener("mouseover", (e) => {
		if (e.target.dataset.diff !== undefined) {
			const diff = Number(e.target.dataset.diff);
			highlightDiff(diff);
		}
	});

	document.addEventListener("mouseout", (e) => {
		if (e.target.dataset.diff !== undefined) {
			highlightStyle.textContent = "";
		}
	});

	syncScrollToggle.addEventListener("click", () => {
		_syncEditor = !_syncEditor;
		updateButtons();
	});

	alignedModeToggle.addEventListener("click", () => {
		if (_alignedMode) {
			disableAlignedMode();
		} else {
			enableAlignedMode();
		}
	});

	function updateButtons() {
		syncScrollToggle.setAttribute("aria-pressed", _syncEditor);
		alignedModeToggle.setAttribute("aria-pressed", _alignedMode);
	}

	return {
		get alignedMode() {
			return _alignedMode;
		},

		set alignedMode(value) {
			if (!!value) {
				enableAlignedMode();
			} else {
				disableAlignedMode();
			}
		},
		get dump() {
			return {
				diffs: _diffs,
				anchors: _anchors,
				leftEditor,
				rightEditor,
			};
		},
	};
})();

function debounce(func, delay) {
	let timeoutId;

	return function (...args) {
		const context = this;
		clearTimeout(timeoutId);
		timeoutId = setTimeout(function () {
			func.apply(context, args);
		}, delay);
	};
}
</script>
</body>

</html>

