<!DOCTYPE html>
<!--
# DiffSeek 
#### ê°œìš”
- ì •ë§ ì„¼ìŠ¤ë§Œì  ì´ë¦„. ì¤‘êµ­ì‚° DeepSeek ì•„ë‹˜.
- ì—…ë¬´ë§¤ë‰´ì–¼ ë¹„êµì˜ ì••ë°• ë•Œë¬¸ì— ê°œë°œ...ì´ë¼ê³  í•˜ë©´ ë„ˆë¬´ ê±°ì°½í•˜ê³  ê·¸ëƒ¥ í•œë²ˆ ì§œë´¤ìŒ.
- ê¸°ë³¸ì ìœ¼ë¡œ Histogram ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©. ë¸Œë¼ìš°ì € ê°œë°œíˆ´ ì½˜ì†”ì—ì„œ `DiffSeek.diffOptions.algorithm = "histogram|lcs|myers"` ë­ ì´ë ‡ê²Œ ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ì§€ë§Œ... `myers` ì•Œê³ ë¦¬ì¦˜ì€ ì•„ì§ ì œëŒ€ë¡œ ì™„ì„± ëª»ì‹œì¼°ê³ (ì‚´ì§ ì–´ë ¤ì›€) `lcs`ëŠ” ì¡°ê¸ˆ ëŠë¦¼.
- ê³µë°± ë¬´ì‹œ. ê³µë°±ì„ ì™„ì „íˆ ë¬´ì‹œí•˜ëŠ”ê±´ ì™„ì „íˆ ì˜ë„ëœ ê²ƒì„. **ì—…ë¬´ë§¤ë‰´ì–¼ì˜ ì¤„ë°”ê¿ˆ ìœ„ì¹˜ëŠ” ì ˆëŒ€ë¡œ ë¬¸ì¥ì˜ ë í˜¹ì€ ë‹¨ë½ì˜ ëê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŒ!**(`DiffSeek.diffOptions.whitespace = "ignore|normalize"`). ì°¸ê³ ë¡œ ê³µë°±ì„ ì „í˜€ ë¬´ì‹œí•˜ì§€ ì•Šê±°ë‚˜ ì •ê·œí™”(ì—¬ëŸ¬ê°œì˜ ì—°ì†ëœ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì¸ì‹)í•´ì„œ ë¹„êµí•˜ëŠ” ì½”ë“œë¥¼ ì§œëŠ”ê²Œ 100ë§Œë°° ì‰¬ì›€.
- ë‹¨ì–´ ë‹¨ìœ„ diff. ê¸€ì ë‹¨ìœ„ diffëŠ” ì„±ëŠ¥ë„ ì„±ëŠ¥ì´ì§€ë§Œ ì‚¬ëŒì˜ ëˆˆì— ì˜¤íˆë ¤ ë” í”¼ê³¤í•˜ê¸°ë§Œ í•¨. ì¤„ ë‹¨ìœ„ì˜ ê²½ìš°ë„ ë¬¸ì„œë§ˆë‹¤ ì¤„ë°”ê¿ˆì˜ ìœ„ì¹˜ê°€ ì§€ë©‹ëŒ€ë¡œë¼ ë¹„íš¨ìœ¨ì ì„(`DiffSeek.diffOptions.tokenization = "char|word|line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

#### êµ¬í˜„ ì˜ë„? ì°¸ê³ ì‚¬í•­?
- ì–‘ìª½ì— í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê³  ì‹¤í–‰ë²„íŠ¼ ë”±~ ëˆ„ë¥´ë©´ diffë“¤ì´ í‘œì‹œë˜.... *ì™œ???? ë²„íŠ¼ì„ ë­í•˜ëŸ¬ ëˆŒëŸ¬?* **diffëŠ” í…ìŠ¤íŠ¸ ë³€ê²½ì‹œ ì‹¤ì‹œê°„ìœ¼ë¡œ, ì…ë ¥í•œ í…ìŠ¤íŠ¸ ë°”ë¡œ ê·¸ ìë¦¬ì—ì„œ ë³´ì—¬ì¤˜ì•¼ í•¨!!**(ì‚¬ì‹¤ ì…ë ¥ê³¼ ê²°ê³¼viewë¥¼ ë¶„ë¦¬í•˜ë©´ ê²°ê³¼viewëŠ” ë” ììœ ë¡­ê²Œ ê¸°ëŠ¥ë„ ë¹µë¹µí•˜ê²Œ ê·¸ë¦¬ê³  ë” ì‰½ê²Œ ë§Œë“¤ ìˆ˜ëŠ” ìˆìŒ).
- ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ê°€ ì¼ì–´ë‚˜ëŠ” ë„ì¤‘ì—ë„ í¸ì§‘ì„ ë°©í•´í•˜ë©´ ì•ˆë¨. ë¯¸ì„¸í•œ ë”œë ˆì´ë¼ë“ ì§€ ì˜ë„í•˜ì§€ ì•Šì€ ì»¤ì„œìœ„ì¹˜ ë³€ê²½, í•œê¸€ì…ë ¥ìƒíƒœ ë³µì› ë“±ë“±(í•œê¸€ì…ë ¥ìƒíƒœ ë³µì› ë°©ë²•ì€ ì—†ë‹¤ ë³´ë©´ ë¨. ìš°íšŒí•˜ëŠ” ë°©ë²•ì€ ì—…ë°ì´íŠ¸ë¥¼ ì•ˆí•˜ëŠ”ê²ƒ, ìµœì†Œí•œ ì»¤ì„œê°€ ìˆëŠ” ë…¸ë“œì— ëŒ€í•´ì„œëŠ” ì—…ë°ì´íŠ¸ë¥¼ ì•ˆí•˜ê³  ë¯¸ë£¨ëŠ” ë°©ë²•ì´ ê±°ì˜ ìœ ì¼í•¨).
- ì—…ë°ì´íŠ¸ë§ˆë‹¤ DOMì„ ì™„ì „íˆ ì‹¹ ê°ˆì•„ì—ì§€ ë§ê³  ê°€ëŠ¥í•œ ê²½ìš° ê¸°ì¡´ ë…¸ë“œë“¤ì„ ì¬ì‚¬ìš© í•  ê²ƒ.
- í¸ì§‘ê¸°(ì‚¬ì‹¤ ê·¸ëƒ¥ í…ìŠ¤íŠ¸ ì…ë ¥ì°½ã…‹)ì˜ ê¸°ë³¸ì ì¸ ê¸°ëŠ¥(ë³µë¶™,undo/redo,...)ë“¤ì€ ë˜ë„ë¡ ë¸Œë¼ìš°ì €ì—ê²Œ ë„˜ê¸¸ ê²ƒ. ì´ëŸ° ê¸°ëŠ¥ë“¤ì€ ìˆ¨ì‰¬ê¸°ì™€ ê°™ì•„ì„œ ì˜ˆìƒëŒ€ë¡œ ì‘ë™ ì•ˆí•˜ëŠ” ìˆœê°„ ì§œì¦ ì†Ÿêµ¬ì¹¨. ë˜í•œ ë‚˜ì²˜ëŸ¼ ê¹ê¹í•œ ì‚¬ëŒì—ê²Œ ì–´ìƒ‰í•¨ì´ ì•ˆëŠê»´ì§ˆë§Œí¼ ì œëŒ€ë¡œ êµ¬í˜„í•˜ê¸°ëŠ” ì‰½ì§€ ì•ŠìŒ(ì»¤ì„œìœ„ì¹˜, í…ìŠ¤íŠ¸ì„ íƒë²”ìœ„, ìŠ¤í¬ë¡¤ ìœ„ì¹˜, ì–¼ë§ˆë‚˜ ë§ì€ í¸ì§‘ì„ í•˜ë‚˜ì˜ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ë¡œ ë¬¶ì„ ê²ƒì¸ê°€, ì–‘ìª½ í¸ì§‘ê¸°ë¥¼ ì™”ë‹¤ê°”ë‹¤ í–ˆì„ ë•Œ, ...).
- ìœ„ì™€ ê°™ì€ ì´ìœ ë¡œ í¸ì§‘ê¸°ì™€ ì‹¤ì œë¡œ diffê°€ í•˜ì´ë¼ì´íŠ¸ë˜ëŠ” ì˜ì—­(mirror)ì„ ë¶„ë¦¬ì‹œí‚´.
- í¬ê¸°ê°€ í° í…ìŠ¤íŠ¸(5ë§Œê¸€ì ì´ìƒ)ë¥¼ ë¹„êµí•  ë•Œì—ë„ í¸ì§‘ê¸°ê°€ ì¶©ë¶„íˆ(ì•„ì£¼ ì¶©ë¶„íˆ) ë°˜ì‘ì ì¼ ê²ƒ. ë”œë ˆì´ ìµœì†Œí™”! ë‹¨ìˆœ debouncingì´ ì•„ë‹ˆë¼ ê·¸ ì´ìƒì´ í•„ìš”.
- ë‹¤ë¥¸ ë¬¸ì(ë¬¸ìcodeê°€ ë‹¤ë¥¸ ê²½ìš°)ì§€ë§Œ ê°™ë‹¤ê³  ì—¬ê²¨ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ë„ ì²˜ë¦¬í•˜ì˜€ì§€ë§Œ ì´ê±´ ì´ëŸ¬í•œ ë¬¸ìë“¤ì„ ì§ì ‘ ì¶”ê°€í•´ì¤˜ì•¼í•¨(`constants.ts/NORMALIZE_CHARS`).
- (ì¶”ê°€),(ì‹ ì„¤),(í˜„í–‰ê³¼ ê°™ìŒ),(ì‚­ì œ) ë“±ì€ wildcardë¡œ ì²˜ë¦¬. ì´ í† í°ë“¤ì€ ê´„í˜¸ ì•ˆ ê³µë°±ì„ ë¬´ì‹œí•˜ê³  ì ˆëŒ€ë¡œ ì¤‘ê°„ì—ì„œ ì•ˆì˜ë¦¬ê²Œ('(í˜„í–‰ê³¼','ê°™ìŒ)'ì´ ë˜ì§€ ì•Šê²Œ) ë§Œë“¤ì–´ë†¨ì§€ë§Œ ì•„ì§ì€ ë”± ê±°ê¸°ê¹Œì§€ì„.
- diff í•˜ì´ë¼ì´íŠ¸ ìƒ‰ë“¤ì€ ì •ë§ ì„¸ì‹¬í•˜ê²Œ ê³ ë¥¸ ê²ƒë“¤ì„. ì ˆëŒ€ ë¶ˆë§Œì„ ê°€ì ¸ì„œëŠ” ì•ˆë¨. ë¹¨ê°„ìƒ‰ ê³„í†µì€ ë°°ê²½ê³¼ í™•ì‹¤íˆ ëŒ€ë¹„ë˜ì§€ ì•Šì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì˜ë„ì ìœ¼ë¡œ ì œì™¸(`constants.ts/DIFF_COLOR_HUES`).
- í° ì›Œë“œë¬¸ì„œì—ì„œ ë³µë¶™ì„ í•  ë•Œì— ë³µì‚¬ê°€ ë°”ë¡œ ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìˆëŠ”ë° ì ˆëŒ€ì ìœ¼ë¡œ MSì›Œë“œì˜ ë¬¸ì œì„. ë ë•Œê¹Œì§€ ë¶™ì—¬ë„£ê¸° í•˜ë©´ ì–¸ì  ê°€ëŠ” ëœë‹¤(ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ì›Œë“œëŠ” ë¨¹í†µë¨).
- ê°œì •ëŒ€ë¹„í‘œvsì „ë¬¸, ì „ë¬¸vsì „ë¬¸ **ì „ì²´ë¥¼ í•œë²ˆ**ì— ë³µ/ë¶™í•´ì„œ ë¹„êµí•  ìˆ˜ ìˆì–´ì•¼í•¨(ìˆ˜ì‹­ë²ˆì”© ë“œë˜ê·¸,ë³µ/ë¶™ì„ í•˜ëŠ” ê²ƒë³´ë‹¤ëŠ” ë¬´ì¡°ê±´ í¸í•¨!!). ê·¸ë˜ì„œ ë§Œë“ ê²Œ  Aligned Mode
- ì—£ì§€(í˜¹ì€ í¬ë¡¬) ì „ìš©. ì¸ê°„ì ìœ¼ë¡œ 2025ë…„ì— ieë¥¼ ì™œ ì¨ì•¼í•˜ì§€?

#### Aligned Mode
- ì´ë¦„ì€ ë§˜ì— ì•ˆë“¤ì§€ë§Œ ì•”íŠ¼ ì–‘ìª½ í…ìŠ¤íŠ¸ì—ì„œ ì„œë¡œ ëŒ€ë¹„ë˜ëŠ” ì¤„ë“¤ì˜ ìœ„ì¹˜ë¥¼ ê°™ê²Œ ë§ì¶°ì£¼ëŠ” ê¸°ëŠ¥. `F2`ë¡œ í† ê¸€.
- ì–‘ìª½ ìŠ¤í¬ë¡¤ ë™ê¸°í™”ë¨.
- readonly ëª¨ë“œì„(í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•˜ê³  ê°„ë‹¨í•œ ìˆ˜ì •ì„ ì‹œë„í•˜ë©´ ê¸°ë³¸ ëª¨ë“œë¡œ ì „í™˜ë˜ë©´ì„œ ìˆ˜ì •ì´ ë˜ê²ŒëŠ” í•´ë†¨ìŒ).
- Aligned ModeëŠ” ê¹Œë§Œ ë°°ê²½ì„(ê¸°ë³¸ ëª¨ë“œì™€ í™•ì‹¤íˆ ëŒ€ë¹„ë˜ëŠ” ëŠë‚Œì´ ìˆì–´ì•¼ í–ˆìŒ).
- ë‘ ëª¨ë“œë¥¼ ì „í™˜í• ë•Œ ì„ íƒëœ í…ìŠ¤íŠ¸ì˜ ë²”ìœ„ë¥¼ ìœ ì§€í•˜ë ¤ê³  ë…¸ë ¥í•œ ë¶€ë¶„ì€ ì¹­ì°¬ ë°›ì•„ì•¼ í•¨(ìˆ˜ê³ í–ˆì–´~).
- ì»¨íŠ¸ë¡¤ í‚¤ë¥¼ ëˆ„ë¥¸ì±„ë¡œ í…ìŠ¤íŠ¸ë¥¼ í´ë¦­í•˜ë©´ ê¸°ë³¸ ëª¨ë“œë¡œ ì „í™˜ë˜ë©´ì„œ í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì»¤ì„œë¥¼ ì˜®ê¹€(ìˆ˜ê³ í–ˆì–´~).
- ì–‘ìª½ diffë¶€ë¶„ì„ ë¸”ëŸ­ë‹¨ìœ„ë¡œ í‘œì‹œí•  ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ê·¸ëŸ¬ë ¤ê³  ë…¸ë ¥(!)í–ˆìŒ.
- ì–‘ìª½ ëŒ€ë¹„(ë§¤ì¹˜)ë˜ëŠ” ë¶€ë¶„ì˜ ìœ„ì¹˜ì˜ ì°¨ì´ëŠ” paddingìš”ì†Œë¥¼ ë„£ì–´ì„œ ë©”ê¿ˆ. TODO: ì—¬ëŸ¬ê°œì˜ ë¹ˆì¤„ë¡œ ì¸í•´ ë°œìƒí•˜ëŠ” ìœ„ì¹˜ ì°¨ì´ëŠ” paddingì´ ì•„ë‹ˆë¼ ë¹ˆì¤„ë“¤ì„ collapseí•˜ëŠ” ìª½ìœ¼ë¡œ í•´ì•¼ ë” ë³´ê¸° ì¢‹ì„ ê²ƒ ê°™ìŒ.

#### ì¸í„°ë„·ë„ ì•ˆë˜ê³  ì•„ë¬´ê²ƒë„ ì—†ëŠ”... ìˆëŠ” ê±°ë¼ê³¤ ë¸Œë¼ìš°ì €, ë©”ëª¨ì¥ ë°–ì— ì—†ëŠ” íšŒì‚¬ pcì—ì„œ ëŒë ¤ì•¼í•¨.
- html + css + jsëŠ” ì–´ì©” ìˆ˜ ì—†ëŠ” ì„ íƒ. ë¦¬ì•¡íŠ¸ ê°™ì€ê±´ ìƒìƒë„ ëª»í•¨. html css jsë¡œ êµ¬í˜„
- ë‹¹ì—°íˆ ì›¹ì„œë²„ ë¶ˆê°€ëŠ¥ì´ê³  file:///...../diffseek.html ê²½ë¡œë¡œ ì—´ì–´ì•¼í•¨. ì œì•½ ë§ìŒ.
- ì„¬ì„¸í•˜ê³  ì´ìœ UIìš”ì†Œê°€ ë¶€ì¡±í•œ ê²ƒì€ ì ˆëŒ€ì ìœ¼ë¡œ ì´ ë•Œë¬¸ì„. ìš”ìƒˆ ëˆ„ê°€ UIìš”ì†Œë¥¼ í•˜ë‚˜í•˜ë‚˜ ì†ìˆ˜ ë§Œë“œë‚˜...
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¡œ ì‘ì„±í•˜ê³  ì»´íŒŒì¼ëœ jsë¥¼ ì˜®ê¸°ëŠ” ê±´ ê°€ëŠ¥.
- ë‹·ë„·, java ëŸ°íƒ€ì„ì€ ê¹”ë ¤ìˆëŠ” ê²ƒ ê°™ì§€ë§Œ ê·¸ ë¿ì„. sdkê°€ ì—†ìŒ.
- ì¸ê°„ì ìœ¼ë¡œ vscodeì •ë„ëŠ” ê¹”ì•„ì£¼ë©´ ì•ˆë˜ë‚˜...

#### ì§‘ì—ì„œ ë§Œë“  ì½”ë“œë¥¼ íšŒì‚¬ë¡œ ì˜®ê¸°ëŠ” ë°©ë²•?
- ì›Œí¬ë¹„ ìª½ì§€/ë‚´ë¶€ë©”ì¼ë¡œ ë³´ë‚´ê³  íšŒì‚¬ì—ì„œ ì—´ì–´ì„œ ë©”ëª¨ì¥ì— ë¶™ì—¬ë„£ê¸°. ê³ ë¡œ ì½”ë“œê°€ ë„ˆë¬´ ì»¤ì§€ë©´ ì•ˆë¨. ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬? ì–´ë¦¼ë„ ì—†ìŒ.
- ë‹¤í–‰íˆë„ íœ´ëŒ€í° ì›Œí¬ë¹„ ì•±ì—ì„œ ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ë¥¼ ì‚¬ìš©í•  ë°©ë²•ì´ ìˆë”ë¼(ë¹„ë°€ ìœ ì§€ í•„ìš”..ã…‹ ì´ê±° ë§‰íˆë©´ ë”ì´ìƒì˜ ì—…ë°ì´íŠ¸ëŠ” ë¶ˆê°€ëŠ¥í•¨).
- ì˜®ê¸°ê¸° ì „ì— í•˜ë‚˜ì˜ íŒŒì¼(diffseek.html)ë¡œ í•©ì¹œ í›„ì— ê·¸ íŒŒì¼ì˜ ë‚´ìš©ì„ ì˜®ê²¨ì•¼í•¨. ì§€ê¸ˆì¯¤ ë¹Œë“œëœ íŒŒì¼ì´ 4000ì¤„ì´ ë„˜ì„ì§€ë„ ëª¨ë¥´ë‹ˆ ë‘ì–´ë²ˆì— ê±¸ì³ ë‚˜ëˆ ì„œ ë³µë¶™ í•„ìš”.
- build, distí´ë”ë¥¼ ëª¨ë‘ gitì— í¬í•¨í•œ ê²ƒì€ ì´ëŸ¬í•œ ì´ìœ ì„(ë‚˜ëˆ ì„œ ë³µë¶™í•˜ë‹¤ê°€ í•œì¤„ ë¹¼ë¨¹ì€ ê²½ìš°ì— íœ´ëŒ€í°ìœ¼ë¡œ githubì˜ ì½”ë“œì™€ ë¹„êµí•´ë´ì•¼í•¨).
- ì»´íŒŒì¼ëœ .jsíŒŒì¼ì— ì£¼ì„ì„ ë‚¨ê¸°ëŠ” ê²ƒë„ íšŒì‚¬ì—ì„œ ë””ë²„ê¹…ì„ í•´ì•¼ë˜ëŠ” ê²½ìš°ê°€ ìˆê¸° ë•Œë¬¸. íšŒì‚¬ì—ì„œ ìˆ˜ì •í•œ ê±¸ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ëŠ”ê±´ ì‰½ì§€ ì•ŠìŒ. ì–´ëŠ ë¶€ë¶„ì„ ì–´ë–»ê²Œ ìˆ˜ì •í–ˆëŠ”ì§€ ê¸°ì–µí•´ì•¼í•¨. ì˜¤ëŠ˜ ë¨¹ì€ ë°˜ì°¬ë„ ê¸°ì–µ ì•ˆë‚¨.

#### ë¸Œë¼ìš°ì €ì—ì„œ ì›¹ ì£¼ì†Œê°€ ì•„ë‹Œ íŒŒì¼ì„ ì—¬ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ë³´ì•ˆìƒ ì œì•½ì´ ë§ìŒ.
- ì¿ í‚¤? localStorage? ... ê·¸ê²Œ ë˜ê² ë‹ˆ? ìƒíƒœ/ì˜µì…˜ ì €ì¥í•˜ëŠ”ê±´ ë¶ˆê°€ëŠ¥.
- new Worker(url) - íŒŒì¼ urlì„ ì—´ ìˆ˜ ì—†ìŒ(ê·¸ë˜ì„œ workerë¥¼ ì“°ë ¤ë©´ ì•½ê°„ì˜ íŠ¸ë¦­ í•„ìš”)
- ê·¸ ì™¸ 'ì´ê²Œ ë ê¹Œ?' ì‹¶ì€ ê²ƒë“¤ì€ ì•ˆëœë‹¤ê³  ë³´ë©´ ë¨
- ìŠ¤í¬ë¦½íŠ¸ë¡œ ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ë¥¼ ì‹¤í–‰í•  ë•Œì˜ ê²½ê³ ëŠ” ì—£ì§€ ì„¤ì •-whitelistì— ë“±ë¡í•´ì„œ í”¼í•  ìˆ˜ ìˆê¸°ëŠ” í•¨. ì§€ê¸ˆì€ ê´€ë ¨ ê¸°ëŠ¥ë“¤ì„ ë‹¤ ì§€ì›Œë²„ë ¸ìœ¼ë‹ˆê¹Œ í•„ìš” ì—†ì§€ë§Œ ë‹¤ì‹œ ë„£ì„ê¹Œí•¨(ë‹¨ì¶•í‚¤ë¡œ ì™¼ìª½ì°½/ì˜¤ë¥¸ìª½ì°½ ì„ íƒì—†ì´ ë°”ë¡œ ë¶™ì—¬ë„£ê¸° ë“±)

#### ë‹¨ì¶•í‚¤?
- F2 - aligned mode í† ê¸€(ì–‘ìª½ ì¤„ë§ì¶¤, ìŠ¤í¬ë¡¤ ë™ê¸°í™”, í¸ì§‘ ë¶ˆê°€)
- SHIFT-F2 - scroll sync í† ê¸€(ì•½ê°„ì˜ ì¤„ë§ì¶¤, ì•½ê°„ì˜ ìŠ¤í¬ë¡¤ ë™ê¸°í™”, í¸ì§‘ ê°€ëŠ¥)
- ctrl-1/ctrl-2 í¸ì§‘ê¸°ì— í¬ì»¤ìŠ¤
- í¸ì§‘ ì¤‘ì— ctrl-space - ë°˜ëŒ€ìª½ í¸ì§‘ê¸°ì˜ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¥¼ í˜„ì¬ í¸ì§‘ê¸°ì— ë§ì¶¤(ê°€ëŠ¥í•œ ê²½ìš°)

#### histogram ì•Œê³ ë¦¬ì¦˜
- ê°€ì¥ ë§ì´ ì“°ì´ëŠ” ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì¸ ê²ƒ ê°™ìŒ.
- ì´ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œê±´ ê³µí†µ ì•µì»¤ë¥¼ ê·¸ê²ƒë„ ì•„ì£¼ ì¢‹ì€ë†ˆìœ¼ë¡œ ì°¾ëŠ” ë¶€ë¶„ì¸ ê²ƒ ê°™ì€ë° ìƒê°í•  ê²ƒì´ ë§ìŒ. ê° ì„¹ì…˜ì˜ ì œëª©(1. ê°œìš”, 2. ì—…ë¬´ì²˜ë¦¬ ìˆœì„œ, ...)ì— ê°€ì¤‘ì¹˜ë¥¼ ì£¼ë ¤í–ˆì§€ë§Œ í•´ë‹¹ ì œëª©ë“¤ì€ ì—…ë¬´ë§¤ë‰´ì–¼ ì›Œë“œíŒŒì¼ì—ì„œ ë§¨ ì•ì— ì ë ¤ìˆëŠ” ê²½ìš°(ì œëª©ì„ ì™¼ìª½ ì»¬ëŸ¼ì— ë„£ê³  ì—”í„°í‚¤ ìˆ˜ì‹­ë²ˆ ëˆŒëŸ¬ì„œ ì„¹ì…˜ì„ ë‚˜ëˆˆ ê²½ìš°)ê°€ ë§ì•„ì„œ ì˜ë¯¸ ì—†ìŒ. (1), (ê°€), 1), ê°€)ì—ëŠ” ì ìš©í–ˆì§€ë§Œ ì–¼ë§ˆë‚˜ ì •í™•í•˜ê³  íš¨ìœ¨ì ì¼ì§€ ê°ì´ ì•ˆì™€ì„œ ê°€ì¤‘ì¹˜ë¥¼ ë†’ê²Œ ì£¼ì§€ ì•Šì•˜ìŒ.
- ìµœìš°ì„ ìˆœìœ„ ì•µì»¤ `@@@`, `###` (ë°œê²¬ì‹œ ë¬´ì¡°ê±´ ì–‘ìª½ í…ìŠ¤íŠ¸ì— ë‚˜ì˜¤ëŠ” ì´ ì•µì»¤ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë§¤ì¹˜ì‹œí‚´). ê°ì´ ì•ˆì˜¤ë©´ ì–‘ìª½ì— ê°™ì€ í…ìŠ¤íŠ¸ë¥¼ ë³µë¶™í•´ë†“ê³  ì™¼ìª½ì—ëŠ” ë§¨ìœ—ì¤„ì— `@@@`, ì˜¤ë¥¸ìª½ì€ ë§¨ì•„ë«ì¤„ì— `@@@`ë¥¼ ì…ë ¥í•´ë³´ê¸°. ë‹¹ì—°íˆ ê³µë°±ì´ë‚˜ ì¤„ë°”ê¿ˆìœ¼ë¡œ ë‹¤ë¥¸ ê¸€ìì™€ ë¶„ë¦¬ê°€ ë˜ì–´ì•¼í•¨.
- ê·¸ì™¸  ì¤„ì˜ ì‹œì‘/ë ë¶€ë¶„ì— ê°€ì¤‘ì¹˜, í¬ê·€ë„ì— ê°€ì¤‘ì¹˜, ë¬¸ìì—´ ê¸¸ì´ì— ê°€ì¤‘ì¹˜.
- ë‹¨ìˆœíˆ ë‹¨ì–´vsë‹¨ì–´ ë¿ë§Œ ì•„ë‹ˆë¼ nê·¸ë¨(ë³µìˆ˜ê°œì˜ ë‹¨ì–´ ë§¤ì¹˜), nê°œì˜ ë‹¨ì–´ì™€ mê°œì˜ ë‹¨ì–´(ë‹¨ì–´ ìˆ˜ê°€ ë‹¤ë¥´ì§€ë§Œ ê³µë°±ì„ ë¬´ì‹œí•˜ê³  ë¹„êµí•  ê²½ìš° ê°™ì€ ë‹¨ì–´ë“¤)ë„ ë§¤ì¹˜ë˜ëŠ” ê²½ìš°ì—ë„ ì•µì»¤ë¡œ ì‚¬ìš©í•˜ë ¤ê³  ë…¸ë ¥...ì€ í•¨.
- ë‚´ ìƒê°ì— ê³µí†µprefix/suffixë¥¼ ìŠ¤í‚µí•˜ëŠ” ë¶€ë¶„ ë•Œë¬¸ì— ìµœê³ ë¡œ ì¢‹ì€ ì•µì»¤ë¥¼ ì°¾ì„ ê¸°íšŒë¥¼ ë†“ì¹˜ëŠ” ê²½ìš°ë„ ìƒê¸¸ ìˆ˜ ìˆì„ ê²ƒ ê°™ì§€ë§Œ ìŠ¤í‚µ ì•ˆí•˜ë©´ ì„±ëŠ¥ ê°œíŒ ë¨. ì ˆëŒ€ì ìœ¼ë¡œ í•„ìš”.

-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script>"use strict";
// DIFF ìƒ‰(HUE). 0(ë¹¨)ì€ DIFF ë°°ê²½ìƒ‰ìœ¼ë¡œ ì“°ì´ë‹ˆ íŒ¨ìŠ¤
// ì™„ì „í•œ ìƒ‰ìƒ ì½”ë“œë³´ë‹¤ HUEë§Œ ì‚¬ìš©í•˜ë©´ ìš©ë„ì— ë”°ë¼ ìƒ‰ì„ ì¡°ì ˆí•˜ê¸° ì‰¬ì›€.
// ì¸ì ‘í•œ ìƒ‰ìƒê³¼ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šë„ë¡ ì•„ì£¼ CAREFULí•˜ê²Œ ê³ ë¥¸ ìˆœì„œ. ê³¼í•™ì´ë‹¤.
const DIFF_COLOR_HUES = [
    30, // ì£¼í™©?
    180, // cyan
    300, // í•‘í¬?
    120, // ì´ˆë¡
    240, // íŒŒë‘
    60, // ë…¸ë‘
    270, // ë³´ë¼?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 20;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;
// ì–´ì°¨í”¼ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬ë˜ê³  ê¸°ì¡´ ì‘ì—…ì´ ì·¨ì†Œì‹œí‚¨ í›„ì— ì‹œì‘ë˜ë‹ˆ ë„ˆë¬´ í¬ê²Œ ì¡ì„ í•„ìš”ëŠ” ì—†ì„ ë“¯
const COMPUTE_DEBOUNCE_TIME = 100; // ms
const FORCE_RENDER_TIMEOUT = 300; // ms
// ë¬¸ì¥ë¶€í˜¸ë‚˜ íŠ¹ìˆ˜ë¬¸ìë¥¼ ì •ê·œí™” í•˜ê¸° ìœ„í•´ì„œ...
// ë”°ì˜´í‘œ, ì¤‘ê°„ì  ë“±ë“±ë“± ë¬¸ìì½”ë“œëŠ” ë‹¤ë¥´ì§€ë§Œ ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼ ë  ë¬¸ìë“¤ì´ ë§ìŒ.
// length===1ì¸ ë¬¸ìëŠ” ê·¸ëƒ¥ ë¬¸ì
// ìˆ«ìëŠ” charCode
// &ë¡œ ì‹œì‘í•˜ë©´ html ì—”í‹°í‹°
// TODO: ê°ì¢… í™”ì‚´í‘œ íŠ¹ìˆ˜ë¬¸ìë“¤...
const NORMALIZE_CHARS = [
    ['"', "â€œ", "â€", "'", "â€˜", "â€™"],
    ["-", "â€“", "â€”"],
    [".", "â€¤"],
    ["â‹…", "Â·", "â€¢"], // &middot;ê³¼ &bullet;(&bull;)ì€ ë‹¤ë¥¸ ê±¸ë¡œ ì—¬ê²¨ì•¼í•˜ì§€ ì•Šì„ê¹Œ? middotëŒ€ì‹  bulletì„ ì“°ë©´ ì ì´ ë„ˆë¬´ ì™•ì ì´ë¼ ë³´ê¸° í‰í•œë°...
    ["â€¦", "â‹¯"],
    ["(", "ï¼ˆ"], // ì´ëŸ° ê±¸ êµ³ì´ íŠ¹ìˆ˜ë¬¸ìë¡œ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì´ ìˆë‹¤ê³ ?? ë¯¿ê¸° í˜ë“¤ì§€ë§Œ ìˆë”ë¼...
    [")", "ï¼‰"],
    ["[", "ï¼»"],
    ["]", "ï¼½"],
    ["{", "ï½›"],
    ["}", "ï½"],
    ["<", "ï¼œ"],
    [">", "ï¼"],
    ["-", "ï¼"], // ì™œ êµ³ì´... ì´ëŸ° ë¬¸ìë¥¼...? ìˆ˜ì‹í¸ì§‘ê¸° ê°™ì€ ê²ƒì—ì„œ ì´ëŸ° ë¬¸ìë¥¼ ë±‰ì–´ë‚´ëŠ” ê±´ê°€...?
    ["=", "ï¼"],
    ["+", "ï¼‹"],
    ["*", "ï¼Š", "âœ±", "x"], // xì™€ *ì„ ê°™ì€ ë¬¸ìë¡œ ì·¨ê¸‰í•˜ëŠ” ê±´ ì¡°ê¸ˆ ìœ„í—˜í•˜ì§€ë§Œ ê°™ì€ ìœ„ì¹˜ì— ì´ ë¬¸ìê°€ ê°ê° ì‚¬ìš©ëœë‹¤ë©´ ê³±ì…ˆ ê¸°í˜¸ë¡œ ì‚¬ìš©í•˜ë ¤ëŠ” ì˜ë„ëŠ” ë»”í•˜ì§€ ì•Šì€ê°€?
    ["/", "ï¼", "Ã·"], // ë§ˆì°¬ê°€ì§€
    ["\\", "ï¼¼", "â‚©"], // ì—­ì‹œ ë§ˆì°¬ê°€ì§€. ê³ ì •í­ì´ ì•„ë‹Œ ëŒ€ë¶€ë¶„ì˜ í•œê¸€ í°íŠ¸ì—ì„œëŠ” ì›í™” ë§ˆí¬ë¡œ í‘œì‹œë˜ê³  ì•„ë§ˆ ë¬¸ì„œì—ì„œë„ ê·¸ ì˜ë„ë¡œ ì‚¬ìš©ëì„ ê²ƒì„!
    ["&", "ï¼†"],
    ["#", "ï¼ƒ"],
    ["@", "ï¼ "],
    ["$", "ï¼„"],
    ["%", "ï¼…"],
    ["^", "ï¼¾"],
    ["~", "ï½"],
    ["`", "ï½€"],
    ["|", "ï½œ"],
];
const PROCESSING_MESSAGES = [
    "í•œë•€í•œë•€ ë¹„êµ ì¤‘...",
    "ì¸ë‚´ì‹¬ í…ŒìŠ¤íŠ¸ ì¤‘...",
    "ìƒê° ì¤‘...",
    "ì¬ë¶€íŒ… ì¤€ë¹„ ì¤‘...",
    "ë¬´í•œ ë£¨í”„ ì¤‘...",
    "ë¨¸ë¦¬ ê¸ëŠ” ì¤‘...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "í‡´ê·¼ ì¤€ë¹„ ì¤‘...",
];
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
const STYLE_NONE = 0;
const STYLE_COLOR_DEFAULT = 1 << 0;
const STYLE_COLOR_RED = 1 << 1;
const STYLE_MASK_COLOR = STYLE_COLOR_DEFAULT | STYLE_COLOR_RED;
const reddishCache = new Map([
    ["red", true],
    ["#ff0000", true],
    ["#e60000", true],
    ["#c00000", true],
    ["rgb(255,0,0)", true],
    ["rgb(230,0,0)", true],
    ["#000000", false],
    ["#333333", false],
    ["#ffffff", false],
    ["black", false],
    ["blue", false],
    ["white", false],
    ["window", false],
    ["windowtext", false],
    // ê¸°íƒ€ ë“±ë“±?
]);
let _ctx = null;
// ìº”ë²„ìŠ¤ëŠ” ë§ì´ ëŠë¦´í…Œë‹ˆê¹Œ ìµœëŒ€í•œ ì •ê·œì‹ì„ ìš°ì„  ì”€!
// ì •ê·œì‹ì€ ìˆ˜ëª…ë‹¨ì¶•ì˜ ì§€ë¦„ê¸¸ì´ë¯€ë¡œ ì ˆëŒ€ì ìœ¼ë¡œ chatgtpí•œí…Œ ë§¡ê¸°ê³ ê³  ë””ë²„ê¹… ì‹œë„ì¡°ì°¨ í•˜ì§€ ë§ ê²ƒ.
function getRGB(color) {
    // #rrggbb
    const hex6 = /^#([0-9a-f]{6})$/i.exec(color);
    if (hex6) {
        const n = parseInt(hex6[1], 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    // #rgb
    const hex3 = /^#([0-9a-f]{3})$/i.exec(color);
    if (hex3) {
        const [r, g, b] = hex3[1].split("").map((c) => parseInt(c + c, 16));
        return [r, g, b];
    }
    // rgb(...) / rgba(...)
    const rgb = /^rgba?\(([^)]+)\)$/i.exec(color);
    if (rgb) {
        const parts = rgb[1].split(",").map((s) => parseInt(s.trim(), 10));
        if (parts.length >= 3)
            return [parts[0], parts[1], parts[2]];
    }
    // ìµœí›„..ì˜ fallback: canvas
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    try {
        _ctx.clearRect(0, 0, 1, 1);
        _ctx.fillStyle = color;
        _ctx.fillRect(0, 0, 1, 1);
        const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
        return [r, g, b];
    }
    catch {
        return null;
    }
}
function isReddish(color) {
    let isRed = reddishCache.get(color);
    if (isRed !== undefined)
        return isRed;
    console.log("no cache hit", color);
    const rgb = getRGB(color);
    isRed = rgb ? rgb[0] >= 139 && rgb[0] - Math.max(rgb[1], rgb[2]) >= 65 : false;
    reddishCache.set(color, isRed);
    return isRed;
}
const BLOCK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    HR: true,
    BR: true, // BLOCKìš”ì†Œê°€ ì•„ë‹ˆê¸´ í•œë°...
};
const TEXTLESS_ELEMENTS = {
    HR: true,
    BR: true,
    IMG: true,
    VIDEO: true,
    AUDIO: true,
    EMBED: true,
    OBJECT: true,
    CANVAS: true,
    SVG: true,
    TABLE: true,
    THEAD: true,
    TBODY: true,
    TFOOT: true,
    TR: true,
    OL: true,
    UL: true,
    DL: true,
    STYLE: true,
    HEAD: true,
    TITLE: true,
    SCRIPT: true,
    LINK: true,
    META: true,
    BASE: true,
    AREA: true,
};
// paste ì´ë²¤íŠ¸ ë•Œ ë¶™ì—¬ë„£ê¸°ë  htmlì„ ì •ë¦¬í•¨
// ê±°~ì˜~ ëª¨ë“  htmlì„ ì œê±°í•˜ê³  ì§€ê¸ˆìœ¼ë¡œì¨ëŠ” redishí•œ ìƒ‰ìƒ(ê°œì •ë˜ëŠ” ë¶€ë¶„ ê°•ì¡°ìƒ‰ìƒ‰)ë§Œ ë‚¨ê²¨ë‘ 
function sanitizeHTML(rawHTML) {
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length);
        }
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(rawHTML, "text/html");
    const body = doc.body;
    // const textProps: TextProperties[] = [];
    // let currentTextProps: TextProperties = { pos: 0, color: null, supsub: null, flags: STYLE_NONE };
    // let textPropsStack: TextProperties[] = [];
    // textProps.push(currentTextProps);
    // textPropsStack.push(currentTextProps);
    let finalHTML = "";
    let currentFlags = STYLE_COLOR_DEFAULT;
    let styleStack = [];
    function extractFlattenedHTML(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (TEXTLESS_ELEMENTS[node.parentElement.nodeName]) {
                return;
            }
            let text = node.nodeValue;
            if (BLOCK_ELEMENTS[node.parentElement.nodeName]) {
                text = text.replace(/[\r\n]/g, "");
            }
            finalHTML += escapeHTML(text);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node;
            if (el.nodeName === "BR") {
                finalHTML += "\n";
                return;
            }
            if (el.nodeName === "IMG") {
                finalHTML += "ğŸ–¼ï¸";
                return;
            }
            // let newTextProps: TextProperties | null = null;
            // let prevTextProps = currentTextProps;
            // let spanAppended = false;
            let color = null; // null: color styleì€ ìˆì§€ë§Œ ë¹¨ê°„ê³„í†µ ìƒ‰ì´ ì•„ë‹Œ ê²½ìš°
            // let pushed = false;
            let colorStyle = null;
            let pushed = false;
            let newFlags = currentFlags;
            if (el.classList.contains("red")) {
                colorStyle = STYLE_COLOR_RED;
            }
            else if (el.style?.color) {
                if (isReddish(el.style.color)) {
                    colorStyle = STYLE_COLOR_RED;
                }
                else {
                    colorStyle = STYLE_COLOR_DEFAULT;
                }
            }
            else {
                colorStyle = currentFlags & STYLE_MASK_COLOR;
            }
            if (colorStyle !== null && (currentFlags & STYLE_MASK_COLOR) !== colorStyle) {
                if (colorStyle === STYLE_COLOR_RED) {
                    color = "red";
                }
                else {
                    color = "default";
                }
                newFlags = (currentFlags & ~STYLE_MASK_COLOR) | colorStyle;
            }
            let tagName = color !== null ? "SPAN" : null;
            if (tagName && color) {
                finalHTML += `<${tagName} class="${color}">`;
            }
            else if (tagName) {
                finalHTML += `<${tagName}>`;
            }
            if (currentFlags !== newFlags) {
                styleStack.push(currentFlags);
                currentFlags = newFlags;
                pushed = true;
            }
            for (const child of el.childNodes) {
                extractFlattenedHTML(child);
            }
            if (tagName) {
                finalHTML += `</${tagName}>`;
            }
            if (BLOCK_ELEMENTS[el.nodeName]) {
                finalHTML += "\n";
            }
            if (pushed) {
                currentFlags = styleStack.pop();
            }
        }
    }
    extractFlattenedHTML(body);
    console.log("sanitized", { rawHTML, finalHTML });
    return finalHTML;
}
function flattenHTML(rootNode) {
    console.log("flattenHTML", rootNode);
    const textProps = [];
    let currentTextProps = { pos: 0, color: null, flags: 0 };
    let textPropsStack = [];
    textProps.push(currentTextProps);
    textPropsStack.push(currentTextProps);
    let finalText = "";
    function extractFlattenedHTML(node) {
        // console.log("extractFlattenedHTML", node)
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.nodeValue || "";
            finalText += text;
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node;
            let newTextProps = null;
            let color = null;
            if (el.classList.contains("red")) {
                color = "red";
            }
            if (currentTextProps.color !== color) {
                if (!newTextProps) {
                    currentTextProps = newTextProps = { ...currentTextProps, pos: finalText.length };
                    textProps.push(newTextProps);
                    textPropsStack.push(currentTextProps);
                }
                newTextProps.color = color;
            }
            for (const child of el.childNodes) {
                extractFlattenedHTML(child);
            }
            if (BLOCK_ELEMENTS[el.nodeName]) {
                finalText += "\n";
            }
            if (newTextProps) {
                textPropsStack.pop();
                currentTextProps = { ...textPropsStack[textPropsStack.length - 1], pos: finalText.length };
                textProps.push(currentTextProps);
            }
        }
    }
    extractFlattenedHTML(rootNode);
    //console.log("flattened", { rootNode, finalText, textProps });
    return [finalText, textProps];
}
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
function findIndexByPos(arr, pos) {
    // binary search
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const item = arr[mid];
        const start = item.pos, end = item.pos + item.len;
        if (start <= pos && pos < end) {
            return mid;
        }
        else if (start > pos) {
            high = mid - 1;
        }
        else if (end <= pos) {
            low = mid + 1;
        }
    }
    return ~low;
}
function getSelectedTokenRange(tokens, startOffset, endOffset) {
    function findTokenIndex(offset, low) {
        let isStart;
        if (low === undefined) {
            isStart = true;
            low = 0;
        }
        else {
            isStart = false;
        }
        let high = tokens.length - 1;
        let result = isStart ? tokens.length : -1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = tokens[mid];
            const tokenEnd = token.pos + token.len;
            if (isStart) {
                const prevEnd = mid > 0 ? tokens[mid - 1].pos + tokens[mid - 1].len : 0;
                if (offset > prevEnd && offset < tokenEnd) {
                    return mid;
                }
                if (mid === 0 && offset >= token.pos && offset < tokenEnd) {
                    return 0;
                }
            }
            else {
                const nextStart = mid + 1 < tokens.length ? tokens[mid + 1].pos : Infinity;
                if (offset >= token.pos && offset < nextStart) {
                    return mid;
                }
            }
            if (isStart) {
                if (token.pos >= offset) {
                    result = mid;
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            else {
                if (tokenEnd < offset) {
                    result = mid;
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
        }
        return result;
    }
    const startIndex = findTokenIndex(startOffset);
    const endIndex = findTokenIndex(endOffset, startIndex);
    return [startIndex, endIndex + 1]; // [inclusive, exclusive]
}
function mapTokenRangeToOtherSide(rawEntries, side, startIndex, endIndex) {
    const otherSide = side === "left" ? "right" : "left";
    let low = 0;
    let high = rawEntries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (startIndex < s.pos) {
            high = mid - 1;
        }
        else if (startIndex >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = rawEntries[mid][otherSide].pos;
            low = mid; // reuse for mappedEnd search
            break;
        }
    }
    high = rawEntries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (endIndex - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endIndex - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function buildOutputHTMLFromRuns(text, textRuns, options) {
    let result = "<pre>";
    let inMark = false;
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            result += "<mark>";
            inMark = true;
        }
        else if (run.type === "DIFF_END") {
            if (inMark) {
                result += "</mark>";
                inMark = false;
            }
        }
        else if (run.type === "CHARS") {
            result += escapeHTML(text.slice(run.pos, run.pos + run.len));
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inMark)
        result += "</mark>";
    result += "\n\n</pre>";
    return result;
}
function buildOutputPlainText(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const leftBody = buildOutputPlainTextFromRuns(leftText, leftRuns, options);
    const rightBody = buildOutputPlainTextFromRuns(rightText, rightRuns, options);
    return `${leftLabel}: ${leftBody}\n${rightLabel}: ${rightBody}\n`;
}
function buildOutputPlainTextFromRuns(text, textRuns, options) {
    const format = options.textFormat ?? 0;
    let result = "";
    let inDiff = false;
    let markStart;
    let markEnd;
    if (format === 1) {
        markStart = "**";
        markEnd = "**";
    }
    else if (format === 2) {
        markStart = "[[ ";
        markEnd = " ]]";
    }
    else {
        markStart = "";
        markEnd = "";
    }
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            if (format !== 0 && !inDiff) {
                result += markStart;
                inDiff = true;
            }
        }
        else if (run.type === "DIFF_END") {
            if (format !== 0 && inDiff) {
                result += markEnd;
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += text.slice(run.pos, run.pos + run.len);
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inDiff && format !== 0)
        result += markEnd;
    return result;
}
function buildOutputHTML(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const htmlFormat = options.htmlFormat ?? "dl";
    if (htmlFormat === "table") {
        // Default: table format
        return `<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr><th>${escapeHTML(leftLabel)}</th><th>${escapeHTML(rightLabel)}</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></td>
      <td><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></td>
    </tr>
  </tbody>
</table>`.trim();
    }
    if (htmlFormat === "dl") {
        return `<dl>
  <dt>${escapeHTML(leftLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></dd>
  <dt>${escapeHTML(rightLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></dd>
</dl>`.trim();
    }
    return `<div>
<div><strong>${escapeHTML(leftLabel)}:</strong> ${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</div>
<div><strong>${escapeHTML(rightLabel)}:</strong> ${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</div>
</div>`.trim();
}
function escapeHTML(str) {
    return str.replace(/[&<>"]|'/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#039;";
            default:
                return char;
        }
    });
}
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const FIRST_OF_LINE = 1;
const LAST_OF_LINE = 2;
const WILD_CARD = 16;
//const NORMALIZE = 32; // &middot;, ë”°ì˜´í‘œ -, ë§ë¨¸ë¦¬ë¬¸ì ë“±ë“± ì‹¤ì œë¡œ ë¬¸ì ì½”ë“œëŠ” ë‹¤ë¥´ì§€ë§Œ ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼ í•  ë¬¸ìë“¤ì´ ìˆë‹¤.
const SECTION_HEADING = 64;
const MANUAL_ANCHOR = 128; // @@@, ### ë“±ë“±
const normalizeChars = {};
// TODO
// ê·¸ëƒ¥ { type: "init? config?", normalizeChars: {...}, ... } ì´ëŸ° ì‹ìœ¼ë¡œ ë³´ë‚´ëŠ”ê²Œ ë” ë‚˜ì„ë“¯.
for (var entry of NORMALIZE_CHARS) {
    // entry[0] = encoder.encode(entry[0]);
    const norm = entry[0];
    normalizeChars[norm] = norm;
    for (var i = 0; i < entry.length; i++) {
        const char = entry[i];
        if (char.length === 1) {
            normalizeChars[char] = norm;
        }
        else if (typeof char === "number") {
            normalizeChars[String.fromCharCode(char)] = norm;
        }
        else if (char[0] === "&") {
            normalizeChars[htmlEntityToChar(char)] = norm;
        }
        else {
            throw new Error("normalizeChars: not a single character: " + char);
        }
    }
}
console.log("normalizeChars: ", normalizeChars);
function htmlEntityToChar(entity) {
    const doc = new DOMParser().parseFromString(entity, "text/html");
    const char = doc.body.textContent;
    if (char.length !== 1) {
        throw new Error("htmlEntityToChar: not a single character entity: " + entity);
    }
    return char;
}
const SPACE_CHARS = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // ê¸€ì„...
    "\f": true, // ì´ê²ƒë“¤ì€...
    "\v": true, // ë³¼ì¼ì´ ì—†ì„ê²ƒ...
    "\u00A0": true, // &nbsp; ??
};
const TOKEN_CACHE_SIZE = 2;
const tokenCache = {
    ["char"]: [],
    ["word"]: [],
    ["line"]: [],
};
// wildcards.
// ì´ê±¸ ì–´ë–»ê²Œ êµ¬í˜„í•´ì•¼í• ì§€ ê°ì´ ì•ˆì˜¤ì§€ë§Œ ì§€ê¸ˆìœ¼ë¡œì¨ëŠ” ì–˜ë„¤ë“¤ì„ atomicí•˜ê²Œ ì·¨ê¸‰(ì‚¬ì´ì— ê³µë°±ì´ ìˆì–´ë„ í•˜ë‚˜ì˜ í† í°ìœ¼ë¡œ ë§Œë“¬. '(í˜„í–‰ê³¼ ê°™ìŒ)'ì—ì„œ ì¼ë¶€ë¶„ë§Œ ë§¤ì¹˜ë˜ëŠ” ê²ƒì„ ë°©ì§€)
// ê¸€ìë‹¨ìœ„ë¡œ í† í°í™”í•˜ëŠ” ê²½ìš°ì—ë„ ì–˜ë„¤ë“¤ì€ (...) í†µì±„ë¡œ í•˜ë‚˜ì˜ í† í°ìœ¼ë¡œ ì·¨ê¸‰.
// ì™€ì¼ë“œì¹´ë“œdiffì¸ ê²½ìš° ë‹¤ë¥¸ diffì™€ ë³‘í•©ë˜ì§€ ì•Šìœ¼ë©´ ì¢‹ì§€ë§Œ ì™€ì¼ë“œì¹´ë“œê°€ ì–¼ë§ˆë‚˜ greedyí•˜ê²Œ ë°˜ëŒ€ìª½ í…ìŠ¤íŠ¸ë¥¼ ì¡ì•„ë¨¹ì–´ì•¼ í• ì§€
// ì–‘ìª½ì— wildcardê°€ ë™ì‹œì— ë‚˜ì˜¤ëŠ” ê²½ìš° ê²½ê³„ë¥¼ ì–´ë””ì„œ ì–´ë–»ê²Œ ì§¤ë¼ì•¼í• ì§€ ì‰½ì§€ ì•ŠìŒ.
// ë˜í•œ wildcardë¥¼ ê°•ì œë¡œ ë‹¤ë¥¸ diffì™€ ë¶„ë¦¬í•˜ëŠ” ê²½ìš° diffê°€ ê°™ì€ ìœ„ì¹˜ì— ë‘ ê°œ ì´ìƒ ìƒê¸°ê²Œ ë˜ëŠ” ìˆ˜ê°€ ìˆë‹¤. (wildcardì™€ wildcardê°€ ì•„ë‹Œ ê²ƒ)
// ì´ ê²½ìš° ì •í™•íˆ ê°™ì€ ìœ„ì¹˜ì— ë‘ê°œì˜ diffë¥¼ ë Œë”ë§í•´ì•¼í•˜ê³  ê²°êµ­ ë‘ê°œê°€ ê²¹ì³ë³´ì´ê²Œ ë˜ëŠ”ë° ë¶„ê°„ì´ ì˜ ì•ˆëœë‹¤.
const WildcardTrie = createTrie(true);
WildcardTrie.insert("(ì¶”ê°€)", WILD_CARD);
WildcardTrie.insert("(ì‚­ì œ)", WILD_CARD);
WildcardTrie.insert("(ì‹ ì„¤)", WILD_CARD);
WildcardTrie.insert("(ìƒëµ)", WILD_CARD);
WildcardTrie.insert("(í˜„í–‰ê³¼ê°™ìŒ)", WILD_CARD);
const TrieRoot = WildcardTrie.root;
const WildcardTrieNode = WildcardTrie.root.next("(");
const SectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    // 1. ì œëª© ==> ì´ íŒ¨í„´ì€ ë¬´ì‹œ. ë³´í†µ ì´ ì œëª©ë“¤ì€ ì™¼ìª½ ë¬¸ì„œ ì „ì²´ í…Œì´ë¸”ì˜ ë§¨ ì™¼ìª½ ì»¬ëŸ¼ì— ë“¤ì–´ê°€ ìˆëŠ”ë°
    // ë§ì€ ë¬¸ì„œë“¤ì´ ì„¹ì…˜ì„ í…Œì´ë¸” í–‰ìœ¼ë¡œ ë¶„ë¦¬í•˜ì§€ ì•Šê³  ê·¸ëƒ¥ ì—”í„°í‚¤ë¥¼ ì—´ì‹¬íˆ ëˆŒëŸ¬ì„œ ë¶„ë¦¬í•´ë‘ì—ˆê¸° ë•Œë¬¸ì—
    // ì´ëŸ° ê²½ìš° ë³µì‚¬ë¶™ì—¬ë„£ê¸° í•˜ë©´ 1. ì œëª©, 2. ì œëª©2, ...ì´ ëª¨ë‘ ë¬¸ì„œì˜ ì²« ë¶€ë¶„ì— ë‚˜ì™€ë²„ë¦¼. ì˜êµ¬ê°™ë‹¤!
    SectionHeadingTrie.insert(`(${i}) `);
    SectionHeadingTrie.insert(`${i}) `);
}
const syllables = "ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ì•„ìì°¨ì¹´íƒ€íŒŒí•˜";
for (let i = 0; i < syllables.length; i++) {
    SectionHeadingTrie.insert(`(${syllables[i]}) `);
    SectionHeadingTrie.insert(`${syllables[i]}) `);
    SectionHeadingTrie.insert(`(${String.fromCharCode(syllables.charCodeAt(i) + 112)}) `);
    SectionHeadingTrie.insert(`${String.fromCharCode(syllables.charCodeAt(i) + 112)}) `);
}
const SectionHeadingTrieNode = SectionHeadingTrie.root;
const SECTION_HEADING_START = extractStartCharsFromTrie(SectionHeadingTrieNode);
const ManualAnchorTrie = createTrie(false);
ManualAnchorTrie.insert(MANUAL_ANCHOR1, MANUAL_ANCHOR);
ManualAnchorTrie.insert(MANUAL_ANCHOR2, MANUAL_ANCHOR);
const ManualAnchorTrieNode = ManualAnchorTrie.root;
const MANUAL_ANCHOR_START = extractStartCharsFromTrie(ManualAnchorTrieNode);
// ============================================================
// Tokenization
// tokenizeë¥¼ uiì“°ë ˆë“œì—ì„œ ì‹¤í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ë°”ê¿”ë´¤ì§€ë§Œ
// editorì—ì„œ ë¬¼íë¥´ë“¯ ìì—°ìŠ¤ëŸ¬ìš´ í¸ì§‘ì´ ì•ˆë˜ëŠ” ëŠë‚Œ. ë¶ˆì¾Œí•¨!
// ê·¸ë˜ë„ UIì“°ë ˆë“œì—ì„œ í† í°ì„ ì§ì ‘ ê°€ì§€ê³  ìˆìœ¼ë©´ í¸ë¦¬í•œ ë¶€ë¶„ì´ ìˆê¸´ ìˆìŒ.
// ============================================================
// #region Tokenization
function tokenizeByChar(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = FIRST_OF_LINE;
    const inputEnd = input.length;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (!SPACE_CHARS[ch]) {
            if (ch === "(") {
                const result = findInTrie(WildcardTrieNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= FIRST_OF_LINE;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (MANUAL_ANCHOR_START[ch]) {
                const nextNode = ManualAnchorTrieNode.next(ch);
                const result = findInTrie(nextNode, input, i + 1);
                if (result) {
                    if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                        flags |= FIRST_OF_LINE;
                    }
                    tokens.push({
                        text: result.word,
                        pos: i,
                        len: result.end - i,
                        lineNum,
                        flags: flags | result.flags,
                    });
                    flags = 0;
                    i = result.end - 1;
                    continue;
                }
            }
            if (tokens.length === 0 || checkIfFirstOfLine(input, i)) {
                flags |= FIRST_OF_LINE;
            }
            const normalized = normalizeChars[ch] || ch;
            tokens.push({
                text: normalized,
                pos: i,
                len: 1,
                lineNum,
                flags,
            });
            flags = 0;
        }
        if (ch === "\n") {
            lineNum++;
            flags = FIRST_OF_LINE;
            if (tokens.length) {
                tokens[tokens.length - 1].flags |= LAST_OF_LINE;
            }
        }
    }
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LAST_OF_LINE;
    }
    return tokens;
}
function tokenizeByWord(input) {
    const tokens = [];
    let currentStart = -1;
    let lineNum = 1;
    let flags = FIRST_OF_LINE;
    let shouldNormalize = false;
    const inputEnd = input.length;
    function emitToken(end) {
        const raw = input.slice(currentStart, end);
        const normalized = shouldNormalize ? normalize(raw) : raw;
        flags |= tokens.length === 0 || checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
        if (normalized === MANUAL_ANCHOR1 || normalized === MANUAL_ANCHOR2) {
            flags |= MANUAL_ANCHOR;
        }
        tokens.push({
            text: normalized,
            pos: currentStart,
            len: end - currentStart,
            lineNum,
            flags,
        });
        currentStart = -1;
        flags = 0;
        shouldNormalize = false;
    }
    for (let i = 0; i < inputEnd; i++) {
        let ch = input[i];
        if (SPACE_CHARS[ch]) {
            if (currentStart !== -1)
                emitToken(i);
            if (ch === "\n") {
                lineNum++;
                flags = FIRST_OF_LINE;
                if (tokens.length)
                    tokens[tokens.length - 1].flags |= LAST_OF_LINE;
            }
            continue;
        }
        if (normalizeChars[ch]) {
            shouldNormalize = true;
            ch = normalizeChars[ch];
        }
        if (ch === "(") {
            const result = findInTrie(WildcardTrieNode, input, i);
            if (result) {
                if (currentStart !== -1)
                    emitToken(i);
                flags |= tokens.length === 0 || checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
                tokens.push({
                    text: result.word,
                    pos: i,
                    len: result.end - i,
                    lineNum,
                    flags: flags | result.flags,
                });
                flags = 0;
                currentStart = -1;
                i = result.end - 1;
                continue;
            }
        }
        if (flags & FIRST_OF_LINE && SECTION_HEADING_START[ch]) {
            const result = findInTrie(SectionHeadingTrieNode, input, i);
            if (result) {
                let p = result.end;
                while (p < inputEnd && SPACE_CHARS[input[p]])
                    p++;
                if (p < inputEnd)
                    flags |= SECTION_HEADING;
            }
        }
        if (currentStart === -1)
            currentStart = i;
    }
    if (currentStart !== -1)
        emitToken(inputEnd);
    if (tokens.length) {
        tokens[tokens.length - 1].flags |= LAST_OF_LINE;
    }
    return tokens;
}
function tokenizeByLine(input) {
    const tokens = [];
    let lineNum = 1;
    let flags = FIRST_OF_LINE | LAST_OF_LINE;
    const inputEnd = input.length;
    let buffer = "";
    let started = false;
    let inSpace = false;
    let pos = -1;
    for (let i = 0; i < inputEnd; i++) {
        const ch = input[i];
        if (ch !== "\n") {
            if (!SPACE_CHARS[ch]) {
                if (!started) {
                    pos = i;
                    started = true;
                    const result = findInTrie(SectionHeadingTrieNode, input, i);
                    if (result) {
                        let p = result.end;
                        while (p < inputEnd && SPACE_CHARS[input[p]])
                            p++;
                        if (p < inputEnd)
                            flags |= SECTION_HEADING;
                    }
                }
                if (inSpace && buffer.length > 0)
                    buffer += " ";
                buffer += ch;
                inSpace = false;
            }
            else {
                inSpace = started;
            }
        }
        else {
            if (started) {
                if (buffer === MANUAL_ANCHOR1 || buffer === MANUAL_ANCHOR2) {
                    flags |= MANUAL_ANCHOR;
                }
                tokens.push({
                    text: buffer,
                    pos,
                    len: i - pos,
                    lineNum,
                    flags,
                });
                buffer = "";
                started = false;
                inSpace = false;
                flags = FIRST_OF_LINE | LAST_OF_LINE;
            }
            lineNum++;
        }
    }
    return tokens;
}
function tokenize(input, mode, noCache = false) {
    let cacheArr = !noCache && tokenCache[mode];
    if (cacheArr) {
        for (let i = 0; i < cacheArr.length; i++) {
            const cache = cacheArr[i];
            if (cache.text === input) {
                if (i !== cacheArr.length - 1) {
                    cacheArr.splice(i, 1);
                    cacheArr.push(cache);
                }
                return cache.tokens;
            }
        }
    }
    const now = performance.now();
    let tokens;
    switch (mode) {
        case "char":
            tokens = tokenizeByChar(input);
            break;
        case "word":
            tokens = tokenizeByWord(input);
            break;
        case "line":
            tokens = tokenizeByLine(input);
            break;
        default:
            throw new Error("Unknown tokenization mode: " + mode);
    }
    console.log("tokenize took %d ms", performance.now() - now);
    // tokens.push({
    // 	text: "",
    // 	pos: input.length,
    // 	len: 0,
    // 	lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
    // 	flags: FIRST_OF_LINE | LAST_OF_LINE,
    // });
    if (cacheArr) {
        if (cacheArr.length >= TOKEN_CACHE_SIZE) {
            cacheArr.shift();
        }
        cacheArr.push({ text: input, tokens: tokens });
    }
    return tokens;
}
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizeChars[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!SPACE_CHARS[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            node = node.addChild(word[i]);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
function createTrieNode(ignoreSpaces) {
    const children = {};
    const node = {
        children,
        word: null,
        flags: 0,
        next(char) {
            if (ignoreSpaces && char === " ")
                return node;
            return children[char] || null;
        },
        addChild(char) {
            return children[char] ?? (children[char] = createTrieNode(ignoreSpaces));
        },
    };
    return node;
}
function findInTrie(trie, input, start) {
    let node = trie;
    let i = start;
    while (i < input.length) {
        const ch = input[i++];
        node = node.next(ch);
        if (!node)
            break;
        if (node.word) {
            return { word: node.word, flags: node.flags, end: i };
        }
    }
    return null;
}
function extractStartCharsFromTrie(trie) {
    const table = {};
    for (const ch in trie.children) {
        table[ch] = 1;
    }
    return table;
}
//# sourceMappingURL=tokenize.js.map
</script>
<script>"use strict";
function getTextRuns(textKey, text, textProps, diffs, anchors, startPos, endPos) {
    anchors ??= [];
    textProps ??= [];
    let nextPropsPos = null;
    let nextProps = null;
    let nextDiffPos = null;
    let nextDiffEndPos = null;
    let nextDiff = null;
    let nextAnchorPos = null;
    let nextAnchor = null;
    let nextNewLinePos = null;
    let nextNewLineIsEndOfString = false;
    let textPropsIndex = -1;
    let diffIndex = -1;
    let anchorIndex = -1;
    let lastSupSubPos = null;
    const textruns = [];
    const textLen = endPos ?? text.length;
    let pos = startPos ?? 0;
    if (pos > 0) {
        for (let i = 0; i < diffs.length; i++) {
            const d = diffs[i][textKey];
            if (d.pos >= pos) {
                diffIndex = i - 1;
                break;
            }
        }
        for (let i = 0; i < anchors.length; i++) {
            const a = anchors[i];
            if (a[textKey] >= pos) {
                anchorIndex = i - 1;
                break;
            }
        }
        for (let i = 0; i < textProps.length; i++) {
            const p = textProps[i];
            if (p.pos >= pos) {
                textPropsIndex = i - 1;
                if (textPropsIndex >= 0) {
                    textruns.push({
                        type: "MODIFIER",
                        pos: pos,
                        len: 0,
                        diffIndex: null,
                        anchorIndex: null,
                        props: textProps[textPropsIndex],
                    });
                }
                break;
            }
        }
    }
    // let counter = 0;
    // pos < textLen ì¡°ê±´ì„ ì“°ë©´ textì˜ ëì— ìœ„ì¹˜í•œ ì´ë²¤íŠ¸ê°€ ë¬´ì‹œë  ìˆ˜ ìˆìŒ.
    while (true) {
        // if (counter++ > 100000) {
        // 	console.error("Infinite loop detected", {
        // 		textruns,
        // 		pos: pos,
        // 		textLen: textLen,
        // 		nextDiffPos: nextDiffPos,
        // 		nextDiffEndPos: nextDiffEndPos,
        // 		nextAnchorPos: nextAnchorPos,
        // 		nextNewLinePos: nextNewLinePos,
        // 		diffIndex: diffIndex,
        // 		anchorIndex: anchorIndex,
        // 		nextDiff: nextDiff,
        // 		nextAnchor: nextAnchor,
        // 		diffs,
        // 		anchors,
        // 	});
        // 	throw new Error("Infinite loop detected");
        // }
        let nextEventPos = textLen;
        if (nextPropsPos === null) {
            textPropsIndex++;
            if (textPropsIndex < textProps.length) {
                nextProps = textProps[textPropsIndex];
                nextPropsPos = nextProps.pos;
                if (nextPropsPos < pos) {
                    // skipped text property. this should not happen.
                    console.warn("Skipped text property", { textProps: nextProps, textPropsIndex: textPropsIndex, pos: pos, propsPos: nextPropsPos });
                    nextPropsPos = nextProps = null;
                }
            }
            else {
                nextPropsPos = Number.MAX_SAFE_INTEGER;
            }
        }
        if (nextPropsPos !== null && nextPropsPos < nextEventPos) {
            nextEventPos = nextPropsPos;
        }
        if (nextAnchorPos === null) {
            anchorIndex++;
            if (anchorIndex < anchors.length) {
                nextAnchor = anchors[anchorIndex];
                nextAnchorPos = nextAnchor[textKey];
                if (nextAnchorPos < pos) {
                    // anchor ìœ„ì¹˜ë¥¼ ì¡°ì ˆí•  ë•Œ ë¬¸ì œê°€ ìƒê¸´ ê²½ìš°ì¸ë°... ì•µì»¤ë¥¼ ëª» ë°•ìœ¼ë©´ ì¤„ë§ì¶¤ ì •ë ¬ì´ ê¹¨ì§„ë‹¤. ë”± ê·¸ë¿...
                    console.warn("Skipped anchor", { anchor: nextAnchor, anchorIndex: anchorIndex, pos: pos, anchorPos: nextAnchorPos });
                    nextAnchorPos = nextAnchor = null;
                    // continue;
                }
            }
            else {
                nextAnchorPos = Number.MAX_SAFE_INTEGER;
            }
        }
        if (nextAnchorPos !== null && nextAnchorPos < nextEventPos) {
            nextEventPos = nextAnchorPos;
        }
        if (nextDiffEndPos === null) {
            diffIndex++;
            if (diffIndex < diffs.length) {
                nextDiff = diffs[diffIndex][textKey];
                nextDiffPos = nextDiff.pos;
                nextDiffEndPos = nextDiff.pos + nextDiff.len;
                if (nextDiffPos < pos) {
                    console.warn("Skipped diff", { diff: nextDiff, diffIndex: diffIndex, pos: pos, diffPos: nextDiffPos });
                    nextDiffPos = nextDiffEndPos = nextDiff = null;
                }
            }
            else {
                nextDiffPos = Number.MAX_SAFE_INTEGER;
                nextDiffEndPos = Number.MAX_SAFE_INTEGER;
            }
        }
        if (nextDiffPos !== null && nextDiffPos < nextEventPos) {
            nextEventPos = nextDiffPos;
        }
        else if (nextDiffEndPos !== null && nextDiffEndPos < nextEventPos) {
            nextEventPos = nextDiffEndPos;
        }
        if (nextNewLinePos === null) {
            nextNewLinePos = text.indexOf("\n", pos);
            if (nextNewLinePos === -1 || nextNewLinePos >= textLen) {
                nextNewLinePos = textLen;
                nextNewLineIsEndOfString = true;
            }
        }
        if (nextNewLinePos !== null && nextNewLinePos < nextEventPos) {
            nextEventPos = nextNewLinePos;
        }
        if (pos < nextEventPos) {
            // chars
            textruns.push({
                type: "CHARS",
                pos: pos,
                len: nextEventPos - pos,
                diffIndex: null,
                anchorIndex: null,
                props: null,
            });
            pos = nextEventPos;
        }
        if (nextEventPos === nextPropsPos) {
            textruns.push({
                type: "MODIFIER",
                pos: nextPropsPos,
                len: 0,
                diffIndex: null,
                anchorIndex: null,
                props: nextProps,
            });
            nextPropsPos = null;
            continue;
        }
        // ì´ë²¤íŠ¸ ì²˜ë¦¬ í›„ ë°˜ë“œì‹œ continueë¡œ ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ë„˜ì–´ê°€ì•¼ í•¨. (í˜¹ì€ else if else if else if...)
        if (nextEventPos === nextAnchorPos && nextAnchor.type === "before") {
            textruns.push({
                type: "ANCHOR",
                pos: nextAnchorPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: anchorIndex,
                props: null,
            });
            nextAnchorPos = nextAnchor = null;
            continue;
        }
        if (nextEventPos === nextDiffPos) {
            textruns.push({
                type: "DIFF",
                pos: nextDiffPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: null,
                props: null,
            });
            nextDiffPos = Number.MAX_SAFE_INTEGER;
            continue;
        }
        if (nextEventPos === nextDiffEndPos) {
            // diff end
            textruns.push({
                type: "DIFF_END",
                pos: nextDiffEndPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: null,
                props: null,
            });
            nextDiffPos = nextDiffEndPos = nextDiff = null;
            continue;
        }
        if (nextEventPos === nextAnchorPos && nextAnchor.type === "after") {
            textruns.push({
                type: "ANCHOR",
                pos: nextAnchorPos,
                len: 0,
                diffIndex: diffIndex,
                anchorIndex: anchorIndex,
                props: null,
            });
            nextAnchorPos = null;
            continue;
        }
        if (nextEventPos === nextNewLinePos) {
            if (nextNewLineIsEndOfString) {
                break;
            }
            else {
                textruns.push({
                    type: "LINEBREAK",
                    pos: nextNewLinePos,
                    len: 1,
                    diffIndex: null,
                    anchorIndex: null,
                    props: null,
                });
                pos = nextEventPos + 1;
                nextNewLinePos = null;
                continue;
            }
        }
    }
    // ë‹«íˆì§€ ì•Šì€ diff. endPosë¥¼ ë„£ì–´ì„œ í˜¸ì¶œí•œ ê²½ìš° diffê°€ ëë‚˜ê¸° ì „ì— endPosì— ë„ë‹¬í•  ìˆ˜ ìˆìŒ.
    if (nextDiffPos === Number.MAX_SAFE_INTEGER && nextDiffEndPos !== Number.MAX_SAFE_INTEGER) {
        textruns.push({
            type: "DIFF_END",
            pos: textLen ?? nextDiffEndPos,
            len: 0,
            diffIndex: diffIndex,
            anchorIndex: null,
            props: null,
        });
    }
    textruns.push({
        type: "END_OF_STRING",
        pos: textLen,
        len: 0,
        diffIndex: null,
        anchorIndex: null,
        props: null,
    });
    console.log("textruns", textruns);
    return textruns;
}
//# sourceMappingURL=textrun.js.map
</script>
<script>"use strict";
function createEditor(container, editorName, callbacks) {
    const { onDiffVisibilityChanged, onTextChanged, onMirrorUpdated } = callbacks;
    const _lineElements = [];
    const _diffElements = [];
    const _anchorElements = [];
    const _lineHints = [];
    const _visibleAnchors = new Set();
    const _visibleDiffIndices = new Set();
    // í¸ì§‘ê¸° ë‚´ì— ì•½ê°„ì˜ htmlì„ í—ˆìš©í• ì§€ ë§ì§€.
    // ì¼ë‹¨ ê¸ˆì§€. browserì—ì„œ ê³„ì‚°í•˜ëŠ” í…ìŠ¤íŠ¸ì™€ ë‚´ê°€ ë§Œë“œëŠ” í…ìŠ¤íŠ¸ë¥¼ ì™„ì „íˆ ì¼ì¹˜ì‹œí‚¤ê¸° í˜ë“¤ë‹¤. í•œê¸€ìí•œê¸€ì ë¬¸ì ì¸ë±ìŠ¤ê¹Œì§€ ì™„ì „íˆ ì¼ì¹˜ì‹œì¼œì•¼ ë¨...
    // ê²Œë‹¤ê°€ contenteditable ë‚´ì— ë¸Œë¼ìš°ì €ê°€ ëœ¸ê¸ˆì—†ì´ ë„£ëŠ” style(ìŠ¤íƒ€ì¼ í´ë˜ìŠ¤ê°€ ì§€ì •ëœ í…ìŠ¤íŠ¸ë¥¼ ì§€ìš°ê³  ë°”ë¡œ ì´ì–´ì„œ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•  ê²½ìš°)ì´ë‚˜ <br> ë“±ë“±ë„ ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼ í•˜ê³ 
    // ì—¬í•˜íŠ¼ ì‹ ê²½ ì“¸ê²Œ ë§ìŒ
    const _allowHTML = true;
    let _text = "";
    let _hasHTML = false;
    let _textProps = [];
    let _savedCaret = null;
    let _editMode = false;
    const wrapper = document.createElement("div");
    wrapper.id = editorName + "EditorWrapper";
    wrapper.classList.add("editor-wrapper");
    // ì–´ì©” ìˆ˜ ì—†ëŠ” ì„ íƒ.
    // dom ì—…ë°ì´íŠ¸ê°€ í…ìŠ¤íŠ¸ ì…ë ¥ì„ ë°©í•´í•˜ëŠ” ê±´ ì›ì¹˜ ì•Šê³  undo,redo íˆìŠ¤í† ë¦¬ë¥¼ ë§ì³ë²„ë¦¬ëŠ” ê²ƒë„ ì‹«ìŒ
    // undo, redoë¥¼ ì–´ì„¤í”„ê²Œ êµ¬í˜„í•˜ëŠë‹ˆ ì•ˆí•˜ëŠ” ê²Œ ë‚«ë‹¤. (ì»¤ì„œìœ„ì¹˜, ìŠ¤í¬ë¡¤ ìœ„ì¹˜, ì„ íƒ ë²”ìœ„, throttling ë“±ë“± ìƒê°í•  ê²Œ ë§ìŒ)
    const mirror = document.createElement("div");
    mirror.id = editorName + "Mirror";
    mirror.classList.add("mirror");
    mirror.spellcheck = false;
    const editor = document.createElement("div");
    editor.id = editorName + "Editor";
    editor.classList.add("editor");
    editor.contentEditable = "plaintext-only";
    editor.spellcheck = false;
    editor.appendChild(document.createTextNode(""));
    wrapper.appendChild(mirror);
    wrapper.appendChild(editor);
    container.appendChild(wrapper);
    // ë³µë¶™í•œ ìŠ¤íƒ€ì¼ì´ ë“¤ì–´ìˆëŠ” ë¶€ë¶„ì„ ìˆ˜ì •í•  ë•Œ(ì •í™•íˆëŠ” ìŠ¤íƒ€ì¼ì´ ì…í˜€ì§„ í…ìŠ¤íŠ¸ë¥¼ ì§€ìš°ê³  ë°”ë¡œ ì…ë ¥í•  ë•Œ)
    // ë¸Œë¼ìš°ì €ê°€ ì§€ì›Œì§€ê¸° ì „ê³¼ ë¹„ìŠ·í•œ ìŠ¤íƒ€ì¼(font, spaníƒœê·¸ì— styleì„ ì…í˜€ì„œ)ì„ ì¹œíˆ ë„£ì–´ì£¼ì‹ ë‹¤!
    // ë¶„ì— ë„˜ì¹˜ê²Œ í™©ê³µí•˜ì˜¤ë‹ˆ ì½ì‹¸ê²Œ ì‚­ì œí•´ë“œë ¤ì•¼í•¨í•¨.
    const { observeEditor, unobserveEditor } = (() => {
        const mutationObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === "childList") {
                    for (const node of mutation.addedNodes) {
                        // ë³´í†µ ë¸Œë¼ìš°ì €ëŠ” spanì´ë‚˜ font íƒœê·¸ë¥¼ ì…í˜€ì„œ ìŠ¤íƒ€ì¼ì„ ë„£ì–´ì¤€ë‹¤...
                        if (node.nodeName === "SPAN" || node.nodeName === "FONT") {
                            if (node.childNodes.length === 1 && node.firstChild?.nodeType === 3) {
                                node.parentNode?.replaceChild(node.firstChild, node);
                            }
                        }
                    }
                }
                // ê¸°ì¡´ íƒœê·¸ì— styleì„ ë°”ë¡œ ë„£ì–´ì£¼ëŠ” ê²½ìš°ê°€ ìˆëŠ”ì§€ëŠ” ëª¨ë¥´ê² ì§€ë§Œ ì•ˆì „ë¹µìœ¼ë¡œ...
                if (mutation.type === "attributes" && mutation.attributeName === "style") {
                    mutation.target.removeAttribute("style");
                }
            }
        });
        function observeEditor() {
            mutationObserver.observe(editor, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true,
            });
        }
        function unobserveEditor() {
            mutationObserver.disconnect();
        }
        return { observeEditor, unobserveEditor };
    })();
    // í™”ë©´ì— ë³´ì´ëŠ” diff, anchor elementë“¤ì„ ì¶”ì í•¨.
    const { trackIntersections, untrackIntersections } = (() => {
        const intersectionObserver = new IntersectionObserver((entries) => {
            for (const entry of entries) {
                if (entry.isIntersecting) {
                    if (entry.target.nodeName === ANCHOR_TAG) {
                        _visibleAnchors.add(entry.target);
                    }
                    else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
                        const diffIndex = Number(entry.target.dataset.diff);
                        _visibleDiffIndices.add(diffIndex);
                        onDiffVisibilityChanged(diffIndex, true);
                    }
                }
                else {
                    if (entry.target.nodeName === ANCHOR_TAG) {
                        _visibleAnchors.delete(entry.target);
                    }
                    else if (entry.target.nodeName === DIFF_ELEMENT_NAME) {
                        const diffIndex = Number(entry.target.dataset.diff);
                        _visibleDiffIndices.delete(diffIndex);
                        onDiffVisibilityChanged(diffIndex, false);
                    }
                }
            }
        }, { threshold: 1, root: wrapper });
        function trackIntersections() {
            for (const anchor of _anchorElements) {
                if (anchor)
                    intersectionObserver.observe(anchor);
            }
            for (const diff of _diffElements.flat()) {
                intersectionObserver.observe(diff);
            }
        }
        function untrackIntersections() {
            _visibleAnchors.clear();
            _visibleDiffIndices.clear();
            intersectionObserver.disconnect();
        }
        return { trackIntersections, untrackIntersections };
    })();
    function updateText() {
        if (_hasHTML) {
            const [text, textProps] = flattenHTML(editor);
            _text = text;
            _textProps = textProps;
            if (textProps.length <= 1) {
                // ì¼ë‹¨ í˜„ì¬ë¡œì¨ëŠ” 1ê°œì˜ textPropsì€ ë°˜ë“œì‹œ ë“¤ì–´ìˆë‹¤.
                _hasHTML = false;
            }
        }
        else {
            _text = editor.textContent || "";
            _textProps = [];
        }
        // if (_text.length === 0 || _text[_text.length - 1] !== "\n") {
        // }
        _text += "\n"; // í…ìŠ¤íŠ¸ì˜ ëì€ í•­ìƒ \nìœ¼ë¡œ ëë‚˜ì•¼ ì¸ìƒì´ í¸í•´ì§„ë‹¤.
        onTextChanged(_text);
    }
    editor.addEventListener("input", updateText);
    editor.addEventListener("paste", (e) => {
        if (!_allowHTML)
            return;
        const html = e.clipboardData?.getData("text/html");
        if (!html)
            return;
        e.preventDefault();
        _hasHTML = true;
        const cleanedHTML = sanitizeHTML(html);
        editor.contentEditable = "true";
        unobserveEditor();
        // deprecatedëœ í•¨ìˆ˜... ìì¡´ì‹¬ ìƒí•˜ì§€ë§Œ ì§ì ‘ htmlì„ ì‚½ì…í•˜ëŠ” ê²½ìš° undo/redoê°€ ì•ˆë¨.
        document.execCommand("insertHTML", false, cleanedHTML);
        observeEditor();
        editor.contentEditable = "plaintext-only";
        updateText();
    });
    const { update } = (() => {
        let _renderId = 0;
        let _cancelRenderId = null;
        function update({ diffs, anchors }) {
            if (_cancelRenderId) {
                cancelIdleCallback(_cancelRenderId);
                _cancelRenderId = null;
            }
            if (_renderId === Number.MAX_SAFE_INTEGER) {
                // ê·¸ëŸ°ì¼ì€... ì ˆëŒ€ë¡œ... ì—†ì„ê±°ë¼...
                _renderId = 0;
            }
            const startTime = performance.now();
            const renderId = ++_renderId;
            const generator = updateGenerator({ renderId, diffs, anchors });
            // ì¼ë‹¨ start!
            console.debug("[%s] update(#%d) started", editorName, renderId);
            generator.next();
            const step = (idleDeadline) => {
                _cancelRenderId = null;
                const { done } = generator.next(idleDeadline);
                if (!done) {
                    if (renderId === _renderId) {
                        _cancelRenderId = requestIdleCallback(step, { timeout: FORCE_RENDER_TIMEOUT });
                    }
                }
                else {
                    console.debug("[%s] update(#%d) took %d ms", editorName, renderId, performance.now() - startTime);
                }
            };
            _cancelRenderId = requestIdleCallback(step, { timeout: FORCE_RENDER_TIMEOUT });
        }
        function* updateGenerator({ renderId, diffs, anchors }) {
            if (!diffs) {
                return;
            }
            untrackIntersections();
            _lineElements.length = 0;
            _lineHints.length = 0;
            _diffElements.length = 0;
            _anchorElements.length = 0;
            // ì—¬ê¸°ì„œ ì¼ë‹¨ í•œë²ˆ yield í•´ì¤˜ì•¼ idleDeadlineì„ ë°›ì„ ìˆ˜ ìˆìŒ.
            let idleDeadline = yield;
            const textruns = getTextRuns(editorName, _text, _textProps, diffs, anchors);
            const text = _text;
            const view = mirror;
            let lineEl = null;
            let nextInlineNode = null;
            let currentDiffIndex = null;
            let currentTextProps = { pos: 0, color: null, flags: 0 };
            let lineNum;
            let lineIsEmpty = true;
            let numConsecutiveBlankLines = 0;
            let textPos;
            let currentContainer;
            let diffEl = null;
            const containerStack = [];
            function appendAnchor(pos, anchorIndex) {
                const anchor = anchors[anchorIndex];
                let anchorEl;
                if (nextInlineNode === null || nextInlineNode.nodeName !== ANCHOR_TAG) {
                    anchorEl = document.createElement(ANCHOR_TAG);
                    anchorEl.contentEditable = "false"; // ë§Œì•½ì— mirrorë¥¼ contentEditableë¡œ ë§Œë“¤ê²½ìš°ì—...
                    currentContainer.insertBefore(anchorEl, nextInlineNode);
                }
                else {
                    anchorEl = nextInlineNode;
                    nextInlineNode = anchorEl.nextSibling;
                }
                anchorEl.id = `${editorName}Anchor${anchorIndex}`;
                anchorEl.dataset.type = anchor.type;
                anchorEl.dataset.anchor = anchorIndex.toString();
                anchorEl.dataset.pos = pos.toString();
                if (anchor.diffIndex !== null) {
                    anchorEl.dataset.diff = anchor.diffIndex.toString();
                }
                else {
                    delete anchorEl.dataset.diff;
                }
                // pushê°€ ì•„ë‹Œ indexë¡œ ì‚½ì…í•¨!
                // textrunì´ ê¼¬ì´ë©´ anchorê°€ ìŠ¤í‚µë  ìˆ˜ë„ ìˆìŒ.
                _anchorElements[anchorIndex] = anchorEl;
            }
            function appendChars(chars) {
                let el;
                const nodeName = "SPAN";
                if (!nextInlineNode || nextInlineNode.nodeName !== nodeName) {
                    el = document.createElement(nodeName);
                    currentContainer.insertBefore(el, nextInlineNode);
                }
                else {
                    el = nextInlineNode;
                    nextInlineNode = el.nextSibling;
                }
                if (lineIsEmpty) {
                    for (const ch of chars) {
                        if (!SPACE_CHARS[ch]) {
                            lineIsEmpty = false;
                            break;
                        }
                    }
                }
                if (el.textContent !== chars) {
                    el.textContent = chars;
                }
                el.className = currentTextProps.color || "";
            }
            function openDiff(diffIndex) {
                if (nextInlineNode === null || nextInlineNode.nodeName !== DIFF_ELEMENT_NAME) {
                    diffEl = document.createElement(DIFF_ELEMENT_NAME);
                    const parent = currentContainer ?? lineEl;
                    parent.insertBefore(diffEl, nextInlineNode);
                    currentContainer = diffEl;
                }
                else {
                    diffEl = currentContainer = nextInlineNode;
                }
                nextInlineNode = diffEl.firstChild;
                diffEl.dataset.diff = diffIndex.toString();
                diffEl.className = `diff-color${(diffIndex % NUM_DIFF_COLORS) + 1}`;
                diffEl.classList.toggle("asBlock", diffs[diffIndex].asBlock);
                (_diffElements[diffIndex] ??= []).push(diffEl);
            }
            function closeDiff() {
                if (diffEl) {
                    // diff ì´í›„ì— ìŒ“ì¸ containerë“¤ì„ poppoppop
                    while (currentContainer !== diffEl) {
                        popContainer();
                    }
                    // diffê¹Œì§€ pop
                    popContainer();
                }
            }
            function popContainer() {
                // í˜„ì¬ containerì— ë‚¨ì•„ìˆëŠ” inline ë…¸ë“œë“¤ ì œê±°(ì´ì „ ì—…ë°ì´íŠ¸ ë•Œ ì“°ì˜€ì§€ë§Œ ì§€ê¸ˆì€ ì•ˆì“°ì´ëŠ” ë…¸ë“œë“¤)
                while (nextInlineNode) {
                    const nextnext = nextInlineNode.nextSibling;
                    nextInlineNode.remove();
                    nextInlineNode = nextnext;
                }
                if (containerStack.length > 0) {
                    nextInlineNode = currentContainer.nextSibling;
                    currentContainer = containerStack.pop();
                    return currentContainer;
                }
                if (currentContainer !== lineEl) {
                    const ret = currentContainer;
                    nextInlineNode = currentContainer.nextSibling;
                    currentContainer = lineEl;
                    return ret;
                }
                return null;
            }
            textPos = 0;
            lineNum = 1;
            lineEl = view.firstElementChild;
            let textRunIndex = 0;
            // ì¤„ë‹¨ìœ„ë¡œ í•„ìš”í•œ ë¶€ë¶„ë§Œ ì—…ë°ì´íŠ¸ í•  ìˆ˜ ìˆê²Œ ì¤„ì— í•´ë‹¹í•˜ëŠ” textrunë“¤ë§Œ ëª¨ì•„ë‘ì§€ë§Œ
            // í•„ìš”í•œ ë¶€ë¶„ë§Œ ì—…ë°ì´íŠ¸ í•˜ëŠ” ì½”ë“œëŠ” ê·¸ëƒ¥ ë‹¤ ì§€ì›Œë²„ë¦¼. ì‹ ê²½ì“¸ê²Œ ë§ê³  ì–»ëŠ”ê²Œ ê·¸ë¦¬ ë§ì§€ ì•Šë‹¤ => ì§€ê¸ˆë„ ì´ë¯¸ ì¶©ë¶„íˆ ë¹ ë¥´ë‹¤.
            let textrunBuffer = [];
            while (textRunIndex < textruns.length) {
                if (renderId !== _renderId) {
                    // ìƒˆë¡œìš´ ë Œë” ìš”ì²­ì´ ë“¤ì–´ì˜´.
                    return;
                }
                // ì‚~~ íƒ€ì„ì˜¤ë²„.
                if (idleDeadline && idleDeadline.timeRemaining() <= 3) {
                    idleDeadline = yield;
                }
                textrunBuffer.length = 0;
                for (; textRunIndex < textruns.length; textRunIndex++) {
                    const textrun = textruns[textRunIndex];
                    textrunBuffer.push(textrun);
                    if (textrun.type === "LINEBREAK" || textrun.type === "END_OF_STRING") {
                        textRunIndex++;
                        break;
                    }
                }
                let textrun;
                const lineStartPos = textPos;
                lineIsEmpty = true;
                if (lineEl === null) {
                    lineEl = document.createElement(LINE_TAG);
                    view.appendChild(lineEl);
                }
                lineEl.dataset.lineNum = lineNum.toString();
                lineEl.dataset.pos = textPos.toString();
                _lineElements[lineNum - 1] = lineEl;
                currentContainer = lineEl;
                nextInlineNode = currentContainer.firstChild;
                if (currentDiffIndex !== null) {
                    openDiff(currentDiffIndex);
                }
                for (textrun of textrunBuffer) {
                    const type = textrun.type;
                    if (type === "CHARS") {
                        const { pos, len } = textrun;
                        appendChars(text.slice(pos, pos + len));
                    }
                    else if (type === "ANCHOR") {
                        appendAnchor(textrun.pos, textrun.anchorIndex);
                    }
                    else if (type === "MODIFIER") {
                        // not implemented yet
                        currentTextProps = textrun.props;
                    }
                    else if (type === "DIFF") {
                        currentDiffIndex = textrun.diffIndex;
                        openDiff(currentDiffIndex);
                    }
                    else if (type === "DIFF_END") {
                        closeDiff();
                        currentDiffIndex = null;
                    }
                }
                // ë‚¨ì€ containerë“¤ pop pop pop
                while (popContainer())
                    ;
                lineEl = lineEl.nextElementSibling;
                textPos = textrun.pos + textrun.len;
                if (lineIsEmpty) {
                    numConsecutiveBlankLines++;
                }
                else {
                    numConsecutiveBlankLines = 0;
                }
                _lineHints[lineNum - 1] = { pos: lineStartPos, len: textPos - lineStartPos, empty: false, numConsecutiveBlankLines };
                lineNum++;
                if (textrun.type === "LINEBREAK") {
                    //
                }
                else {
                    // ì•ˆí•´ë„ textrunIndex === textruns.lengthê°€ ë˜ì„œ whileë¬¸ì´ ëë‚˜ê¸´ í•˜ì§€ë§Œ... ë‚˜ë¥¼ ëª»ë¯¿ê² ì–´.
                    break;
                }
            }
            // ë‚¨ì€ ì¤„ë“¤ì€ ëª¨ì¡°ë¦¬ ì œê±°
            while (lineEl) {
                const nextnext = lineEl.nextElementSibling;
                lineEl.remove();
                lineEl = nextnext;
            }
            trackIntersections();
            onMirrorUpdated();
        }
        return { update };
    })();
    function getVisibleAnchors() {
        return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
    }
    // caret(í…ìŠ¤íŠ¸ì»¤ì„œ '|')ê°€ ìˆëŠ” ìœ„ì¹˜ì— ê°€ì¥ ê°€ê¹Œìš´ ì•µì»¤ë¥¼ ê°€ì ¸ì˜´.
    // edit ëª¨ë“œê°€ ì•„ë‹Œ ê²½ìš°ì—ëŠ” null ë¦¬í„´
    function getClosestAnchorToCaret() {
        if (!_editMode) {
            return null;
        }
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null;
        }
        let range = selection.getRangeAt(0);
        if (!editor.contains(range.startContainer)) {
            return null;
        }
        let rect = range.getBoundingClientRect();
        let y;
        if (rect.left === 0 && rect.top === 0) {
            y = EDITOR_PADDING + TOPBAR_HEIGHT;
        }
        else {
            y = rect.top;
        }
        let closestAnchor = null;
        let minDistance = Number.MAX_SAFE_INTEGER;
        for (const anchor of _visibleAnchors) {
            const rect = anchor.getBoundingClientRect();
            const distance = Math.abs(rect.top - y);
            if (distance < minDistance) {
                minDistance = distance;
                closestAnchor = anchor;
            }
        }
        return closestAnchor;
    }
    function getFirstVisibleLineElement() {
        const lineEls = _lineElements;
        let low = 0;
        let high = lineEls.length - 1;
        let mid;
        let lineEl = null;
        let distance = null;
        while (low <= high) {
            mid = (low + high) >>> 1;
            const thisDistance = lineEls[mid].getBoundingClientRect().top - TOPBAR_HEIGHT;
            if (thisDistance >= -LINE_HEIGHT) {
                lineEl = lineEls[mid];
                distance = thisDistance;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return [lineEl, distance]; //nullì¼ ìˆ˜ë„ ìˆì§€ë§Œ ì˜ë„ì ìœ¼ë¡œ ëŠë‚Œí‘œ ë•Œë ¤ë°•ìŒ
    }
    function scrollToDiff(diffIndex) {
        const offsetTop = _diffElements[diffIndex][0].offsetTop - wrapper.clientTop;
        wrapper.scrollTop = offsetTop - SCROLL_MARGIN;
    }
    // ë‚´ê°€ ë¨¸ë¦¬ê°€ ë‚˜ì˜ë‹¤ëŠ” ê±¸ í™•ì‹¤í•˜ê²Œ ì•Œê²Œ í•´ì£¼ëŠ” í•¨ìˆ˜
    function scrollToLine(lineNum, margin = 0) {
        const lineEl = _lineElements[lineNum - 1];
        if (lineEl) {
            const scrollTop = lineEl.offsetTop - margin;
            wrapper.scrollTop = scrollTop;
        }
    }
    function getFirstVisibleAnchor() {
        let firstAnchor = null;
        let firstPos = null;
        for (const anchor of _visibleAnchors) {
            if (firstAnchor === null) {
                firstAnchor = anchor;
                firstPos = Number(anchor.dataset.pos);
            }
            else {
                const pos = Number(anchor.dataset.pos);
                if (pos < firstPos) {
                    firstAnchor = anchor;
                    firstPos = pos;
                }
            }
        }
        return firstAnchor;
    }
    function setEditMode(editMode) {
        _editMode = !!editMode;
    }
    function findLineIndexByPos(pos, low = 0, high = _lineHints.length - 1) {
        const lineHints = _lineHints;
        if (lineHints.length === 0)
            return -1;
        if (pos < 0)
            return -1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const hint = lineHints[mid];
            const start = hint.pos;
            const end = mid + 1 < lineHints.length ? lineHints[mid + 1].pos : Infinity;
            if (pos < start) {
                high = mid - 1;
            }
            else if (pos >= end) {
                low = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1; // posê°€ ë§ˆì§€ë§‰ ì¤„ endë¥¼ ë„˜ì–´ê°„ ê²½ìš°
        // let mid;
        // while (low <= high) {
        // 	mid = (low + high) >> 1;
        // 	const lineEl = _lineElements[mid];
        // 	const linePos = Number(lineEl.dataset.pos);
        // 	if (linePos === pos) {
        // 		return mid;
        // 	}
        // 	if (linePos > pos) {
        // 		high = mid - 1;
        // 	} else {
        // 		low = mid + 1;
        // 	}
        // }
        // return high;
    }
    // selectTextRange, getTextSelectionRange ì´ ë‘˜ì€ ë‹¤ìŒë‚  ë³´ë©´ ë‹¤ì‹œ ê¹œê¹œí•´ì§„ë‹¤.
    // ì†ëŒ€ë ¤ë©´ ì •ë§ ê° ì¡ê³  í•´ì•¼í•¨.
    function selectTextRange(startOffset, endOffset) {
        startOffset = Math.max(0, Math.min(startOffset, _text.length));
        endOffset = Math.max(0, Math.min(endOffset, _text.length));
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        const range = document.createRange();
        let startSet = false;
        let endSet = false;
        if (_editMode) {
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
            let currentNode;
            let pos = 0;
            while (!endSet && (currentNode = walker.nextNode())) {
                if (!startSet && pos + currentNode.nodeValue.length >= startOffset) {
                    range.setStart(currentNode, startOffset - pos);
                    startSet = true;
                }
                if (!endSet && pos + currentNode.nodeValue.length >= endOffset) {
                    range.setEnd(currentNode, endOffset - pos);
                    endSet = true;
                }
                pos += currentNode.nodeValue.length;
            }
        }
        else {
            let startLineIndex = findLineIndexByPos(startOffset);
            let endLineIndex = findLineIndexByPos(endOffset, startLineIndex);
            let currentNode;
            let walker = document.createTreeWalker(_lineElements[startLineIndex], NodeFilter.SHOW_TEXT, null);
            let pos = Number(_lineElements[startLineIndex].dataset.pos);
            while ((currentNode = walker.nextNode())) {
                const nodeLen = currentNode.nodeValue.length;
                if (pos + nodeLen >= startOffset) {
                    range.setStart(currentNode, startOffset - pos);
                    startSet = true;
                    break;
                }
                pos += nodeLen;
            }
            walker = document.createTreeWalker(_lineElements[endLineIndex], NodeFilter.SHOW_TEXT, null);
            pos = Number(_lineElements[endLineIndex].dataset.pos);
            if (pos === endOffset) {
                range.setEndBefore(_lineElements[endLineIndex]);
                endSet = true;
            }
            else {
                while ((currentNode = walker.nextNode())) {
                    const nodeLen = currentNode.nodeValue.length;
                    if (pos + nodeLen >= endOffset) {
                        range.setEnd(currentNode, endOffset - pos);
                        endSet = true;
                        break;
                    }
                    pos += nodeLen;
                }
            }
        }
        if (startSet && endSet) {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
    function getFirstTextNode(node) {
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);
        return walker.nextNode();
    }
    function getTextSelectionRange() {
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount) {
            return [null, null];
        }
        const range = selection.getRangeAt(0);
        if (!wrapper.contains(range.commonAncestorContainer)) {
            return [null, null];
        }
        let startOffset = Number.NaN;
        let endOffset = Number.NaN;
        let startNode = range.startContainer;
        let endNode = range.endContainer;
        let nodeStartOffset = range.startOffset;
        let nodeEndOffset = range.endOffset;
        if (startNode.nodeType !== 3) {
            startNode = getFirstTextNode(startNode.childNodes[nodeStartOffset]);
            nodeStartOffset = 0;
        }
        if (endNode.nodeType !== 3) {
            endNode = getFirstTextNode(endNode.childNodes[nodeEndOffset]);
            nodeEndOffset = 0;
        }
        if (!startNode || !endNode) {
            return [null, null];
        }
        if (_editMode) {
            // edit ëª¨ë“œì—ì„œ contenteditableì€ ê·¸ëƒ¥ textNode ì§‘í•©ì„. textNode í•˜ë‚˜ê°€ í•œ ì¤„ì¼ ìˆ˜ë„ ìˆê³ 
            // í•˜ë‚˜ì˜ textNodeì— ì—¬ëŸ¬ì¤„ì´ ë“¤ì–´ê°€ ìˆì„ ìˆ˜ë„ ìˆë‹¤. ê³ ë¡œ ê·¸ëƒ¥ ê¸€ì ìˆ˜ë¥¼ ìƒˆì–´ë³´ëŠ” ìˆ˜ ë°–ì— ì—†ìŒ.
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
            let currentNode;
            let pos = 0;
            while ((currentNode = walker.nextNode())) {
                if (currentNode === startNode) {
                    startOffset = pos + nodeStartOffset;
                }
                if (currentNode === endNode) {
                    endOffset = pos + nodeEndOffset;
                    break;
                }
                pos += currentNode.nodeValue.length;
            }
        }
        else {
            // aligned mode.
            // ì´ ê²½ìš° ì¡°ê¸ˆ ìµœì í™”ê°€ ê°€ëŠ¥. ì‹¤ì œë¡œ ì´ê²Œ ì–¼ë§ˆë‚˜ íš¨ìœ¨ì ì¸ì§€ëŠ” í…ŒìŠ¤íŠ¸í•´ ë³¼ í•„ìš”ê°€ ìˆê² ì§€ë§Œ...
            // ëª‡ ì²œ ë¼ì¸ì˜ í…ìŠ¤íŠ¸ì— diff, anchorê°€ ë§ì€ ê²½ìš° ë‹¹ì—°íˆ ì‹œì‘ì¤„, ëì¤„ì„ ë¨¼ì € ì°¾ê³  ê·¸ ì¤„ì— ëŒ€í•´ì„œë§Œ
            // offsetì„ ê³„ì‚°í•˜ëŠ” ê²ƒì´ ë” ë¹ ë¥´ê² ì§€!
            let startLineEl = startNode.parentElement?.closest("div[data-pos]");
            let endLineEl = endNode.parentElement?.closest("div[data-pos]");
            if (startLineEl && endLineEl) {
                let walker = document.createTreeWalker(startLineEl, NodeFilter.SHOW_TEXT, null);
                let pos = Number(startLineEl.dataset.pos);
                let currentNode;
                while ((currentNode = walker.nextNode())) {
                    if (currentNode === startNode) {
                        startOffset = pos + nodeStartOffset;
                        break;
                    }
                    pos += currentNode.nodeValue.length;
                }
                walker = document.createTreeWalker(endLineEl, NodeFilter.SHOW_TEXT, null);
                pos = Number(endLineEl.dataset.pos);
                while ((currentNode = walker.nextNode())) {
                    if (currentNode === endNode) {
                        endOffset = pos + nodeEndOffset;
                        break;
                    }
                    pos += currentNode.nodeValue.length;
                }
            }
            if (startOffset > _text.length - 1) {
                startOffset = _text.length - 1;
            }
            if (endOffset > _text.length - 1) {
                endOffset = _text.length - 1;
            }
        }
        if (isNaN(startOffset) || isNaN(endOffset)) {
            return [null, null];
        }
        if (startOffset > endOffset) {
            [startOffset, endOffset] = [endOffset, startOffset];
        }
        return [startOffset, endOffset];
    }
    return {
        name: editorName,
        wrapper,
        editor,
        mirror,
        updateText,
        update,
        scrollToDiff,
        // saveCaret,
        // restoreCaret,
        getVisibleAnchors,
        trackIntersections,
        untrackIntersections,
        getFirstVisibleAnchor,
        scrollToLine,
        getFirstVisibleLineElement,
        getClosestAnchorToCaret: getClosestAnchorToCaret,
        setEditMode,
        getTextSelectionRange,
        selectTextRange,
        // ê·¸ëƒ¥ states ê°ì²´ë¥¼ í•˜ë‚˜ ë§Œë“¤ì–´ì„œ ë¦¬í„´í• ê¹Œ...
        get text() {
            return _text;
        },
        get lineElements() {
            return _lineElements;
        },
        get diffElements() {
            return _diffElements;
        },
        get visibleAnchors() {
            return _visibleAnchors;
        },
        get anchorElements() {
            return _anchorElements;
        },
        get visibleDiffIndices() {
            return _visibleDiffIndices;
        },
        get lineHints() {
            return _lineHints;
        },
    };
}
//# sourceMappingURL=editor.js.map
</script>
<script>"use strict";
// ì–´ì„¤í”„ê³  ì—‰ì„±í•˜ê³  ëª»ìƒê¹€.
// ë‚˜ë„ uië¼ì´ë¸ŒëŸ¬ë¦¬ ì“¸ ìˆ˜ ìˆìœ¼ë©´ë©´ ì´ì˜ê²Œ ì˜ ë§Œë“¤ ìˆ˜ ìˆë‹¤!
function InitializeStatusBar(items) {
    const statusBarElement = document.getElementById("statusbar");
    const popup = document.getElementById("settingsPopup");
    const leftContainer = document.createElement("div");
    leftContainer.classList.add("status-bar-left");
    statusBarElement.appendChild(leftContainer);
    const centerContainer = document.createElement("div");
    centerContainer.classList.add("status-bar-center");
    statusBarElement.appendChild(centerContainer);
    const rightContainer = document.createElement("div");
    rightContainer.classList.add("status-bar-right");
    statusBarElement.appendChild(rightContainer);
    function init() {
        items.forEach(createStatusItem);
    }
    function createStatusItem(item) {
        const statusItem = document.createElement("div");
        statusItem.classList.add("status-item");
        statusItem.setAttribute("data-popup", item.key);
        if (item.options) {
            statusItem.classList.add("clickable");
            statusItem.innerHTML = `${item.label} <span></span> â–¼`;
            statusItem.addEventListener("click", () => {
                togglePopup(item.key, statusItem, item);
            });
        }
        else if (item.toggle) {
            statusItem.classList.add("clickable");
            statusItem.innerHTML = `${item.label} <span></span>`;
            statusItem.addEventListener("click", () => {
                item.toggle();
            });
        }
        else {
            statusItem.innerHTML = `${item.label} <span></span>`;
        }
        if (item.side === "left") {
            leftContainer.appendChild(statusItem);
        }
        else if (item.side === "right") {
            rightContainer.appendChild(statusItem);
        }
        else if (item.side === "center") {
            centerContainer.appendChild(statusItem);
        }
        else {
            console.error(`Unknown side: ${item.side}`);
            return;
        }
    }
    function togglePopup(key, targetElement, item) {
        const currentOpenPopup = document.querySelector("[data-popup].open");
        if (currentOpenPopup && currentOpenPopup !== targetElement) {
            currentOpenPopup.classList.remove("open");
            currentOpenPopup.style.display = "none";
        }
        const isOpen = targetElement.classList.contains("open");
        if (!isOpen && item.options) {
            showPopup(key, targetElement, item);
        }
        else {
            closePopup();
        }
    }
    function showPopup(key, targetElement, item) {
        if (item.visible && !item.visible()) {
            return;
        }
        popup.innerHTML = "";
        const options = item.options;
        const value = item.get();
        options.forEach((option) => {
            const div = document.createElement("div");
            div.textContent = option.label;
            if (option.value === value) {
                div.classList.add("selected");
            }
            div.onclick = () => {
                item.set(option.value);
                updateItem(item);
                closePopup();
            };
            popup.appendChild(div);
        });
        popup.style.display = "block";
        targetElement.classList.add("open");
        requestAnimationFrame(() => setPopupPosition(key, targetElement));
    }
    function setPopupPosition(key, targetElement) {
        const rect = targetElement.getBoundingClientRect();
        const popupHeight = popup.offsetHeight;
        const popupWidth = popup.offsetWidth;
        const offset = 5;
        let topPosition = rect.top - popupHeight - offset;
        if (topPosition < 0) {
            topPosition = rect.bottom + offset;
        }
        let leftPosition = rect.left;
        if (leftPosition + popupWidth > window.innerWidth) {
            leftPosition = window.innerWidth - popupWidth - offset;
        }
        if (leftPosition < 0) {
            leftPosition = offset;
        }
        popup.style.top = `${topPosition}px`;
        popup.style.left = `${leftPosition}px`;
    }
    function updateItem(item) {
        const element = statusBarElement.querySelector(`[data-popup="${item.key}"] span`);
        if (!element)
            return;
        if (item.visible && !item.visible()) {
            // element.parentElement!.classList.toggle("disabled", true);
            element.parentElement.style.display = "none";
        }
        else {
            // element.parentElement!.classList.toggle("disabled", false);
            element.parentElement.style.removeProperty("display");
            const value = item.get();
            const text = (item.options && item.options.find((opt) => opt.value === value)) || value || "";
            element.textContent = text?.label || value.toString();
        }
    }
    function closePopup() {
        popup.style.display = "none";
        const openElements = document.querySelectorAll("[data-popup].open");
        openElements.forEach((el) => el.classList.remove("open"));
    }
    function update() {
        for (const item of items) {
            updateItem(item);
            // const value = item.get();
            // if (item.visible && !item.visible()) {
            // 	const element = statusBarElement.querySelector(`[data-popup="${item.key}"] span`) as HTMLElement;
            // 	if (element) {
            // 		element.style.display = "none";
            // 	}
            // }
            // updateOption(item.key, value);
        }
    }
    init();
    document.addEventListener("click", (event) => {
        if (!popup.contains(event.target) && !statusBarElement.contains(event.target)) {
            closePopup();
        }
    });
    document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
            closePopup();
        }
    });
    return {
        update,
        closePopup,
    };
}
//# sourceMappingURL=statusbar.js.map
</script>
<script id="worker.js" type="text/plain">"use strict";
const FIRST_OF_LINE = 1;
const LAST_OF_LINE = 2;
const WILD_CARD = 16;
const NORMALIZE = 32; // &middot;, ë”°ì˜´í‘œ -, ë§ë¨¸ë¦¬ë¬¸ì ë“±ë“± ì‹¤ì œë¡œ ë¬¸ì ì½”ë“œëŠ” ë‹¤ë¥´ì§€ë§Œ ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼ í•  ë¬¸ìë“¤ì´ ìˆë‹¤.
const SECTION_HEADING = 64;
const MANUAL_ANCHOR = 128; // @@@, ### ë“±ë“±
let _nextCtx = null;
let _currentCtx = null;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "myers") {
            result = await runMyersDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            diffs: result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhsTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    // return postProcess(ctx, rawResult, lhsTokens, rhsTokens);
    return rawResult;
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // í…ìŠ¤íŠ¸ê°€ ê¸¸ì–´ì§€ëŠ” ê²½ìš°(í† í°ì´ ë§ì€ ê²½ìš°) ë”ì°í•˜ê²Œ ë§ì€ ë°˜ë³µì„ ìˆ˜í–‰í•˜ê²Œëœë‹¤.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // ì£¼ê¸°ì ìœ¼ë¡œ yield í•´ì„œ ì·¨ì†Œìš”ì²­ì„ ë°›ì•„ì•¼í•¨.
            // performance.now()ëŠ” ë¯¸ì¹œê²Œ ì•„ë‹Œê°€ ì‹¶ì„ ì •ë„ë¡œ ë¬´ê±°ìš´ í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— ë˜ë„ë¡ ìì œ.
            // await new Promise(...) ì—­ì‹œ ìì£¼ ì‚¬ìš©í•˜ë©´ ì•ˆë¨
            // (i+j) % 0x4000 === 0 ì¼ ë•Œë§Œ ì‚¬ìš©í•˜ê¸°ë¡œ. ë¸Œë¼ìš°ì € jsì—”ì§„ì˜ ë¹„íŠ¸ì—°ì‚° ì†ë„ë¥¼ ë¯¿ì–´ë³¸ë‹¤ ã…‹
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// ì •ë“¤ì—ˆë˜ diff í•¨ìˆ˜. íê¸°ì²˜ë¶„ ì˜ˆì •.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // ìœ íš¨í•œ í† í° index
                (!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
                    (!greedyMatch && i < lcsEntry.leftIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // ìœ íš¨í•œ í† í° index
                (!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
                    (!greedyMatch && j < lcsEntry.rightIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Myers Algorithm
// ============================================================
// not fully working yet! ìƒê°ë³´ë‹¤ ì´í•´ê°€ ì•ˆë˜ëŠ” ì•Œê³ ë¦¬ì¦˜...
async function runMyersDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const vectorSize = (lhsTokens.length + rhsTokens.length + 1) * 2;
    const vectorDown = new Array(vectorSize);
    const vectorUp = new Array(vectorSize);
    ctx.states.vectorDown = vectorDown;
    ctx.states.vectorUp = vectorUp;
    const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findMiddleSnake);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return rawEntries;
}
// ì•Œì­ë‹¬ì­.
function findMiddleSnake(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const max = lhsTokens.length + rhsTokens.length + 1;
    const width = lhsUpper - lhsLower;
    const height = rhsUpper - rhsLower;
    const delta = width - height;
    const kdown = lhsLower - rhsLower;
    const kup = lhsUpper - rhsUpper;
    const offset_down = max - kdown;
    const offset_up = max - kup;
    const maxD = (lhsUpper - lhsLower + rhsUpper - rhsLower) / 2 + 1;
    const odd = (delta & 1) != 0;
    // const ret = { x: 0, y: 0 };
    // console.log("getShortestMiddleSnake", {
    // 	lhsLower,
    // 	lhsUpper,
    // 	rhsLower,
    // 	rhsUpper,
    // 	width,
    // 	height,
    // 	delta,
    // 	kDown: kdown,
    // 	kUp: kup,
    // 	offsetDown: offset_down,
    // 	offsetUp: offset_up,
    // 	maxD,
    // 	odd,
    // });
    const { vectorDown, vectorUp } = ctx.states;
    vectorDown[offset_down + kdown + 1] = lhsLower;
    vectorUp[offset_up + kup - 1] = lhsUpper;
    // console.log("offsetDown", offset_down, kdown, vectorD[offset_down + kdown + 1]);
    let d, k, x, y;
    for (d = 0; d <= maxD; d++) {
        for (k = kdown - d; k <= kdown + d; k += 2) {
            if (k === kdown - d) {
                x = vectorDown[offset_down + k + 1]; //down
            }
            else {
                x = vectorDown[offset_down + k - 1] + 1; //right
                if (k < kdown + d && vectorDown[offset_down + k + 1] >= x) {
                    x = vectorDown[offset_down + k + 1]; //down
                }
            }
            y = x - k;
            // console.log("BEFORE \\", x, y);
            while (x < lhsUpper && y < rhsUpper && lhsTokens[x].text === rhsTokens[y].text) {
                x++;
                y++;
            }
            vectorDown[offset_down + k] = x;
            // console.log("FORWARD", {
            // 	x,
            // 	y,
            // 	k,
            // 	d,
            // 	kDown: kdown,
            // 	vectorD,
            // 	vectorU,
            // 	"vectorDown[offsetDown + k + 1]": vectorD[offset_down + k + 1],
            // 	"vectorDown[offsetDown + k - 1]": vectorD[offset_down + k - 1],
            // });
            if (odd && kup - d < k && k < kup + d) {
                //if (vectorUp[offset_up + k] <= vectorDown[offset_down + k]) {
                if (vectorDown[offset_down + k] >= vectorUp[offset_up + k]) {
                    return {
                        lhsIndex: vectorDown[offset_down + k],
                        lhsLength: 1,
                        rhsIndex: vectorDown[offset_down + k] - k,
                        rhsLength: 1,
                    };
                    // ret.x = vectorDown[offset_down + k];
                    // ret.y = vectorDown[offset_down + k] - k;
                    // return ret;
                }
            }
        }
        for (k = kup - d; k <= kup + d; k += 2) {
            // find the only or better starting point
            if (k === kup + d) {
                x = vectorUp[offset_up + k - 1]; // up
            }
            else {
                x = vectorUp[offset_up + k + 1] - 1; // left
                if (k > kup - d && vectorUp[offset_up + k - 1] < x)
                    x = vectorUp[offset_up + k - 1]; // up
            }
            y = x - k;
            while (x > lhsLower && y > rhsLower && lhsTokens[x - 1].text === rhsTokens[y - 1].text) {
                // diagonal
                x--;
                y--;
            }
            vectorUp[offset_up + k] = x;
            // console.log("BACKWARD", {
            // 	x,
            // 	y,
            // 	k,
            // 	d,
            // 	kUp: kup,
            // 	vectorD,
            // 	vectorU,
            // 	"vectorD[offset_down + k]": vectorD[offset_down + k],
            // 	"vectorU[offset_up + k]": vectorU[offset_up + k],
            // });
            // overlap ?
            if (!odd && kdown - d <= k && k <= kdown + d) {
                // if (vectorUp[offset_up + k] <= vectorDown[offset_down + k]) {
                if (vectorDown[offset_down + k] >= vectorUp[offset_up + k]) {
                    return {
                        lhsIndex: vectorDown[offset_down + k],
                        lhsLength: 1,
                        rhsIndex: vectorDown[offset_down + k] - k,
                        rhsLength: 1,
                    };
                }
            }
        }
    }
    return null;
    // throw new Error("No middle snake found");
    // return { x: lhsLower - 1, y: rhsLower - 1 };
    // return { x: -1, y: -1 }; // No snake found
}
// ============================================================
// Histogram Algorithm
// ì¼ë‹¨ ì§€ê¸ˆì€ ì´ë†ˆì´ ë””í´íŠ¸
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    ctx.states.entries = [];
    const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findBestHistogramAnchor);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return rawEntries;
}
// histogram diffì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ í•¨ìˆ˜
// ì–¼ë§ˆë‚˜ ê°’ì–´ì¹˜ ìˆëŠ” ê³µí†µ ì•µì»¤ë¥¼ ì°¾ëŠëƒê°€ ë§¤ìš° ì¤‘ìš”í•˜ê³  ê³ ë¡œ ê·¸ ê°’ì–´ì¹˜ë¥¼ ë§¤ê¸°ëŠ” ê¸°ì¤€ê³¼ ë°©ë²•ì´ ë˜ ë§¤ìš° ì¤‘ìš”í•¨
// ì—¬ëŸ¬ê°€ì§€ ìƒê°í•´ë³¼ ê²ƒë“¤ì´ ë§ì§€ë§Œ...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // ê¸¸ì´ê°€ ë„ˆë¬´ í¬ê²Œ ì˜í–¥ì„ ì£¼ëŠ” ê²½í–¥ì´ ìˆì–´ì„œ ì´ê±¸ë¡œ ì¡°ì ˆ
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; nê·¸ë¨ì„ ì‚¬ìš©ì‹œ ì—¬ëŸ¬ë‹¨ì–´ê°€ ë§¤ì¹˜ë˜ëŠ” ê²½ìš° ì˜¤íˆë ¤ ë§ˆì§€ë§‰ ë‹¨ì–´ê°€ ë‹¤ìŒ ì¤„ë¡œ ë„˜ì–´ê°€ì„œ ë³´ë„ˆìŠ¤ë¥¼ ëª» ë°›ì„ ìˆ˜ê°€ ìˆë‹¤
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + lhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            for (let k = 1; k < n; k++) {
                key += delimiter + rhsTokens[i + k].text;
            }
            freq[key] = (freq[key] || 0) + 1;
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // íŠ¹ìˆ˜ ì¼€ì´ìŠ¤
        // ê°•ì œë¡œ ë¬¸ì„œì˜ íŠ¹ì • ì§€ì ë¼ë¦¬ ë§¤ì¹­ì‹œí‚´. ë¬¸ì„œ êµ¬ì¡°ê°€ í•­ìƒ ë‚´ ë§˜ ê°™ì€ ê²ƒì´ ì•„ë‹ˆì•¼. ã… 
        // if (ltext1 === MANUAL_ANCHOR1 || ltext1 === MANUAL_ANCHOR2) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            const rtext1 = rhsTokens[j].text;
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    if (lhsTokens[li].flags & rhsTokens[ri].flags & MANUAL_ANCHOR) {
                        return {
                            lhsIndex: li,
                            lhsLength: 1,
                            rhsIndex: ri,
                            rhsLength: 1,
                        };
                    }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext1.length !== rtext1.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & FIRST_OF_LINE) {
                    // if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LAST_OF_LINE) {
                    // 	score *= FULL_LINE_BONUS;
                    // } else {
                    // }
                    score *= LINE_START_BONUS;
                }
                else if (lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LAST_OF_LINE) {
                    score *= LINE_END_BONUS;
                }
                if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING) {
                    score *= SECTION_HEADING_BONUS;
                }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience ì•Œê³ ë¦¬ì¦˜ì— ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì¬ê·€í•¨ìˆ˜
// 1. ì–‘ í…ìŠ¤íŠ¸ë¥¼ ê³µí†µë˜ëŠ” ë¶€ë¶„(ì•µì»¤)ìœ¼ë¡œ ë¶„í• 
// 2. ë¶„í• ëœ ì˜ì—­ì— ëŒ€í•´ì„œ ì¬ê·€í˜¸ì¶œ
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // ì‚¬ì‹¤ ì´ê±¸ ì“°ë©´ ë¦¬í„´ê°’ì´ í•„ìš” ì—†ëŠ”ë°...
    // í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê³ ì¹˜ê¸° ê·€ì°®ì•„ì„œ ì¼ë‹¨ ë‚´ë¹„ë‘ .
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // ê³µí†µ ë¶€ë¶„ì„ ìŠ¤í‚µí•˜ëŠ”ê±´ë° ë¬¸ì œëŠ” ì—¬ê¸°ì—ì„œ HEAD, TAILì„ ìŠ¤í‚µí•˜ê³ 
    // ì´í›„ì— diffCoreë¥¼ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•  ë•Œ ì•ìª½ ì ˆë°˜ì— ëŒ€í•´ì„œ HEADë¶€ë¶„, ë’¤ìª½ ì ˆë°˜ì— ëŒ€í•´ì„œ TAILë¶€ë¶„ì„ ë‹¤ì‹œ í•œë²ˆ ìŠ¤í‚µì„ ì‹œë„í•˜ê²Œ ëœë‹¤.
    // ë” ì´ìƒ ìŠ¤í‚µí•  ê²Œ ì—†ìœ¼ë‹ˆ ê²°ê³¼ì—ëŠ” ì°¨ì´ê°€ ì—†ê² ì§€ë§Œ ë¶ˆí•„ìš”í•œ ì‹œë„ë¥¼ ì•ˆí•˜ëŠ” ìª½ìœ¼ë¡œ ê°œì„ í•´ ë³¼ í•„ìš”ê°€ ìˆìŒ!
    // ìƒê°í•´ë³¼ ê²ƒ: ê³µí†µ prefix,suffixë¥¼ ìŠ¤í‚µí•˜ì§€ ì•Šì•˜ì„ ê²½ìš° ìŠ¤í‚µë˜ì§€ ì•Šì€ ë¶€ë¶„ì—ì„œ ë” ë‚˜ì€ ì•µì»¤ê°€ ë‚˜ì˜¬ í™•ë¥ ì´ ìˆë‹¤.
    // ê·¸ë ‡ì§€ë§Œ ìŠ¤í‚µí•˜ì§€ ì•Šìœ¼ë©´ ì„±ëŠ¥ ìƒ ì•„ì£¼ í° ë¬¸ì œê°€ ìƒê¹€!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize" // consumeCommonEdges í•¨ìˆ˜ì— ê¸€ìë‹¨ìœ„ ë§¤ì¹˜ë¥¼ ì‹œë„í• ì§€ë¥¼ ê°€ë¥´í‚¤ëŠ” ì¸ìë¥¼ ì¶”ê°€í•´ì•¼ ë§ì§€ë§Œ ì§€ê¸ˆì€ ì¢€ ê·€ì°®ë„¤!
    );
    entries.push(...skippedHead);
    // ì–‘ìª½ ëª¨ë‘ ë‚¨ì•„ìˆëŠ” ì˜ì—­ì´ ìˆëŠ” ê²½ìš° ê³µí†µ ì•µì»¤ë¥¼ ì°¾ì•„ë³¸ë‹¤!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! ì ì–´ë„ í•œìª½ì´ë¼ë„ ì˜ì—­ì„ ì¤„ì—¬ì•¼ ë¬´í•œë£¨í”„ ì•ˆ ìƒê¸¸ ë“¯?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor);
        // ì•µì»¤ëŠ” common sequenceì„!
        entries.push({
            type: 0,
            left: {
                pos: anchor.lhsIndex,
                len: anchor.lhsLength,
            },
            right: {
                pos: anchor.rhsIndex,
                len: anchor.rhsLength,
            },
        });
        await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor);
    }
    else {
        // ìœ íš¨í•œ ì•µì»¤ëŠ” ëª»ì°¾ì•˜ì§€ë§Œ ë‚¨ì•„ìˆëŠ” í† í°ë“¤ì´ ìˆë‹¤ë©´ diffë¡œ ì²˜ë¦¬
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    entries.push(...skippedTail);
    return entries;
}
// ê³µë°±ì„ ì™„ì „íˆ ë¬´ì‹œí•˜ëŠ” ê²½ìš° "ì•ˆë…• í•˜ì„¸ìš”" vs "ì•ˆë…•í•˜ì„¸ìš”"ëŠ” ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼í•˜ì§€ë§Œ
// ë‹¨ì–´ë‹¨ìœ„ í† í°ì¸ ê²½ìš° í† í° ëŒ€ í† í° ë¹„êµëŠ” ì‹¤íŒ¨í•  ìˆ˜ ë°–ì— ì—†ë‹¤.
// ë”°ë¼ì„œ ê° í† í°ì˜ ê¸€ìë¥¼ í•œë•€í•œë•€ ë§¤ì¹˜ì‹œì¼œë´ì•¼í•˜ê³  ì–‘ìª½ì—ì„œ í† í°ì´ ëë‚˜ëŠ” ì‹œì ê¹Œì§€ ëª¨ë“  ê¸€ìê°€ ë§¤ì¹˜ë˜ì—ˆë‹¤ë©´
// ê·¸ ëë‚˜ëŠ” ì‹œì ê¹Œì§€ì˜ í† í° ìˆ˜ë§Œí¼ consumeì„ í•¨.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore") {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
        if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
            head.push({
                type: 0,
                left: { pos: lhsLower, len: 1 },
                right: { pos: rhsLower, len: 1 },
            });
            lhsLower++;
            rhsLower++;
        }
        else if (whitespace === "ignore" &&
            lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
            lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
            (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
            head.push({
                type: 0,
                left: {
                    pos: lhsLower,
                    len: matchedCount[0],
                },
                right: {
                    pos: rhsLower,
                    len: matchedCount[1],
                },
            });
            lhsLower += matchedCount[0];
            rhsLower += matchedCount[1];
        }
        else {
            break;
        }
    }
    // Suffix
    while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
        if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
            tail.push({
                type: 0,
                left: { pos: lhsUpper - 1, len: 1 },
                right: { pos: rhsUpper - 1, len: 1 },
            });
            lhsUpper--;
            rhsUpper--;
        }
        else if (whitespace === "ignore" &&
            lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
            lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
            (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
            tail.push({
                type: 0,
                left: {
                    pos: lhsUpper - matchedCount[0],
                    len: matchedCount[0],
                },
                right: {
                    pos: rhsUpper - matchedCount[1],
                    len: matchedCount[1],
                },
            });
            lhsUpper -= matchedCount[0];
            rhsUpper -= matchedCount[1];
        }
        else {
            break;
        }
    }
    tail.reverse();
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    const llen = lhsUpper;
    const rlen = rhsUpper;
    while (i < llen && j < rlen) {
        const ltext = leftTokens[i].text;
        const rtext = rightTokens[j].text;
        const llen2 = ltext.length;
        const rlen2 = rtext.length;
        while (ci < llen2 && cj < rlen2) {
            if (ltext[ci++] !== rtext[cj++])
                return false;
        }
        if (ci >= ltext.length) {
            i++;
            ci = 0;
        }
        if (cj >= rtext.length) {
            j++;
            cj = 0;
        }
        if (ci === 0 && cj === 0)
            return [i - lhsLower, j - rhsLower];
    }
    return false;
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let ci = leftTokens[i].text.length - 1, cj = rightTokens[j].text.length - 1;
    const llen = lhsLower;
    const rlen = rhsLower;
    OUTER: while (i >= llen && j >= rlen) {
        const ltext = leftTokens[i].text;
        const rtext = rightTokens[j].text;
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                break OUTER;
            }
        }
        if (ci === -1 && cj === -1) {
            return [lhsUpper - i, rhsUpper - j];
        }
        if (ci < 0) {
            i--;
            if (i >= llen)
                ci = leftTokens[i].text.length - 1;
        }
        if (cj < 0) {
            j--;
            if (j >= rlen)
                cj = rightTokens[j].text.length - 1;
        }
    }
    return false;
}
//# sourceMappingURL=worker.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 22px;
	font-size: 16px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr 250px;
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 8px;
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: "ë‹ì›€ì²´", monospace;
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	white-space: pre-wrap;
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -1;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: rgba(0, 0, 0, 0.1);
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: inherit;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
}

mark {
	background-color: inherit;
	color: inherit;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
}

mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-blockìœ¼ë¡œ ì•ˆí•´ë‘ë©´ ë†’ì´ 1pxì´ ëª¨ìë¥´ê²Œ ëœë‹¤. ë¬»ì§€ë§ˆ... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
ê³µê°„ì„ ì „í˜€ ì°¨ì§€í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ visualì´ ìˆì–´ì•¼í•¨
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror {
	color: #fff;
	background-color: #000;
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
ì¤„(div)ì•ˆì— ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë„£ì–´ì„œ ê°•ì œë¡œ ì¤„ë°”ê¿ˆ íš¨ê³¼ë¥¼ ì£¼ì—ˆì„ ë•Œ
diffê°€ ì—†ëŠ” ê°€ìƒì˜ ì¤„ë„ diffê°€ ìˆëŠ” ì¤„ì²˜ëŸ¼ í‘œì‹œë˜ëŠ” ë¬¸ì œ.
ë‹¹ì—°í•œê±°ê¸´ í•œë°... ì‰¬ìš´ í•´ê²°ë°©ë²•ì´ ë– ì˜¤ë¥´ì§ˆ ì•ŠëŠ”ë‹¤!
ê³ ë¯¼ í•„ìš”
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "ğŸ‘¬";
	font-size: 128px;
	font-weight: bold;
	font-family: "Consolas", Courier, monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "ğŸ’­";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: "Consolas", "Courier New", monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "â—€ï¸"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "â–¶ï¸" !important; */
}

.edit hr {
	height: 0 !important;
}

/* ì˜ë¯¸ì—†ë‹¤
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	font-family: "Segoe UI", sans-serif;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: 1000;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}


</style>
</head>

<body>
    <div class="container">
        <main id="main">
            <div id="scrollSyncIndicator">ğŸ”—</div>
            <!--leftEditor will be here -->
            <!-- rightEditor will be here -->
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="statusbar"></div>
    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>

    <div data-line-num="1">
        <a class="anchor" href="#1">1</a>
    </div>
    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT}px;\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script>"use strict";
// ì´ê²ƒì €ê²ƒ ì´ì–´ë¶™ì´ëŠ” ì½”ë“œ ì§‘í•©
const DiffSeek = (function () {
    let _alignedMode = false;
    let _alignedDirty = false;
    let _activeEditor = null;
    let _lastFocusedEditor = null;
    let _lastScrolledEditor = null;
    let _currentlyScrollingEditor = null;
    let _preventScrollSync = false;
    let _currentDiffIndex = -1;
    let _syncEditor = false;
    let _resetCurrentlyScrollingEditorId = null;
    // let _diffResult: DiffResponse | null = null;
    let _diffContext = { done: false, reqId: 0 };
    let _outputOptions = {
        leftLabel: "Left",
        rightLabel: "Right",
        htmlFormat: "div",
        textFormat: 0,
    };
    // devtools ì½˜ì†”ì—ì„œ ì„¤ì • ê°’ì„ ë°”ê¿¨ì„ë•Œ ë°”ë¡œ ì—…ë°ì´íŠ¸ ì‹œí‚¤ê¸° ìœ„í•´...
    const _diffOptions = (function (defaultValues) {
        let _diffOptions = { ...defaultValues };
        function setValue(key, value) {
            if (_diffOptions[key] !== value) {
                _diffOptions[key] = value;
                computeDiff();
            }
        }
        return {
            get algorithm() {
                return _diffOptions.algorithm;
            },
            set algorithm(value) {
                if (value !== "histogram" && value !== "myers" && value !== "lcs") {
                    throw new Error("Invalid algorithm: " + value);
                }
                setValue("algorithm", value);
            },
            get tokenization() {
                return _diffOptions.tokenization;
            },
            set tokenization(value) {
                if (value !== "char" && value !== "word" && value !== "line") {
                    throw new Error("Invalid tokenization: " + value);
                }
                setValue("tokenization", value);
            },
            get whitespace() {
                return _diffOptions.whitespace;
            },
            set whitespace(value) {
                if (value !== "ignore" && value !== "normalize") {
                    throw new Error("Invalid whitespace handling: " + value);
                }
                setValue("whitespace", value);
            },
            get greedyMatch() {
                return !!_diffOptions.greedyMatch;
            },
            set greedyMatch(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid greedyMatch: " + value);
                }
                setValue("greedyMatch", !!value);
            },
            get useLengthBias() {
                return !!_diffOptions.useLengthBias;
            },
            set useLengthBias(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid useLengthBias: " + value);
                }
                setValue("useLengthBias", !!value);
            },
            get maxGram() {
                return _diffOptions.maxGram;
            },
            set maxGram(value) {
                if (value < 1) {
                    throw new Error("Invalid maxGram: " + value);
                }
                setValue("maxGram", value);
            },
            get lengthBiasFactor() {
                return _diffOptions.lengthBiasFactor;
            },
            set lengthBiasFactor(value) {
                if (value <= 0) {
                    throw new Error("Invalid lengthBiasFactor: " + value);
                }
                setValue("lengthBiasFactor", value);
            },
            get sectionHeadingMultiplier() {
                return _diffOptions.sectionHeadingMultiplier;
            },
            set sectionHeadingMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid sectionHeadingMultiplier: " + value);
                }
                setValue("sectionHeadingMultiplier", value);
            },
            get lineStartMultiplier() {
                return _diffOptions.lineStartMultiplier;
            },
            set lineStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineStartMultiplier: " + value);
                }
                setValue("lineStartMultiplier", value);
            },
            get lineEndMultiplier() {
                return _diffOptions.lineEndMultiplier;
            },
            set lineEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineEndMultiplier: " + value);
                }
                setValue("lineEndMultiplier", value);
            },
            get uniqueMultiplier() {
                return _diffOptions.uniqueMultiplier;
            },
            set uniqueMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid uniqueMultiplier: " + value);
                }
                setValue("uniqueMultiplier", value);
            },
        };
    })({
        algorithm: "histogram",
        tokenization: "word",
        whitespace: "ignore",
        greedyMatch: false,
        useLengthBias: true,
        maxGram: 5,
        lengthBiasFactor: 0.7,
        sectionHeadingMultiplier: 1 / 0.75,
        lineStartMultiplier: 1 / 0.85,
        lineEndMultiplier: 1 / 0.9,
        uniqueMultiplier: 1 / 0.6667,
    });
    const useEditableMirror = false;
    const container = document.getElementById("main");
    const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
    const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
    leftEditor.wrapper.tabIndex = 100;
    rightEditor.wrapper.tabIndex = 101;
    // ì§€ì €ë¶„ì˜ ë
    const statusBar = InitializeStatusBar([
        {
            side: "center",
            key: "mode",
            label: "",
            get: () => (_alignedMode ? "ğŸ“–" : "âœï¸"),
            toggle: () => {
                if (_alignedMode) {
                    disableAlignedMode();
                }
                else {
                    enableAlignedMode();
                }
            },
        },
        {
            side: "left",
            key: "tokenization",
            label: "ë‹¨ìœ„",
            get: () => _diffOptions.tokenization,
            set: (value) => (_diffOptions.tokenization = value),
            options: [
                { label: "ê¸€ì", value: "char" },
                { label: "ë‹¨ì–´", value: "word" },
                { label: "ì¤„", value: "line" },
            ],
        },
        // {
        // 	side: "left",
        // 	key: "algorithm",
        // 	label: "ì•Œê³ ë¦¬ì¦˜",
        // 	get: () => _diffOptions.algorithm,
        // 	set: (value: DiffAlgorithm) => (_diffOptions.algorithm = value),
        // 	options: [
        // 		{ label: "Histogram", value: "histogram" },
        // 		{ label: "âš ï¸ Myers âŒ", value: "myers" },
        // 		{ label: "LCS DP", value: "lcs" },
        // 	],
        // },
        {
            side: "left",
            key: "whitespace",
            label: "ê³µë°±",
            get: () => _diffOptions.whitespace,
            set: (value) => (_diffOptions.whitespace = value),
            visible: () => _diffOptions.algorithm === "histogram" && _diffOptions.tokenization === "word",
            options: [
                { label: "ì •ê·œí™”", value: "normalize" },
                { label: "ë¬´ì‹œ", value: "ignore" },
            ],
        },
        // {
        // 	side: "right",
        // 	key: "greedyMatch",
        // 	label: "Greedy Match",
        // 	get: () => _diffOptions.greedyMatch,
        // 	set: (value: boolean) => (_diffOptions.greedyMatch = value),
        // 	disabled: () => _diffOptions.algorithm === "lcs",
        // 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
        // },
        // {
        // 	side: "right",
        // 	key: "useLengthBias",
        // 	label: "Length Bias",
        // 	get: () => _diffOptions.useLengthBias,
        // 	set: (value: boolean) => (_diffOptions.useLengthBias = value),
        // 	disabled: () => _diffOptions.algorithm === "histogram",
        // 	options: [false, true].map((v) => ({ label: v ? "On" : "Off", value: v })),
        // },
        // {
        // 	side: "right",
        // 	key: "maxGram",
        // 	label: "Max Gram",
        // 	get: () => _diffOptions.maxGram,
        // 	set: (value: number) => (_diffOptions.maxGram = value),
        // 	disabled: () => _diffOptions.algorithm === "histogram",
        // 	options: [1, 2, 3, 4, 5, 6, 7].reverse().map((v) => ({ label: v.toString(), value: v })),
        // },
        {
            side: "right",
            key: "diffs",
            label: "â‰ ",
            get: () => {
                if (!_diffContext.done) {
                    return "...";
                }
                return `${_diffContext.diffs.length}`;
            },
        },
        {
            side: "right",
            key: "tokenCount",
            label: "#",
            get: () => {
                if (!_diffContext.leftTokens || !_diffContext.rightTokens) {
                    return "...";
                }
                return `${_diffContext.leftTokens.length} / ${_diffContext.rightTokens.length}`;
            },
        },
        {
            side: "right",
            key: "processTime",
            label: "â±",
            get: () => {
                if (!_diffContext.done) {
                    return "...";
                }
                return `${Math.ceil(_diffContext.processTime)}ms`;
            },
        },
    ]);
    const body = document.querySelector("body");
    const diffList = document.getElementById("diffList");
    const highlightStyle = document.getElementById("highlightStyle");
    const progress = document.getElementById("progress");
    const scrollSyncIndicator = document.getElementById("scrollSyncIndicator");
    const alignmentStyleElement = document.createElement("style");
    document.head.appendChild(alignmentStyleElement);
    const resizeObserver = new ResizeObserver(() => {
        _alignedDirty = true;
        if (_alignedMode) {
            recalculateAlignmentPaddingAndPositionsDebounced();
        }
        else if (_syncEditor) {
            // ì–´ëŠ ì—ë””í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‹±í¬ë¥¼ í•˜ëƒ?
            // ê¸°ì¤€ì´ ë‹¨ìˆœí•˜ê³  ëª…í™•í•˜ì§€ ì•Šìœ¼ë©´ ì˜¤íˆë ¤ ë” í˜¼ë€ìŠ¤ëŸ¬ì›€.
            // 1. í¬ì»¤ìŠ¤ë¥¼ ê°€ì§„ ì—ë””í„°?...
            // 2. ë§ˆìš°ìŠ¤ì»¤ì„œê°€ ì˜¬ë ¤ì§„ ì—ë””í„°?...
            // 3. ìµœê·¼ì— ìŠ¤í¬ë¡¤ëœ ì—ë””í„°?...
            // 4. ê·€ì°®ë‹¤.
        }
    });
    resizeObserver.observe(container);
    const recalculateAlignmentPaddingAndPositionsDebounced = debounce(recalculateAlignmentPaddingAndPositions, 200);
    function getEditorCallbacks(editorName) {
        const pendingDiffVisibilities = new Map();
        let updateDiffVisilitiesPending = false;
        return {
            onTextChanged: function () {
                computeDiff();
            },
            onMirrorUpdated: function () {
                _alignedDirty = true;
                if (_alignedMode) {
                    recalculateAlignmentPaddingAndPositions();
                }
            },
            // í˜„ì¬ í™”ë©´ ìƒì— ë³´ì´ëŠ” diff ì•„ì´í…œë“¤.
            onDiffVisibilityChanged: (diffIndex, visible) => {
                pendingDiffVisibilities.set(diffIndex, visible);
                if (!updateDiffVisilitiesPending) {
                    updateDiffVisilitiesPending = true;
                    requestAnimationFrame(() => {
                        updateDiffVisilitiesPending = false;
                        for (const [diffIndex, visible] of pendingDiffVisibilities) {
                            const listItem = diffList.children[diffIndex];
                            if (listItem) {
                                const button = listItem.firstElementChild;
                                button.classList.toggle(editorName + "-visible", visible);
                            }
                        }
                        pendingDiffVisibilities.clear();
                    });
                }
            },
        };
    }
    function createWorker() {
        // ë³´ì•ˆ ìƒ new Worker("worker.js")ëŠ” ì‹¤í–‰ ì•ˆë¨.
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerURL);
        return worker;
    }
    const { computeDiff } = (function () {
        const worker = createWorker();
        let reqId = 0;
        let computeDiffTimeoutId = null;
        function* computeDiffGenerator(ctx) {
            let idleDeadline = yield ctx;
            ctx.leftTokens = tokenize(ctx.leftText, _diffOptions.tokenization);
            if (idleDeadline.timeRemaining() < 1) {
                idleDeadline = yield;
            }
            ctx.rightTokens = tokenize(ctx.rightText, _diffOptions.tokenization);
            if (idleDeadline.timeRemaining() < 1) {
                idleDeadline = yield;
            }
            const request = {
                type: "diff",
                reqId: ctx.reqId,
                options: ctx.diffOptions,
                leftTokens: ctx.leftTokens,
                rightTokens: ctx.rightTokens,
            };
            worker.postMessage(request);
            console.log("postMessage", request);
            updateButtons();
        }
        function computeDiff() {
            if (computeDiffTimeoutId) {
                cancelIdleCallback(computeDiffTimeoutId);
                //clearTimeout(computeDiffTimeoutId);
            }
            _currentDiffIndex = -1;
            _alignedDirty = true;
            const leftText = leftEditor.text;
            const rightText = rightEditor.text;
            body.classList.add("computing");
            progress.textContent = "...";
            body.classList.toggle("identical", leftText === rightText);
            const ctx = (_diffContext = {
                reqId: ++reqId, //overflow ë˜ëŠ” ìˆœê°„ ì§€êµ¬ ë©¸ë§
                leftText: leftText,
                rightText: rightText,
                diffOptions: { ..._diffOptions },
                done: false,
                processTime: 0,
            });
            const generator = computeDiffGenerator(ctx);
            const step = (idleDeadline) => {
                computeDiffTimeoutId = null;
                const { done } = generator.next(idleDeadline);
                if (!done && ctx === _diffContext) {
                    computeDiffTimeoutId = requestIdleCallback(step, { timeout: 200 });
                }
            };
            computeDiffTimeoutId = requestIdleCallback(step);
        }
        worker.onmessage = function (e) {
            console.log("worker message", e);
            const data = e.data;
            if (data.type === "diff") {
                if (data.reqId === reqId) {
                    console.debug("diff response:", data);
                    document.querySelector("body").classList.remove("computing");
                    _diffContext.rawEntries = data.diffs;
                    postProcess(_diffContext);
                    _diffContext.done = true;
                    _diffContext.processTime = data.processTime;
                    onDiffComputed(_diffContext);
                }
            }
            else if (data.type === "start") {
                progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
            }
        };
        function onDiffComputed(diffContext) {
            leftEditor.update({ diffs: diffContext.diffs, anchors: diffContext.anchors });
            rightEditor.update({ diffs: diffContext.diffs, anchors: diffContext.anchors });
            updateDiffList();
            updateButtons();
        }
        return { computeDiff };
    })();
    // ì† ë³¼ ì—¬ì§€ê°€ ë§ì€ë°... ìœ¼...
    // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ê³„ì‚°í•˜ëŠ”ê²Œ ì¢€.. ìŒ...
    function enableAlignedMode() {
        // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ëŠ” ì–´ë””ìª½ ì—ë””í„°ì— ë§ì¶”ë‚˜?
        // ì—­ì‹œ ëª…í™•í•œ ê¸°ì¤€ì´ í•„ìš”.
        if (!_alignedMode) {
            const currentSelectionRange = getSelectionRange();
            const currentEditor = _activeEditor || _lastFocusedEditor || rightEditor;
            const [firstVisibleLineEl, firstVisibleLineDistance] = currentEditor.getFirstVisibleLineElement();
            _alignedMode = true;
            leftEditor.mirror.tabIndex = 100;
            rightEditor.mirror.tabIndex = 101;
            if (useEditableMirror) {
                leftEditor.mirror.contentEditable = "plaintext-only";
                rightEditor.mirror.contentEditable = "plaintext-only";
            }
            leftEditor.setEditMode(false);
            rightEditor.setEditMode(false);
            body.classList.toggle("aligned", true);
            body.classList.toggle("edit", false);
            recalculateAlignmentPaddingAndPositions();
            if (currentSelectionRange) {
                restoreSelectionRange(currentSelectionRange);
            }
            updateButtons();
            requestAnimationFrame(() => {
                // ë ˆì´ì•„ì›ƒì´ ëë‚œ í›„ ë¯¸ë¦¬ ì°¾ì•„ë’€ë˜ ì¤„ ìœ„ì¹˜ë¡œ ìŠ¤í¬ë¡¤.
                let lineNum = Number(firstVisibleLineEl?.dataset?.lineNum) || 1;
                let distance = firstVisibleLineDistance || 0;
                currentEditor.scrollToLine(lineNum, distance);
                const theOtherEditor = currentEditor === leftEditor ? rightEditor : leftEditor;
                theOtherEditor.wrapper.scrollTop = currentEditor.wrapper.scrollTop;
                // í¬ì»¤ìŠ¤ë¥¼ ê°€ì ¸ì•¼ aligned mode ì§„ì… í›„ ë°”ë¡œ í‚¤ë³´ë“œë¡œ ìŠ¤í¬ë¡¤ í•  ìˆ˜ ìˆìŒ.
                // ìŠ¤í¬ë¡¤ì´ ë™ê¸°í™”ë˜ë‹ˆ ì‚¬ì‹¤ ì–´ëŠìª½ì´ í¬ì»¤ìŠ¤ë¥¼ ê°€ì§€ë“  ìƒê´€ ë¬´.
                currentEditor.mirror.focus();
            });
        }
    }
    function disableAlignedMode() {
        const currentSelectionRange = getSelectionRange();
        // ì¼ë‹¨ editmodeë¡œ ê°€ê¸° ì „ì— í˜„ì¬ í™”ë©´ ìƒ ì²«ì¤„ì„ ë³´ì¡´
        const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElement();
        const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElement();
        _alignedMode = false;
        leftEditor.setEditMode(true);
        rightEditor.setEditMode(true);
        leftEditor.mirror.removeAttribute("tabindex");
        rightEditor.mirror.removeAttribute("tabindex");
        leftEditor.mirror.contentEditable = "false";
        rightEditor.mirror.contentEditable = "false";
        body.classList.toggle("aligned", false);
        body.classList.toggle("edit", true);
        updateButtons();
        _preventScrollSync = true;
        requestAnimationFrame(() => {
            if (leftFirstLine) {
                leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
            }
            if (rightFirstLine) {
                rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
            }
            requestAnimationFrame(() => {
                _preventScrollSync = false;
            });
        });
        if (currentSelectionRange) {
            restoreSelectionRange(currentSelectionRange);
        }
    }
    function recalculateAlignmentPaddingAndPositions() {
        if (!_alignedDirty) {
            return;
        }
        if (!_diffContext.done) {
            return;
        }
        const anchors = _diffContext.anchors, lhsTokens = _diffContext.leftTokens, rhsTokens = _diffContext.rightTokens, lhsLines = leftEditor.lineElements, rhsLines = rightEditor.lineElements, lhsLineHints = leftEditor.lineHints, rhsLineHints = rightEditor.lineHints;
        // ì–˜ë„¤ë“¤ì€ ì•Œì•„ì„œ ìŠ¤ìŠ¤ë¡œ ì‘¥ì‘¥ ìë¼ê²Œ autoë¡œ
        leftEditor.mirror.style.height = "auto";
        rightEditor.mirror.style.height = "auto";
        // ê¸°ì¡´ ìŠ¤íƒ€ì¼ í•œë²ˆì— ë‚ ë ¤ë²„ë¦¬ê¸°
        alignmentStyleElement.textContent = "";
        const leftAnchorEls = leftEditor.anchorElements, rightAnchorEls = rightEditor.anchorElements;
        let styleText = "";
        let leftDelta = 0, rightDelta = 0;
        for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
            const anchor = anchors[anchorIndex];
            const leftAnchorEl = leftAnchorEls[anchorIndex], rightAnchorEl = rightAnchorEls[anchorIndex];
            if (!leftAnchorEl || !rightAnchorEl) {
                continue;
            }
            const leftTop = leftAnchorEl.offsetTop, rightTop = rightAnchorEl.offsetTop;
            const leftY = leftTop + leftDelta, rightY = rightTop + rightDelta;
            let delta;
            if (anchor.type === "before") {
                delta = leftY - rightY;
                if (delta > LINE_HEIGHT) {
                    const anchorLineIndex = anchor.leftLine - 1;
                    // const anchorLineIndex = findIndexByPos(lhsLineHints, anchor.left);
                    if (anchorLineIndex > 0) {
                        const lastBlankLineIndex = anchorLineIndex - 1;
                        const hint = lhsLineHints[lastBlankLineIndex];
                        const collapseLimit = hint.numConsecutiveBlankLines - 1;
                        let collapsedLines = 0;
                        while (collapsedLines < collapseLimit) {
                            const lineIndex = lastBlankLineIndex - collapsedLines;
                            const lineEl = lhsLines[lineIndex];
                            const lineHeight = lineEl.offsetHeight;
                            if (lineHeight > delta)
                                break;
                            delta -= lineHeight;
                            rightDelta += lineHeight;
                            collapsedLines++;
                            const lineNum = lineIndex + 1;
                            styleText += `.aligned #leftMirror div[data-line-num="${lineNum}"] { display:none; }\n`;
                        }
                    }
                }
                else if (delta < -LINE_HEIGHT) {
                    const anchorLineIndex = anchor.rightLine - 1;
                    if (anchorLineIndex > 0) {
                        const lastBlankLineIndex = anchorLineIndex - 1;
                        const hint = rhsLineHints[lastBlankLineIndex];
                        const collapseLimit = hint.numConsecutiveBlankLines - 1;
                        let collapsedLines = 0;
                        while (collapsedLines < collapseLimit) {
                            const lineIndex = lastBlankLineIndex - collapsedLines;
                            const lineEl = rhsLines[lineIndex];
                            const lineHeight = lineEl.offsetHeight;
                            if (-delta < lineHeight)
                                break;
                            delta += lineHeight;
                            leftDelta += lineHeight;
                            collapsedLines++;
                            const lineNum = lineIndex + 1;
                            styleText += `.aligned #rightMirror div[data-line-num="${lineNum}"] { display:none; }\n`;
                        }
                    }
                }
            }
            else if (anchor.type === "after") {
                const leftHeight = leftAnchorEl.offsetHeight, rightHeight = rightAnchorEl.offsetHeight;
                const leftB = leftY + leftHeight, rightB = rightY + rightHeight;
                delta = leftB - rightB;
            }
            else {
                console.warn("unknown anchor type", anchor.type);
                continue;
            }
            if (delta > 0) {
                styleText += `.aligned #rightAnchor${anchorIndex} { display:block; height:${delta}px; }\n`;
                rightDelta += delta;
            }
            else {
                styleText += `.aligned #leftAnchor${anchorIndex} { display:block; height:${-delta}px; }\n`;
                leftDelta += -delta;
            }
        }
        alignmentStyleElement.textContent = styleText;
        _alignedDirty = false;
        requestAnimationFrame(() => {
            // ë ˆì´ì•„ì›ƒì´ ëë‚œ í›„ mirror ë†’ì´ ì¡°ì •
            const height = Math.max(leftEditor.mirror.offsetHeight, rightEditor.mirror.offsetHeight);
            leftEditor.mirror.style.height = `${height}px`;
            rightEditor.mirror.style.height = `${height}px`;
        });
    }
    function restoreSelectionRange({ editor, startOffset, endOffset }) {
        if (editor) {
            editor.selectTextRange(startOffset, endOffset);
        }
    }
    function getSelectionRange() {
        let editor = null;
        let [startOffset, endOffset] = leftEditor.getTextSelectionRange();
        if (startOffset !== null) {
            editor = leftEditor;
        }
        else {
            [startOffset, endOffset] = rightEditor.getTextSelectionRange();
            if (startOffset !== null) {
                editor = rightEditor;
            }
        }
        if (editor) {
            return {
                editor,
                startOffset: startOffset,
                endOffset: endOffset,
            };
        }
        else {
            return null;
        }
    }
    function syncScrollPosition(sourceEditor) {
        if (_preventScrollSync) {
            return;
        }
        if (!sourceEditor) {
            sourceEditor = _currentlyScrollingEditor || _activeEditor || _lastFocusedEditor;
            if (!sourceEditor) {
                return;
            }
        }
        if (_currentlyScrollingEditor !== null && _currentlyScrollingEditor !== sourceEditor) {
            return;
        }
        _preventScrollSync = true;
        const targetEditor = sourceEditor === leftEditor ? rightEditor : leftEditor;
        let sourceAnchor = null;
        let targetAnchor = null;
        sourceAnchor = sourceEditor.getClosestAnchorToCaret() || sourceEditor.getFirstVisibleAnchor();
        if (sourceAnchor) {
            const anchorIndex = Number(sourceAnchor.dataset.anchor);
            targetAnchor = targetEditor.anchorElements[anchorIndex];
        }
        if (sourceAnchor && targetAnchor) {
            const prevLastScrolledEditor = _lastScrolledEditor;
            const sourceWrapper = sourceEditor.wrapper;
            const targetWrapper = targetEditor.wrapper;
            targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
            _lastScrolledEditor = prevLastScrolledEditor;
        }
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    function highlightDiff(diffIndex) {
        highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
animation: highlightAnimation 0.3s linear 3; 
}`;
    }
    document.addEventListener("mouseover", (e) => {
        if (e.target.dataset.diff !== undefined) {
            const diff = Number(e.target.dataset.diff);
            highlightDiff(diff);
        }
    });
    document.addEventListener("mouseout", (e) => {
        if (e.target.dataset.diff !== undefined) {
            highlightStyle.textContent = "";
        }
    });
    // syncScrollToggle.addEventListener("click", () => {
    // 	toggleSyncScroll();
    // });
    // alignedModeToggle.addEventListener("click", () => {
    // 	if (_alignedMode) {
    // 		disableAlignedMode();
    // 	} else {
    // 		enableAlignedMode();
    // 	}
    // });
    function toggleSyncScroll() {
        _syncEditor = !_syncEditor;
        updateButtons();
    }
    function updateButtons() {
        if (_syncEditor && !_alignedMode) {
            scrollSyncIndicator.style.display = "block";
        }
        else {
            scrollSyncIndicator.style.display = "none";
        }
        statusBar.update();
    }
    function updateDiffList() {
        if (!_diffContext.done) {
            return;
        }
        const diffs = _diffContext.diffs;
        const leftWholeText = leftEditor.text;
        const rightWholeText = rightEditor.text;
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < diffs.length; i++) {
            const diff = diffs[i];
            const li = document.createElement("LI");
            const button = document.createElement("MARK");
            button.draggable = true;
            button.dataset.diff = i.toString();
            button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
            li.appendChild(button);
            const leftText = leftWholeText.slice(diff.left.pos, diff.left.pos + diff.left.len);
            const leftSpan = document.createElement("SPAN");
            leftSpan.textContent = leftText;
            leftSpan.classList.add("left");
            button.appendChild(leftSpan);
            const rightText = rightWholeText.slice(diff.right.pos, diff.right.pos + diff.right.len);
            const rightSpan = document.createElement("SPAN");
            rightSpan.textContent = rightText;
            rightSpan.classList.add("right");
            button.appendChild(rightSpan);
            fragment.appendChild(li);
        }
        diffList.innerHTML = "";
        diffList.appendChild(fragment);
    }
    document.addEventListener("keydown", (e) => {
        // ì–´ëŠ ë‹¨ì¶•í‚¤ë¥¼ ì¨ì•¼ ì˜ì¼ë‹¤ê³  ì†Œë¬¸ë‚˜ëƒ?
        if (e.key === "F2") {
            e.preventDefault();
            if (e.shiftKey) {
                toggleSyncScroll();
                return;
            }
            if (_alignedMode) {
                disableAlignedMode();
            }
            else {
                enableAlignedMode();
            }
            return;
        }
        // ê¸°ë³¸ì ìœ¼ë¡œ ë¸Œë¼ìš°ì €ì˜ ì²«ë²ˆì§¸ íƒ­, ë‘ë²ˆì§¸ íƒ­ì„ ì„ íƒí•˜ëŠ” ë‹¨ì¶•í‚¤ì¸ë°...
        // ë¸Œë¼ìš°ì €ì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë‹¨ì¶•í‚¤ë¥¼ ë®ì–´ì“°ëŠ” ê±´ ì •ë§ ëª»ëœ ì§“ì´ê¸´ í•œë°...
        // ì‚¬ìš©ìì˜ ì˜ë„ë¥¼ ë¬´ì‹œí•´ë²„ë¦´ ìˆ˜ ìˆëŠ” ì•„ì£¼ ë‚˜ìœ ë‹¨ì¶•í‚¤ì§€ë§Œ... ì¸í„°ë„·ë„ ì•ˆë˜ëŠ” ì»´ì—ì„œ ëˆ„ê°€ ì—£ì§€ì— íƒ­ì„ ì—¬ëŸ¬ê°œ ì—´ì–´ë†“ê³  ì“¸ê¹Œ ì‹¶ë‹¤.
        if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
            e.preventDefault();
            if (_alignedMode) {
                disableAlignedMode();
            }
            const editor = e.key === "1" ? leftEditor : rightEditor;
            editor.editor.focus();
            return;
        }
        // mirrorë¡œ ì´ë²¤íŠ¸í•¸ë“¤ëŸ¬ ì˜®ê¹€. í…ŒìŠ¤íŠ¸ í•´ë´ì•¼í•¨í•¨
        // if ((_alignedMode && !e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
        // 	disableAlignedMode();
        // 	return;
        // }
        // diff cycling
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            e.preventDefault();
            if (_diffContext.done) {
                const diffs = _diffContext.diffs;
                if (!diffs || diffs.length === 0) {
                    return;
                }
                _currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
                if (_currentDiffIndex < 0) {
                    _currentDiffIndex = diffs.length - 1;
                }
                if (_currentDiffIndex >= diffs.length) {
                    _currentDiffIndex = 0;
                }
                scrollToDiff(_currentDiffIndex);
                highlightDiff(_currentDiffIndex);
            }
        }
    });
    diffList.addEventListener("click", (e) => {
        const diffIndex = Number(e.target.dataset.diff);
        if (!isNaN(diffIndex)) {
            _currentDiffIndex = diffIndex;
            scrollToDiff(diffIndex);
        }
    });
    function scrollToDiff(diffIndex) {
        _preventScrollSync = true;
        leftEditor.scrollToDiff(diffIndex);
        rightEditor.scrollToDiff(diffIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    for (const editor of [leftEditor, rightEditor]) {
        editor.wrapper.addEventListener("scroll", (e) => {
            if (_currentlyScrollingEditor !== null || _preventScrollSync) {
                return;
            }
            _lastScrolledEditor = _currentlyScrollingEditor = editor;
            if (_alignedMode) {
                // aligned modeì¼ ë•ŒëŠ” ì–‘ìª½ ì—ë””í„°ì˜ ë†’ì´ê°€ ê°™ê²Œ ìœ ì§€ë˜ë‹ˆ ë‘˜ ë‹¤ overflow:visibleë¡œ í•´ë‘ê³ 
                // ë¶€ëª¨ì—ì„œ ìŠ¤í¬ë¡¤í•˜ë©´ ë‘˜ ë‹¤ ìŠ¤í¬ë¡¤ì´ ë˜ì§€ë§Œ(ë”œë ˆì´ ì „í˜€ ì—†ì´ ì™„ì „ ìì—°ìŠ¤ëŸ½ê²Œ!) ê·¸ë ‡ê²Œ ë§Œë“¤ë©´ ìŠ¤í¬ë¡¤ë°”ê°€ í•˜ë‚˜ë§Œ ë³´ì´ëŠ”ê²Œ ìƒê°ë³´ë‹¤ ì–´ìƒ‰í•˜ê³  ë¶ˆí¸í•˜ë‹¤.
                // ê·¸ë˜ì„œ ê·¸ëƒ¥ ê°•ì œë¡œ ìŠ¤í¬ë¡¤ ë™ê¸°í™” ì‹œí‚´.
                if (editor === leftEditor) {
                    rightEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
                }
                else {
                    leftEditor.wrapper.scrollTop = editor.wrapper.scrollTop;
                }
            }
            else if (_syncEditor) {
                syncScrollPosition(editor);
            }
            if (_resetCurrentlyScrollingEditorId) {
                cancelAnimationFrame(_resetCurrentlyScrollingEditorId);
            }
            _resetCurrentlyScrollingEditorId = requestAnimationFrame(() => {
                _currentlyScrollingEditor = null;
            });
        });
        function onFocus() {
            _activeEditor = _lastFocusedEditor = editor;
        }
        function onBlur() {
            _activeEditor = null;
        }
        editor.editor.addEventListener("focus", onFocus);
        editor.mirror.addEventListener("focus", onFocus);
        editor.editor.addEventListener("blur", onBlur);
        editor.mirror.addEventListener("blur", onBlur);
        editor.editor.addEventListener("keydown", (e) => {
            if (e.key === " " && e.ctrlKey) {
                // ì—ë””í„°ì—ì„œ í¸ì§‘ ì¤‘ ë°˜ëŒ€ìª½ ì—ë””í„°ì˜ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¥¼ í˜„ì¬ ì—ë””í„°ì˜ ë‚´ìš©ì— ë§ì¶”...ë ¤ê³  ì‹œë„ë§Œ í•´ ë´„.
                syncScrollPosition(editor);
                return;
            }
            if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
                // ì´ì •ë„ ìŠ¤í¬ë¡¤ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë˜ì–´ë˜ëŠ”ê±° ì•„ë‹ˆì•¼?? ì´ ê¸°ëŠ¥ ë‚˜ë§Œ ì“°ë‚˜?
                // ìŠ¤í¬ë¡¤ ì˜ì—­ ë°–ì˜ ë”± í•œë‘ì¤„! ë”± ê·¸ì •ë„ë§Œ ë³´ë©´ ëœë‹¤ ì‹¶ì„ ë•Œ?
                // í…ìŠ¤íŠ¸ì»¤ì„œê°€ ì¤‘ì•™ ë¶€ë¶„ì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë§ˆìŒì´ ë†“ì´ì§€ ì•Šì•„ì„œ ì§€ê¸ˆ ë‹¹ì¥ ìœ„ì•„ë˜ë¡œ ì¡°ê¸ˆ ìŠ¤í¬ë¡¤ í•´ì•¼ë§Œ í•  ë•Œ!!!!
                const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2;
                editor.wrapper.scrollTop += delta;
                e.preventDefault();
            }
        });
        editor.mirror.addEventListener("paste", (e) => {
            disableAlignedMode();
        });
        editor.mirror.addEventListener("cut", (e) => {
            disableAlignedMode();
        });
        editor.mirror.addEventListener("keydown", (e) => {
            // aligned ëª¨ë“œì—ì„œ ê°„ë‹¨í•œ í¸ì§‘ì„ ì‹œë„í•  ë•Œ ì½ì‹¸ê²Œ aligned ëª¨ë“œì—ì„œ ë‚˜ê°€ê¸°!
            // aligned ëª¨ë“œì—ì„œ ë‚˜ê°ˆë•Œ mirrorì—ì„œ ì„ íƒë˜ì–´ìˆë˜ í…ìŠ¤íŠ¸ ì˜ì—­ì´ contenteditable ë‚´ì—ì„œ ë³µì›ì´ ë˜ë¯€ë¡œ
            // ê·¸ ì´í›„ëŠ” ë³µì›ëœ í…ìŠ¤íŠ¸ ì˜ì—­ì„ ë¸Œë¼ìš°ì €ê°€ keyì— ë§ê²Œ ì²˜ë¦¬í•´ì¤Œ. ì¡°ê¸ˆ ì–ì‚½?
            if ((!e.ctrlKey && e.key.length === 1) || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") {
                disableAlignedMode();
                return;
            }
            // mirrorì—ì„œ ì „ì²´ í…ìŠ¤íŠ¸ ì„ íƒ ì‹œì— ì°½ ì „ì²´ì˜ í…ìŠ¤íŠ¸ê°€ ì•„ë‹Œ í˜„ì¬ ì—ë””í„°ì˜ í…ìŠ¤íŠ¸ë§Œ ì„ íƒë˜ë„ë¡.
            if (e.ctrlKey && (e.key === "A" || e.key === "a")) {
                e.preventDefault();
                editor.selectTextRange(0, editor.text.length);
                return;
            }
        });
        // editor.editor.addEventListener("click", (e) => {
        // 	if (e.ctrlKey) {
        // 		enableAlignedMode(true);
        // 	}
        // });
        editor.mirror.addEventListener("click", (e) => {
            if (e.ctrlKey) {
                _activeEditor = editor;
                disableAlignedMode();
            }
        });
        editor.mirror.addEventListener("dragstart", (e) => {
            console.log("[dragstart] fired");
            const sideKey = editor === leftEditor ? "left" : "right";
            const otherSideKey = sideKey === "left" ? "right" : "left";
            const tokens = sideKey === "left" ? _diffContext.leftTokens : _diffContext.rightTokens;
            const otherTokens = sideKey === "left" ? _diffContext.rightTokens : _diffContext.leftTokens;
            const text = sideKey === "left" ? leftEditor.text : rightEditor.text;
            const otherText = sideKey === "left" ? rightEditor.text : leftEditor.text;
            const rawEntries = _diffContext.rawEntries;
            const diffs = _diffContext.diffs;
            const selection = window.getSelection();
            if (!tokens || !otherTokens || !selection || selection.isCollapsed)
                return;
            const range = selection.getRangeAt(0);
            if (!editor.mirror.contains(range.commonAncestorContainer))
                return;
            const [startOffset, endOffset] = editor.getTextSelectionRange();
            if (startOffset === null || endOffset === null)
                return;
            console.log("text from range", text.slice(startOffset, endOffset));
            const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
            const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
            console.log("startIndex, endIndex", startIndex, endIndex);
            const startToken = tokens[startIndex];
            const endToken = tokens[endIndex - 1];
            const otherStartToken = otherTokens[mappedStartIndex];
            const otherEndToken = otherTokens[mappedEndIndex - 1];
            const startPos = startToken?.pos ?? 0;
            const endPos = endToken ? endToken.pos + endToken.len : startPos;
            const otherStartPos = otherStartToken?.pos ?? 0;
            const otherEndPos = otherEndToken ? otherEndToken.pos + otherEndToken.len : otherStartPos;
            console.log("thistext:", text.slice(startPos, endPos));
            console.log("othertxt:", otherText.slice(otherStartPos, otherEndPos));
            const leftRuns = getTextRuns("left", leftEditor.text, [], diffs, [], sideKey === "left" ? startPos : otherStartPos, sideKey === "left" ? endPos : otherEndPos);
            const rightRuns = getTextRuns("right", rightEditor.text, [], diffs, [], sideKey === "right" ? startPos : otherStartPos, sideKey === "right" ? endPos : otherEndPos);
            const html = buildOutputHTML(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
            const plain = buildOutputPlainText(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
            e.dataTransfer.setData("text/html", html);
            e.dataTransfer.setData("text/plain", plain);
        });
        if (useEditableMirror) {
            // editor.mirror.addEventListener("paste", (e) => {
            // 	disableAlignedMode();
            // });
            // editor.mirror.addEventListener("paste", (e) => {
            // 	disableAlignedMode();
            // });
            // editor.mirror.addEventListener("cut", (e) => {
            // 	disableAlignedMode();
            // });
            editor.mirror.addEventListener("drop", (e) => {
                e.preventDefault();
            });
        }
    }
    //type PostProcessResult = ReturnType<typeof postProcess>;
    function postProcess(diffContext) {
        let prevEntry = null;
        const leftText = diffContext.leftText;
        const rightText = diffContext.rightText;
        const leftTokens = diffContext.leftTokens;
        const rightTokens = diffContext.rightTokens;
        const rawEntries = diffContext.rawEntries;
        const diffs = [];
        const anchors = [];
        const MAX_ANCHOR_SKIP = 5;
        let anchorSkipCount = 0;
        for (let i = 0; i < rawEntries.length; i++) {
            const entry = rawEntries[i];
            if (entry.type) {
                if (prevEntry) {
                    console.assert(prevEntry.left.pos + prevEntry.left.len === entry.left.pos, prevEntry, entry);
                    console.assert(prevEntry.right.pos + prevEntry.right.len === entry.right.pos, prevEntry, entry);
                    prevEntry.type |= entry.type;
                    prevEntry.left.len += entry.left.len;
                    prevEntry.right.len += entry.right.len;
                }
                else {
                    prevEntry = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
                    //prevEntry = entry;
                }
            }
            else {
                if (prevEntry) {
                    addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
                    // mappings.push(prevEntry);
                }
                prevEntry = null;
                const leftToken = leftTokens[entry.left.pos];
                const rightToken = rightTokens[entry.right.pos];
                if (leftToken.flags & rightToken.flags & FIRST_OF_LINE) {
                    // ì•µì»¤ ì¶”ê°€
                    addAnchor("before", leftToken.pos, leftToken.lineNum, rightToken.pos, rightToken.lineNum, null);
                }
                // mappings.push(entry);
            }
        }
        addAnchor("before", leftText.length, -1, rightText.length, -1, null);
        if (prevEntry) {
            addDiff(prevEntry.left.pos, prevEntry.left.len, prevEntry.right.pos, prevEntry.right.len);
            // mappings.push(prevEntry);
        }
        function addAnchor(type, leftPos, leftLine, rightPos, rightLine, diffIndex) {
            if (leftPos === undefined || rightPos === undefined) {
                console.error("addAnchor", { type, leftPos, rightPos, diffIndex });
            }
            // ì•µì»¤ê°€ ë„ˆë¬´ ë§ì•„ì§€ëŠ” ê±¸ ë°©ì§€!
            if (diffIndex === null && anchorSkipCount < MAX_ANCHOR_SKIP && anchors.length > 0) {
                const lastAnchor = anchors[anchors.length - 1];
                if (lastAnchor.type === type && lastAnchor.diffIndex === null && leftLine - lastAnchor.leftLine <= 1 && rightLine - lastAnchor.rightLine <= 1) {
                    anchorSkipCount++;
                    return;
                }
            }
            anchorSkipCount = 0;
            if (type === "before") {
                // before ì•µì»¤ëŠ” í•­ìƒ ì¤„ì˜ ì‹œì‘ìœ„ì¹˜ì¼ ë•Œë§Œ ì¶”ê°€í•˜ë¯€ë¡œ ì¤„ë°”ê¿ˆ ë¬¸ìë§Œ í™•ì¸í•˜ë©´ ëœë‹¤!
                while (leftPos > 0 && leftText[leftPos - 1] !== "\n") {
                    leftPos--;
                }
                while (rightPos > 0 && rightText[rightPos - 1] !== "\n") {
                    rightPos--;
                }
            }
            else if (type === "after") {
                // empty diffì˜ afterì•µì»¤ëŠ” ì´í›„ì— ë‹¤ë¥¸ í† í°ì´ ì¡´ì¬í•  ìˆ˜ ìˆìŒ.
                // ê³µë°±ì´ ì•„ë‹Œ ë¬¸ìê°€ ë‚˜ì˜¤ë©´ ë©ˆì¶”ê³  ê¸°ë³¸ ìœ„ì¹˜ ì‚¬ìš©.
                let p;
                p = leftPos;
                while (p < leftText.length) {
                    const ch = leftText[p++];
                    if (ch === "\n") {
                        leftPos = p - 1;
                        break;
                    }
                    else if (!SPACE_CHARS[ch]) {
                        break;
                    }
                }
                p = rightPos;
                while (p < rightText.length) {
                    const ch = rightText[p++];
                    if (ch === "\n") {
                        rightPos = p - 1;
                        break;
                    }
                    else if (!SPACE_CHARS[ch]) {
                        break;
                    }
                }
            }
            if (anchors.length > 0) {
                let lastAnchor = anchors[anchors.length - 1];
                if (lastAnchor.left > leftPos || lastAnchor.right > rightPos) {
                    return;
                }
                if (lastAnchor.left === leftPos || lastAnchor.right === rightPos) {
                    if (type === lastAnchor.type || type === "before") {
                        return;
                    }
                }
            }
            anchors.push({ type, left: leftPos, leftLine, right: rightPos, rightLine, diffIndex });
        }
        function addDiff(leftIndex, leftCount, rightIndex, rightCount) {
            let leftPos, leftLen, rightPos, rightLen;
            let leftBeforeAnchorPos, leftBeforeAnchorLine, rightBeforeAnchorPos, rightBeforeAnchorLine, leftAfterAnchorPos, leftAfterAnchorLine, rightAfterAnchorPos, rightAfterAnchorLine;
            let leftEmpty, rightEmpty;
            let type;
            let asBlock = false;
            // ì–‘ìª½ì— ëŒ€ì‘í•˜ëŠ” í† í°ì´ ëª¨ë‘ ì¡´ì¬í•˜ëŠ” ê²½ìš°. ì‰¬ìš´ ì¼€ì´ìŠ¤
            if (leftCount > 0 && rightCount > 0) {
                type = 3;
                let leftTokenStart = leftTokens[leftIndex];
                let leftTokenEnd = leftTokens[leftIndex + leftCount - 1];
                let rightTokenEnd = rightTokens[rightIndex + rightCount - 1];
                let rightTokenStart = rightTokens[rightIndex];
                leftPos = leftTokenStart.pos;
                leftLen = leftTokenEnd.pos + leftTokenEnd.len - leftPos;
                leftEmpty = false;
                rightPos = rightTokenStart.pos;
                rightLen = rightTokenEnd.pos + rightTokenEnd.len - rightPos;
                rightEmpty = false;
                // ìƒê°: í•œìª½ë§Œ ì¤„ì˜ ì²« í† í°ì¼ ë•Œì—ë„ ì•µì»¤ë¥¼ ë„£ì„ê¹Œ? ì•µì»¤ì— display:blockì„ ì¤˜ì„œ ê°•ì œë¡œ ì¤„ë°”ê¿ˆ ì‹œí‚¨ í›„ì—ì—
                // ì¢Œìš° ì •ë ¬ì„ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ê¸°ë„ í•œë°...
                if (leftTokenStart.flags & rightTokenStart.flags & FIRST_OF_LINE) {
                    leftBeforeAnchorPos = leftPos;
                    rightBeforeAnchorPos = rightPos;
                    while (leftBeforeAnchorPos > 0 && leftText[leftBeforeAnchorPos - 1] !== "\n") {
                        leftBeforeAnchorPos--;
                    }
                    while (rightBeforeAnchorPos > 0 && rightText[rightBeforeAnchorPos - 1] !== "\n") {
                        rightBeforeAnchorPos--;
                    }
                    // addAnchor("before", leftAnchorPos, rightAnchorPos, null);
                    if (leftTokenEnd.flags & rightTokenEnd.flags & LAST_OF_LINE) {
                        asBlock = true;
                        leftAfterAnchorPos = leftPos + leftLen;
                        rightAfterAnchorPos = rightPos + rightLen;
                        if (leftText[leftAfterAnchorPos] !== "\n") {
                            do {
                                leftAfterAnchorPos++;
                            } while (leftAfterAnchorPos < leftText.length && leftText[leftAfterAnchorPos] !== "\n");
                        }
                        if (rightText[rightAfterAnchorPos] !== "\n") {
                            do {
                                rightAfterAnchorPos++;
                            } while (rightAfterAnchorPos < rightText.length && rightText[rightAfterAnchorPos] !== "\n");
                        }
                        // while (leftAnchorPos + 1 < leftText.length && leftText[leftAnchorPos + 1] !== "\n") {
                        // 	leftAnchorPos++;
                        // }
                        // while (rightAnchorPos + 1 < rightText.length && rightText[rightAnchorPos + 1] !== "\n") {
                        // 	rightAnchorPos++;
                        // }
                        // addAnchor("after", leftBeforeAnchorPos, rightBeforeAnchorPos, null);
                    }
                }
            }
            else {
                // í•œìª½ì´ ë¹„ì–´ìˆìŒ.
                // ë‹¨ìˆœí•˜ê²Œ í† í° ì‚¬ì´ì— ìœ„ì¹˜ì‹œì¼œë„ ë˜ì§€ë§Œ ë˜ë„ë¡ì´ë©´ ëŒ€ì‘í•˜ëŠ” ìª½ê³¼ ìœ ì‚¬í•œ ìœ„ì¹˜(ì¤„ì‹œì‘/ì¤„ë)ì— ìœ„ì¹˜ì‹œí‚¤ê¸° ìœ„í•´...
                // ìê¾¸ ì´ëŸ°ì €ëŸ° ì‹œë„ë¥¼ í•˜ë‹¤ë³´ë‹ˆ ë‚œì¥íŒì¸ë° ë§Œì§€ê¸° ì‹«ìŒ...
                let longSideText, shortSideText;
                let longSideIndex, longSideCount, longSideTokens;
                let shortSideIndex, shortSideTokens;
                let longSidePos, longSideLen;
                let shortSidePos, shortSideLen;
                let longSideBeforeAnchorPos, shortSideBeforeAnchorPos, longSideBeforeAnchorLine, shortSideBeforeAnchorLine;
                let longSideAfterAnchorPos, shortSideAfterAnchorPos, longSideAfterAnchorLine, shortSideAfterAnchorLine;
                let longSideTokenStart, longSideTokenEnd;
                let shortSideBeforeToken, shortSideAfterToken;
                if (leftCount > 0) {
                    type = 1; // 1: left
                    longSideText = leftText;
                    longSideTokens = leftTokens;
                    longSideIndex = leftIndex;
                    longSideCount = leftCount;
                    shortSideText = rightText;
                    shortSideTokens = rightTokens;
                    shortSideIndex = rightIndex;
                    leftEmpty = false;
                    rightEmpty = true;
                }
                else {
                    type = 2; // 2: right
                    longSideText = rightText;
                    longSideTokens = rightTokens;
                    longSideIndex = rightIndex;
                    longSideCount = rightCount;
                    shortSideText = leftText;
                    shortSideTokens = leftTokens;
                    shortSideIndex = leftIndex;
                    leftEmpty = true;
                    rightEmpty = false;
                }
                longSideTokenStart = longSideTokens[longSideIndex];
                longSideTokenEnd = longSideTokens[longSideIndex + longSideCount - 1];
                shortSideBeforeToken = shortSideTokens[shortSideIndex - 1];
                shortSideAfterToken = shortSideTokens[shortSideIndex];
                longSidePos = longSideTokenStart.pos;
                longSideLen = longSideTokenEnd.pos + longSideTokenEnd.len - longSidePos;
                shortSidePos = shortSideBeforeToken ? shortSideBeforeToken.pos + shortSideBeforeToken.len : 0;
                shortSideLen = 0;
                const longSideIsFirstWord = longSideTokenStart.flags & FIRST_OF_LINE;
                const longSideIsLastWord = longSideTokenEnd.flags & LAST_OF_LINE;
                const shortSideIsOnLineEdge = shortSideTokens.length === 0 ||
                    (shortSideBeforeToken && shortSideBeforeToken.flags & LAST_OF_LINE) ||
                    (shortSideAfterToken && shortSideAfterToken.flags & FIRST_OF_LINE);
                let shortSidePushedToNextLine = false;
                // base posëŠ” ë˜ë„ë¡ì´ë©´ ì•ìª½ìœ¼ë¡œ ì¡ì. ë‚œë°ì—†ì´ ë¹ˆì¤„ 10ê°œ ìŠ¤í‚µí•˜ê³  diffê°€ ì‹œì‘ë˜ë©´ ì´ìƒí•˜ìë‚˜.
                if (shortSideIsOnLineEdge) {
                    // ì¤„ì˜ ê²½ê³„ì— empty diffë¥¼ í‘œì‹œí•˜ëŠ” ê²½ìš° í˜„ì¬ ì¤„ì˜ ëì´ë‚˜ ë‹¤ìŒ ì¤„ì˜ ì‹œì‘ ì¤‘ "ì ì ˆí•˜ê²Œ" ì„ íƒ. í˜„ì¬ ì¤„ì˜ ë(ì´ì „ í† í°ì˜ ë’¤)ì— ìœ„ì¹˜ ì¤‘ì„.
                    if (longSideIsFirstWord) {
                        if (shortSidePos !== 0) {
                            // posê°€ 0ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì´ì „ í† í°ì˜ ë’¤ë¡œ ìœ„ì¹˜ë¥¼ ì¡ì€ ê²½ìš°ë‹ˆê¹Œ ë‹¤ìŒ ì¤„ë°”ê¿ˆì„ ì°¾ì•„ì„œ ê·¸ ì¤„ë°”ê¿ˆ ë’¤ë¡œ ë°€ì–´ì¤Œ
                            // ì£¼ì˜: í˜„ì¬ ìœ„ì¹˜ ì´í›„ì— ì¤„ë°”ê¿ˆì´ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ í™•ì¸í•˜ê¸°ë³´ë‹¤ëŠ” ì›ë³¸ í…ìŠ¤íŠ¸ì˜ ë§ˆì§€ë§‰ì— ì¤„ë°”ê¿ˆì´ ì—†ëŠ” ê²½ìš° ê°•ì œë¡œ ì¤„ë°”ê¿ˆì„ ë¶™ì—¬ì£¼ëŠ”ê²Œ í¸í•¨.
                            // ìŠì§€ë§ê³  ê¼­ ì›ë³¸í…ìŠ¤íŠ¸ì˜ ëì— ì¤„ë°”ê¿ˆ í•˜ë‚˜ ë¶™ì¼ ê²ƒ.
                            // const maxPos = shortSideAfterToken ? shortSideAfterToken.pos - 1 : shortSideText.length - 1;
                            // while (shortSidePos < maxPos && shortSideText[shortSidePos++] !== "\n");
                            while (shortSideText[shortSidePos++] !== "\n")
                                ;
                            shortSidePushedToNextLine = true;
                        }
                        // ì–‘ìª½ ëª¨ë‘ ì¤„ì˜ ì‹œì‘ ë¶€ë¶„ì— ìœ„ì¹˜í•˜ë¯€ë¡œ ì•µì»¤ ì¶”ê°€.
                        // ë¹ˆ diffê°€ ì¤„ ì‹œì‘ì´ë‚˜ ì¤„ ë ìœ„ì¹˜ì— ìˆë‹¤ë©´ í•˜ë‚˜ì˜ ì¤„ë¡œ í‘œì‹œë˜ê²Œ í•  ìˆ˜ ìˆìŒ(css ì‚¬ìš©)
                        longSideBeforeAnchorPos = longSidePos;
                        longSideBeforeAnchorLine = longSideTokenStart.lineNum;
                        shortSideBeforeAnchorPos = shortSidePos;
                        shortSideBeforeAnchorLine = (shortSideBeforeToken ? shortSideBeforeToken.lineNum : 1) + (shortSidePushedToNextLine ? 1 : 0);
                        if (longSideIsLastWord
                        // && !shortSideAfterToken || (shortSideBeforeToken && shortSideAfterToken.lineNum - shortSideBeforeToken.lineNum > 1)
                        ) {
                            asBlock = true;
                            longSideAfterAnchorPos = longSidePos + longSideLen;
                            longSideAfterAnchorLine = longSideTokenEnd.lineNum;
                            shortSideAfterAnchorPos = shortSidePos;
                            shortSideAfterAnchorLine = shortSideBeforeAnchorLine;
                        }
                    }
                }
                if (leftCount > 0) {
                    leftPos = longSidePos;
                    leftLen = longSideLen;
                    leftEmpty = false;
                    leftBeforeAnchorPos = longSideBeforeAnchorPos;
                    leftBeforeAnchorLine = longSideBeforeAnchorLine;
                    leftAfterAnchorPos = longSideAfterAnchorPos;
                    leftAfterAnchorLine = longSideAfterAnchorLine;
                    rightPos = shortSidePos;
                    rightLen = shortSideLen;
                    rightEmpty = true;
                    rightBeforeAnchorPos = shortSideBeforeAnchorPos;
                    rightBeforeAnchorLine = shortSideBeforeAnchorLine;
                    rightAfterAnchorPos = shortSideAfterAnchorPos;
                    rightAfterAnchorLine = shortSideAfterAnchorLine;
                }
                else {
                    leftPos = shortSidePos;
                    leftLen = shortSideLen;
                    leftEmpty = true;
                    leftBeforeAnchorPos = shortSideBeforeAnchorPos;
                    leftAfterAnchorPos = shortSideAfterAnchorPos;
                    rightPos = longSidePos;
                    rightLen = longSideLen;
                    rightEmpty = false;
                    rightBeforeAnchorPos = longSideBeforeAnchorPos;
                    rightBeforeAnchorLine = longSideBeforeAnchorLine;
                    rightAfterAnchorPos = longSideAfterAnchorPos;
                    rightAfterAnchorLine = longSideAfterAnchorLine;
                }
            }
            if (leftBeforeAnchorPos !== undefined && rightBeforeAnchorPos !== undefined) {
                addAnchor("before", leftBeforeAnchorPos, leftBeforeAnchorLine, rightBeforeAnchorPos, rightBeforeAnchorLine, diffs.length);
            }
            if (leftAfterAnchorPos !== undefined && rightAfterAnchorPos !== undefined) {
                addAnchor("after", leftAfterAnchorPos, leftAfterAnchorLine, rightAfterAnchorPos, rightAfterAnchorLine, diffs.length);
            }
            const newEntry = {
                type: type,
                left: {
                    pos: leftPos,
                    len: leftLen,
                    empty: leftEmpty,
                },
                right: {
                    pos: rightPos,
                    len: rightLen,
                    empty: rightEmpty,
                },
                asBlock,
            };
            diffs.push(newEntry);
        }
        diffContext.diffs = diffs;
        diffContext.anchors = anchors;
        return { diffs, anchors, leftTokenCount: leftTokens.length, rightTokenCount: rightTokens.length };
    }
    disableAlignedMode();
    leftEditor.updateText();
    rightEditor.updateText();
    _diffContext = {
        reqId: 0,
        leftText: leftEditor.text,
        rightText: rightEditor.text,
        diffOptions: { ..._diffOptions },
        done: false,
    };
    computeDiff();
    return {
        get alignedMode() {
            return _alignedMode;
        },
        set alignedMode(value) {
            if (!!value) {
                enableAlignedMode();
            }
            else {
                disableAlignedMode();
            }
        },
        get dump() {
            // ë””ë²„ê¹… í•  ë•Œ...
            return {
                _diffContext: _diffContext,
                // diffs: _diffResult?.diffs,
                // anchors: _diffResult?.anchors,
                diffOptions: _diffOptions,
                leftEditor,
                rightEditor,
                activeEditor: _activeEditor,
            };
        },
        compute: computeDiff,
        diffOptions: _diffOptions,
        get outputOptions() {
            return _outputOptions;
        },
    };
})();
//# sourceMappingURL=main.js.map
</script>
</body>

</html>
