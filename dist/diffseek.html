<!DOCTYPE html>
<!--
# DiffSeek 

### ê°œìš”
- ì •ë§ ì„¼ìŠ¤ë§Œì  ì´ë¦„. ì¤‘êµ­ì‚° DeepSeek ì•„ë‹˜. diffë¥¼ seekí•¨.
- í•œê¸€ì í•œê¸€ì ëˆˆìœ¼ë¡œ ë¹„êµí•˜ëŠ”ê±´ ì£½ì–´ë„ ëª»í•˜ê² ê³  ì£½ì–´ë„ í•˜ê¸° ì‹«ì–´ì„œ.
- ê³µë°± ë¬´ì‹œ. ê³µë°±ì„ ì™„ì „íˆ ë¬´ì‹œí•˜ëŠ”ê±´ ì™„ì „íˆ ì˜ë„ëœ ê²ƒì„. **ì—…ë¬´ë§¤ë‰´ì–¼ì˜ ì¤„ë°”ê¿ˆ ìœ„ì¹˜ëŠ” ì ˆëŒ€ë¡œ ë¬¸ì¥ì˜ ë í˜¹ì€ ë‹¨ë½ì˜ ëê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŒ!** ê³µë°±ì„ ì „í˜€ ë¬´ì‹œí•˜ì§€ ì•Šê±°ë‚˜ ì •ê·œí™”(ì—¬ëŸ¬ê°œì˜ ì—°ì†ëœ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì¸ì‹)í•´ì„œ ë¹„êµí•˜ëŠ” ì½”ë“œë¥¼ ì§œëŠ”ê²Œ 100ë§Œë°° ì‰½ê³  ê³„ì‚°ì†ë„ë„ í›¨ì”¬ ë¹ ë¦„. (í† ê¸€ ê°€ëŠ¥: `DiffSeek.diffOptions.whitespace = "ignore" | "normalize"`)
- ë‹¨ì–´ ë‹¨ìœ„ diffê°€ ê¸°ë³¸. ê¸€ì ë‹¨ìœ„ diffëŠ” ì„±ëŠ¥ë„ ì„±ëŠ¥ì´ì§€ë§Œ ì‚¬ëŒì˜ ëˆˆì— ì˜¤íˆë ¤ ë” í”¼ê³¤í•˜ê¸°ë§Œ í•¨. ì¤„ ë‹¨ìœ„ì˜ ê²½ìš°ë„ ë¬¸ì„œë§ˆë‹¤ ì¤„ë°”ê¿ˆì˜ ìœ„ì¹˜ê°€ ì§€ë©‹ëŒ€ë¡œë¼ ë¹„íš¨ìœ¨ì ì„. (í† ê¸€ ê°€ëŠ¥: `DiffSeek.diffOptions.tokenization = "char" | "word" | "line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

### êµ¬í˜„ ì˜ë„? ì°¸ê³ ì‚¬í•­?
- ì–‘ìª½ì— í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê³  ì‹¤í–‰ë²„íŠ¼ ë”±~ ëˆ„ë¥´ë©´ diffë“¤ì´ í‘œì‹œë˜.... 
    *ì™œ???? ë²„íŠ¼ì„ ë­í•˜ëŸ¬ ëˆŒëŸ¬?*
    **diffëŠ” í…ìŠ¤íŠ¸ ë³€ê²½ì‹œ ì‹¤ì‹œê°„ìœ¼ë¡œ, ì…ë ¥í•œ í…ìŠ¤íŠ¸ ë°”ë¡œ ê·¸ ìë¦¬ì— ë³´ì—¬ì¤˜ì•¼ í•¨!!** ë§¤ë²ˆ ê·€ì°®ê²Œ ë²„íŠ¼ ëˆ„ë¥´ëŠ” ì§“ì€ í•˜ê³  ì‹¶ì§€ ì•Šì–ì•„? ì†”ì§íˆ ì…ë ¥ê³¼ ì¶œë ¥ì„ ë¶„ë¦¬í•˜ëŠ” ê²Œ ë” í›¨ì”¬ ì‰¬ì›€.
- ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ê°€ ì¼ì–´ë‚˜ëŠ” ë„ì¤‘ì—ë„ í¸ì§‘ì„ ë°©í•´í•˜ë©´ ì•ˆë¨. ë¯¸ì„¸í•œ ë”œë ˆì´ë¼ë“ ì§€ ì˜ë„í•˜ì§€ ì•Šì€ ì»¤ì„œìœ„ì¹˜ ë³€ê²½, í•œê¸€ì…ë ¥ìƒíƒœ ë³µì› ë“±ë“±(í•œê¸€ì…ë ¥ìƒíƒœ ë³µì› ë°©ë²•ì€ ì—†ë‹¤ ë³´ë©´ ë¨. ìš°íšŒí•˜ëŠ” ë°©ë²•ì€ ì—…ë°ì´íŠ¸ë¥¼ ì•ˆí•˜ëŠ”ê²ƒ, ìµœì†Œí•œ í˜„ì¬ ì»¤ì„œê°€ ìœ„ì¹˜í•œ ë…¸ë“œì— ëŒ€í•´ì„œëŠ” ì—…ë°ì´íŠ¸ë¥¼ ì•ˆí•˜ê³  ë¯¸ë£¨ëŠ” ë°©ë²•ì´ ê±°ì˜ ìœ ì¼í•¨).
- ì—…ë°ì´íŠ¸ë§ˆë‹¤ DOMì„ ì™„ì „íˆ ì‹¹ ê°ˆì•„ì—ì§€ ë§ê³  ê°€ëŠ¥í•œ ê²½ìš° ê¸°ì¡´ ë…¸ë“œë“¤ì„ ì¬ì‚¬ìš©.
- í¸ì§‘ê¸°(ê·¸ëƒ¥ ë‹¨ìˆœ `<div contenteditable>`ì„)ì˜ ê¸°ë³¸ì ì¸ ê¸°ëŠ¥(ë³µë¶™,undo/redo,...)ë“¤ì€ ë˜ë„ë¡ ë¸Œë¼ìš°ì €ì—ê²Œ ë„˜ê¸¸ ê²ƒ. ì´ëŸ° ê¸°ëŠ¥ë“¤ì€ ìˆ¨ì‰¬ê¸°ì™€ ê°™ì•„ì„œ ì˜ˆìƒëŒ€ë¡œ ì‘ë™ ì•ˆí•˜ëŠ” ìˆœê°„ ì§œì¦ ì†Ÿêµ¬ì¹¨. ë˜í•œ ë‚˜ì²˜ëŸ¼ ê¹ê¹í•œ ì‚¬ëŒì—ê²Œ ì–´ìƒ‰í•¨ì´ ì•ˆëŠê»´ì§ˆë§Œí¼ ì œëŒ€ë¡œ êµ¬í˜„í•˜ê¸°ëŠ” ì‰½ì§€ ì•ŠìŒ(ì»¤ì„œìœ„ì¹˜, í…ìŠ¤íŠ¸ì„ íƒë²”ìœ„, ìŠ¤í¬ë¡¤ ìœ„ì¹˜, ì–¼ë§ˆë‚˜ ë§ì€ í¸ì§‘ì„ ì–¼ë§ˆì˜ ë”œë ˆì´ ê°„ê²©ìœ¼ë¡œ í•˜ë‚˜ì˜ íˆìŠ¤í† ë¦¬ ì—”íŠ¸ë¦¬ë¡œ ë¬¶ì„ ê²ƒì¸ê°€, ê·¸ë¦¬ê³  ì–‘ìª½ í¸ì§‘ê¸°ë¥¼ ì™”ë‹¤ê°”ë‹¤ í–ˆì„ ë•Œ ë“± ìƒê°ë³´ë‹¤ ì‹ ê²½ì“¸ ê²Œ ë§ìŒ. ë‹¨ìˆœíˆ textë§Œ ë³´ê´€í•˜ëŠ” ê²ƒìœ¼ë¡œëŠ” ì–´ë¦¼ ì—†ìŒ).
- ìœ„ì™€ ê°™ì€ ì´ìœ ë¡œ, í¸ì§‘ê¸°ì™€ ì‹¤ì œ diff í•˜ì´ë¼ì´íŠ¸ ì˜ì—­(mirror)ì„ ë”°ë¡œ ê´€ë¦¬í•˜ë©´ì„œ 1pxì˜ ì˜¤ì°¨ ì—†ì´ ì •í™•í•˜ê²Œ ê²¹ì¹˜ê²Œ ë§Œë“œëŠ” ì–ì‚½í•œ ë°©ë²•ì„ ì”€. ì´ê±´ ê·¸ëƒ¥ ì„¼ìŠ¤ë‹¤. editor(see-through) â†’ mirror
- í¬ê¸°ê°€ í° í…ìŠ¤íŠ¸(5ë§Œê¸€ì ì´ìƒ)ë¥¼ ë¹„êµí•  ë•Œì—ë„ í¸ì§‘ê¸°ê°€ **ì¶©ë¶„íˆ(ì•„ì£¼ ì¶©ë¶„íˆ) ë°˜ì‘ì ì¼ ê²ƒ**. ë”œë ˆì´ ìµœì†Œí™”! ë‹¨ìˆœ debouncingì´ ì•„ë‹ˆë¼ ê·¸ ì´ìƒì´ í•„ìš”(web worker, RequestIdleCallback, ...)
- ë‹¤ë¥¸ ë¬¸ì(ë¬¸ìcodeê°€ ë‹¤ë¥¸ ê²½ìš°)ì§€ë§Œ ê°™ë‹¤ê³  ì—¬ê²¨ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ë„ ì²˜ë¦¬í•˜ì˜€ì§€ë§Œ ì´ê±´ ì´ëŸ¬í•œ ë¬¸ìë“¤ì„ ì§ì ‘ ì¶”ê°€í•´ì¤˜ì•¼í•¨(`constants.ts/NORMALIZE_CHARS`).
- (ì¶”ê°€),(ì‹ ì„¤),(í˜„í–‰ê³¼ ê°™ìŒ),(ì‚­ì œ) ë“±ì€ wildcardë¡œ ì²˜ë¦¬. ì´ í† í°ë“¤ì€ ê´„í˜¸ ì•ˆ ê³µë°±ì„ ë¬´ì‹œí•˜ê³  ì ˆëŒ€ë¡œ ì¤‘ê°„ì—ì„œ ì•ˆì˜ë¦¬ê²Œ(`(í˜„í–‰ê³¼`,`ê°™ìŒ)`ì´ ë˜ì§€ ì•Šê²Œ) ë§Œë“¤ì–´ë†¨ì§€ë§Œ ì•„ì§ì€ ë”± ê±°ê¸°ê¹Œì§€ì„.
- diff í•˜ì´ë¼ì´íŠ¸ ìƒ‰ë“¤ì€ ì •ë§ **ì„¸ì‹¬í•˜ê²Œ ê³ ë¥¸** ê²ƒë“¤ì„. ì ˆëŒ€ ë¶ˆë§Œì„ ê°€ì ¸ì„œëŠ” ì•ˆë¨. ë¹¨ê°„ìƒ‰ ê³„í†µì€ ë°°ê²½ê³¼ í™•ì‹¤íˆ ëŒ€ë¹„ë˜ì§€ ì•Šì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì˜ë„ì ìœ¼ë¡œ ì œì™¸(`constants.ts/DIFF_COLOR_HUES`).
- í° ì›Œë“œë¬¸ì„œì—ì„œ ë³µë¶™ì„ í•  ë•Œì— ë³µì‚¬ê°€ ë°”ë¡œ ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìˆëŠ”ë° ì ˆëŒ€ì ìœ¼ë¡œ MSì›Œë“œì˜ ë¬¸ì œì„. ë ë•Œê¹Œì§€ ë¶™ì—¬ë„£ê¸° í•˜ë©´ ì–¸ì  ê°€ëŠ” ëœë‹¤(ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ì›Œë“œëŠ” ë¨¹í†µë¨).
    - ì²˜ìŒì—” ì´ì „ì— í´ë¦½ë³´ë“œì— ë“¤ì–´ìˆë˜ ë‚´ìš©ì´ ë¶™ì—¬ë„£ê¸° ë¨
    - ì¬ì‹œë„(`ctrl-v`) í•˜ë‹¤ë³´ë©´ ë¹ˆ í…ìŠ¤íŠ¸ê°€ ë¶™ì—¬ë„£ê¸° ë¨
    - ê³„ì†... ì¬ì‹œë„(`ctrl-v`)í•˜ë‹¤ë³´ë©´ ê²°êµ­ ì„±ê³µí•¨.
- ê°œì •ëŒ€ë¹„í‘œvsì „ë¬¸, ì „ë¬¸vsì „ë¬¸, ì›¹ì „ë¬¸vsì „ë¬¸ **ì „ì²´ë¥¼ í•œë²ˆ**ì— ë³µ/ë¶™í•´ì„œ ë¹„êµí•  ìˆ˜ ìˆì–´ì•¼í•¨(ìˆ˜ì‹­ë²ˆì”© ë“œë˜ê·¸,ë³µ/ë¶™ì„ í•˜ëŠ” ê²ƒë³´ë‹¤ëŠ” ë¬´ì¡°ê±´ í¸í•¨!!). ê·¸ë˜ì„œ ë§Œë“ ê²Œ  Aligned Mode
- ì—£ì§€(í˜¹ì€ í¬ë¡¬) ì „ìš©. ì¸ê°„ì ìœ¼ë¡œ 2025ë…„ì— ieë¥¼ ì™œ ì¨ì•¼í•˜ì§€?
- Heading(*1. ê°œìš”*, *(ê°€) ì–´ì©Œê³ *, ë“±)ë„ ì°¾ì•„ë‚´ì„œ ì‹œê°ì  ê°•ì¡°ë¥¼ ì£¼ê¸´ í–ˆì§€ë§Œ ë”± ê±°ê¸°ê¹Œì§€ì„. ì• ë‹¹ì´ˆ ì›ë³¸ ë¬¸ì„œ êµ¬ì¡°ê°€ ì—‰ë§ì´ë¼ì„œ 100% ì •í™•í•œ/ì˜ë¯¸ ìˆëŠ” headingì„ ì¶”ì¶œí•˜ê¸°ëŠ” ì–´ë ¤ì›€. ì–´ì„¤í”„ê²Œ ë°˜ì€ ë§ê³  ë°˜ì€ í‹€ë¦° ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” ê²ƒë³´ë‹¤ëŠ” ì•„ì˜ˆ ì •ë³´ë¥¼ ì£¼ì§€ ì•ŠëŠ” ê²ƒì´ ë‚«ë‹¤.
- ë¶™ì—¬ë„£ê¸°ëŠ” plaintextë§Œ. html ë¶™ì—¬ë„£ê¸°ë„ ë§Œë“¤ì–´ ë´¤ì§€ë§Œ ë“ë³´ë‹¤ ì‹¤ì´ ë§ì€ ëŠë‚Œ(ì´ì „ ë²„ì „ ì½”ë“œ ë’¤ì ¸ë³´ë©´ ìˆìŒ).
- ì¢Œ/ìš° í…ìŠ¤íŠ¸ê°€ ì™„ì „íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš° ìŒë‘¥ì´ğŸ‘¬ë¥¼ ë³´ì—¬ì¤Œ. ì´ê±´ ctrl-cê°€ ì œëŒ€ë¡œ ì•ˆë˜ì—ˆê±°ë‚˜(ì†ê°€ë½ í˜ ë¶€ì¡±?) ì›Œë“œ ë¬¸ì œë¡œ ë³µë¶™ì´ ì œëŒ€ë¡œ ë˜ì§€ ì•Šì€ ê²½ìš°ì— ë‚´ê°€ í™•ì‹¤íˆ ì¸ì§€í•  ìˆ˜ ìˆë„ë¡ ë„£ì€ ê²ƒì„. ì¬ë¯¸ë¡œ ë„£ì€ ê±° ì•„ë‹˜.

### Aligned Mode
- ì´ë¦„ì€ ë§˜ì— ì•ˆë“¤ì§€ë§Œ ì•”íŠ¼ ì–‘ìª½ í…ìŠ¤íŠ¸ì—ì„œ ì„œë¡œ ëŒ€ë¹„ë˜ëŠ” ì¤„ë“¤ì˜ ìœ„ì¹˜ë¥¼ ê°™ê²Œ ë§ì¶°ì£¼ëŠ” ê¸°ëŠ¥. `F2`ë¡œ í† ê¸€.
- ì–‘ìª½ ìŠ¤í¬ë¡¤ ë™ê¸°í™”ë¨.
- readonly ëª¨ë“œì„(ê°„ë‹¨í•œ ìˆ˜ì •ì„ ì‹œë„í•˜ë©´ ê¸°ë³¸ ëª¨ë“œë¡œ ì „í™˜ë˜ë©´ì„œ ë°”ë¡œ ìˆ˜ì •ì´ ì ìš©ë˜ê²ŒëŠ” í•´ë†¨ìŒ).
- Aligned ModeëŠ” ê¹Œë§Œ ë°°ê²½ì„(ë§ˆìŒì— ì•ˆë“¤ì§€ë§Œ **ê¸°ë³¸ ëª¨ë“œì™€ í™•ì‹¤íˆ ëŒ€ë¹„ë˜ëŠ” ëŠë‚Œì´ ìˆì–´ì•¼ í–ˆìŒ**).
- ë‘ ëª¨ë“œë¥¼ ì „í™˜í• ë•Œ ì„ íƒëœ í…ìŠ¤íŠ¸ì˜ ë²”ìœ„ë¥¼ ìœ ì§€í•˜ë ¤ê³  ë…¸ë ¥í•œ ë¶€ë¶„ì€ ì¹­ì°¬ ë°›ì•„ì•¼ í•¨. ìƒê°ë³´ë‹¤ ê¹Œë‹¤ë¡œì›€(ìˆ˜ê³ í–ˆì–´~).
- ì»¨íŠ¸ë¡¤ í‚¤ë¥¼ ëˆ„ë¥¸ì±„ë¡œ í…ìŠ¤íŠ¸ë¥¼ í´ë¦­í•˜ë©´ ê¸°ë³¸ ëª¨ë“œë¡œ ì „í™˜ë˜ë©´ì„œ í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì»¤ì„œë¥¼ ì˜®ê¹€(ìˆ˜ê³ í–ˆì–´~).
- ì–‘ìª½ diffë¶€ë¶„ì„ ë¸”ëŸ­ë‹¨ìœ„ë¡œ í‘œì‹œí•  ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ê·¸ëŸ¬ë ¤ê³  ë…¸ë ¥(!)í–ˆìŒ.
- ì–‘ìª½ ëŒ€ë¹„(ë§¤ì¹˜)ë˜ëŠ” ë¶€ë¶„ì˜ ìœ„ì¹˜ì˜ ì°¨ì´ëŠ” paddingìš”ì†Œë¥¼ ë„£ì–´ì„œ ë©”ê¿ˆ. TODO: ì—¬ëŸ¬ê°œì˜ ë¹ˆì¤„ë¡œ ì¸í•´ ë°œìƒí•˜ëŠ” ìœ„ì¹˜ ì°¨ì´ëŠ” paddingì´ ì•„ë‹ˆë¼ ë¹ˆì¤„ë“¤ì„ collapseí•˜ëŠ” ìª½ìœ¼ë¡œ í•´ì•¼ ë” ë³´ê¸° ì¢‹ì„ ê²ƒ ê°™ìŒ.

### ì¸í„°ë„·ë„ ì•ˆë˜ê³  ì•„ë¬´ê²ƒë„ ì—†ëŠ”... ìˆëŠ” ê±°ë¼ê³¤ ë¸Œë¼ìš°ì €, ë©”ëª¨ì¥ ë°–ì— ì—†ëŠ” pcì—ì„œ ëŒë ¤ì•¼í•¨.
- html + css + jsëŠ” ì–´ì©” ìˆ˜ ì—†ëŠ” ì„ íƒ. react? ê¿ˆë„ ê¾¸ì§€ë§ˆ. ìŒ©html ìŒ©css ìŒ©jsë¡œ êµ¬í˜„
- ë‹¹ì—°íˆ ì›¹ì„œë²„ ë¶ˆê°€ëŠ¥ì´ê³  íŒŒì¼ê²½ë¡œ(`file:///...../diffseek.html`)ë¡œ ì—´ì–´ì•¼í•¨. ì œì•½ ë§ìŒ.
- ì„¬ì„¸í•˜ê³  ì´ìœ UIìš”ì†Œê°€ ë¶€ì¡±í•œ ê²ƒì€ ì ˆëŒ€ì ìœ¼ë¡œ ì´ ë•Œë¬¸ì„. ìš”ìƒˆ ëˆ„ê°€ UIìš”ì†Œë¥¼ í•˜ë‚˜í•˜ë‚˜ ì†ìˆ˜ ë§Œë“œë‚˜...
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¡œ ì‘ì„±í•˜ê³  ì»´íŒŒì¼ëœ jsë¥¼ ì˜®ê¸°ëŠ” ê±´ ê°€ëŠ¥.
- ë‹·ë„·, java ëŸ°íƒ€ì„ì€ ê¹”ë ¤ìˆëŠ” ê²ƒ ê°™ì§€ë§Œ ê·¸ ë¿ì„. sdkê°€ ì—†ìŒ.
- ì•„ë¬´íŠ¼ ì´ëŸ¬ì €ëŸ¬í•œ ì´ìœ ë¡œ ìë°”ìŠ¤í¬ë¦½íŠ¸ê°€ ìœ ì¼í•œ ì˜µì…˜ì¸ë° ì‚¬ì‹¤ ì›¹ë¸Œë¼ìš°ì €ì— ìµìˆ™í•˜ì§€ ì•Šì€ ì‚¬ëŒì€ ì—†ê³  ê¸°ë³¸ì ì¸ ë™ì‘ë“¤ì€ ëª¨ë‘ ë§¤ë„ëŸ½ê²Œ êµ¬í˜„ì´ ë‹¤ ë˜ì–´ìˆìœ¼ë‹ˆ ì–´ì°Œë³´ë©´ ìµœê³ /ìµœì„ ì˜ ì„ íƒì„.
- ì¸ê°„ì ìœ¼ë¡œ vscodeì •ë„ëŠ”... ì“°ê³ ì‹¶ë‹¤.

### ì§‘ì—ì„œ ë§Œë“  ì½”ë“œë¥¼ íšŒì‚¬ë¡œ ì˜®ê¸°ëŠ” ë°©ë²•?
- ì›Œí¬ë¹„ ìª½ì§€/ë‚´ë¶€ë©”ì¼ë¡œ ë³´ë‚´ê³  íšŒì‚¬ì—ì„œ ì—´ê³  ë©”ëª¨ì¥ì— ë¶™ì—¬ë„£ê¸°. ê³ ë¡œ ì½”ë“œê°€ ë„ˆë¬´ ì»¤ì§€ë©´ ì•ˆë¨. ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬? ì–´ë¦¼ë„ ì—†ìŒ.
- ë‹¤í–‰íˆë„ íœ´ëŒ€í° ì›Œí¬ë¹„ì•± ë³´ì•ˆì„ ìš°íšŒí•´ì„œ ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ë¥¼ ì‚¬ìš©í•  ë°©ë²•ì´ ìˆë”ë¼(ë¹„ë°€ ìœ ì§€ í•„ìš”..ã…‹ ì´ê±° ë§‰íˆë©´ ë”ì´ìƒì˜ ì—…ë°ì´íŠ¸ëŠ” ë¶ˆê°€ëŠ¥í•¨).
- ì˜®ê¸°ê¸° ì „ì— í•˜ë‚˜ì˜ íŒŒì¼(diffseek.html)ë¡œ í•©ì¹œ í›„ì— ê·¸ íŒŒì¼ì˜ ë‚´ìš©ì„ ì˜®ê²¨ì•¼í•¨. ë¹Œë“œëœ íŒŒì¼ì´ 4000ì¤„ì´ ë„˜ìœ¼ë‹ˆ ë‘ì–´ë²ˆì— ê±¸ì³ ë³µë¶™ í•„ìš”.
- build, distí´ë”ë¥¼ ëª¨ë‘ gitì— í¬í•¨í•œ ê²ƒì€ ì´ëŸ¬í•œ ì´ìœ ì„(ë‚˜ëˆ ì„œ ë³µë¶™í•˜ë‹¤ê°€ í•œë‘ì¤„ ë¹¼ë¨¹ì€ ê²½ìš°ì— íœ´ëŒ€í°ìœ¼ë¡œ githubì˜ ì½”ë“œì™€ ë¹„êµí•´ë´ì•¼í•¨).
- .tsë¡œë¶€í„° ì»´íŒŒì¼ëœ .jsíŒŒì¼ì— ì£¼ì„ì„ ë‚¨ê²¨ë‘ëŠ” ê²ƒì€ íšŒì‚¬ì—ì„œ ë””ë²„ê¹…ì„ í•´ì•¼ë˜ëŠ” ê²½ìš°ê°€ ìˆê¸° ë•Œë¬¸.
- íšŒì‚¬ì—ì„œ ìˆ˜ì •í•œ ê±¸ ì§‘ìœ¼ë¡œ ê°€ì ¸ê°€ëŠ”ê±´ ì‰½ì§€ ì•ŠìŒ. ì–´ëŠ ë¶€ë¶„ì„ ì–´ë–»ê²Œ ìˆ˜ì •í–ˆëŠ”ì§€ ê¸°ì–µí–ˆë‹¤ê°€ ì§‘ì—ê°€ì„œ ë‹¤ì‹œ ì‘ì—…í•´ì•¼í•¨. ì˜¤ëŠ˜ ë¨¹ì€ ë°˜ì°¬ë„ ê¸°ì–µ ì•ˆë‚¨.

### ë¸Œë¼ìš°ì €ì—ì„œ ì›¹ ì£¼ì†Œê°€ ì•„ë‹Œ íŒŒì¼ì„ ì—¬ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ë³´ì•ˆìƒ ì œì•½ì´ ë§ìŒ.
- ì¿ í‚¤? localStorage? ... ë‹¹ì—°íˆ ë¶ˆê°€ - ìƒíƒœ/ì˜µì…˜ ì €ì¥í•˜ëŠ”ê±´ ì ˆëŒ€ ë¶ˆê°€ëŠ¥.
- new Worker(url) - íŒŒì¼ urlì„ ì—´ ìˆ˜ ì—†ìŒ(ê·¸ë˜ì„œ workerë¥¼ ì“°ë ¤ë©´ ì•½ê°„ì˜ íŠ¸ë¦­ í•„ìš”)
- ê·¸ ì™¸ 'ì´ê²Œ ë ê¹Œ?' ì‹¶ì€ ê²ƒë“¤ì€ ì•ˆëœë‹¤ê³  ë³´ë©´ ë¨
- ìŠ¤í¬ë¦½íŠ¸ë¡œ ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ë¥¼ ì‹¤í–‰í•  ë•Œì˜ ê²½ê³ ëŠ” ì—£ì§€ ì„¤ì •-whitelistì— ë“±ë¡í•´ì„œ í”¼í•  ìˆ˜ ìˆê¸°ëŠ” í•¨. ì§€ê¸ˆì€ ê´€ë ¨ ê¸°ëŠ¥ë“¤ì„ ë‹¤ ì§€ì›Œë²„ë ¸ìœ¼ë‹ˆê¹Œ í•„ìš” ì—†ì§€ë§Œ ë‹¤ì‹œ ë„£ì„ê¹Œí•¨(ë‹¨ì¶•í‚¤ë¡œ ì™¼ìª½ì°½/ì˜¤ë¥¸ìª½ì°½ ì„ íƒì—†ì´ ë°”ë¡œ ë¶™ì—¬ë„£ê¸° ë“±)

### ë‹¨ì¶•í‚¤?
- F2 - aligned mode í† ê¸€(ì–‘ìª½ ì¤„ë§ì¶¤, ìŠ¤í¬ë¡¤ ë™ê¸°í™”, í¸ì§‘ ë¶ˆê°€)
- SHIFT-F2 - scroll sync í† ê¸€(ì•½ê°„ì˜ ì¤„ë§ì¶¤, ì•½ê°„ì˜ ìŠ¤í¬ë¡¤ ë™ê¸°í™”, í¸ì§‘ ê°€ëŠ¥)
- ctrl-1/ctrl-2 í¸ì§‘ê¸°ì— í¬ì»¤ìŠ¤
- í¸ì§‘ ì¤‘ì— ctrl-space - ë°˜ëŒ€ìª½ í¸ì§‘ê¸°ì˜ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¥¼ í˜„ì¬ í¸ì§‘ê¸°ì— ë§ì¶¤(ê°€ëŠ¥í•œ ê²½ìš°)

### copy mode?
- ì´ê±´ ì•„ì§ í”„ë¡œí† íƒ€ì… ë‹¨ê³„
- raw: ê·¸ëƒ¥ ë³´í†µì˜ ctrl-c
- formatted: - ì•½ê°„ì˜ diff í•˜ì´ë¼ì´íŠ¸. ë“œë˜ê·¸ ë²”ìœ„ê°€ ì–´ì„¤í”„ê²Œ ë‹¨ì–´ ì¤‘ê°„ì—ì„œ ì‹œì‘ë˜ê±°ë‚˜ ëë‚˜ëŠ” ê²½ìš°ì—ëŠ” ë‹¨ì–´ì˜ ê²½ê³„(ì •í™•íˆëŠ” í† í°ì˜ ê²½ê³„)ë¡œ ë§ì¶¤
- compare: í•œìª½ì˜ í…ìŠ¤íŠ¸ë¥¼ ë³µì‚¬í–ˆì„ ë•Œ ëŒ€ì‘ë˜ëŠ” ë°˜ëŒ€ìª½ í…ìŠ¤íŠ¸ê¹Œì§€ ê°™ì´ ë³µì‚¬í•´ì„œ í¬ë§·í•¨(*ì¢Œ:ê·¸ë‹¨ì–´, ìš°:ì €ë‹¨ì–´*)

### histogram ì•Œê³ ë¦¬ì¦˜
- ê°€ì¥ ë„ë¦¬ ì“°ì´ëŠ” ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì¸ ê²ƒ ê°™ìŒ...?
- ì´ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œê±´ ì•µì»¤(ì¼ì¹˜ë˜ëŠ” ê¸°ì¤€ì )ë¥¼ ê·¸ê²ƒë„ ì•„ì£¼ ì¢‹ì€ë†ˆìœ¼ë¡œ ì°¾ëŠ” ë¶€ë¶„ì¸ ê²ƒ ê°™ì€ë° ìƒê°í•  ê²ƒì´ ë§ìŒ. ê° ì„¹ì…˜ì˜ ì œëª©(1. ê°œìš”, 2. ì—…ë¬´ì²˜ë¦¬ ìˆœì„œ, ...)ì— ê°€ì¤‘ì¹˜ë¥¼ ì£¼ë ¤í–ˆì§€ë§Œ í•´ë‹¹ ì œëª©ë“¤ì€ ì—…ë¬´ë§¤ë‰´ì–¼ ì›Œë“œíŒŒì¼ì—ì„œ ë§¨ ì•ì— ì ë ¤ìˆëŠ” ê²½ìš°(ì œëª©ì„ ì™¼ìª½ ì»¬ëŸ¼ì— ë„£ê³  ì—”í„°í‚¤ ìˆ˜ì‹­ë²ˆ ëˆŒëŸ¬ì„œ ì„¹ì…˜ì„ ë‚˜ëˆˆ ê²½ìš°)ê°€ ë§ì•„ì„œ ì˜ë¯¸ ì—†ìŒ. (1), (ê°€), 1), ê°€)ì—ëŠ” ì ìš©í–ˆì§€ë§Œ ì–¼ë§ˆë‚˜ ì •í™•í•˜ê³  íš¨ìœ¨ì ì¼ì§€ ê°ì´ ì•ˆì™€ì„œ ê°€ì¤‘ì¹˜ë¥¼ ë†’ê²Œ ì£¼ì§€ ì•Šì•˜ìŒ.
- ê·¸ì™¸ ì¤„ì˜ ì‹œì‘/ë ë¶€ë¶„ì— ê°€ì¤‘ì¹˜, í¬ê·€ë„ì— ê°€ì¤‘ì¹˜, ì•µì»¤ ë¬¸ìì—´ ê¸¸ì´ì— ê°€ì¤‘ì¹˜.
- ìµœìš°ì„ ìˆœìœ„ ì•µì»¤ `@@@`, `###` (ë°œê²¬ì‹œ ë¬´ì¡°ê±´ ì–‘ìª½ í…ìŠ¤íŠ¸ì— ë‚˜ì˜¤ëŠ” ì´ ì•µì»¤ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë§¤ì¹˜ì‹œí‚´). ì¢Œìš° ë¬¸ì„œê°€ ë„ˆë¬´ ì•ˆë§ì„ ë•Œ ê°•ì œë¡œ íŠ¹ì •ìœ„ì¹˜ë¥¼ ë§¤ì¹˜ì‹œí‚¤ê³  ì‹¶ì„ ë•Œ. ê¸´ ë¬¸ì„œ ë¹„êµ ì‹œì— ì„¹ì…˜ ëŒ€ ì„¹ì…˜ì´ ë§¤ì¹˜ê°€ ì˜ ì•ˆë  ê²½ìš° ì“°ë©´ í¸í•¨.
- ë‹¨ìˆœíˆ ë‹¨ì–´vsë‹¨ì–´ ë¿ë§Œ ì•„ë‹ˆë¼ nê·¸ë¨(ë³µìˆ˜ê°œì˜ ë‹¨ì–´ ë§¤ì¹˜), nê°œì˜ ë‹¨ì–´ì™€ mê°œì˜ ë‹¨ì–´(ë‹¨ì–´ ìˆ˜ê°€ ë‹¤ë¥´ì§€ë§Œ ê³µë°±ì„ ë¬´ì‹œí•˜ê³  ë¹„êµí•  ê²½ìš° ê°™ì€ ë‹¨ì–´ë“¤)ë„ ë§¤ì¹˜ë˜ëŠ” ê²½ìš°ì—ë„ ì•µì»¤ë¡œ ì‚¬ìš©í•˜ë ¤ê³  ë…¸ë ¥...ì€ í•¨.
- ë‚´ ìƒê°ì— ê³µí†µprefix/suffixë¥¼ ìŠ¤í‚µí•˜ëŠ” ë¶€ë¶„ ë•Œë¬¸ì— ìµœê³ ë¡œ ì¢‹ì€ ì•µì»¤ë¥¼ ì°¾ì„ ê¸°íšŒë¥¼ ë†“ì¹˜ëŠ” ê²½ìš°ë„ ìƒê¸¸ ìˆ˜ ìˆì„ ê²ƒ ê°™ì§€ë§Œ ìŠ¤í‚µ ì•ˆí•˜ë©´ ì„±ëŠ¥ ê°œíŒ ë¨. ì ˆëŒ€ì ìœ¼ë¡œ í•„ìš”.
- ì¼ì¹˜ë˜ëŠ” ë‹¨ì–´ê°€ ë‹¤ë¥´ë‹¤ê³  í‘œì‹œë˜ëŠ” ê²½ìš°ëŠ” ìˆì„ ìˆ˜ ìˆìŒ(ë¬¸ì„œ ë‚´ì— ê°™ì€ ë‹¨ì–´ê°€ ì—¬ëŸ¬ë²ˆ ë‚˜ì˜¤ëŠ” ê²½ìš° ê·¸ ì¤‘ ì–´ëŠ ê²ƒì— ë§¤ì¹˜ì‹œí‚¬ ê²ƒì¸ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ ë™ì‘ì— ë‹¬ë ¤ìˆìŒ).
- ì¼ì¹˜ë˜ì§€ ì•ŠëŠ” ë‹¨ì–´ê°€ ê°™ë‹¤ê³  í‘œì‹œë˜ëŠ” ê²½ìš°ëŠ” ë‹¹ì—°íˆ ì—†ì–´ì•¼í•¨(ì—†ìŒ!).

### DiffSeek.diffOptions
ì •ë§ë¡œ ì •ë§ë¡œ really really ì›í•œë‹¤ë©´ ë¸Œë¼ìš°ì € devtools ì½˜ì†”ì—ì„œ...
```
DiffSeek.diffOptions = {
    algorithm: "histogram" | "lcs"; // ("histogram")
	tokenization: "char" | "word" | "line"; // ("word")
	whitespace: "ignore" | "normalize"; //("ignore")
	useLengthBias: true | false; //(true)
	maxGram: 4; // 1~5ì •ë„ë§Œ...
	lengthBiasFactor: 0.7; // ì•µì»¤ ê¸¸ì´ì— ëŒ€í•œ ê°€ì¤‘ì¹˜ ì¡°ì •
	sectionHeadingMultiplier: 1.3333; // 1 / 0.75
	lineStartMultiplier: 1.1764;  // 1 / 0.85
	lineEndMultiplier: 1.1111;  // 1 / 0.9
	uniqueMultiplier: 1.4999; // 1/ 0.6667
}
```
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="github" content="https://github.com/mundi4/DiffSeek">
    <title>DiffSeek</title>
<script>"use strict";
// DIFF ìƒ‰(HUE). 0(ë¹¨)ì€ DIFF ë°°ê²½ìƒ‰ìœ¼ë¡œ ì“°ì´ë‹ˆ íŒ¨ìŠ¤
// ì™„ì „í•œ ìƒ‰ìƒ ì½”ë“œë³´ë‹¤ HUEë§Œ ì‚¬ìš©í•˜ë©´ ìš©ë„ì— ë”°ë¼ ìƒ‰ì„ ì¡°ì ˆí•˜ê¸° ì‰¬ì›€.
// ì¸ì ‘í•œ ìƒ‰ìƒê³¼ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šë„ë¡ ì•„ì£¼ CAREFULí•˜ê²Œ ê³ ë¥¸ ìˆœì„œ. ê³¼í•™ì´ë‹¤.
const DIFF_COLOR_HUES = [
    30, // ì£¼í™©?
    180, // cyan
    300, // í•‘í¬?
    120, // ì´ˆë¡
    240, // íŒŒë‘
    60, // ë…¸ë‘
    270, // ë³´ë¼?
];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;
const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const EDITOR_PADDING = 8;
const LINE_HEIGHT = 1.5;
const TOPBAR_HEIGHT = 0;
const SCROLL_MARGIN = LINE_HEIGHT * 4;
const COMPUTE_DEBOUNCE_TIME = 200; // ms
const FORCE_RENDER_TIMEOUT = 100; // ms
const PROCESSING_MESSAGES = [
    "í•œë•€í•œë•€ ë¹„êµ ì¤‘...",
    "ì¸ë‚´ì‹¬ í…ŒìŠ¤íŠ¸ ì¤‘...",
    "ìƒê° ì¤‘...",
    "ì¬ë¶€íŒ… ì¤€ë¹„ ì¤‘...",
    "ë¬´í•œ ë£¨í”„ ì¤‘...",
    "ë¨¸ë¦¬ ê¸ëŠ” ì¤‘...",
    "DIFFSEEKING...",
    "COME ON, TARS!",
    "3... 2... 1...",
    "99... 98... 97...",
    "í‡´ê·¼ ì¤€ë¹„ ì¤‘...",
];
const HANGUL_ORDER = "ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ì•„ìì°¨ì¹´íƒ€íŒŒí•˜ê±°ë„ˆë”ëŸ¬ë¨¸ë²„ì„œì–´ì €ì²˜ì»¤í„°í¼í—ˆ";
const VOID_ELEMENTS = {
    AREA: true,
    BASE: true,
    BR: true,
    COL: true,
    COMMAND: true,
    EMBED: true,
    HR: true,
    IMG: true,
    INPUT: true,
    LINK: true,
    META: true,
    PARAM: true,
    SOURCE: true,
    TRACK: true,
    WBR: true,
};
const TEXTLESS_ELEMENTS = {
    ...VOID_ELEMENTS,
    VIDEO: true,
    AUDIO: true,
    OBJECT: true,
    CANVAS: true,
    SVG: true,
    TABLE: true,
    THEAD: true,
    TBODY: true,
    TFOOT: true,
    TR: true,
    OL: true,
    UL: true,
    DL: true,
    STYLE: true,
    HEAD: true,
    TITLE: true,
    SCRIPT: true,
    "#document-fragment": true,
};
const LINE_ELEMENTS = {
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
};
// ë§ì€ ìš”ì†Œë“¤ì´ ìˆì§€ë§Œ ë‹¤ ë¬´ì‹œí•˜ê³  rootì™€ td/thë§Œ ìƒê°í•¨.
// ë‹¤ë¥¸ ìš”ì†Œë“¤ì€ ì–´ì°¨í”¼ ë ˆì´ì•„ì›ƒê³¼ ë¬´ê´€
const TEXT_FLOW_CONTAINERS = {
    TD: true,
    TH: true,
    // DIV: true,
    // PRE: true,
    // BLOCKQUOTE: true,
    // LI: true,
    // SECTION: true,
    // ARTICLE: true,
    // HEADER: true,
    // FOOTER: true,
    // ASIDE: true,
    // MAIN: true,
    // CAPTION: true,
    // FIGURE: true,
    // FIGCAPTION: true,
};
const BLOCK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
    //TD: true,
    "#document-fragment": true,
};
//# sourceMappingURL=constants.js.map
</script>
<script>"use strict";
function isRectVisible(top, bottom, left, right, viewportTop, viewportLeft, viewportWidth, viewportHeight) {
    return bottom >= viewportTop && top <= viewportTop + viewportHeight && right >= viewportLeft && left <= viewportLeft + viewportWidth;
}
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function () {
            func.apply(context, args);
        }, delay);
    };
}
function findIndexByPos(arr, pos) {
    // binary search
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
        const mid = (low + high) >>> 1;
        const item = arr[mid];
        const start = item.pos, end = item.pos + item.len;
        if (start <= pos && pos < end) {
            return mid;
        }
        else if (start > pos) {
            high = mid - 1;
        }
        else if (end <= pos) {
            low = mid + 1;
        }
    }
    return ~low;
}
function findDiffEntryRangeByPos(entries, side, pos, endPos) {
    console.log("findDiffEntryRangeByPos", { entries, side, pos, endPos });
    let low = 0;
    let high = entries.length - 1;
    let mappedStart = 0;
    let mappedEnd = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (pos < s.pos) {
            high = mid - 1;
        }
        else if (pos >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = mid;
            break;
        }
    }
    low = mappedStart;
    high = entries.length - 1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = entries[mid][side];
        if (endPos - 1 < s.pos) {
            high = mid - 1;
        }
        else if (endPos - 1 >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedEnd = mid + 1;
            break;
        }
    }
    return [mappedStart, mappedEnd];
}
function mapTokenRangeToOtherSide(rawEntries, side, startIndex, endIndex) {
    console.log("mapTokenRangeToOtherSide", { rawEntries, side, startIndex, endIndex });
    const otherSide = side === "left" ? "right" : "left";
    let low = 0;
    let high = rawEntries.length - 1;
    let mappedStart = -1;
    let mappedEnd = -1;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const s = rawEntries[mid][side];
        if (startIndex < s.pos) {
            high = mid - 1;
        }
        else if (startIndex >= s.pos + s.len) {
            low = mid + 1;
        }
        else {
            mappedStart = rawEntries[mid][otherSide].pos;
            if (endIndex <= s.pos + s.len) {
                mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            }
            // if (rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len < endIndex) {
            // 	mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
            // }
            low = mid; // reuse for mappedEnd search
            break;
        }
    }
    if (mappedStart >= 0 && mappedEnd === -1) {
        mappedEnd = mappedStart;
        high = rawEntries.length - 1;
        while (low <= high) {
            const mid = (low + high) >> 1;
            const s = rawEntries[mid][side];
            if (endIndex - 1 < s.pos) {
                high = mid - 1;
            }
            else if (endIndex - 1 >= s.pos + s.len) {
                low = mid + 1;
            }
            else {
                mappedEnd = rawEntries[mid][otherSide].pos + rawEntries[mid][otherSide].len;
                break;
            }
        }
    }
    return [mappedStart, mappedEnd];
}
function buildOutputHTMLFromRuns(text, textRuns, options) {
    let inDiff = false;
    let result = options.htmlPre ? "<pre>" : "";
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            const diffIndex = run.dataIndex;
            // result += "<mark>";
            const color = DIFF_COLOR_HUES[diffIndex % DIFF_COLOR_HUES.length];
            result += `<mark style="background-color: hsl(${color}, 100%, 80%);">`;
            inDiff = true;
        }
        else if (run.type === "DIFF_END") {
            if (inDiff) {
                // result += "</mark>";
                result += "</mark>";
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += escapeHTML(text.slice(run.pos, run.pos + run.len));
        }
        else if (run.type === "LINEBREAK") {
            result += "<br/>";
        }
    }
    if (inDiff)
        result += "</mark>";
    if (options.htmlPre)
        result += "</pre>";
    // result += "<br/>";
    return result;
}
function buildOutputPlainText(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const leftBody = buildOutputPlainTextFromRuns(leftText, leftRuns, options);
    const rightBody = buildOutputPlainTextFromRuns(rightText, rightRuns, options);
    return `${leftLabel}: ${leftBody}\n${rightLabel}: ${rightBody}\n`;
}
function buildOutputPlainTextFromRuns(text, textRuns, options) {
    const format = options.textFormat ?? 0;
    let result = "";
    let inDiff = false;
    let markStart;
    let markEnd;
    if (format === 1) {
        markStart = "**";
        markEnd = "**";
    }
    else if (format === 2) {
        markStart = "[[ ";
        markEnd = " ]]";
    }
    else {
        markStart = "";
        markEnd = "";
    }
    for (const run of textRuns) {
        if (run.type === "DIFF") {
            if (format !== 0 && !inDiff) {
                result += markStart;
                inDiff = true;
            }
        }
        else if (run.type === "DIFF_END") {
            if (format !== 0 && inDiff) {
                result += markEnd;
                inDiff = false;
            }
        }
        else if (run.type === "CHARS") {
            result += text.slice(run.pos, run.pos + run.len);
        }
        else if (run.type === "LINEBREAK") {
            result += "\n";
        }
    }
    if (inDiff && format !== 0)
        result += markEnd;
    return result;
}
function buildOutputHTML(leftText, leftRuns, rightText, rightRuns, options = {}) {
    const leftLabel = options.leftLabel ?? "Left";
    const rightLabel = options.rightLabel ?? "Right";
    const htmlFormat = options.htmlFormat ?? "div";
    if (htmlFormat === "table") {
        // Default: table format
        return `<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr><th>${escapeHTML(leftLabel)}</th><th>${escapeHTML(rightLabel)}</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></td>
      <td><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></td>
    </tr>
  </tbody>
</table>`.trim();
    }
    if (htmlFormat === "dl") {
        return `<dl>
  <dt>${escapeHTML(leftLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</pre></dd>
  <dt>${escapeHTML(rightLabel)}</dt>
  <dd><pre>${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</pre></dd>
</dl>`.trim();
    }
    return `<div>
<div><strong>${escapeHTML(leftLabel)}:</strong> ${buildOutputHTMLFromRuns(leftText, leftRuns, options)}</div>
<div><strong>${escapeHTML(rightLabel)}:</strong> ${buildOutputHTMLFromRuns(rightText, rightRuns, options)}</div>
</div>`.trim();
}
function escapeHTML(str) {
    return str.replace(/[&<>"]|'/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#039;";
            default:
                return char;
        }
    });
}
function parseOrdinalNumber(ordinalText) {
    const norm = ordinalText.replace(/[\(\)\.]/g, "");
    if (/^\d+$/.test(norm)) {
        return Number(norm);
    }
    const idx = HANGUL_ORDER.indexOf(norm);
    if (idx !== -1) {
        return idx + 1;
    }
    return NaN;
}
function findFirstNodeAfter(root, after) {
    let current = after;
    while (current && current !== root) {
        if (current.nextSibling) {
            return current.nextSibling;
        }
        else {
            current = current.parentNode;
        }
    }
    return null;
}
function getTextOffsetOfNode(root, node, end = false) {
    const filter = node.nodeType === 3 ? NodeFilter.SHOW_TEXT : NodeFilter.SHOW_ALL;
    let walker = document.createTreeWalker(root, filter, null);
    let pos = 0;
    let currentNode;
    while ((currentNode = walker.nextNode())) {
        if (currentNode === node && !end) {
            break;
        }
        if (currentNode.nodeType === 3) {
            pos += currentNode.nodeValue.length;
        }
        if (currentNode === node && end) {
            break;
        }
    }
    return pos;
}
function dumpRange() {
    const sel = window.getSelection();
    if (sel && sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        console.log("current selection", {
            range,
            startContainer: range.startContainer,
            startOffset: range.startOffset,
            endContainer: range.endContainer,
            endOffset: range.endOffset,
        });
        return range;
    }
    else {
        console.log("no selection");
    }
}
function advanceNode(currentNode, rootNode = null, skipChildren = false) {
    if (!skipChildren && currentNode.firstChild) {
        return currentNode.firstChild;
    }
    let node = currentNode;
    while (node && node !== rootNode) {
        if (node.nextSibling) {
            return node.nextSibling;
        }
        node = node.parentNode;
    }
    return null;
}
function retreatNode(currentNode) {
    if (!currentNode)
        return null;
    const prev = currentNode.previousSibling;
    if (prev) {
        let node = prev;
        while (node.lastChild)
            node = node.lastChild;
        return node;
    }
    return currentNode.parentNode;
}
function findNextAncestorSibling(node, rootNode) {
    while (node && node !== rootNode) {
        if (node.nextSibling)
            return node.nextSibling;
        node = node.parentNode;
    }
    return null;
}
function mergeRects(rects, toleranceX = 0, toleranceY = 0) {
    rects.sort((a, b) => a.y - b.y || a.x - b.x);
    const merged = [];
    const used = new Array(rects.length).fill(false);
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = 0;
    let maxY = 0;
    for (let i = 0; i < rects.length; i++) {
        if (used[i])
            continue;
        let base = rects[i];
        for (let j = i + 1; j < rects.length; j++) {
            if (used[j])
                continue;
            const compare = rects[j];
            // ì„¸ë¡œ ìœ„ì¹˜/ë†’ì´ ê±°ì˜ ê°™ì•„ì•¼ ë³‘í•© ëŒ€ìƒì´ ë¨
            const sameY = Math.abs(base.y - compare.y) <= toleranceY && Math.abs(base.height - compare.height) <= toleranceY;
            if (!sameY)
                continue;
            // xì¶• ê²¹ì¹˜ê±°ë‚˜ toleranceX ì´ë‚´
            const baseRight = base.x + base.width;
            const compareRight = compare.x + compare.width;
            const xOverlapOrClose = baseRight >= compare.x - toleranceX && compareRight >= base.x - toleranceX;
            if (xOverlapOrClose) {
                const newX = Math.min(base.x, compare.x);
                const newRight = Math.max(baseRight, compareRight);
                base = {
                    x: newX,
                    y: Math.min(base.y, compare.y),
                    width: newRight - newX,
                    height: Math.max(base.height, compare.height),
                };
                used[j] = true;
            }
        }
        merged.push(base);
        used[i] = true;
        minX = Math.min(minX, base.x);
        minY = Math.min(minY, base.y);
        maxX = Math.max(maxX, base.x + base.width);
        maxY = Math.max(maxY, base.y + base.height);
    }
    return {
        minX,
        minY,
        maxX,
        maxY,
        rects: merged,
    };
}
function isLastChildOrFollowing(container, child) {
    // fast path. ì—¬ê¸°ì„œ ì–¼ë§ˆë‚˜ ê±¸ë¦´ ì§€ ëª¨ë¥´ê² ì§€ë§Œ...
    if (container.lastChild === child || container.nextSibling === child) {
        return true;
    }
    const range = document.createRange();
    range.selectNode(container);
    range.comparePoint;
}
function extractTextRanges(sourceRange) {
    if (sourceRange.startContainer.nodeType === 3 && sourceRange.startContainer === sourceRange.endContainer) {
        return [sourceRange];
    }
    const root = sourceRange.commonAncestorContainer;
    const result = [];
    const walker = document.createTreeWalker(sourceRange.commonAncestorContainer, NodeFilter.SHOW_ALL);
    let startNode;
    let endNode;
    let currentNode;
    if (sourceRange.startContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.startContainer, sourceRange.startOffset);
        r.setEnd(sourceRange.startContainer, sourceRange.startContainer.nodeValue.length);
        result.push(r);
        walker.currentNode = sourceRange.startContainer;
        currentNode = walker.nextNode();
    }
    else if (sourceRange.startContainer.nodeType === 1) {
        startNode = sourceRange.startContainer.childNodes[sourceRange.startOffset] || sourceRange.startContainer;
        walker.currentNode = currentNode = startNode;
    }
    else {
        throw new Error("Invalid start container");
    }
    if (sourceRange.endContainer.nodeType === 3) {
        endNode = sourceRange.endContainer;
    }
    else if (sourceRange.endContainer.nodeType === 1) {
        if (sourceRange.endOffset < sourceRange.endContainer.childNodes.length) {
            endNode = sourceRange.endContainer.childNodes[sourceRange.endOffset];
        }
        else {
            endNode = advanceNode(sourceRange.endContainer, root, true);
        }
    }
    else {
        throw new Error("Invalid end container");
    }
    while (currentNode && currentNode !== endNode) {
        if (currentNode.nodeType === 3) {
            const r = document.createRange();
            r.selectNodeContents(currentNode);
            result.push(r);
        }
        else {
            if (currentNode.nodeName === "BR") {
                const r = document.createRange();
                r.selectNode(currentNode);
                result.push(r);
            }
            // do nothing for now
        }
        currentNode = walker.nextNode();
    }
    if (sourceRange.endContainer.nodeType === 3) {
        const r = document.createRange();
        r.setStart(sourceRange.endContainer, 0);
        r.setEnd(sourceRange.endContainer, sourceRange.endOffset);
        result.push(r);
    }
    return result;
}
function findFirstTextNode(root) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (text.nodeValue && text.nodeValue.trim() !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        // ì•ì—ì„œë¶€í„° ìˆœíšŒ (0 â†’ N)
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function findLastTextNode(root, skipEmpty = false) {
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node;
            if (!skipEmpty || text.nodeValue !== "") {
                return text;
            }
        }
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
    return null;
}
function getNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const commonAncestor = range.commonAncestorContainer;
    const walker = document.createTreeWalker(commonAncestor, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        nodeRange.selectNodeContents(node);
        const startsBeforeEnd = nodeRange.compareBoundaryPoints(Range.END_TO_START, range) < 0;
        const endsAfterStart = nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0;
        if (startsBeforeEnd && endsAfterStart) {
            nodes.push(node);
        }
        else if (!startsBeforeEnd) {
            // ì´ë¯¸ ë²”ìœ„ë¥¼ ì§€ë‚œ ê²½ìš° break
            break;
        }
        node = walker.nextNode();
    }
    return nodes;
}
function getFullyContainedNodesInRange(range, whatToShow = NodeFilter.SHOW_ALL, filter = null) {
    const walker = document.createTreeWalker(range.commonAncestorContainer, whatToShow, filter);
    walker.currentNode = range.startContainer;
    const nodes = [];
    let node = walker.currentNode;
    while (node) {
        const nodeRange = document.createRange();
        try {
            nodeRange.selectNode(node);
        }
        catch {
            // í…ìŠ¤íŠ¸ ë…¸ë“œ ë“± selectNode ì‹¤íŒ¨ ì‹œì—ëŠ” selectNodeContents
            nodeRange.selectNodeContents(node);
        }
        const startsAfterOrAt = nodeRange.compareBoundaryPoints(Range.START_TO_START, range) >= 0;
        const endsBeforeOrAt = nodeRange.compareBoundaryPoints(Range.END_TO_END, range) <= 0;
        if (startsAfterOrAt && endsBeforeOrAt) {
            nodes.push(node);
        }
        else if (!startsAfterOrAt && nodeRange.compareBoundaryPoints(Range.START_TO_END, range) > 0) {
            break; // ì•ìœ¼ë¡œëŠ” í¬í•¨ë  ê°€ëŠ¥ì„± ì—†ìŒ
        }
        node = walker.nextNode();
    }
    return nodes;
}
function isEmptyElement(el) {
    for (const node of Array.from(el.childNodes)) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent?.trim()) {
                return false; // ë‚´ìš©ì´ ìˆëŠ” í…ìŠ¤íŠ¸
            }
        }
        else if (node.nodeType === Node.ELEMENT_NODE) {
            const elem = node;
            if (elem.tagName !== "BR") {
                return false; // <br> ì™¸ì˜ ìš”ì†Œê°€ ìˆìŒ
            }
        }
        else {
            return false; // ì•Œ ìˆ˜ ì—†ëŠ” ë…¸ë“œ (ì˜ˆ: ì£¼ì„ ë“±)
        }
    }
    return true;
}
function isNodeStartInsideRange(element, range) {
    const elementStart = document.createRange();
    elementStart.setStartBefore(element);
    elementStart.setEndBefore(element);
    return range.compareBoundaryPoints(Range.START_TO_START, elementStart) <= 0 && range.compareBoundaryPoints(Range.END_TO_START, elementStart) > 0;
}
function extractRects(sourceRange) {
    // console.debug("extractRects", sourceRange);
    const result = [];
    const tempRange = document.createRange();
    let startNode;
    if (sourceRange.startContainer.nodeType === 3) {
        tempRange.setStart(sourceRange.startContainer, sourceRange.startOffset);
        if (sourceRange.startContainer === sourceRange.endContainer) {
            tempRange.setEnd(sourceRange.startContainer, sourceRange.endOffset);
        }
        else {
            tempRange.setEnd(sourceRange.startContainer, sourceRange.startContainer.nodeValue.length);
        }
        for (const rect of tempRange.getClientRects()) {
            result.push({
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
            });
        }
        startNode = advanceNode(sourceRange.startContainer);
    }
    else {
        startNode = sourceRange.startContainer.childNodes[sourceRange.startOffset];
        if (!startNode) {
            startNode = advanceNode(sourceRange.startContainer, null, true);
            if (!startNode) {
                console.warn("extractRects: No startNode found", sourceRange);
                return result;
            }
        }
    }
    const endContainer = sourceRange.endContainer;
    let endOffset;
    let endNode;
    if (endContainer.nodeType === 3) {
        endNode = endContainer;
        endOffset = sourceRange.endOffset;
    }
    else {
        endNode = endContainer.childNodes[sourceRange.endOffset];
        if (!endNode) {
            endNode = advanceNode(endContainer, null, true);
        }
        endOffset = -1;
    }
    console.debug("extractRects", { sourceRange, startNode, endNode, endOffset });
    const walker = document.createTreeWalker(sourceRange.commonAncestorContainer, NodeFilter.SHOW_ALL);
    if (!startNode || !endNode) {
        console.warn("extractRects: No startNode or endNode", sourceRange);
        return result;
    }
    if (endNode.compareDocumentPosition(startNode) & Node.DOCUMENT_POSITION_FOLLOWING) {
        // startNodeê°€ endNodeë³´ë‹¤ ë’¤ì— ìˆëŠ” ê²½ìš°
        console.warn("extractRects: startNode is after endNode", startNode, endNode);
        return result;
    }
    walker.currentNode = startNode;
    // const hardEnd = advanceNode(editor);
    do {
        const currentNode = walker.currentNode;
        if (!currentNode) {
            console.error("extractRects: currentNode is null", sourceRange);
        }
        if (currentNode === endNode) {
            if (currentNode.nodeType === 3 && endOffset >= 0) {
                tempRange.setStart(endNode, 0);
                tempRange.setEnd(endNode, endOffset);
                for (const rect of tempRange.getClientRects()) {
                    result.push({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height,
                    });
                }
            }
            break;
        }
        // if (currentNode === hardEnd) {
        // 	console.warn("extractRects: reached hard end", currentNode, endOffset);
        // 	break;
        // }
        if (currentNode.nodeType === 3) {
            tempRange.selectNodeContents(currentNode);
            for (const rect of tempRange.getClientRects()) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
        }
        else if (currentNode.nodeName === "BR") {
            //
        }
        else if (currentNode.nodeName === "A") {
            const tempText = document.createTextNode("\u200B"); // zero-width space
            currentNode.appendChild(tempText);
            tempRange.selectNodeContents(tempText);
            for (const rect of tempRange.getClientRects()) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
            tempText.remove();
        }
        else if (currentNode.nodeName === "IMG") {
            tempRange.selectNode(currentNode);
            for (const rect of tempRange.getClientRects()) {
                result.push({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                });
            }
        }
    } while (walker.nextNode());
    return result;
}
//# sourceMappingURL=utils.js.map
</script>
<script>"use strict";
const STYLE_NONE = 0;
const STYLE_COLOR_RED = 1;
const STYLE_MASK_COLOR = STYLE_COLOR_RED;
const reddishCache = new Map([
    ["red", true],
    ["#ff0000", true],
    ["#e60000", true],
    ["#c00000", true],
    ["rgb(255,0,0)", true],
    ["rgb(230,0,0)", true],
    ["#000000", false],
    ["#333333", false],
    ["#ffffff", false],
    ["black", false],
    ["blue", false],
    ["white", false],
    ["window", false],
    ["windowtext", false],
]);
let _ctx = null;
// ìº”ë²„ìŠ¤ëŠ” ë§ì´ ëŠë¦´í…Œë‹ˆê¹Œ ìµœëŒ€í•œ ì •ê·œì‹ì„ ìš°ì„  ì”€!
// ì •ê·œì‹ì€ ìˆ˜ëª…ë‹¨ì¶•ì˜ ì§€ë¦„ê¸¸ì´ë¯€ë¡œ ì ˆëŒ€ì ìœ¼ë¡œ chatgtpí•œí…Œ ë§¡ê¸°ê³  ëˆˆê¸¸ ì¡°ì°¨ ì£¼ì§€ ë§ ê²ƒ.
function getRGB(color) {
    // #rrggbb
    const hex6 = /^#([0-9a-f]{6})$/i.exec(color);
    if (hex6) {
        const n = parseInt(hex6[1], 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    // #rgb
    const hex3 = /^#([0-9a-f]{3})$/i.exec(color);
    if (hex3) {
        const [r, g, b] = hex3[1].split("").map((c) => parseInt(c + c, 16));
        return [r, g, b];
    }
    // rgb(...) / rgba(...)
    const rgb = /^rgba?\(([^)]+)\)$/i.exec(color);
    if (rgb) {
        const parts = rgb[1].split(",").map((s) => parseInt(s.trim(), 10));
        if (parts.length >= 3)
            return [parts[0], parts[1], parts[2]];
    }
    // fallback: canvas. ì•„ë§ˆë„ ë§ì´ ëŠë¦´ ê²ƒ...
    if (!_ctx) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        _ctx = canvas.getContext("2d");
    }
    try {
        _ctx.clearRect(0, 0, 1, 1);
        _ctx.fillStyle = color;
        _ctx.fillRect(0, 0, 1, 1);
        const [r, g, b] = _ctx.getImageData(0, 0, 1, 1).data;
        return [r, g, b];
    }
    catch {
        return null;
    }
}
function isReddish(color) {
    let isRed = reddishCache.get(color);
    if (isRed !== undefined)
        return isRed;
    console.log("no cache hit", color);
    const rgb = getRGB(color);
    isRed = rgb ? rgb[0] >= 139 && rgb[0] - Math.max(rgb[1], rgb[2]) >= 65 : false;
    reddishCache.set(color, isRed);
    return isRed;
}
const INLINE_ELEMENTS = {
    SPAN: true,
    A: true,
    B: true,
    I: true,
    U: true,
    EM: true,
    STRONG: true,
    S: true,
    STRIKE: true,
    SUB: true,
    SUP: true,
    SMALL: true,
    BIG: true,
    MARK: true,
    INS: true,
    DEL: true,
    CODE: true,
    KBD: true,
    SAMP: true,
    VAR: true,
    DFN: true,
    ABBR: true,
    TIME: true,
    CITE: true,
    Q: true,
    LABEL: true,
};
const LINEBREAK_ELEMENTS = {
    DD: true,
    DT: true,
    DIV: true,
    P: true,
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true,
    UL: true,
    OL: true,
    LI: true,
    BLOCKQUOTE: true,
    FORM: true,
    HEADER: true,
    FOOTER: true,
    ARTICLE: true,
    SECTION: true,
    ASIDE: true,
    NAV: true,
    ADDRESS: true,
    FIGURE: true,
    FIGCAPTION: true,
    TABLE: true,
    CAPTION: true,
    TR: true,
};
const EXCLUDED_HTML_TAGS = {
    SCRIPT: 1,
    STYLE: 1,
    IFRAME: 1,
    OBJECT: 1,
    EMBED: 1,
    LINK: 1,
    META: 1,
    BASE: 1,
    APPLET: 1,
    FRAME: 1,
    FRAMESET: 1,
    NOSCRIPT: 1,
    SVG: 1,
    MATH: 1,
    TEMPLATE: 1,
    HEAD: 1,
};
const EMPTY_ATTRS = {};
const ALLOWED_CONTAINER_TAGS = {
    TABLE: EMPTY_ATTRS,
    TBODY: EMPTY_ATTRS,
    THEAD: EMPTY_ATTRS,
    TFOOT: EMPTY_ATTRS,
    CAPTION: EMPTY_ATTRS,
    TR: EMPTY_ATTRS,
    TH: { colspan: true, rowspan: true },
    TD: { colspan: true, rowspan: true },
    H1: EMPTY_ATTRS,
    H2: EMPTY_ATTRS,
    H3: EMPTY_ATTRS,
    H4: EMPTY_ATTRS,
    H5: EMPTY_ATTRS,
    H6: EMPTY_ATTRS,
    SUP: EMPTY_ATTRS,
    SUB: EMPTY_ATTRS,
    EM: EMPTY_ATTRS,
    I: EMPTY_ATTRS,
    S: EMPTY_ATTRS,
    B: EMPTY_ATTRS,
    STRONG: EMPTY_ATTRS,
    U: EMPTY_ATTRS,
    STRIKE: EMPTY_ATTRS,
    P: EMPTY_ATTRS,
    UL: EMPTY_ATTRS,
    OL: EMPTY_ATTRS,
    LI: EMPTY_ATTRS,
    DL: EMPTY_ATTRS,
    DT: EMPTY_ATTRS,
    DD: EMPTY_ATTRS,
    DIV: EMPTY_ATTRS,
    HEADER: EMPTY_ATTRS,
    FOOTER: EMPTY_ATTRS,
    SECTION: EMPTY_ATTRS,
    ARTICLE: EMPTY_ATTRS,
    ASIDE: EMPTY_ATTRS,
    BLOCKQUOTE: EMPTY_ATTRS,
    ADDRESS: EMPTY_ATTRS,
    //"#document-fragment": EMPTY_ATTRS,
};
function customTrim(str) {
    return str.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
}
function coerceColor(color) {
    if (isReddish(color)) {
        return "red";
    }
    return undefined;
}
// ì¡°ê±´ ì‹œì‘ ì •ê·œì‹ (ì£¼ì„ ìœ ë¬´ ìƒê´€ì—†ì´, [if ...]> ë˜ëŠ” <![if ...]> ëª¨ë‘ í¬ê´„)
const ifRegex = /(?:<!--)?<?!?\[if\s+([^\]]+?)\]>?/gi;
// ì¡°ê±´ ì¢…ë£Œ ì •ê·œì‹
const endifRegex = /<!\[endif\](?:-->|\])?/i;
/**
 * input: íŒŒì‹±í•  ì „ì²´ ë¬¸ìì—´
 * start: íŒŒì‹± ì‹œì‘ ìœ„ì¹˜ (ë¬´ì¡°ê±´ [if ...]ê°€ ì‹œì‘í•˜ëŠ” ìœ„ì¹˜ì—¬ì•¼ í•¨)
 *
 * returns: [ì¡°ê±´ë¶€ ë¸”ë¡, ì¢…ë£Œ ìœ„ì¹˜]
 */
function parseIfBlock(input, start) {
    ifRegex.lastIndex = start;
    const ifMatch = ifRegex.exec(input);
    if (!ifMatch || ifMatch.index !== start) {
        console.error("parseIfBlock must start at an [if] condition", { ifMatch, start, input });
        throw new Error("parseIfBlock must start at an [if] condition");
    }
    const condition = ifMatch[1].trim();
    let cursor = ifRegex.lastIndex;
    const children = [];
    while (cursor < input.length) {
        ifRegex.lastIndex = cursor;
        endifRegex.lastIndex = cursor;
        const nextIf = ifRegex.exec(input);
        const nextEndIf = endifRegex.exec(input);
        if (nextEndIf && (!nextIf || nextEndIf.index < nextIf.index)) {
            // endifê°€ ë¨¼ì € ë‚˜ì˜¤ë©´ í˜„ì¬ ì¡°ê±´ ì¢…ë£Œ
            if (nextEndIf.index > cursor) {
                const text = input.slice(cursor, nextEndIf.index);
                if (text.trim())
                    children.push(text);
            }
            cursor = nextEndIf.index + nextEndIf[0].length;
            return [{ condition, children }, cursor];
        }
        if (nextIf && nextIf.index === cursor) {
            // ì¤‘ì²©ëœ if ì¡°ê±´ íŒŒì‹± ì¬ê·€ í˜¸ì¶œ
            console.log("parseIfBlock called at pos:", start);
            console.log("String at start:", input.slice(start, start + 20));
            const [childBlock, newPos] = parseIfBlock(input, cursor);
            children.push(childBlock);
            cursor = newPos;
            continue;
        }
        // ì¼ë°˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ (ë‹¤ìŒ ì¡°ê±´ë¬¸ í˜¹ì€ endifê¹Œì§€)
        let nextPos = input.length;
        if (nextIf)
            nextPos = Math.min(nextPos, nextIf.index);
        if (nextEndIf)
            nextPos = Math.min(nextPos, nextEndIf.index);
        const text = input.slice(cursor, nextPos);
        if (text.trim())
            children.push(text);
        cursor = nextPos;
    }
    throw new Error("Missing matching [endif]");
}
function sanitizeHTML(rawHTML) {
    const START_TAG = "<!--StartFragment-->";
    const END_TAG = "<!--EndFragment-->";
    const startIndex = rawHTML.indexOf(START_TAG);
    if (startIndex >= 0) {
        const endIndex = rawHTML.lastIndexOf(END_TAG);
        if (endIndex >= 0) {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
        }
        else {
            rawHTML = rawHTML.slice(startIndex + START_TAG.length);
        }
    }
    const tmpl = document.createElement("template");
    tmpl.innerHTML = rawHTML;
    let flags = 0;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "ğŸ–¼ï¸";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName === "P" ? "DIV" : node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(tmpl.content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return result;
}
function sanitizeNode(content) {
    let hasBlockElements = false;
    const containerStack = [];
    function traverse(node) {
        if (node.nodeType === 3) {
            if (TEXTLESS_ELEMENTS[node.parentNode.nodeName]) {
                return null;
            }
            let text = node.nodeValue;
            if (TEXT_FLOW_CONTAINERS[node.parentNode.nodeName]) {
                text = customTrim(text);
            }
            if (text.length === 0) {
                return null;
            }
            text = text.replace(/\n+/g, " ");
            return document.createTextNode(text);
        }
        // if (node.nodeType === 8) {
        // 	console.log("comment", node.nodeValue);
        // 	const parseResult = parseIfBlock(node.nodeValue!, 0);
        // 	console.log("parseResult", parseResult);
        // 	return null;
        // }
        if (node.nodeType !== 1 && node.nodeType !== 11) {
            return null;
        }
        if (EXCLUDED_HTML_TAGS[node.nodeName]) {
            return null;
        }
        if (node.nodeName === "O:P") {
            // if (node.childNodes.length === 1) {
            // 	const onlyChild = node.childNodes[0];
            // 	if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "\u00A0") {
            // 		return document.createTextNode("");
            // 	}
            // }
            return null;
        }
        if (node.nodeName === "BR") {
            return document.createElement("BR");
        }
        if (node.nodeName === "IMG") {
            const span = document.createElement("SPAN");
            span.textContent = "ğŸ–¼ï¸";
            span.className = "dsimg";
            span.contentEditable = "false";
            span.dataset.src = node.src;
            return span;
        }
        let color = containerStack[containerStack.length - 1].color;
        if (node.nodeType === 1) {
            let colorValue = node.style?.color;
            if (colorValue) {
                if (colorValue === "inherit") {
                    // use parent color
                }
                else {
                    if (isReddish(colorValue)) {
                        color = "red";
                    }
                    else {
                        color = undefined;
                    }
                }
            }
        }
        let containerNode = null;
        const allowedAttrs = ALLOWED_CONTAINER_TAGS[node.nodeName];
        if (allowedAttrs) {
            containerNode = document.createElement(node.nodeName);
            for (const attr of node.attributes) {
                if (allowedAttrs[attr.name]) {
                    containerNode.setAttribute(attr.name, attr.value);
                }
            }
        }
        else {
            containerNode = document.createDocumentFragment();
        }
        //containerStack[containerStack.length - 1].node.appendChild(containerNode);
        containerStack.push({ node: containerNode, color: color });
        let hasChildren = false;
        //node.normalize();
        for (const child of node.childNodes) {
            let childResult = traverse(child);
            if (!childResult) {
                continue;
            }
            if (childResult.nodeType === 3) {
                if (color) {
                    const span = document.createElement("span");
                    span.className = "color-" + color;
                    span.appendChild(childResult);
                    childResult = span;
                }
                // console.log("childresult:", {
                // 	child:child,
                // 	childResult: childResult,
                // 	nodeName: childResult.nodeName,
                // 	nodeType: childResult.nodeType,
                // 	textContent: (childResult as Text).textContent,
                // });
            }
            containerNode.appendChild(childResult);
            if (!TEXTLESS_ELEMENTS[node.nodeName]) {
                if (BLOCK_ELEMENTS[child.nodeName] && !BLOCK_ELEMENTS[childResult.nodeName]) {
                    // containerNode.appendChild(document.createElement("BR"));
                }
            }
        }
        containerNode.normalize();
        if (containerNode.nodeName === "P") {
            if (containerNode.childNodes.length === 0) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        else {
            if (BLOCK_ELEMENTS[node.nodeName] && !BLOCK_ELEMENTS[containerNode.nodeName]) {
                containerNode.appendChild(document.createElement("BR"));
            }
        }
        // if (containerNode.nodeType !== 11) {
        // }
        containerStack.pop();
        if (containerNode.nodeType === 1 && !TEXTLESS_ELEMENTS[containerNode.nodeName] && containerNode.childNodes.length === 0) {
            containerNode.appendChild(document.createTextNode(""));
        }
        if (INLINE_ELEMENTS[containerNode.nodeName]) {
            if (containerNode.childNodes.length === 0) {
                containerNode = null;
            }
            else if (containerNode.childNodes.length === 1) {
                const onlyChild = containerNode.childNodes[0];
                if (onlyChild.nodeType === 3 && onlyChild.nodeValue === "") {
                    containerNode = null;
                }
            }
        }
        else if (!hasBlockElements && BLOCK_ELEMENTS[containerNode.nodeName]) {
            hasBlockElements = true;
        }
        return containerNode;
    }
    const root = document.createDocumentFragment();
    containerStack.push({ node: root, color: undefined });
    const result = traverse(content);
    result.normalize();
    if (result.childNodes.length === 0) {
        result.appendChild(document.createTextNode(""));
    }
    return [result, hasBlockElements];
}
function formatPlaintext(plaintext) {
    const lines = plaintext.split("\n");
    const fragment = document.createDocumentFragment();
    for (const line of lines) {
        const p = document.createElement("p");
        p.textContent = line;
        fragment.appendChild(p);
    }
    return fragment;
}
//# sourceMappingURL=sanitize.js.map
</script>
<script>"use strict";
const MANUAL_ANCHOR1 = "@@@";
const MANUAL_ANCHOR2 = "###";
const SECTION_HEADING_MASK = 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */ |
    1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */ |
    2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */ |
    4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */;
// const normalizeChars: { [ch: string]: string } = {};
// text flow containers?
const containerElements = {
    DIV: true,
    PRE: true,
    BLOCKQUOTE: true,
    LI: true,
    TD: true,
    TH: true,
    SECTION: true,
    ARTICLE: true,
    HEADER: true,
    FOOTER: true,
    ASIDE: true,
    MAIN: true,
    CAPTION: true,
    FIGURE: true,
    FIGCAPTION: true,
};
const spaceChars = {
    " ": true,
    "\t": true,
    "\n": true,
    "\r": true, // ê¸€ì„...
    "\f": true, // ì´ê²ƒë“¤ì€...
    "\v": true, // ë³¼ì¼ì´ ì—†ì„ê²ƒ...
    "\u00A0": true, // &nbsp; ??
};
const splitChars = {
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
};
const normalizedCharMap = ((normChars) => {
    const result = {};
    let parser;
    function htmlEntityToChar(entity) {
        const doc = (parser = parser || new DOMParser()).parseFromString(entity, "text/html");
        const char = doc.body.textContent;
        if (char.length !== 1) {
            throw new Error("htmlEntityToChar: not a single character entity: " + entity);
        }
        return char;
    }
    for (const entry of normChars) {
        const [norm, ...variants] = entry;
        for (const variant of variants) {
            if (typeof variant === "number") {
                result[String.fromCharCode(variant)] = norm;
            }
            else if (typeof variant === "string") {
                if (variant.length === 1 || (variant.length === 2 && variant.charCodeAt(0) >= 0xd800)) {
                    result[variant] = norm;
                }
                else if (variant[0] === "&") {
                    result[htmlEntityToChar(variant)] = norm;
                }
            }
        }
    }
    return result;
})([
    ['"', "â€œ", "â€", "'", "â€˜", "â€™"], // ë¹„ì¦ˆí”Œë«í¼ í¸ì§‘ê¸°ì—ì„œ ì‘ì€ë”°ì˜´í‘œë¥¼ í°ë”°ì˜´í‘œë¡œ ë°”ê¾¸ì–´ë²„ë¦¼. WHY?
    ["-", "â€", "â€‘", "â€’", "â€“", "ï¹˜", "â€”", "ï¼"],
    [".", "â€¤", "ï¼"],
    [",", "ï¼Œ"],
    ["â€¢", "â—"], // ì´ê±¸ ì¤‘ê°„ì  ìš©ë„ë¡œ ì“°ëŠ” ì‚¬ëŒë“¤ì€ ì •ë§ ê°ˆì•„ë§ˆì…”ì•¼ëœë‹¤. ë„ì €íˆ ìš©ë‚©í•´ì¤„ ìˆ˜ ì—†ê³  ê°™ì€ ë¬¸ìë¡œ ì¸ì‹í•˜ê²Œ ë§Œë“¤ê³  ì‹¶ì§€ ì•Šë‹¤.
    ["â—¦", "â—‹", "ã…‡"], // ììŒ "ì´ì‘"ì„ ì“°ëŠ” ì‚¬ëŒë“¤ë„ ê°œì¸ì ìœ¼ë¡œ ì´í•´ê°€ ì•ˆë˜ì§€ë§Œ ë§ë”ë¼.
    ["â– ", "â–ª", "â—¼"],
    ["â–¡", "â–«", "â—»", "ã…"],
    ["Â·", "â‹…", "âˆ™", "ã†", "â€§"], // ìœ ë‹ˆì½”ë“œë¥¼ ë§Œë“  ì§‘ë‹¨ì€ ë„ëŒ€ì²´ ë¬´ìŠ¨ ìƒê°ì´ì—ˆë˜ê±¸ê¹Œ?...
    ["â€¦", "â‹¯"],
    ["(", "ï¼ˆ"],
    [")", "ï¼‰"],
    ["[", "ï¼»"],
    ["]", "ï¼½"],
    ["{", "ï½›"],
    ["}", "ï½"],
    ["<", "ï¼œ"],
    [">", "ï¼"],
    ["=", "ï¼"],
    ["+", "ï¼‹"],
    ["*", "ï¼Š", "âœ±", "Ã—", "âˆ—"],
    ["/", "ï¼", "Ã·"],
    ["\\", "â‚©"], // ì•„ë§ˆë„ ì›í™” ê¸°í˜¸ë¡œ ì‚¬ìš©í–ˆê² ì§€
    ["&", "ï¼†"],
    ["#", "ï¼ƒ"],
    ["@", "ï¼ "],
    ["$", "ï¼„"],
    ["%", "ï¼…"],
    ["^", "ï¼¾"],
    ["~", "ï½"],
    ["`", "ï½€"],
    ["|", "ï½œ"],
    [":", "ï¼š"],
    [";", "ï¼›"],
    ["?", "ï¼Ÿ"],
    ["!", "ï¼"],
    ["_", "ï¼¿"],
    ["â†’", "â‡’", "â¡", "â”", "â", "âŸ"],
    ["â†", "â‡", "â¬…", "âŸµ", "âŸ¸"],
    ["â†‘", "â‡‘", "â¬†"],
    ["â†“", "â‡“", "â¬‡"],
    ["â†”", "â‡”"],
    ["â†•", "â‡•"],
    [" ", "\u00A0"],
]);
// wildcards.
// ì´ê±¸ ì–´ë–»ê²Œ êµ¬í˜„í•´ì•¼í• ì§€ ê°ì´ ì•ˆì˜¤ì§€ë§Œ ì§€ê¸ˆìœ¼ë¡œì¨ëŠ” ì–˜ë„¤ë“¤ì„ atomicí•˜ê²Œ ì·¨ê¸‰(ì‚¬ì´ì— ê³µë°±ì´ ìˆì–´ë„ í•˜ë‚˜ì˜ í† í°ìœ¼ë¡œ ë§Œë“¬. '(í˜„í–‰ê³¼ ê°™ìŒ)'ì—ì„œ ì¼ë¶€ë¶„ë§Œ ë§¤ì¹˜ë˜ëŠ” ê²ƒì„ ë°©ì§€)
// ê¸€ìë‹¨ìœ„ë¡œ í† í°í™”í•˜ëŠ” ê²½ìš°ì—ë„ ì–˜ë„¤ë“¤ì€ (...) í†µì±„ë¡œ í•˜ë‚˜ì˜ í† í°ìœ¼ë¡œ ì·¨ê¸‰.
// ì™€ì¼ë“œì¹´ë“œdiffì¸ ê²½ìš° ë‹¤ë¥¸ diffì™€ ë³‘í•©ë˜ì§€ ì•Šìœ¼ë©´ ì¢‹ì§€ë§Œ ì™€ì¼ë“œì¹´ë“œê°€ ì–¼ë§ˆë‚˜ greedyí•˜ê²Œ ë°˜ëŒ€ìª½ í…ìŠ¤íŠ¸ë¥¼ ì¡ì•„ë¨¹ì–´ì•¼ í• ì§€
// ì–‘ìª½ì— wildcardê°€ ë™ì‹œì— ë‚˜ì˜¤ëŠ” ê²½ìš° ê²½ê³„ë¥¼ ì–´ë””ì„œ ì–´ë–»ê²Œ ì§¤ë¼ì•¼í• ì§€ ì‰½ì§€ ì•ŠìŒ.
// ë˜í•œ wildcardë¥¼ ê°•ì œë¡œ ë‹¤ë¥¸ diffì™€ ë¶„ë¦¬í•˜ëŠ” ê²½ìš° diffê°€ ê°™ì€ ìœ„ì¹˜ì— ë‘ ê°œ ì´ìƒ ìƒê¸°ê²Œ ë˜ëŠ” ìˆ˜ê°€ ìˆë‹¤. (wildcardì™€ wildcardê°€ ì•„ë‹Œ ê²ƒ)
// ì´ ê²½ìš° ì •í™•íˆ ê°™ì€ ìœ„ì¹˜ì— ë‘ê°œì˜ diffë¥¼ ë Œë”ë§í•´ì•¼í•˜ê³  ê²°êµ­ ë‘ê°œê°€ ê²¹ì³ë³´ì´ê²Œ ë˜ëŠ”ë° ë¶„ê°„ì´ ì˜ ì•ˆëœë‹¤.
const wildcardTrie = createTrie(true);
wildcardTrie.insert("(ì¶”ê°€)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(ì‚­ì œ)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(ì‹ ì„¤)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(ìƒëµ)", 16384 /* TokenFlags.WILD_CARD */);
wildcardTrie.insert("(í˜„í–‰ê³¼ê°™ìŒ)", 16384 /* TokenFlags.WILD_CARD */);
const wildcardTrieNode = wildcardTrie.root.next("(");
const sectionHeadingTrie = createTrie(false);
for (let i = 1; i < 40; i++) {
    sectionHeadingTrie.insert(`${i}.`, 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */);
    sectionHeadingTrie.insert(`(${i})`, 2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */);
    sectionHeadingTrie.insert(`${i})`, 8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */);
}
for (let i = 0; i < HANGUL_ORDER.length; i++) {
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]}.`, 1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */);
    sectionHeadingTrie.insert(`(${HANGUL_ORDER[i]})`, 4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */);
    sectionHeadingTrie.insert(`${HANGUL_ORDER[i]})`, 8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */);
}
const SectionHeadingTrieNode = sectionHeadingTrie.root;
const sectionHeadingStartChars = extractStartCharsFromTrie(SectionHeadingTrieNode);
const manualAnchorTrie = createTrie(false);
manualAnchorTrie.insert(MANUAL_ANCHOR1, 32768 /* TokenFlags.MANUAL_ANCHOR */);
manualAnchorTrie.insert(MANUAL_ANCHOR2, 32768 /* TokenFlags.MANUAL_ANCHOR */);
const manualAnchorTrieNode = manualAnchorTrie.root;
const manualAnchorStartChars = extractStartCharsFromTrie(manualAnchorTrieNode);
function normalize(text) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        result += normalizedCharMap[char] || char;
    }
    return result;
}
function checkIfFirstOfLine(input, pos) {
    pos--;
    while (pos >= 0) {
        if (input[pos] === "\n") {
            break;
        }
        else if (!spaceChars[input[pos]]) {
            return false;
        }
        pos--;
    }
    return true;
}
function createTrie(ignoreSpaces = false) {
    const root = createTrieNode(ignoreSpaces);
    function insert(word, flags = 0) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            node = node.addChild(word[i]);
        }
        node.word = word;
        node.flags = flags;
    }
    return { insert, root };
}
function createTrieNode(ignoreSpaces) {
    const children = {};
    const node = {
        children,
        word: null,
        flags: 0,
        next(char) {
            if (ignoreSpaces && char === " ")
                return node;
            return children[char] || null;
        },
        addChild(char) {
            return children[char] ?? (children[char] = createTrieNode(ignoreSpaces));
        },
    };
    return node;
}
function findInTrie(trie, input, start) {
    let node = trie;
    let i = start;
    while (i < input.length) {
        const ch = input[i++];
        node = node.next(ch);
        if (!node)
            break;
        if (node.word) {
            return { word: node.word, flags: node.flags, end: i };
        }
    }
    return null;
}
function extractStartCharsFromTrie(trie) {
    const table = {};
    for (const ch in trie.children) {
        table[ch] = 1;
    }
    return table;
}
// const TOKEN_BOUNDARY_ELEMENTS: Record<string, boolean> = {
// 	...BLOCK_ELEMENTS,
// 	BR: true,
// 	HR: true,
// 	IMG: true,
// };
// function* tokenizeWithContainers(root: Node): Generator<TokenizationEvent, void, unknown> {
// 	const containerStack: ContainerInfo[] = [];
// 	function* traverse(node: Node, depth: number, indexInParent: number): Generator<TokenizationEvent> {
// 		// ì»¨í…Œì´ë„ˆ ì—¬ë¶€ íŒë‹¨
// 		const nodeName = node.nodeName;
// 		const isTokenBoundary = nodeName === "BR" || BLOCK_ELEMENTS[nodeName];
// 		// ë…¼ë¦¬ì ìœ¼ë¡œ ì˜ë¯¸ê°€ ìˆëŠ”, í† í°í™”ì— ì“¸ëª¨ ìˆëŠ” ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆëŠ” container ë…¸ë“œë§Œ ì·¨ê¸‰
// 		const isContainer =
// 			BLOCK_ELEMENTS[nodeName] || // ë¸”ëŸ­ìš”ì†ŒëŠ” ë¸”ëŸ­ì˜ ì‹œì‘ê³¼ ëì„ íŒë‹¨í•˜ëŠ”ë° í•„ìš”
// 			nodeName === "TABLE" || // ë§ˆì°¬ê°€ì§€ í…Œì´ë¸” í–‰ì˜ ì‹œì‘ê³¼ ë
// 			nodeName === "TR" || // í…Œì´ë¸” í–‰ì˜ ì‹œì‘ê³¼ ë
// 			nodeName === "TD" || // í…Œì´ë¸” ì…€ì˜ ì‹œì‘ê³¼ ë
// 			nodeName === "TH" || // í…Œì´ë¸” ì…€ì˜ ì‹œì‘ê³¼ ë
// 			nodeName === "SUP" || // SUP
// 			nodeName === "SUB"; // SUB
// 		if (isContainer) {
// 			const containerInfo: ContainerInfo = {
// 				node,
// 				depth,
// 			};
// 			containerStack.push(containerInfo);
// 			yield { type: "containerStart", container: containerInfo };
// 		}
// 		if (node.nodeType === 3) {
// 			// í…ìŠ¤íŠ¸ ë…¸ë“œì¼ ë•Œ
// 			if (containerStack.length > 0) {
// 				const parentContainer = containerStack[containerStack.length - 1];
// 				yield {
// 					type: "textNode",
// 					node: node as Text,
// 					parent: parentContainer,
// 					indexInParent,
// 					text: node.nodeValue!,
// 				};
// 				if (containerStack.length > 0) {
// 					containerStack[containerStack.length - 1].tokenCount++;
// 				}
// 			}
// 		} else if (node.nodeType === 1) {
// 			if (nodeName === "IMG") {
// 				yield { type: "img", node, src: (node as HTMLImageElement).src, indexInParent };
// 			}
// 			if (nodeName === "BR") {
// 				yield { type: "break" };
// 			}
// 			if (nodeName === "A") {
// 				return;
// 			}
// 			// ì—˜ë¦¬ë¨¼íŠ¸ ë…¸ë“œ
// 			let childIndex = 0;
// 			for (const child of node.childNodes) {
// 				yield* traverse(child, depth + 1, childIndex++);
// 			}
// 		}
// 		if (isContainer) {
// 			const containerInfo = containerStack.pop()!;
// 			yield { type: "containerEnd", container: containerInfo };
// 		}
// 	}
// 	yield* traverse(root, 0, 0);
// }
// function* tokenize2(ctx: TokinizeContext) {
// 	const tokens: RichToken[] = (ctx.tokens ??= []);
// 	let tokenIndex = 0;
// 	let buffer: TextTokenizationEvent[] = [];
// 	const iterator = tokenizeWithContainers(ctx.content);
// 	let nextResult = iterator.next();
// 	let currentToken: RichToken | null = null;
// 	let currentFlags = LINE_START;
// 	let shouldNormalize = false;
// 	let containerStack: ContainerInfo[] = [];
// 	let currentContainer: ContainerInfo = {
// 		node: ctx.content,
// 		depth: 0,
// 		indexInParent: 0,
// 		tokenStartIndex: 0,
// 		tokenCount: 0,
// 		commonFlags: 0,
// 	};
// 	function processToken(textNode: Text, startOffset: number, endOffset: number, flags: number = 0) {
// 		let str = textNode.nodeValue!.slice(startOffset, endOffset);
// 		if (shouldNormalize) {
// 			str = normalize(str);
// 			shouldNormalize = false;
// 		}
// 		if (currentToken) {
// 			currentToken.text += str;
// 			currentToken.endContainer = textNode;
// 			currentToken.endOffset = endOffset;
// 		} else {
// 			currentToken = {
// 				text: str,
// 				flags: currentFlags | flags,
// 				startContainer: textNode,
// 				startOffset: startOffset,
// 				endContainer: textNode,
// 				endOffset: endOffset,
// 			};
// 		}
// 	}
// 	function finalizeToken(flags: number = 0) {
// 		if (currentToken) {
// 			currentToken.flags |= flags;
// 			tokens[tokenIndex] = currentToken;
// 			tokenIndex++;
// 			currentToken = null;
// 			currentFlags = 0;
// 		}
// 	}
// 	function findInTrie2(trie: TrieNode, buffer: TextTokenizationEvent[], bufferIndex: number, bufferCount: number, charIndex: number) {
// 		let node: TrieNode | null = trie;
// 		let i = bufferIndex;
// 		let j = charIndex;
// 		do {
// 			const text = buffer[i].text;
// 			for (; j < text.length; j++) {
// 				node = node!.next(text[j]);
// 				if (!node) {
// 					return null;
// 				}
// 				if (node.word) {
// 					return { bufferIndex: i, charIndex: j + 1, word: node.word, flags: node.flags };
// 				}
// 			}
// 			i++;
// 			j = 0;
// 		} while (i < bufferCount);
// 		return null;
// 	}
// 	while (!nextResult.done) {
// 		let event = nextResult.value;
// 		if (event.type === "textNode") {
// 			console.assert(currentToken === null, "currentToken should be null at this point");
// 			let bufferCount = 0;
// 			do {
// 				buffer[bufferCount++] = event;
// 			} while (!(nextResult = iterator.next()).done && (event = nextResult.value).type === "textNode");
// 			let i = 0;
// 			OUTER: for (let bufferIndex = 0; bufferIndex < bufferCount; bufferIndex++) {
// 				const text = buffer[bufferIndex].text;
// 				const textLen = text.length;
// 				let currentStart = -1;
// 				for (; i < textLen; i++) {
// 					let char = text[i];
// 					char = normalizedCharMap[char] || char; // normalize the character
// 					if (spaceChars[char]) {
// 						if (currentStart !== -1) {
// 							processToken(buffer[bufferIndex].node, currentStart, i);
// 							currentStart = -1;
// 						}
// 						finalizeToken();
// 					} else {
// 						// ëª¨ë“  ë¬¸ìì— ëŒ€í•´ì„œ trieë¥¼ íƒìƒ‰í•˜ëŠ”ê±´ ë„ˆë¬´ ë¹„íš¨ìœ¨ì ì´ë¼ì„œ...
// 						if (char === "(") {
// 							// ì •ë§ ì§€ì €ë¶„í•˜ì§€ë§Œ... ë³„ ìˆ˜ ì—†ë‹¤.
// 							const found = findInTrie2(wildcardTrieNode, buffer, bufferIndex, bufferCount, i + 1);
// 							if (found) {
// 								const startContainer = buffer[bufferIndex].node;
// 								const startOffset = i;
// 								if (currentStart !== -1) {
// 									processToken(buffer[bufferIndex].node, currentStart, i);
// 									currentStart = -1;
// 								}
// 								finalizeToken();
// 								tokens[tokenIndex++] = {
// 									text: found.word,
// 									flags: currentFlags | found.flags,
// 									startContainer,
// 									startOffset,
// 									endContainer: buffer[found.bufferIndex].node,
// 									endOffset: found.charIndex,
// 								};
// 								currentFlags = 0;
// 								bufferIndex = found.bufferIndex - 1;
// 								i = found.charIndex; // continue OUTERë¡œ ë„˜ì–´ê°ˆ ë•Œ i++ëŠ” ì‹¤í–‰ì´ ì•ˆëœë‹¤!
// 								continue OUTER;
// 							}
// 						}
// 						if (currentFlags & LINE_START && sectionHeadingStartChars[char]) {
// 							const found = findInTrie2(SectionHeadingTrieNode, buffer, bufferIndex, bufferCount, i);
// 							if (found) {
// 								const startContainer = buffer[bufferIndex].node;
// 								const startOffset = i;
// 								if (currentStart !== -1) {
// 									processToken(buffer[bufferIndex].node, currentStart, i);
// 									currentStart = -1;
// 								}
// 								finalizeToken();
// 								tokens[tokenIndex++] = {
// 									text: found.word,
// 									flags: currentFlags | found.flags,
// 									startContainer,
// 									startOffset,
// 									endContainer: buffer[found.bufferIndex].node,
// 									endOffset: found.charIndex,
// 								};
// 								currentFlags = 0;
// 								bufferIndex = found.bufferIndex - 1;
// 								i = found.charIndex; // continue OUTERë¡œ ë„˜ì–´ê°ˆ ë•Œ i++ëŠ” ì‹¤í–‰ì´ ì•ˆëœë‹¤!
// 								continue OUTER;
// 							}
// 						}
// 						if (normalizedCharMap[char]) {
// 							shouldNormalize = true;
// 						}
// 						if (currentStart === -1) {
// 							currentStart = i;
// 						}
// 					}
// 				}
// 				if (currentStart !== -1) {
// 					processToken(buffer[bufferIndex].node, currentStart, textLen);
// 				}
// 				i = 0;
// 			}
// 			if (currentToken) {
// 				finalizeToken();
// 			}
// 			if (nextResult.done) {
// 				break;
// 			}
// 		}
// 		console.assert(currentToken === null, "currentToken should be null at this point");
// 		if (event.type === "containerStart") {
// 			containerStack.push(currentContainer);
// 			currentContainer = event.container;
// 			currentContainer.tokenStartIndex = tokenIndex;
// 		} else if (event.type === "containerEnd") {
// 			currentContainer.tokenCount = tokenIndex - currentContainer.tokenStartIndex;
// 			(currentContainer.node as HTMLElement).dataset.tokenStart = String(currentContainer.tokenStartIndex);
// 			(currentContainer.node as HTMLElement).dataset.tokenEnd = String(tokenIndex);
// 			const nodeName = currentContainer.node.nodeName;
// 			const firstToken = tokens[currentContainer.tokenStartIndex];
// 			const lastToken = tokens[tokenIndex - 1];
// 			if (currentContainer.commonFlags !== 0) {
// 				for (let i = currentContainer.tokenStartIndex; i < tokenIndex; i++) {
// 					tokens[i].flags |= currentContainer.commonFlags;
// 				}
// 			}
// 			if (TEXT_FLOW_CONTAINERS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | CONTAINER_START | BLOCK_START | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= CONTAINER_END | BLOCK_END | LINE_END;
// 				}
// 			} else if (LINEBREAK_ELEMENTS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= LINE_END;
// 				}
// 			}
// 			if (LINE_ELEMENTS[nodeName]) {
// 				if (firstToken) {
// 					firstToken.flags |= currentFlags | LINE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= LINE_END;
// 				}
// 			}
// 			if (nodeName === "TD" || nodeName === "TH") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLECELL_START | NO_JOIN_PREV;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLECELL_END | NO_JOIN_NEXT;
// 				}
// 			} else if (nodeName === "TR") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLEROW_START | NO_JOIN_PREV;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLEROW_END | NO_JOIN_NEXT;
// 				}
// 			} else if (nodeName === "TABLE") {
// 				if (firstToken) {
// 					firstToken.flags |= TABLE_START;
// 				}
// 				if (lastToken) {
// 					lastToken.flags |= TABLE_END;
// 				}
// 			}
// 			currentContainer = containerStack.pop()!;
// 			currentFlags &= ~CONTAINER_START;
// 		} else if (event.type === "break") {
// 			if (tokenIndex > 0) {
// 				tokens[tokenIndex - 1].flags |= LINE_END;
// 			}
// 			currentFlags |= LINE_START;
// 		} else if (event.type === "img") {
// 			tokens[tokenIndex++] = {
// 				text: event.src || "ğŸ–¼ï¸",
// 				flags: IMAGE | NO_JOIN_PREV | NO_JOIN_NEXT | currentFlags,
// 				startContainer: event.node.parentNode!,
// 				startOffset: currentContainer.indexInParent,
// 				endContainer: event.node.parentNode!,
// 				endOffset: currentContainer.indexInParent + 1,
// 			};
// 		}
// 		nextResult = iterator.next();
// 	}
// 	if (currentToken) {
// 		finalizeToken();
// 	}
// 	tokens.length = tokenIndex;
// 	return tokens;
// }
//
// ì™•ì™• í° í•¨ìˆ˜. ê·¸ë˜ë„ ê´œíˆ ì—¬ëŸ¬ í•¨ìˆ˜ë¡œ ìª¼ê°œì„œ ì„±ëŠ¥ ì†í•´ ë³´ê³  ì‹¶ì§€ ì•Šì€ ë§ˆìŒ...
function* tokenizer(ctx, idleDeadline) {
    const tokens = [];
    const containers = new Map();
    const root = ctx.content;
    const textNodes = [];
    const textNodeIndices = [];
    let tokenIndex = 0;
    let currentToken = null;
    let nextTokenFlags = 0;
    let recursionCount = 0;
    const containerStack = [];
    let currentContainer = null;
    function processToken(textNode, startOffset, endOffset, flags = 0) {
        if (currentToken) {
            currentToken.text += textNode.nodeValue.slice(startOffset, endOffset);
            currentToken.range.endContainer = textNode;
            currentToken.range.endOffset = endOffset;
        }
        else {
            currentToken = {
                text: textNode.nodeValue.slice(startOffset, endOffset),
                flags: nextTokenFlags | flags,
                range: {
                    startContainer: textNode,
                    startOffset: startOffset,
                    endContainer: textNode,
                    endOffset: endOffset,
                },
                container: currentContainer,
            };
            nextTokenFlags = 0;
        }
    }
    function finalizeToken(flags = 0) {
        if (currentToken) {
            currentToken.flags |= flags;
            tokens[tokenIndex++] = currentToken;
            currentToken = null;
        }
    }
    function findInTrie2(trie, bufferIndex, charIndex) {
        let node = trie;
        let i = bufferIndex;
        let j = charIndex;
        do {
            const text = textNodes[i].nodeValue;
            for (; j < text.length; j++) {
                let ch = text[j];
                ch = normalizedCharMap[ch] || ch;
                node = node.next(ch);
                if (!node) {
                    return null;
                }
                if (node.word) {
                    return { bufferIndex: i, charIndex: j + 1, word: node.word, flags: node.flags };
                }
            }
            i++;
            j = 0;
        } while (i < textNodes.length);
        return null;
    }
    function doTokenize() {
        console.assert(textNodes.length > 0, "textNodes should not be empty at this point");
        let nodeIndex = 0;
        let charIndex = 0;
        // for loopë¥¼ ì“°ë©´ ë¨¸ë¦¬ ì•„íŒŒì§„ë‹¤.
        // trie ë§¤ì¹­ì´ ì„±ê³µ í–ˆì„ë•Œ ì„ì˜ë¡œ nodeIndexì™€ charIndexë¥¼ advance ì‹œì¼œì•¼í•˜ê¸° ë•Œë¬¸ì—
        // continue í• ë•Œ ì¸ë±ìŠ¤ ê°’ì„ í•˜ë‚˜ ë¹¼ì¤˜ì•¼í•˜ëŠ”ì§€ ë§ì•„ì•¼í•˜ëŠ”ì§€ ìƒê°ì„ ì•ˆí•´ë„ ëœë‹¤ë©´ ê·¸ê²ƒë§Œìœ¼ë¡œ whileì˜ ê°€ì¹˜ëŠ” ì¶©ë¶„í•¨!
        do {
            const textNode = textNodes[nodeIndex];
            const text = textNode.nodeValue;
            const textLen = text.length;
            let shouldNormalize = false;
            let currentStart = -1;
            while (charIndex < textLen) {
                // 4byte ë¬¸ìë¥¼ ìƒê°í•´ì•¼í•œë‹¤. later....
                const cp = text.codePointAt(charIndex);
                // todo ë¬¸ìê°€ ì•„ë‹ˆë¼ ì½”ë“œí¬ì¸íŠ¸ë¡œ spaceCharë‚˜ normalizeChar ë“±ë“± í™•ì¸í•˜ê¸°
                let char = text[charIndex];
                if (spaceChars[char]) {
                    // split here
                    if (currentStart !== -1) {
                        processToken(textNode, currentStart, charIndex);
                        currentStart = -1;
                    }
                    finalizeToken();
                }
                else {
                    if (char === "(") {
                        const match = findInTrie2(wildcardTrieNode, nodeIndex, charIndex + 1);
                        if (match) {
                            const startContainer = textNode;
                            const startOffset = charIndex;
                            if (currentStart !== -1) {
                                processToken(textNode, currentStart, charIndex);
                                currentStart = -1;
                            }
                            finalizeToken();
                            tokens[tokenIndex++] = {
                                text: match.word,
                                flags: nextTokenFlags | match.flags,
                                range: {
                                    startContainer,
                                    startOffset,
                                    endContainer: textNodes[match.bufferIndex],
                                    endOffset: match.charIndex,
                                },
                                container: currentContainer,
                            };
                            nextTokenFlags = 0;
                            nodeIndex = match.bufferIndex;
                            charIndex = match.charIndex;
                            continue;
                        }
                    }
                    if (sectionHeadingStartChars[char] && nextTokenFlags & 1 /* TokenFlags.LINE_START */) {
                    }
                    if (currentStart === -1) {
                        currentStart = charIndex;
                    }
                }
                // ...
                // ...
                charIndex++;
                if (cp > 0xffff) {
                    charIndex++;
                }
            }
            if (currentStart !== -1) {
                processToken(textNode, currentStart, textLen);
                currentStart = -1;
            }
            nodeIndex++;
            charIndex = 0;
        } while (nodeIndex < textNodes.length);
        finalizeToken();
        textNodes.length = 0;
        textNodeIndices.length = 0;
    }
    function* traverse(node) {
        const nodeName = node.nodeName;
        const isTextFlowContainer = TEXT_FLOW_CONTAINERS[nodeName] || node === ctx.content;
        const isBlockElement = BLOCK_ELEMENTS[nodeName];
        let containerCreated = false;
        if (isBlockElement || isTextFlowContainer) {
            nextTokenFlags |= 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
            if (isTextFlowContainer) {
                nextTokenFlags |= 16 /* TokenFlags.CONTAINER_START */;
            }
            containerStack.push(currentContainer);
            currentContainer = {
                element: node,
                depth: (currentContainer?.depth ?? -1) + 1,
                startTokenIndex: tokenIndex,
                tokenCount: 0,
                parent: currentContainer || null,
            };
            containerCreated = true;
        }
        const isTokenBoundary = isTextFlowContainer || isBlockElement || nodeName === "TD";
        if (isTokenBoundary && textNodes.length > 0) {
            doTokenize();
        }
        const childNodes = node.childNodes;
        const tokenStartIndex = tokenIndex;
        for (let i = 0; i < childNodes.length; i++) {
            // ++recursionCount % 31 === 0 ì´ë ‡ê²Œ í•´ë„ ë˜ì§€ë§Œ ë¹„íŠ¸ì—°ì‚°ì„ ì“°ë©´ ë­”ê°€ ìˆì–´ ë³´ì¸ë‹¤. ëˆˆê¼½ë§Œí¼ ë” ë¹ ë¥¼ê±¸?
            if ((++recursionCount & 31) === 0 && idleDeadline.timeRemaining() < 1) {
                idleDeadline = yield;
            }
            const child = childNodes[i];
            if (child.nodeType === 3) {
                textNodes.push(child);
                textNodeIndices.push(i);
            }
            else if (child.nodeType === 1) {
                const childNodeName = child.nodeName;
                // ì¬ê·€ í˜¸ì¶œì„ ì•ˆí•´ë„ ë˜ëŠ” ë‹¨ìˆœí•œ case
                if (childNodeName === "A" || VOID_ELEMENTS[childNodeName]) {
                    if (childNodeName === "BR" || childNodeName === "HR") {
                        if (textNodes.length > 0) {
                            doTokenize();
                        }
                        nextTokenFlags |= 2 /* TokenFlags.LINE_END */;
                    }
                    else if (childNodeName === "IMG") {
                        if (textNodes.length > 0) {
                            doTokenize();
                        }
                        const range = document.createRange();
                        range.selectNode(child);
                        tokens[tokenIndex++] = {
                            text: child.src,
                            flags: 65536 /* TokenFlags.IMAGE */ | 4096 /* TokenFlags.NO_JOIN_PREV */ | 8192 /* TokenFlags.NO_JOIN_NEXT */ | nextTokenFlags,
                            range,
                            container: currentContainer,
                        };
                        nextTokenFlags = 0;
                    }
                    continue;
                }
                yield* traverse(child);
            }
        }
        if (isTokenBoundary && textNodes.length > 0) {
            doTokenize();
        }
        const tokenCount = tokenIndex - tokenStartIndex;
        if (tokenCount > 0) {
            const firstToken = tokens[tokenStartIndex];
            const lastToken = tokens[tokenIndex - 1];
            if (nodeName === "SUP" || nodeName === "SUB") {
                // SUP + SUPëŠ” ì¡°ì¸ì´ ê°€ëŠ¥í•´ì•¼ í•˜ë¯€ë¡œ NO_JOIN_PREV, NO_JOIN_NEXT í”Œë˜ê·¸ë¥¼ ì£¼ì§€ ì•ŠìŒ
                // ì˜ˆ: <sup>ì£¼</sup><sup>1)</sup> ì´ëŸ° ê±°ì§€ê°™ì€ ìƒí™©ì´ ë‚˜ì˜¬ ìˆ˜ë„ ìˆë‹¤.
                const commonFlags = nodeName === "SUP" ? 131072 /* TokenFlags.HTML_SUP */ : 262144 /* TokenFlags.HTML_SUB */;
                for (let i = tokenStartIndex; i < tokenIndex; i++) {
                    tokens[i].flags |= commonFlags;
                }
            }
            else if (nodeName === "TD" || nodeName === "TH") {
                if (firstToken) {
                    firstToken.flags |=
                        1024 /* TokenFlags.TABLECELL_START */ | 4096 /* TokenFlags.NO_JOIN_PREV */ | 16 /* TokenFlags.CONTAINER_START */ | 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
                }
                if (lastToken) {
                    lastToken.flags |=
                        2048 /* TokenFlags.TABLECELL_END */ | 8192 /* TokenFlags.NO_JOIN_NEXT */ | 32 /* TokenFlags.CONTAINER_END */ | 8 /* TokenFlags.BLOCK_END */ | 2 /* TokenFlags.LINE_END */;
                }
            }
            else if (nodeName === "TR") {
                if (firstToken) {
                    firstToken.flags |= 256 /* TokenFlags.TABLEROW_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 512 /* TokenFlags.TABLEROW_END */;
                }
            }
            else if (nodeName === "TABLE") {
                if (firstToken) {
                    firstToken.flags |= 64 /* TokenFlags.TABLE_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 128 /* TokenFlags.TABLE_END */;
                }
            }
            if (BLOCK_ELEMENTS[nodeName]) {
                if (firstToken) {
                    firstToken.flags |= nextTokenFlags | 4 /* TokenFlags.BLOCK_START */ | 1 /* TokenFlags.LINE_START */;
                }
                if (lastToken) {
                    lastToken.flags |= 8 /* TokenFlags.BLOCK_END */ | 2 /* TokenFlags.LINE_END */;
                }
                nextTokenFlags |= 1 /* TokenFlags.LINE_START */;
            }
            if (node === ctx.content) {
                firstToken.flags |= nextTokenFlags | 4 /* TokenFlags.BLOCK_START */ | 16 /* TokenFlags.CONTAINER_START */ | 1 /* TokenFlags.LINE_START */;
                lastToken.flags |= 8 /* TokenFlags.BLOCK_END */ | 32 /* TokenFlags.CONTAINER_END */ | 2 /* TokenFlags.LINE_END */;
            }
        }
        if (containerCreated) {
            if (tokenCount > 0) {
                currentContainer.startTokenIndex = tokenStartIndex;
                currentContainer.tokenCount = tokenCount;
                containers.set(node, currentContainer);
            }
            currentContainer = containerStack.pop();
        }
    }
    yield* traverse(root);
    tokens.length = tokenIndex;
    return { tokens, containers };
}
//# sourceMappingURL=tokenize.js.map
</script>
<script>"use strict";
const TEXT_SELECTION_HIGHLIGHT_FILL_STYLE = "hsl(210 100% 40%)";
/*
contenteditable ìš”ì†Œì— ì„ì˜ë¡œ ì•µì»¤ ê°™ì€ íƒœê·¸ë¥¼ ì‚½ì…í•˜ê±°ë‚˜ ì œê±°í•˜ëŠ” ê²ƒì€ ê°€ëŠ¥í•˜ì§€ë§Œ
ì–´ë–¤ ê²½ìš°ì—ë„ í…ìŠ¤íŠ¸ë…¸ë“œ ìì²´ë¥¼ ì¡°ì‘í•˜ë©´ ì•ˆë¨!
 - í…ìŠ¤íŠ¸ë…¸ë“œë¥¼ ë‹¤ë¥¸ ìš”ì†Œë¡œ ê°ì‹¸ê±°ë‚˜
 - í…ìŠ¤íŠ¸ë…¸ë“œë¥¼ ë‹¤ë¥¸ ìœ„ì¹˜ë¡œ ì´ë™ì‹œí‚¤ê±°ë‚˜
 - í…ìŠ¤íŠ¸ë…¸ë“œë¥¼ ìª¼ê°œì„œ ì‚¬ì´ì— íƒœê·¸ë¥¼ ì§‘ì–´ë„£ê±°ë‚˜
 - ë“±ë“±
ëª¨ë‘ ì¬ì•™ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì„.

íƒœê·¸ë¥¼ ì‚½ì…í•  ë•Œì—ë„ ì ˆëŒ€ íƒœê·¸ê°€ í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì„œëŠ” ì•ˆë¨.
ëˆˆì— ë³´ì´ì§€ ì•ŠëŠ” zws ê°™ì€ ê²ƒë„ ì‹¤ì œë¡œëŠ” ë¬¸ìê°€ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— ì§€ìš°ê±°ë‚˜ ì»¤ì„œë¥¼ ì´ë™í•  ë•Œ í‚¤ë¥¼ í•œë²ˆ ë” ëˆŒëŸ¬ì•¼ë˜ê³ 
ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ë…¸ë“œì— ë¬»ì–´ë²„ë¦¬ë©´ ì§œì¦ë‚¨.

ì°¸ê³ : ì‚½ì…í•˜ëŠ” íƒœê·¸ì— contenteditable="false" ì†ì„±ì„ ë„£ì–´ë²„ë¦¬ë©´ ì»¤ì„œê°€ ì œëŒ€ë¡œ í†µê³¼í•˜ì§€ ëª»í•¨.
*/
function createEditor(container, editorName, callbacks) {
    const { onContentChanged, onScroll } = callbacks;
    const _visibleAnchors = new Set();
    let _tokens = [];
    let _containers = null;
    const _diffAnchorElements = [];
    const wrapper = document.createElement("div");
    wrapper.id = editorName + "EditorWrapper";
    wrapper.classList.add("editor-wrapper");
    const INITIAL_EDITOR_HTML = document.createElement("P");
    INITIAL_EDITOR_HTML.appendChild(document.createElement("BR"));
    const editor = document.createElement("div");
    editor.id = editorName + "Editor";
    editor.classList.add("editor");
    editor.contentEditable = "true";
    editor.spellcheck = false;
    if (true) {
        // editor.innerHTML = `<table><tbody><tr><td><p>í•˜ë‚˜ ì€í–‰</p></td><td><p>êµ­ë¯¼ ì€í–‰</p></td><td><p>ì‹ í•œ ì€í–‰</p></td></tr><tr><td><p>ì‚°ì—… ì€í–‰</p></td><td><p>ì¹´ì¹´ì˜¤ ë±…í¬</p></td><td rowspan="2"><p>ì¼€ì´ ë±…í¬</p></td></tr><tr><td><p>ìš°ë¦¬ ì€í–‰</p></td><td><p>ìš°ì²´êµ­</p></td></tr></tbody></table>hello`;
        if (editorName === "right") {
            const WTF = false;
            if (WTF) {
                editor.innerHTML = `<table border="1">
  <tr>
    <td>
      <h2>1. ì„œë¡ </h2>
      <p></p>
      <p></p>
      <p></p>
      <p></p>

      <h2>2. ë°°ê²½</h2>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>

      <h2>3. ì‹œìŠ¤í…œ êµ¬ì„±</h2>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>

      <h2>4. ì ìš© ì‚¬ë¡€</h2>
      <p></p>
      <p></p>
      <p></p>

      <h2>5. ê²°ë¡ </h2>
      <p></p>
      <p></p>
    </td>
    <td>
      <p>ì´ ë¬¸ì„œëŠ” ë¬¸ì„œ ë¹„êµ ì‹œìŠ¤í…œì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
      <p>ë¬¸ì„œ ê°„ì˜ ì°¨ì´ì ì„ ì •í™•í•˜ê²Œ íŒŒì•…í•˜ê³ , ì‹œê°ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
      <p>ë¹„êµ ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ ë° ì •ë°€ë„ë„ ì£¼ìš”í•œ ê´€ì‹¬ì‚¬ì…ë‹ˆë‹¤.</p>
      <p>í…ŒìŠ¤íŠ¸ í™˜ê²½ì„ ìœ„í•œ ì¶©ë¶„í•œ ì…ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>

      <h3>ê°€. ê¸°ì¡´ ë°©ë²•ì˜ í•œê³„</h3>
      <p>ìˆ˜ì‘ì—… ë¹„êµëŠ” ì‹œê°„ ì†Œëª¨ì ì´ë©° ì˜¤ë¥˜ ë°œìƒ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤.</p>

      <h3>ë‚˜. ìë™í™” í•„ìš”ì„±</h3>
      <p>ìë™í™”ëœ ë¹„êµëŠ” ì¼ê°„ì„± ìˆëŠ” ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
      <p>ìƒì‚°ì„±ê³¼ ì •í™•ì„±ì„ ë™ì‹œì— ë†’ì¼ ìˆ˜ ìˆìë‹ˆë‹¤.</p>

      <h3>ê°€. ì…ë ¥</h3>
      <p>HTML ë¬¸ì„œë¥¼ ì…ë ¥ë°›ì•„ í•„ìš”í•œ ë‚´ìš©ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.</p>

      <h3>ë‚˜. ì „ì²˜ë¦¬</h3>
      <p>í† í°í™”ì™€ ìŠ¤íƒ€ì¼ ì œê±° ë“± í•„ìš”í•œ ì •ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.</p>
      <p>ì•µì»¤ ì‚½ì…ì„ í†µí•´ ìœ„ì¹˜ ì¶”ì ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.</p>

      <h3>ë‹¤. ë¹„êµ</h3>
      <p>êµ¬ì¡° ë° í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ë¹„êµí•˜ì—¬ ì°¨ì´ì ì„ ì‹œê°í™”í•©ë‹ˆë‹¤.</p>
      <p>ì¢Œìš° ì—ë””í„° ê°„ ì •ë ¬ ê¸°ì¤€ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.</p>

      <h3>ê°€. ë²•ë¥  ë¬¸ì„œ</h3>
      <p>ë²•ë ¹ ê°œì •ì•ˆ ë¹„êµì— íš¨ê³¼ì ì…ë‹ˆë‹¤.</p>

      <h3>ë‚˜. ë…¼ë¬¸ ë²„ì „</h3>
      <p>ë²„ì „ ê°„ ë³€ê²½ì ì´ ë§ì•„ ì •ë°€í•œ ë¹„êµê°€ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
      <p>ë‹¨ë½ ì´ë™, ì‚½ì…/ì‚­ì œ ê°ì§€ë¥¼ ì§€ì›í•´ì•¼ í•©ë‹ˆë‹¤.</p>

      <p>ì‹œìŠ¤í…œ ì •ë°€ë„, ì†ë„, ì§ê´€ì ì¸ UIëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.</p>
      <p>ì§€ì†ì ì¸ í…ŒìŠ¤íŠ¸ì™€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
    </td>
  </tr>
</table>

`;
            }
            else {
                editor.innerHTML = `<table style="width: 100%; table-layout: fixed; border-collapse: collapse;" border="1">
  <tr>
    <td style="vertical-align: top; width: 25%;">
      <h2>1. ì„œë¡ </h2>
    </td>
    <td>
	  <p>(í˜„í–‰ê³¼ ê°™ìŒ)</p>
      <p>ì´ ë¬¸ì„œëŠ” ë¬¸ì„œ ë¹„êµ ì‹œìŠ¤í…œì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
	  <p>(ì‚­ì œ)</p>
      <p>ë¬¸ì„œ ê°„ì˜ ì°¨ì´ì ì„ ì •í™•í•˜ê²Œ íŒŒì•…í•˜ê³ , ì‹œê°ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
      <p>ë¹„êµ ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ ë° ì •ë°€ë„ë„ ì£¼ìš”í•œ ê´€ì‹¬ì‚¬ì…ë‹ˆë‹¤.</p>
      <p>í…ŒìŠ¤íŠ¸ í™˜ê²½ì„ ìœ„í•œ ì¶©ë¶„í•œ ì…ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      <h2>2. ë°°ê²½</h2>
    </td>
    <td>
      <h3>ê°€. ê¸°ì¡´ ë°©ë²•ì˜ í•œê³„</h3>
	  
      <p>ìˆ˜ì‘ì—… ë¹„êµëŠ” ì‹œê°„ ì†Œëª¨ì ì´ë©° ì˜¤ë¥˜ ë°œìƒ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤.</p>

      <h3>ë‚˜. ìë™í™” í•„ìš”ì„±</h3>
      <p>ìë™í™”ëœ ë¹„êµëŠ” ì¼ê°„ì„± ìˆëŠ” ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
      <p>ìƒì‚°ì„±ê³¼ ì •í™•ì„±ì„ ë™ì‹œì— ë†’ì¼ ìˆ˜ ìˆìë‹ˆë‹¤.</p>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      <h2>3. ì‹œìŠ¤í…œ êµ¬ì„±</h2>
    </td>
    <td>
      <h3>ê°€. ì…ë ¥</h3>
      <p>HTML ë¬¸ì„œë¥¼ ì…ë ¥ë°›ì•„ í•„ìš”í•œ <img src="xxx"> ë‚´ìš©ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.</p>

      <h3>ë‚˜. ì „ì²˜ë¦¬</h3>
      <p>í† í°í™”ì™€ ìŠ¤íƒ€ì¼ ì œê±° ë“± í•„ìš”í•œ ì •ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.</p>
      <p>ì•µì»¤ ì‚½ì…ì„ í†µí•´ ìœ„ì¹˜ ì¶”ì ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.</p>

      <h3>ë‹¤. ë¹„êµ</h3>
      <p>êµ¬ì¡° ë° í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ë¹„êµí•˜ì—¬ ì°¨ì´ì ì„ ì‹œê°í™”í•©ë‹ˆë‹¤.</p>
      <p>ì¢Œìš° ì—ë””í„° ê°„ ì •ë ¬ ê¸°ì¤€ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.</p>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      <h2>4. ì ìš© ì‚¬ë¡€</h2>
    </td>
    <td>
      <h3>ê°€. ë²•ë¥  ë¬¸ì„œ</h3>
      <p>ë²•ë ¹ ê°œì •ì•ˆ ë¹„êµì— íš¨ê³¼ì ì…ë‹ˆë‹¤.</p>

      <h3>ë‚˜. ë…¼ë¬¸ ë²„ì „</h3>
      <p>ë²„ì „ ê°„ ë³€ê²½ì ì´ ë§ì•„ ì •ë°€í•œ ë¹„êµê°€ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
      <p>ë‹¨ë½ ì´ë™, ì‚½ì…/ì‚­ì œ ê°ì§€ë¥¼ ì§€ì›í•´ì•¼ í•©ë‹ˆë‹¤.</p>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      <h2>5. ê²°ë¡ </h2>
    </td>
    <td>
      <p>ì‹œìŠ¤í…œ ì •ë°€ë„, ì†ë„, ì§ê´€ì ì¸ UIëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.</p>
      <p>ì§€ì†ì ì¸ í…ŒìŠ¤íŠ¸ì™€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
    </td>
  </tr>
</table>

`;
            }
        }
        else {
            editor.innerHTML = `<div>
  <h2>1. ì„œë¡ </h2>
  <p>hello world!</p>
  <p>ì´ ë¬¸ì„œëŠ” ë¬¸ì„œ ë¹„êµ ì‹œìŠ¤í…œì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
  
  <p>ë¬¸ì„œ ê°„ì˜ ì°¨ì´ì ì„ ì •í™•í•˜ê²Œ íŒŒì•…í•˜ê³ , ì‹œê°ì ìœ¼ë¡œ ë¹„êµí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
  <p>ë¹„êµ ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ ë° ì •ë°€ë„ë„ ì£¼ìš”í•œ ê´€ì‹¬ì‚¬ì…ë‹ˆë‹¤.</p>
  <p>í…ŒìŠ¤íŠ¸ í™˜ê²½ì„ ìœ„í•œ ì¶©ë¶„í•œ ì…ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>

  <h2>2. ë°°ê²½</h2>
  <h3>ê°€. ê¸°ì¡´ ë°©ë²•ì˜ í•œê³„</h3>
  <p>ìˆ˜ì‘ì—… ë¹„êµëŠ” ì‹œê°„ ì†Œëª¨ì ì´ë©° ì˜¤ë¥˜ ë°œìƒ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤.</p>

  <h3>ë‚˜. ìë™í™” í•„ìš”ì„±</h3>
  <p>ìë™í™”ëœ ë¹„êµëŠ” ì¼ê´€ì„± ìˆëŠ” ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
  <p>ìƒì‚°ì„±ê³¼ ì •í™•ì„±ì„ ë™ì‹œì— ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

  <h2>3. ì‹œìŠ¤í…œ êµ¬ì„±</h2>
  <h3>ê°€. ì…ë ¥</h3>
  <p>HTML ë¬¸ì„œë¥¼ ì…ë ¥ë°›ì•„ í•„ìš”í•œ <img src="yyy"> ë‚´ìš©ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.</p>

  <h3>ë‚˜. ì „ì²˜ë¦¬</h3>
  <p>í† í°í™”ì™€ ìŠ¤íƒ€ì¼ ì œê±° ë“± í•„ìš”í•œ ì •ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.</p>
  <p>ì•µì»¤ ì‚½ì…ì„ í†µí•´ ìœ„ì¹˜ ì¶”ì ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.</p>

  <h3>ë‹¤. ë¹„êµ</h3>
  <p>êµ¬ì¡° ë° í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ë¹„êµí•˜ì—¬ ì°¨ì´ì ì„ ì‹œê°í™”í•©ë‹ˆë‹¤.</p>
  <p>ì¢Œìš° ì—ë””í„° ê°„ ì •ë ¬ ê¸°ì¤€ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.</p>

  <h2>4. ì ìš© ì‚¬ë¡€</h2>
  <h3>ê°€. ë²•ë¥  ë¬¸ì„œ</h3>
  <p>ë²•ë ¹ ê°œì •ì•ˆ ë¹„êµì— íš¨ê³¼ì ì…ë‹ˆë‹¤.</p>

  <h3>ë‚˜. ë…¼ë¬¸ ë²„ì „</h3>
  <p>ë²„ì „ ê°„ ë³€ê²½ì ì´ ë§ì•„ ì •ë°€í•œ ë¹„êµê°€ ìš”êµ¬ë©ë‹ˆë‹¤.</p>
  <p>ë‹¨ë½ ì´ë™, ì‚½ì…/ì‚­ì œ ê°ì§€ë¥¼ ì§€ì›í•´ì•¼ í•©ë‹ˆë‹¤.</p>

  <h2>5. ê²°ë¡ </h2>
  <p>ì‹œìŠ¤í…œ ì •ë°€ë„, ì†ë„, ì§ê´€ì ì¸ UIëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.</p>
  <p>ì§€ì†ì ì¸ í…ŒìŠ¤íŠ¸ì™€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
</div>
`;
        }
    }
    wrapper.appendChild(editor);
    container.appendChild(wrapper);
    wrapper.addEventListener("scroll", () => {
        // renderer.markDirty(RenderFlags.DIFF);
        onScroll(wrapper.scrollTop, wrapper.scrollLeft);
        // const scrollTop = wrapper.scrollTop;
        // const scrollLeft = wrapper.scrollLeft;
        // console.log(editorName, "WRAPPER", wrapper.getBoundingClientRect(), "scrollTop", scrollTop, "scrollLeft", scrollLeft);
        const visibleRect = wrapper.getBoundingClientRect();
    });
    // *** HTML ë¶™ì—¬ë„£ê¸°ë¥¼ í—ˆìš©í•  ë•Œë§Œ ì‚¬ìš©í•  ì½”ë“œ ***
    // ì§€ê¸ˆì€ ê´€ë ¨ ì½”ë“œë¥¼ ë‹¤ ì§€ì›Œë²„ë ¸ê³  ë³µêµ¬í•˜ë ¤ë©´ ê¹ƒí—ˆë¸Œì—ì„œ ì´ì „ ì½”ë“œë¥¼ ë’¤ì ¸ì•¼í•¨...
    const { observeEditor, unobserveEditor } = (() => {
        const mutationObserver = new MutationObserver((mutations) => {
            if (editor.childNodes.length === 0) {
                editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
                return;
            }
        });
        function observeEditor() {
            mutationObserver.observe(editor, {
                childList: true,
                // subtree: true,
                // attributes: true,
                // characterData: true,
            });
        }
        function unobserveEditor() {
            mutationObserver.disconnect();
        }
        return { observeEditor, unobserveEditor };
    })();
    observeEditor();
    function formatPlaintext(plaintext) {
        const lines = plaintext.split("\n");
        const fragment = document.createDocumentFragment();
        for (const line of lines) {
            const p = document.createElement("p");
            p.textContent = line;
            fragment.appendChild(p);
        }
        return fragment;
    }
    editor.addEventListener("paste", (e) => {
        // ë¹„êµì  ë¬´ê±°ìš´ ì‘ì—…ì´ì§€ë§Œ ë’¤ë¡œ ë¯¸ë£¨ë©´ ì•ˆë˜ëŠ” ì‘ì—…ì´ê¸° ë•Œë¬¸ì— UI blockingì„ í”¼í•  ë¾°ì¡±í•œ ìˆ˜ê°€ ì—†ë‹¤.
        // ë¶™ì—¬ë„£ê¸° ì´í›„ ë°”ë¡œ ì¶”ê°€ ì…ë ¥ => ë¶™ì—¬ë„£ê¸°ë¥¼ ë’¤ë¡œ ë¯¸ë£¨ë©´ ì…ë ¥ì´ ë¨¼ì € ë í…Œë‹ˆê¹Œ.
        console.time("paste");
        e.preventDefault();
        let rawHTML = e.clipboardData?.getData("text/html");
        let sanitized;
        if (rawHTML) {
            const START_TAG = "<!--StartFragment-->";
            const END_TAG = "<!--EndFragment-->";
            const startIndex = rawHTML.indexOf(START_TAG);
            if (startIndex >= 0) {
                const endIndex = rawHTML.lastIndexOf(END_TAG);
                if (endIndex >= 0) {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
                }
                else {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length);
                }
            }
            sanitized = sanitizeHTML(rawHTML);
        }
        else {
            sanitized = formatPlaintext(e.clipboardData?.getData("text/plain") || "");
        }
        // ìì¡´ì‹¬ ìƒí•˜ì§€ë§Œ document.execCommand("insertHTML",...)ë¥¼ ì¨ì•¼í•œë‹¤.
        // 1. ë¸Œë¼ìš°ì €ê°€ undo/redo íˆìŠ¤í† ë¦¬ ê´€ë¦¬ë¥¼ í•  ìˆ˜ ìˆìŒ.
        // 2. í•„ìš”í•œ ê²½ìš° ë¸Œë¼ìš°ì €ê°€ ì•Œì•„ì„œ DOMì„ ìˆ˜ì •í•´ ì¤Œ.
        // 	ì˜ˆ: ì¸ë¼ì¸ ì—˜ëŸ¬ë¨¼íŠ¸ ì•ˆì— ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë¶™ì—¬ë„£ëŠ” ê²½ìš° ë¸Œë¼ìš°ì €ê°€ ì•Œì•„ì„œ ì¸ë¼ì¸ ìš”ì†Œë¥¼ ë°˜ìœ¼ë¡œ ê°ˆë¼ì„œ ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë°–ìœ¼ë¡œ êº¼ë‚´ì¤€ë‹¤.
        const div = document.createElement("DIV");
        div.appendChild(sanitized);
        unobserveEditor();
        document.execCommand("insertHTML", false, div.innerHTML);
        observeEditor();
        console.log("insertHTML", div.innerHTML);
        console.timeEnd("paste");
    });
    editor.addEventListener("input", onChange);
    function onChange() {
        tokenize();
    }
    function onTokenizeDone() {
        onContentChanged();
    }
    // temp
    setTimeout(onChange, 0);
    // ì•µì»¤ë¥¼ ì–´ë–¤ì‹ìœ¼ë¡œ ì¶”ê°€í• ì§€
    // 1. classListì— ë„£ê³  anchor:before
    // 2. <a> íƒœê·¸ë¥¼ ë„£ëŠ”ë‹¤
    const tokenize = (function () {
        const _TIMEOUT = 200;
        let _callbackId = null;
        let _currentContext = null;
        return () => {
            if (_callbackId !== null) {
                // ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šê³  ëŒ€ê¸° ì¤‘ì¸ ì½œë°± ì·¨ì†Œ
                cancelIdleCallback(_callbackId);
                _callbackId = null;
            }
            if (_currentContext) {
                // ì´ë¯¸ ì½œë°±ì´ ì‹¤í–‰ ì¤‘ì´ë¼ë©´ ë‹¤ìŒ stepì—ì„œ ì·¨ì†Œì²˜ë¦¬í•´ì•¼í•˜ë¯€ë¡œ...
                _currentContext.cancelled = true;
            }
            const startTime = performance.now();
            const ctx = (_currentContext = {
                cancelled: false,
                content: editor,
            });
            // ì—¬ê¸°ì„œ ë°”ë¡œ generatorë¥¼ ìƒì„±ì„ í•´ë²„ë¦¬ë©´ idleDeadlineì„ ë°”ë¡œ ë„˜ê²¨ì¤„ ìˆ˜ê°€ ì—†ë‹¤.
            // generator ë‚´ë¶€ì—ì„œ idleDeadlineì„ íšë“í•˜ë ¤ë©´ "ì„±ê¸‰í•˜ê²Œ" yieldë¥¼ í•´ì•¼ë˜ëŠ”ë° ê·¸ëŸ¬ë©´ í™©ê¸ˆê°™ì€ ìœ íœ´ì‹œê°„ì„ í•œë²ˆ ë‚­ë¹„í•˜ê²Œ ë¨.
            let generator = null;
            const step = (idleDeadline) => {
                _callbackId = null;
                if (ctx.cancelled) {
                    // ì–´ì°¨í”¼ ë‹¨ì¼ì“°ë ˆë“œì´ë¯€ë¡œ ì½œë°±ì´ ì‹¤í–‰ë˜ëŠ” ë„ì¤‘ì—ëŠ” cancelled ê°’ì´ ë°”ë€” ìˆ˜ëŠ” ì—†ìŒ!
                    // ê·¸ë˜ì„œ next()ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì—ë‚˜ í•œë²ˆì”© í™•ì¸í•´ì£¼ë©´ ë¨.
                    // ë‹¤ë§Œ generator ë‚´ë¶€ì—ì„œ ì£¼ê¸°ì ìœ¼ë¡œ yieldì„ í•´ì£¼ì§€ ì•Šìœ¼ë©´ í† í°í™”ê°€ ëë‚ ë•Œê¹Œì§€ ë©ˆì¶œ ìˆ˜ ì—†ìŒ.
                    console.debug(editorName, "tokenize cancelled");
                    return;
                }
                if (generator === null) {
                    generator = tokenizer(ctx, idleDeadline);
                }
                const { done, value } = generator.next(idleDeadline);
                if (done) {
                    const endTime = performance.now();
                    ({ tokens: _tokens, containers: _containers } = value);
                    console.log(editorName, "tokenize done", Math.ceil(endTime - startTime) + "ms", value);
                    onTokenizeDone();
                }
                else {
                    _callbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
                }
            };
            _callbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
        };
    })();
    function getOrInsertStartAnchor(tokenIndex) {
        const token = _tokens[tokenIndex];
        let container = token.range.startContainer;
        let beforeNode;
        if (container.nodeType === 3) {
            beforeNode = container;
            container = container.parentElement;
        }
        else {
            container = token.range.startContainer.parentNode;
            beforeNode = token.range.startContainer;
        }
        do {
            if (BLOCK_ELEMENTS[container.nodeName]) {
                if (beforeNode) {
                    let anchor = beforeNode.previousSibling;
                    if (!anchor || anchor.nodeName !== "A") {
                        anchor = document.createElement("A");
                        container.insertBefore(anchor, beforeNode);
                    }
                    return anchor;
                }
            }
            beforeNode = container;
            container = container.parentNode;
        } while (container);
        return null;
    }
    // function getOrCreateDiffAnchorFromInsertionPoint(point: AnchorInsertionPoint, diffIndex: number): Range {
    // 	if (point.existingAnchor) {
    // 		const range = document.createRange();
    // 		range.selectNode(point.existingAnchor);
    // 		return range;
    // 	}
    // 	if (point.container.nodeType === 3) {
    // 		const range = document.createRange();
    // 		range.setStart(point.container, point.offset);
    // 		range.collapse(true);
    // 		return range;
    // 	}
    // 	const range = document.createRange();
    // 	range.setStart(point.container, point.offset);
    // 	range.collapse(true);
    // 	const diffAnchorEl = document.createElement("a");
    // 	diffAnchorEl.classList.add("anchor", "diff-anchor");
    // 	diffAnchorEl.dataset.diff = String(diffIndex);
    // 	range.insertNode(diffAnchorEl);
    // 	range.selectNode(diffAnchorEl);
    // 	_diffAnchorElements[diffIndex] = diffAnchorEl;
    // 	console.warn(editorName, "created diff anchor", diffAnchorEl, point);
    // 	return range;
    // }
    return {
        name: editorName,
        getOrInsertStartAnchor,
        wrapper,
        editor,
        createTokenRange,
        scrollToOffset,
        scrollByOffset,
        yieldAnchorPointsInRange,
        // getOrCreateDiffAnchorFromInsertionPoint,
        contains: wrapper.contains.bind(wrapper),
        findTokenOverlapIndices,
        get tokens() {
            return _tokens;
        },
        get scrollTop() {
            return wrapper.scrollTop;
        },
        set scrollTop(value) {
            wrapper.scrollTop = value;
        },
        get scrollLeft() {
            return wrapper.scrollLeft;
        },
        set scrollLeft(value) {
            wrapper.scrollLeft = value;
        },
    };
    function* yieldAnchorPointsInRange(tokenIndex) {
        const prevToken = _tokens[tokenIndex - 1];
        const nextToken = _tokens[tokenIndex];
        let endContainer;
        let endOffset;
        // let endNode: Node;
        let lastYielded = null;
        // console.log(editorName, "generateInsertionPointsInRange", { tokenIndex, prevToken, nextToken });
        let container;
        let childIndex;
        const indexStack = [];
        if (prevToken && nextToken && prevToken.range.endContainer === nextToken.range.startContainer && prevToken.range.endContainer.nodeType === 3) {
            yield* createPoint(prevToken.range.endContainer, prevToken.range.endOffset);
            return;
        }
        if (prevToken) {
            container = prevToken.range.endContainer;
            childIndex = prevToken.range.endOffset;
            if (container.nodeType === 3) {
                // í…ìŠ¤íŠ¸ë…¸ë“œëŠ” ì»¨í…Œì´ë„ˆë¡œ ì§€ì •ë˜ì§€ ì•ŠìŒ!
                yield* createPoint(container, childIndex);
                childIndex = Array.prototype.indexOf.call(container.parentNode.childNodes, container) + 1;
                container = container.parentNode;
            }
        }
        else {
            container = editor;
            childIndex = 0;
        }
        if (nextToken) {
            endContainer = nextToken.range.startContainer;
            endOffset = nextToken.range.startOffset;
        }
        else {
            endContainer = editor;
            endOffset = editor.childNodes.length;
        }
        if (container === endContainer) {
            if (container.nodeType === 3) {
                yield* createPoint(container, childIndex);
                return;
            }
        }
        while (container) {
            if (!TEXTLESS_ELEMENTS[container.nodeName]) {
                yield* createPoint(container, childIndex);
            }
            if (container === endContainer && childIndex >= endOffset) {
                break;
            }
            let current = container.childNodes[childIndex];
            if (!current) {
                current = container;
                container = container.parentNode;
                if (indexStack.length > 0) {
                    childIndex = indexStack.pop();
                }
                else {
                    if (!container || !container.childNodes) {
                        console.warn(editorName, "No childNodes in container", current, container, prevToken, nextToken);
                    }
                    childIndex = Array.prototype.indexOf.call(container.childNodes, current);
                }
                childIndex++;
                continue;
            }
            if (current.nodeType === 1 && !VOID_ELEMENTS[current.nodeName]) {
                // ì£¼ì–´ì§„ childIndexì— í•´ë‹¹í•˜ëŠ” ìì‹ìœ¼ë¡œ ë“¤ì–´ê°€ê¸°
                if (current.firstChild) {
                    indexStack.push(childIndex);
                    container = current;
                    childIndex = 0;
                    continue;
                }
                else {
                    // ìì‹ì´ ì—†ë”ë¼ë„ ìš”ì†Œ ì•ˆì— í•˜ë‚˜ì˜ pointëŠ” ë§Œë“¤ì–´ì•¼í•¨.
                    // firstChild ì¡°ê±´ ì²´í¬ ì—†ì´ container=current, childIndex=0ìœ¼ë¡œ ì„¤ì •í•´ë‘ê³  continue í•´ë²„ë ¤ë„ ë˜ì§€ë§Œ
                    // ì¼ë‹¨ ê·¸ëƒ¥ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ê³  ë£¨í”„ í•œë°”í€´ ê±´ë„ˆë›°ì.
                    if (!TEXTLESS_ELEMENTS[current.nodeName]) {
                        yield* createPoint(current, 0);
                    }
                }
            }
            else if (current.nodeType === 3) {
                if (current === endContainer) {
                    yield* createPoint(current, endOffset);
                    break;
                }
            }
            childIndex++;
        }
        function* createPoint(container, offset, flags = 0) {
            if (lastYielded && lastYielded.container === container && lastYielded.offset === offset) {
                return;
            }
            let existingAnchor = null;
            if (container.nodeType === 3) {
                //
            }
            else {
                existingAnchor = container.childNodes[offset] || null;
                if (existingAnchor && existingAnchor.nodeName !== "A") {
                    existingAnchor = null;
                }
                const comparePrev = prevToken ? container.compareDocumentPosition(prevToken.range.endContainer) : 0;
                const compareNext = nextToken ? container.compareDocumentPosition(nextToken.range.startContainer) : 0;
                if (offset === 0 || !(comparePrev & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 16 /* InsertionPointFlags.ContainerStart */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 64 /* InsertionPointFlags.BlockStart */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 256 /* InsertionPointFlags.TableCellStart */;
                        if (container.parentNode.firstElementChild === container) {
                            flags |= 1024 /* InsertionPointFlags.TableRowStart */;
                        }
                    }
                }
                if (offset === container.childNodes.length || !(compareNext & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 32 /* InsertionPointFlags.ContainerEnd */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 128 /* InsertionPointFlags.BlockEnd */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 512 /* InsertionPointFlags.TableCellEnd */;
                        if (container.parentNode.lastElementChild === container) {
                            flags |= 2048 /* InsertionPointFlags.TableRowEnd */;
                        }
                    }
                }
                if (offset > 0) {
                    const prevSibling = container.childNodes[offset - 1];
                    if (prevSibling && prevSibling.nodeName === "TABLE") {
                        flags |= 8 /* InsertionPointFlags.AfterTable */;
                    }
                }
                let nextSibling = existingAnchor ? existingAnchor.nextSibling : container.childNodes[offset];
                if (nextSibling) {
                    if (nextSibling.nodeName === "TABLE") {
                        flags |= 4 /* InsertionPointFlags.BeforeTable */;
                    }
                }
            }
            lastYielded = { container: container, offset, flags, existingAnchor };
            yield lastYielded;
        }
    }
    function scrollToOffset(offset) {
        wrapper.scrollTop = offset;
    }
    function scrollByOffset(offset) {
        wrapper.scrollTop += offset;
    }
    function createTokenRange(index, count = 1) {
        const range = document.createRange();
        if (count === 1 && index >= 0 && index < _tokens.length) {
            const token = _tokens[index];
            range.setStart(token.range.startContainer, token.range.startOffset);
            range.setEnd(token.range.endContainer, token.range.endOffset);
        }
        else if (count > 0) {
            const startToken = _tokens[index];
            const endToken = _tokens[index + count - 1];
            if (startToken) {
                range.setStart(startToken.range.startContainer, startToken.range.startOffset);
            }
            else {
                range.setStart(editor, 0);
            }
            if (endToken) {
                range.setEnd(endToken.range.endContainer, endToken.range.endOffset);
            }
            else {
                range.setEnd(editor, editor.childNodes.length);
            }
        }
        else {
            const prevToken = _tokens[index - 1];
            const nextToken = _tokens[index];
            if (prevToken) {
                range.setStart(prevToken.range.endContainer, prevToken.range.endOffset);
            }
            else {
                range.setStart(editor, 0);
            }
            if (nextToken) {
                range.setEnd(nextToken.range.startContainer, nextToken.range.startOffset);
            }
            else {
                range.setEnd(editor, editor.childNodes.length);
            }
        }
        return range;
    }
    function findTokenOverlapIndices(range) {
        let low = 0;
        let high = _tokens.length - 1;
        let startIndex = -1;
        let endIndex = -1;
        // console.debug(editorName, "findTokenOverlapIndices", { range, text: range.toString() });
        /*
        comparePoint(referenceNode, offset)
            returns
                -1 if the point specified by the referenceNode and offset is before the start of this Range.
                0 if the point specified by the referenceNode and offset is within this Range (including the start and end points of the range).
                1 if the point specified by the referenceNode and offset is after the end of this Range.
        
        compareBoundaryPoints(how, otherRange)
            how
                Range.END_TO_END compares the end boundary-point of this Range to the end boundary-point of otherRange.
                Range.END_TO_START compares the start boundary-point of this Range to the end boundary-point of otherRange.
                Range.START_TO_END compares the end boundary-point of this Range to the start boundary-point of otherRange.
                Range.START_TO_START compares the start boundary-point of this Range to the start boundary-point of otherRange.
            returns
                -1 if the specified boundary-point of this Range is before the specified boundary-point of otherRange.
                0 if the specified boundary-point of this Range is the same as the specified boundary-point of otherRange.
                1 if the specified boundary-point of this Range is after the specified boundary-point of otherRange.
        */
        const tokenRange = document.createRange();
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = _tokens[mid].range;
            tokenRange.setStart(token.startContainer, token.startOffset);
            tokenRange.setEnd(token.endContainer, token.endOffset);
            const c = range.compareBoundaryPoints(Range.END_TO_START, tokenRange);
            // console.debug(mid, _tokens[mid].text, c, _tokens[mid]);
            if (c < 0) {
                const c2 = range.compareBoundaryPoints(Range.START_TO_START, tokenRange);
                console.debug(">>", mid, _tokens[mid].text, c2, _tokens[mid]);
                startIndex = mid;
                high = mid - 1; // ì™¼ìª½ìœ¼ë¡œ
            }
            else {
                low = mid + 1; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ
            }
        }
        if (startIndex !== -1) {
            low = endIndex = startIndex;
            high = _tokens.length - 1;
            while (low <= high) {
                const mid = (low + high) >> 1;
                const token = _tokens[mid].range;
                tokenRange.setStart(token.startContainer, token.startOffset);
                tokenRange.setEnd(token.endContainer, token.endOffset);
                const c = range.compareBoundaryPoints(Range.START_TO_END, tokenRange);
                if (c > 0) {
                    endIndex = mid + 1;
                    low = mid + 1; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                }
                else {
                    high = mid - 1; // ì™¼ìª½ìœ¼ë¡œ
                }
            }
        }
        // console.debug(editorName, "findTokenOverlapIndices", { range, text: range.toString(), startIndex, endIndex });
        return [startIndex, endIndex];
    }
}
const INITIAL_EDITOR_HTML = document.createElement("P");
INITIAL_EDITOR_HTML.appendChild(document.createElement("BR"));
class Editor2 {
    #editorName;
    #container;
    #wrapper = document.createElement("div");
    #editor = document.createElement("div");
    #mutationObserver;
    #tokens = [];
    #tokenizeContext = null;
    #tokenizeCallbackId = null;
    #callbacks;
    constructor(container, editorName, callbacks) {
        this.#editorName = editorName;
        this.#container = container;
        this.#callbacks = callbacks;
        this.#editor.id = editorName + "Editor";
        this.#editor.classList.add("editor");
        this.#editor.contentEditable = "true";
        this.#editor.spellcheck = false;
        this.#editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
        this.#wrapper.id = editorName + "EditorWrapper";
        this.#wrapper.classList.add("editor-wrapper");
        this.#wrapper.appendChild(this.#editor);
        this.#container.appendChild(this.#wrapper);
        this.#mutationObserver = new MutationObserver((mutations) => this.onMutation(mutations));
        this.observeMutation();
        this.#wrapper.addEventListener("scroll", (e) => this.onScroll(e));
        this.#editor.addEventListener("paste", (e) => this.onPaste(e));
        this.#editor.addEventListener("input", () => this.onContentChange());
        setTimeout(() => this.tokenize(), 0);
    }
    get name() {
        return this.#editorName;
    }
    get wrapper() {
        return this.#wrapper;
    }
    get editor() {
        return this.#editor;
    }
    get tokens() {
        return this.#tokens;
    }
    get scrollTop() {
        return this.#wrapper.scrollTop;
    }
    set scrollTop(value) {
        this.#wrapper.scrollTop = value;
    }
    get scrollLeft() {
        return this.#wrapper.scrollLeft;
    }
    set scrollLeft(value) {
        this.#wrapper.scrollLeft = value;
    }
    scrollToOffset(offset) {
        this.#wrapper.scrollTop = offset;
    }
    scrollByOffset(offset) {
        this.#wrapper.scrollTop += offset;
    }
    onScroll(e) { }
    onContentChange() {
        this.tokenize();
    }
    onMutation(mutations) {
        if (this.#editor.childNodes.length === 0) {
            this.#editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
        }
    }
    observeMutation() {
        this.#mutationObserver.observe(this.#wrapper, {
            childList: true,
            subtree: true,
            attributes: true,
            characterData: true,
        });
    }
    unobserveMutation() {
        this.#mutationObserver.disconnect();
    }
    onPaste(e) {
        // ë¹„êµì  ë¬´ê±°ìš´ ì‘ì—…ì´ì§€ë§Œ ë’¤ë¡œ ë¯¸ë£¨ë©´ ì•ˆë˜ëŠ” ì‘ì—…ì´ê¸° ë•Œë¬¸ì— UI blockingì„ í”¼í•  ë¾°ì¡±í•œ ìˆ˜ê°€ ì—†ë‹¤.
        // ë¶™ì—¬ë„£ê¸° ì´í›„ ë°”ë¡œ ì¶”ê°€ ì…ë ¥ => ë¶™ì—¬ë„£ê¸°ë¥¼ ë’¤ë¡œ ë¯¸ë£¨ë©´ ì…ë ¥ì´ ë¨¼ì € ë í…Œë‹ˆê¹Œ.
        console.time("paste");
        e.preventDefault();
        let rawHTML = e.clipboardData?.getData("text/html") ?? "";
        let sanitized;
        if (rawHTML) {
            const START_TAG = "<!--StartFragment-->";
            const END_TAG = "<!--EndFragment-->";
            const startIndex = rawHTML.indexOf(START_TAG);
            if (startIndex >= 0) {
                const endIndex = rawHTML.lastIndexOf(END_TAG);
                if (endIndex >= 0) {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length, endIndex);
                }
                else {
                    rawHTML = rawHTML.slice(startIndex + START_TAG.length);
                }
            }
            sanitized = sanitizeHTML(rawHTML);
        }
        else {
            sanitized = formatPlaintext(e.clipboardData?.getData("text/plain") ?? "");
        }
        // ìì¡´ì‹¬ ìƒí•˜ì§€ë§Œ document.execCommand("insertHTML",...)ë¥¼ ì¨ì•¼í•œë‹¤.
        // 1. ë¸Œë¼ìš°ì €ê°€ undo/redo íˆìŠ¤í† ë¦¬ ê´€ë¦¬ë¥¼ í•  ìˆ˜ ìˆìŒ.
        // 2. í•„ìš”í•œ ê²½ìš° ë¸Œë¼ìš°ì €ê°€ ì•Œì•„ì„œ DOMì„ ìˆ˜ì •í•´ ì¤Œ.
        // 	ì˜ˆ: ì¸ë¼ì¸ ì—˜ëŸ¬ë¨¼íŠ¸ ì•ˆì— ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë¶™ì—¬ë„£ëŠ” ê²½ìš° ë¸Œë¼ìš°ì €ê°€ ì•Œì•„ì„œ ì¸ë¼ì¸ ìš”ì†Œë¥¼ ë°˜ìœ¼ë¡œ ê°ˆë¼ì„œ ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë°–ìœ¼ë¡œ êº¼ë‚´ì¤€ë‹¤. ë¯¿ìŒì§í•œê°€? ì•„ë‹ˆì˜¤.
        const div = document.createElement("DIV");
        div.appendChild(sanitized);
        this.unobserveMutation();
        document.execCommand("insertHTML", false, div.innerHTML);
        this.observeMutation();
        console.timeEnd("paste");
    }
    // 	const { observeEditor, unobserveEditor } = (() => {
    // 	const mutationObserver = new MutationObserver((mutations) => {
    // 		if (editor.childNodes.length === 0) {
    // 			editor.appendChild(INITIAL_EDITOR_HTML.cloneNode(true));
    // 			return;
    // 		}
    // 	});
    // 	function observeEditor() {
    // 		mutationObserver.observe(editor, {
    // 			childList: true,
    // 			// subtree: true,
    // 			// attributes: true,
    // 			// characterData: true,
    // 		});
    // 	}
    // 	function unobserveEditor() {
    // 		mutationObserver.disconnect();
    // 	}
    // 	return { observeEditor, unobserveEditor };
    // })();
    // observeEditor();
    findTokenOverlapIndices(range) {
        let low = 0;
        let high = this.#tokens.length - 1;
        let startIndex = -1;
        let endIndex = -1;
        // console.debug(editorName, "findTokenOverlapIndices", { range, text: range.toString() });
        /*
        comparePoint(referenceNode, offset)
            returns
                -1 if the point specified by the referenceNode and offset is before the start of this Range.
                0 if the point specified by the referenceNode and offset is within this Range (including the start and end points of the range).
                1 if the point specified by the referenceNode and offset is after the end of this Range.

        compareBoundaryPoints(how, otherRange)
            how
                Range.END_TO_END compares the end boundary-point of this Range to the end boundary-point of otherRange.
                Range.END_TO_START compares the start boundary-point of this Range to the end boundary-point of otherRange.
                Range.START_TO_END compares the end boundary-point of this Range to the start boundary-point of otherRange.
                Range.START_TO_START compares the start boundary-point of this Range to the start boundary-point of otherRange.
            returns
                -1 if the specified boundary-point of this Range is before the specified boundary-point of otherRange.
                0 if the specified boundary-point of this Range is the same as the specified boundary-point of otherRange.
                1 if the specified boundary-point of this Range is after the specified boundary-point of otherRange.
        */
        const tokenRange = document.createRange();
        while (low <= high) {
            const mid = (low + high) >> 1;
            const token = this.#tokens[mid].range;
            tokenRange.setStart(token.startContainer, token.startOffset);
            tokenRange.setEnd(token.endContainer, token.endOffset);
            const c = range.compareBoundaryPoints(Range.END_TO_START, tokenRange);
            // console.debug(mid, this.#tokens[mid].text, c, this.#tokens[mid]);
            if (c < 0) {
                const c2 = range.compareBoundaryPoints(Range.START_TO_START, tokenRange);
                console.debug(">>", mid, this.#tokens[mid].text, c2, this.#tokens[mid]);
                startIndex = mid;
                high = mid - 1; // ì™¼ìª½ìœ¼ë¡œ
            }
            else {
                low = mid + 1; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ
            }
        }
        if (startIndex !== -1) {
            low = endIndex = startIndex;
            high = this.#tokens.length - 1;
            while (low <= high) {
                const mid = (low + high) >> 1;
                const token = this.#tokens[mid].range;
                tokenRange.setStart(token.startContainer, token.startOffset);
                tokenRange.setEnd(token.endContainer, token.endOffset);
                const c = range.compareBoundaryPoints(Range.START_TO_END, tokenRange);
                if (c > 0) {
                    endIndex = mid + 1;
                    low = mid + 1; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                }
                else {
                    high = mid - 1; // ì™¼ìª½ìœ¼ë¡œ
                }
            }
        }
        // console.debug(editorName, "findTokenOverlapIndices", { range, text: range.toString(), startIndex, endIndex });
        return [startIndex, endIndex];
    }
    createTokenRange(index, count = 1) {
        const range = document.createRange();
        if (count === 1 && index >= 0 && index < this.#tokens.length) {
            const token = this.#tokens[index];
            range.setStart(token.range.startContainer, token.range.startOffset);
            range.setEnd(token.range.endContainer, token.range.endOffset);
        }
        else if (count > 0) {
            const startToken = this.#tokens[index];
            const endToken = this.#tokens[index + count - 1];
            if (startToken) {
                range.setStart(startToken.range.startContainer, startToken.range.startOffset);
            }
            else {
                range.setStart(this.#editor, 0);
            }
            if (endToken) {
                range.setEnd(endToken.range.endContainer, endToken.range.endOffset);
            }
            else {
                range.setEnd(this.#editor, this.#editor.childNodes.length);
            }
        }
        else {
            const prevToken = this.#tokens[index - 1];
            const nextToken = this.#tokens[index];
            if (prevToken) {
                range.setStart(prevToken.range.endContainer, prevToken.range.endOffset);
            }
            else {
                range.setStart(this.#editor, 0);
            }
            if (nextToken) {
                range.setEnd(nextToken.range.startContainer, nextToken.range.startOffset);
            }
            else {
                range.setEnd(this.#editor, this.#editor.childNodes.length);
            }
        }
        return range;
    }
    tokenize() {
        const _TIMEOUT = 200;
        if (this.#tokenizeCallbackId !== null) {
            // ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šê³  ëŒ€ê¸° ì¤‘ì¸ ì½œë°± ì·¨ì†Œ
            cancelIdleCallback(this.#tokenizeCallbackId);
            this.#tokenizeCallbackId = null;
        }
        if (this.#tokenizeContext) {
            // ì´ë¯¸ ì½œë°±ì´ ì‹¤í–‰ ì¤‘ì´ë¼ë©´ ë‹¤ìŒ stepì—ì„œ ì·¨ì†Œì²˜ë¦¬í•´ì•¼í•˜ë¯€ë¡œ...
            this.#tokenizeContext.cancelled = true;
        }
        const startTime = performance.now();
        const ctx = (this.#tokenizeContext = {
            cancelled: false,
            content: this.#editor,
        });
        // ì—¬ê¸°ì„œ ë°”ë¡œ generatorë¥¼ ìƒì„±ì„ í•´ë²„ë¦¬ë©´ idleDeadlineì„ ë°”ë¡œ ë„˜ê²¨ì¤„ ìˆ˜ê°€ ì—†ë‹¤.
        // generator ë‚´ë¶€ì—ì„œ idleDeadlineì„ íšë“í•˜ë ¤ë©´ "ì„±ê¸‰í•˜ê²Œ" yieldë¥¼ í•´ì•¼ë˜ëŠ”ë° ê·¸ëŸ¬ë©´ í™©ê¸ˆê°™ì€ ìœ íœ´ì‹œê°„ì„ í•œë²ˆ ë‚­ë¹„í•˜ê²Œ ë¨.
        let generator = null;
        const step = (idleDeadline) => {
            this.#tokenizeCallbackId = null;
            if (ctx.cancelled) {
                // ì–´ì°¨í”¼ ë‹¨ì¼ì“°ë ˆë“œì´ë¯€ë¡œ ì½œë°±ì´ ì‹¤í–‰ë˜ëŠ” ë„ì¤‘ì—ëŠ” cancelled ê°’ì´ ë°”ë€” ìˆ˜ëŠ” ì—†ìŒ!
                // ê·¸ë˜ì„œ next()ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì—ë‚˜ í•œë²ˆì”© í™•ì¸í•´ì£¼ë©´ ë¨.
                // ë‹¤ë§Œ generator ë‚´ë¶€ì—ì„œ ì£¼ê¸°ì ìœ¼ë¡œ yieldì„ í•´ì£¼ì§€ ì•Šìœ¼ë©´ í† í°í™”ê°€ ëë‚ ë•Œê¹Œì§€ ë©ˆì¶œ ìˆ˜ ì—†ìŒ.
                console.debug(this.#editorName, "tokenize cancelled");
                return;
            }
            if (generator === null) {
                generator = tokenizer(ctx, idleDeadline);
            }
            const { done, value } = generator.next(idleDeadline);
            if (done) {
                const endTime = performance.now();
                ({ tokens: this.#tokens } = value);
                console.log(this.#editorName, "tokenize done", Math.ceil(endTime - startTime) + "ms", value);
                this.onTokenizeDone();
            }
            else {
                this.#tokenizeCallbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
            }
        };
        this.#tokenizeCallbackId = requestIdleCallback(step, { timeout: _TIMEOUT });
    }
    onTokenizeDone() {
        this.#callbacks.onContentChanged();
    }
    getOrInsertStartAnchor(tokenIndex) {
        const token = this.#tokens[tokenIndex];
        let container = token.range.startContainer;
        let beforeNode;
        if (container.nodeType === 3) {
            beforeNode = container;
            container = container.parentElement;
        }
        else {
            container = token.range.startContainer.parentNode;
            beforeNode = token.range.startContainer;
        }
        do {
            if (BLOCK_ELEMENTS[container.nodeName]) {
                if (beforeNode) {
                    let anchor = beforeNode.previousSibling;
                    if (!anchor || anchor.nodeName !== "A") {
                        anchor = document.createElement("A");
                        container.insertBefore(anchor, beforeNode);
                    }
                    return anchor;
                }
            }
            beforeNode = container;
            container = container.parentNode;
        } while (container);
        return null;
    }
    *yieldAnchorPointsInRange(tokenIndex) {
        const prevToken = this.#tokens[tokenIndex - 1];
        const nextToken = this.#tokens[tokenIndex];
        let endContainer;
        let endOffset;
        // let endNode: Node;
        let lastYielded = null;
        // console.log(editorName, "generateInsertionPointsInRange", { tokenIndex, prevToken, nextToken });
        let container;
        let childIndex;
        const indexStack = [];
        if (prevToken && nextToken && prevToken.range.endContainer === nextToken.range.startContainer && prevToken.range.endContainer.nodeType === 3) {
            yield* createPoint(prevToken.range.endContainer, prevToken.range.endOffset);
            return;
        }
        if (prevToken) {
            container = prevToken.range.endContainer;
            childIndex = prevToken.range.endOffset;
            if (container.nodeType === 3) {
                // í…ìŠ¤íŠ¸ë…¸ë“œëŠ” ì»¨í…Œì´ë„ˆë¡œ ì§€ì •ë˜ì§€ ì•ŠìŒ!
                yield* createPoint(container, childIndex);
                childIndex = Array.prototype.indexOf.call(container.parentNode.childNodes, container) + 1;
                container = container.parentNode;
            }
        }
        else {
            container = this.#editor;
            childIndex = 0;
        }
        if (nextToken) {
            endContainer = nextToken.range.startContainer;
            endOffset = nextToken.range.startOffset;
        }
        else {
            endContainer = this.#editor;
            endOffset = this.#editor.childNodes.length;
        }
        if (container === endContainer) {
            if (container.nodeType === 3) {
                yield* createPoint(container, childIndex);
                return;
            }
        }
        while (container) {
            if (!TEXTLESS_ELEMENTS[container.nodeName]) {
                yield* createPoint(container, childIndex);
            }
            if (container === endContainer && childIndex >= endOffset) {
                break;
            }
            let current = container.childNodes[childIndex];
            if (!current) {
                current = container;
                container = container.parentNode;
                if (indexStack.length > 0) {
                    childIndex = indexStack.pop();
                }
                else {
                    if (!container || !container.childNodes) {
                        console.warn(this.#editorName, "No childNodes in container", current, container, prevToken, nextToken);
                    }
                    childIndex = Array.prototype.indexOf.call(container.childNodes, current);
                }
                childIndex++;
                continue;
            }
            if (current.nodeType === 1 && !VOID_ELEMENTS[current.nodeName]) {
                // ì£¼ì–´ì§„ childIndexì— í•´ë‹¹í•˜ëŠ” ìì‹ìœ¼ë¡œ ë“¤ì–´ê°€ê¸°
                if (current.firstChild) {
                    indexStack.push(childIndex);
                    container = current;
                    childIndex = 0;
                    continue;
                }
                else {
                    // ìì‹ì´ ì—†ë”ë¼ë„ ìš”ì†Œ ì•ˆì— í•˜ë‚˜ì˜ pointëŠ” ë§Œë“¤ì–´ì•¼í•¨.
                    // firstChild ì¡°ê±´ ì²´í¬ ì—†ì´ container=current, childIndex=0ìœ¼ë¡œ ì„¤ì •í•´ë‘ê³  continue í•´ë²„ë ¤ë„ ë˜ì§€ë§Œ
                    // ì¼ë‹¨ ê·¸ëƒ¥ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ê³  ë£¨í”„ í•œë°”í€´ ê±´ë„ˆë›°ì.
                    if (!TEXTLESS_ELEMENTS[current.nodeName]) {
                        yield* createPoint(current, 0);
                    }
                }
            }
            else if (current.nodeType === 3) {
                if (current === endContainer) {
                    yield* createPoint(current, endOffset);
                    break;
                }
            }
            childIndex++;
        }
        function* createPoint(container, offset, flags = 0) {
            if (lastYielded && lastYielded.container === container && lastYielded.offset === offset) {
                return;
            }
            let existingAnchor = null;
            if (container.nodeType === 3) {
                //
            }
            else {
                existingAnchor = container.childNodes[offset] || null;
                if (existingAnchor && existingAnchor.nodeName !== "A") {
                    existingAnchor = null;
                }
                const comparePrev = prevToken ? container.compareDocumentPosition(prevToken.range.endContainer) : 0;
                const compareNext = nextToken ? container.compareDocumentPosition(nextToken.range.startContainer) : 0;
                if (offset === 0 || !(comparePrev & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 16 /* InsertionPointFlags.ContainerStart */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 64 /* InsertionPointFlags.BlockStart */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 256 /* InsertionPointFlags.TableCellStart */;
                        if (container.parentNode.firstElementChild === container) {
                            flags |= 1024 /* InsertionPointFlags.TableRowStart */;
                        }
                    }
                }
                if (offset === container.childNodes.length || !(compareNext & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                    if (TEXT_FLOW_CONTAINERS[container.nodeName]) {
                        flags |= 32 /* InsertionPointFlags.ContainerEnd */;
                    }
                    if (BLOCK_ELEMENTS[container.nodeName]) {
                        flags |= 128 /* InsertionPointFlags.BlockEnd */;
                    }
                    if (container.nodeName === "TD" || container.nodeName === "TH") {
                        flags |= 512 /* InsertionPointFlags.TableCellEnd */;
                        if (container.parentNode.lastElementChild === container) {
                            flags |= 2048 /* InsertionPointFlags.TableRowEnd */;
                        }
                    }
                }
                if (offset > 0) {
                    const prevSibling = container.childNodes[offset - 1];
                    if (prevSibling && prevSibling.nodeName === "TABLE") {
                        flags |= 8 /* InsertionPointFlags.AfterTable */;
                    }
                }
                let nextSibling = existingAnchor ? existingAnchor.nextSibling : container.childNodes[offset];
                if (nextSibling) {
                    if (nextSibling.nodeName === "TABLE") {
                        flags |= 4 /* InsertionPointFlags.BeforeTable */;
                    }
                }
            }
            lastYielded = { container: container, offset, flags, existingAnchor };
            yield lastYielded;
        }
    }
}
//# sourceMappingURL=editor.js.map
</script>
<script>"use strict";
function createRenderer(_container, _leftEditor, _rightEditor, callbacks) {
    const DIFF_EXPAND_X = 2;
    const DIFF_EXPAND_Y = 0;
    const DIFF_LINE_EXPAND_Y = 1;
    const DIFF_LINE_FILL_STYLE = "hsl(0 100% 95%)";
    const DIFF_LINE_HEIGHT_MULTIPLIER = 1.1;
    const onDiffVisibilityChanged = callbacks.onDiffVisibilityChanged || (() => { });
    const _leftRegion = {
        editor: _leftEditor,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        scrollTop: 0,
        scrollLeft: 0,
        dirtyFlags: 0,
        diffRanges: null,
        diffRenderItems: null,
        diffLineRects: [],
        diffRectsDirty: false,
        visibleDiffIndices: new Set(),
    };
    const _rightRegion = {
        editor: _rightEditor,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        scrollTop: 0,
        scrollLeft: 0,
        dirtyFlags: 0,
        diffRanges: null,
        diffRenderItems: null,
        diffLineRects: [],
        diffRectsDirty: false,
        visibleDiffIndices: new Set(),
    };
    let _canvasX = 0;
    let _canvasY = 0;
    let _canvasWidth = 0;
    let _canvasHeight = 0;
    let _renderPending = false;
    let _diffs = [];
    let _selectionHighlight = null;
    let _selectionHighlightRects = null;
    const diffCanvas = document.createElement("canvas");
    const diffCanvasCtx = diffCanvas.getContext("2d");
    _container.appendChild(diffCanvas);
    const highlightCanvas = document.createElement("canvas");
    const highlightCanvasCtx = highlightCanvas.getContext("2d");
    _container.appendChild(highlightCanvas);
    const resizeObserver = new ResizeObserver((entries) => {
        // updateLayout();
        // render();
    });
    resizeObserver.observe(_container);
    resizeObserver.observe(_leftEditor.wrapper);
    resizeObserver.observe(_rightEditor.wrapper);
    function onEditorScroll(e) {
        // const editor = e.target === _leftEditor.wrapper ? _leftEditor : _rightEditor;
        // const editorName = editor.name;
        // const scrollTop = editor.wrapper.scrollTop;
        // const scrollLeft = editor.wrapper.scrollLeft;
        // const region = editorName === "left" ? _leftRegion : _rightRegion;
        // if (region.scrollTop !== scrollTop || region.scrollLeft !== scrollLeft) {
        // 	region.scrollTop = scrollTop;
        // 	region.scrollLeft = scrollLeft;
        // 	region.dirtyFlags |= RenderFlags.ALL;
        // 	render();
        // }
    }
    _leftEditor.wrapper.addEventListener("scroll", onEditorScroll);
    _rightEditor.wrapper.addEventListener("scroll", onEditorScroll);
    function updateLayout() {
        const { x, y, width, height } = _container.getBoundingClientRect();
        if (_canvasWidth === width && _canvasHeight === height && _canvasX === x && _canvasY === y) {
            return;
        }
        _canvasX = x;
        _canvasY = y;
        _canvasWidth = width;
        _canvasHeight = height;
        diffCanvas.width = width;
        diffCanvas.height = height;
        highlightCanvas.width = width;
        highlightCanvas.height = height;
        for (const editor of [_leftEditor, _rightEditor]) {
            const editorName = editor.name;
            const region = editorName === "left" ? _leftRegion : _rightRegion;
            const { x, y, width, height } = editor.wrapper.getBoundingClientRect();
            region.x = x - _canvasX;
            region.y = y - _canvasY;
            region.width = width;
            region.height = height;
            region.scrollTop = editor.wrapper.scrollTop;
            region.scrollLeft = editor.wrapper.scrollLeft;
            // region.diffRenderItems = null;
            region.dirtyFlags |= 7 /* RenderFlags.ALL */;
        }
        markDirty(1 /* RenderFlags.DIFF */ | 4 /* RenderFlags.DIFF_GEOMETRY */ | 8 /* RenderFlags.LEFT_EDITOR */ | 16 /* RenderFlags.RIGHT_EDITOR */);
        render();
    }
    let _renderCounter = 0;
    function render() {
        renderEditorRegion("left");
        renderEditorRegion("right");
        renderSelectionHighlight();
    }
    function renderEditorRegion(editorName) {
        const region = editorName === "left" ? _leftRegion : _rightRegion;
        if (region.dirtyFlags & 1 /* RenderFlags.DIFF */) {
            let renderItems = region.diffRenderItems;
            if (!renderItems) {
                console.warn("No diff render items found for editor:", editorName);
                return;
            }
            if (region.dirtyFlags & 4 /* RenderFlags.DIFF_GEOMETRY */) {
                buildDiffGeometries(region);
            }
            const ctx = diffCanvasCtx;
            const { scrollLeft, scrollTop } = region.editor;
            console.log("rendering editor region:", editorName, "scrollLeft:", scrollLeft, "scrollTop:", scrollTop);
            ctx.clearRect(region.x, region.y, region.width, region.height);
            let visibleDiffIndices = region.visibleDiffIndices;
            ctx.fillStyle = DIFF_LINE_FILL_STYLE;
            console.log("diffLineRects:", region.diffLineRects);
            for (const rect of region.diffLineRects) {
                const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                if (y + height < 0 || y > _canvasHeight)
                    continue;
                if (x + width < 0 || x > _canvasWidth)
                    continue;
                ctx.fillRect(x, y, width, height);
            }
            let shown = [];
            let hidden = [];
            for (let diffIndex = 0; diffIndex < renderItems.length; ++diffIndex) {
                const item = renderItems[diffIndex];
                if (!item) {
                    continue;
                }
                const geometry = item.geometry;
                let isVisible = !(geometry.maxY - scrollTop < 0 || geometry.minY - scrollTop > _canvasHeight) &&
                    !(geometry.maxX - scrollLeft < 0 || geometry.minX - scrollLeft > _canvasWidth);
                if (isVisible) {
                    if (!visibleDiffIndices.has(diffIndex)) {
                        visibleDiffIndices.add(diffIndex);
                        shown.push(diffIndex);
                    }
                }
                else {
                    if (visibleDiffIndices.has(diffIndex)) {
                        visibleDiffIndices.delete(diffIndex);
                        hidden.push(diffIndex);
                    }
                    continue;
                }
                ctx.fillStyle = item.fill;
                ctx.strokeStyle = item.stroke;
                for (const rect of geometry.rects) {
                    const x = Math.floor(rect.x - scrollLeft), y = Math.floor(rect.y - scrollTop), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                    if (y + height < 0 || y > _canvasHeight)
                        continue;
                    if (x + width < 0 || x > _canvasWidth)
                        continue;
                    // console.log("rendering rect:", x, y, width, height, "isVisible:", isVisible);
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeRect(x, y, width, height);
                    // item.renderedRect.push(rect);
                }
            }
            if (shown.length > 0 || hidden.length > 0) {
                onDiffVisibilityChanged(editorName, shown, hidden);
            }
        }
    }
    function renderSelectionHighlight() {
        console.log("Rendering selection highlight:", _selectionHighlight?.toString(), _selectionHighlight);
        const ctx = highlightCanvasCtx;
        ctx.clearRect(0, 0, _canvasWidth, _canvasHeight);
        if (_selectionHighlight) {
            if (!_selectionHighlightRects) {
                const rawRects = extractRects(_selectionHighlight);
                console.log("Raw selection highlight rects:", rawRects);
                _selectionHighlightRects = mergeRects(rawRects, 1, 1);
            }
            console.log("Selection highlight rects:", _selectionHighlightRects);
            ctx.fillStyle = "rgba(128, 128, 128, 0.5)";
            for (const rect of _selectionHighlightRects.rects) {
                const x = Math.floor(rect.x - _canvasX), y = Math.floor(rect.y - _canvasY), width = Math.ceil(rect.width), height = Math.ceil(rect.height);
                ctx.fillRect(x, y, width, height);
            }
        }
    }
    function buildDiffGeometries(region) {
        const wrapper = region.editor.wrapper;
        const _canvasOffsetX = _canvasX; // + region.x;
        const _canvasOffsetY = _canvasY; // + region.y;
        const scrollTop = wrapper.scrollTop;
        const scrollLeft = wrapper.scrollLeft;
        const offsetX = -_canvasOffsetX + scrollLeft;
        const offsetY = -_canvasOffsetY + scrollTop;
        void region.editor.wrapper.offsetWidth; // force reflow
        const allDiffRects = [];
        if (region.diffRenderItems) {
            for (let diffIndex = 0; diffIndex < region.diffRenderItems.length; diffIndex++) {
                const item = region.diffRenderItems[diffIndex];
                const range = item.range;
                const rawRects = extractRects(range);
                for (const rect of rawRects) {
                    rect.x += offsetX - DIFF_EXPAND_X;
                    rect.y += offsetY - DIFF_EXPAND_Y;
                    rect.width += DIFF_EXPAND_X * 2;
                    rect.height += DIFF_EXPAND_Y * 2;
                    allDiffRects.push(rect);
                }
                item.geometry = mergeRects(rawRects, 1, 1);
            }
        }
        buildDiffLineRects(region, allDiffRects);
    }
    function buildDiffLineRects(region, diffRects) {
        const TOLERANCE = 1;
        const _diffLineRects = region.diffLineRects;
        _diffLineRects.length = 0;
        diffRects.sort((a, b) => a.y - b.y);
        const rects = [];
        let lineRect = null;
        for (const rect of diffRects) {
            const y = rect.y - DIFF_LINE_EXPAND_Y;
            const height = rect.height * DIFF_LINE_HEIGHT_MULTIPLIER + DIFF_LINE_EXPAND_Y * 2;
            //const height = rect.height + lineExpand * 2;
            if (lineRect === null || y > lineRect.y + lineRect.height) {
                lineRect = {
                    x: region.x,
                    y: y,
                    width: region.width - 2,
                    height: height,
                };
                rects.push(lineRect);
            }
            else {
                lineRect.height = y + height - lineRect.y;
            }
        }
        if (rects.length > 0) {
            let current = rects[0];
            for (let i = 1; i < rects.length; i++) {
                const next = rects[i];
                const currentBottom = current.y + current.height;
                const nextTop = next.y;
                const gap = nextTop - currentBottom;
                if (gap <= TOLERANCE) {
                    const newBottom = Math.max(currentBottom, next.y + next.height);
                    current = {
                        x: current.x,
                        y: current.y,
                        width: current.width,
                        height: newBottom - current.y,
                    };
                }
                else {
                    // ë³‘í•© ë¶ˆê°€: í˜„ì¬ê¹Œì§€ ë³‘í•©ëœ ê²ƒ push
                    _diffLineRects.push(current);
                    current = next;
                }
            }
            _diffLineRects.push(current);
        }
        console.log("Built diff line rects:", _diffLineRects, "for editor:", region.editor.name);
    }
    updateLayout();
    function markDirty(flags) {
        const editorFlags = flags & 24 /* RenderFlags.EDITOR_MASK */;
        if (editorFlags & 8 /* RenderFlags.LEFT_EDITOR */) {
            _leftRegion.dirtyFlags |= flags & ~24 /* RenderFlags.EDITOR_MASK */;
        }
        if (editorFlags & 16 /* RenderFlags.RIGHT_EDITOR */) {
            _rightRegion.dirtyFlags |= flags & ~24 /* RenderFlags.EDITOR_MASK */;
        }
        render();
    }
    function setDiffs(editorName, diffs) {
        const region = editorName === "left" ? _leftRegion : _rightRegion;
        if (region.diffRenderItems !== diffs) {
            region.diffRenderItems = diffs;
            region.diffRectsDirty = true;
            region.dirtyFlags |= 1 /* RenderFlags.DIFF */ | 4 /* RenderFlags.DIFF_GEOMETRY */;
        }
    }
    function setSelectionHighlight(range) {
        _selectionHighlight = range;
        _selectionHighlightRects = null; // reset cached rects
        markDirty(2 /* RenderFlags.SELECTION_HIGHLIGHT */);
    }
    function clearSelectionHighlight() { }
    return {
        updateLayout,
        markDirty,
        render,
        setDiffs,
        setSelectionHighlight,
        clearSelectionHighlight,
    };
}
//# sourceMappingURL=renderer.js.map
</script>
<script id="worker.js" type="text/plain">"use strict";
const SECTION_HEADING_MASK = 524288 /* TokenFlags.SECTION_HEADING_TYPE1 */ |
    1048576 /* TokenFlags.SECTION_HEADING_TYPE2 */ |
    2097152 /* TokenFlags.SECTION_HEADING_TYPE3 */ |
    4194304 /* TokenFlags.SECTION_HEADING_TYPE4 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE5 */ |
    8388608 /* TokenFlags.SECTION_HEADING_TYPE6 */;
let _nextCtx = null;
let _currentCtx = null;
self.onmessage = (e) => {
    if (e.data.type === "diff") {
        const request = e.data;
        const ctx = {
            ...request,
            cancel: false,
            start: 0,
            finish: 0,
            lastYield: 0,
            entries: [],
            states: {},
        };
        if (ctx.leftTokens === null) {
            ctx.leftTokens = _currentCtx.leftTokens;
        }
        if (ctx.rightTokens === null) {
            ctx.rightTokens = _currentCtx.rightTokens;
        }
        if (_currentCtx) {
            _currentCtx.cancel = true;
            _nextCtx = ctx;
            return;
        }
        runDiff(ctx);
    }
};
async function runDiff(ctx) {
    _currentCtx = ctx;
    try {
        ctx.lastYield = ctx.start = performance.now();
        self.postMessage({
            reqId: ctx.reqId,
            type: "start",
            start: ctx.start,
        });
        let result;
        if (ctx.options.algorithm === "histogram") {
            result = await runHistogramDiff(ctx);
        }
        else if (ctx.options.algorithm === "lcs") {
            result = await runLcsDiff(ctx);
        }
        else {
            throw new Error("Unknown algorithm: " + ctx.options.algorithm);
        }
        ctx.finish = performance.now();
        _currentCtx = null;
        self.postMessage({
            reqId: ctx.reqId,
            type: "diff",
            processTime: ctx.finish - ctx.start,
            diffs: result,
        });
    }
    catch (e) {
        if (e instanceof Error && e.message === "cancelled") {
            // console.debug("Diff canceled");
        }
        else {
            console.error(e);
        }
    }
    [ctx, _nextCtx] = [_nextCtx, null];
    if (ctx) {
        return await runDiff(ctx);
    }
}
// #endregion
// =============================================================
// LCS Algorithm
// =============================================================
async function runLcsDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    const rawResult = await computeDiff(lhsTokens, rhsTokens, !!ctx.options.greedyMatch, ctx);
    // return postProcess(ctx, rawResult, lhsTokens, rhsTokens);
    return rawResult;
}
async function computeLCS(leftTokens, rightTokens, ctx) {
    const m = leftTokens.length;
    const n = rightTokens.length;
    const dp = new Array(m + 1);
    for (let i = 0; i <= m; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    // í…ìŠ¤íŠ¸ê°€ ê¸¸ì–´ì§€ëŠ” ê²½ìš°(í† í°ì´ ë§ì€ ê²½ìš°) ë”ì°í•˜ê²Œ ë§ì€ ë°˜ë³µì„ ìˆ˜í–‰í•˜ê²Œëœë‹¤.
    for (let i = 1; i <= m; i++) {
        const leftText = leftTokens[i - 1].text;
        for (let j = 1; j <= n; j++) {
            // ì£¼ê¸°ì ìœ¼ë¡œ yield í•´ì„œ ì·¨ì†Œìš”ì²­ì„ ë°›ì•„ì•¼í•¨.
            // performance.now()ëŠ” ë¯¸ì¹œê²Œ ì•„ë‹Œê°€ ì‹¶ì„ ì •ë„ë¡œ ë¬´ê±°ìš´ í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— ë˜ë„ë¡ ìì œ.
            // await new Promise(...) ì—­ì‹œ ìì£¼ ì‚¬ìš©í•˜ë©´ ì•ˆë¨
            // (i+j) % 0x4000 === 0 ì¼ ë•Œë§Œ ì‚¬ìš©í•˜ê¸°ë¡œ. ë¸Œë¼ìš°ì € jsì—”ì§„ì˜ ë¹„íŠ¸ì—°ì‚° ì†ë„ë¥¼ ë¯¿ì–´ë³¸ë‹¤ ã…‹
            if (ctx && ((i + j) & 16383) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 50) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (leftText === rightTokens[j - 1].text) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    let i = m;
    let j = n;
    const lcsIndices = [];
    while (i > 0 && j > 0) {
        if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
            lcsIndices.push({
                leftIndex: i - 1,
                rightIndex: j - 1,
            });
            i--;
            j--;
        }
        else if (dp[i - 1][j] >= dp[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }
    lcsIndices.reverse();
    return lcsIndices;
}
// ì •ë“¤ì—ˆë˜ diff í•¨ìˆ˜. íê¸°ì²˜ë¶„ ì˜ˆì •.
async function computeDiff(lhsTokens, rhsTokens, greedyMatch = false, ctx) {
    const entries = [];
    const lcs = await computeLCS(lhsTokens, rhsTokens, ctx);
    const lcsLength = lcs.length;
    const leftTokensLength = lhsTokens.length;
    const rightTokensLength = rhsTokens.length;
    if (leftTokensLength === 0 && rightTokensLength === 0) {
    }
    else if (leftTokensLength === 0) {
        entries.push({
            type: 2,
            left: {
                pos: 0,
                len: leftTokensLength,
                // empty: true,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
            },
        });
    }
    else if (rightTokensLength === 0) {
        entries.push({
            type: 1,
            left: {
                pos: 0,
                len: leftTokensLength,
            },
            right: {
                pos: 0,
                len: rightTokensLength,
                // empty: true,
            },
        });
    }
    else {
        let i = 0;
        let j = 0;
        let lcsIndex = 0;
        let iteration = 0;
        while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
            if (ctx && (iteration & 1023) === 0) {
                const now = performance.now();
                if (now - ctx.lastYield > 100) {
                    ctx.lastYield = now;
                    await new Promise((resolve) => setTimeout(resolve, 0));
                    if (ctx.cancel) {
                        throw new Error("cancelled");
                    }
                }
            }
            if (lcsIndex < lcsLength &&
                ((greedyMatch &&
                    lhsTokens[i].text === lhsTokens[lcs[lcsIndex].leftIndex].text &&
                    rhsTokens[j].text === rhsTokens[lcs[lcsIndex].rightIndex].text) ||
                    (i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex))) {
                entries.push({
                    type: 0,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                i++;
                j++;
                lcsIndex++;
                continue;
            }
            const lcsEntry = lcs[lcsIndex];
            while (i < leftTokensLength && // ìœ íš¨í•œ í† í° index
                (!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
                    (!greedyMatch && i < lcsEntry.leftIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
                    lhsTokens[i].text !== lhsTokens[lcsEntry.leftIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
            ) {
                entries.push({
                    type: 1,
                    left: {
                        pos: i,
                        len: 1,
                    },
                    right: {
                        pos: j,
                        len: 0,
                    },
                });
                i++;
            }
            while (j < rightTokensLength && // ìœ íš¨í•œ í† í° index
                (!lcsEntry || // ê³µí†µ sequenceê°€ ì—†ëŠ” ê²½ìš°
                    (!greedyMatch && j < lcsEntry.rightIndex) || // ì •í™•í•œ lcsIndexì—ë§Œ ë§¤ì¹­ì‹œí‚¤ëŠ” ê²½ìš°
                    rhsTokens[j].text !== rhsTokens[lcsEntry.rightIndex].text) // or í…ìŠ¤íŠ¸ê°€ ê°™ìœ¼ë©´ ë°”ë¡œ ì¤‘ë‹¨
            ) {
                entries.push({
                    type: 2,
                    left: {
                        pos: i,
                        len: 0,
                    },
                    right: {
                        pos: j,
                        len: 1,
                    },
                });
                j++;
            }
        }
    }
    return entries;
}
// ============================================================
// Histogram Algorithm
// ì¼ë‹¨ ì§€ê¸ˆì€ ì´ë†ˆì´ ë””í´íŠ¸
// ============================================================
async function runHistogramDiff(ctx) {
    const lhsTokens = ctx.leftTokens; // tokenize(ctx.leftText, ctx.options.tokenization);
    const rhsTokens = ctx.rightTokens; // tokenize(ctx.rightText, ctx.options.tokenization);
    // ctx.entries = [] as DiffEntry[];
    let leftAnchors = [];
    let rightAnchors = [];
    for (let i = 0; i < lhsTokens.length; i++) {
        if (lhsTokens[i].flags & 32768 /* TokenFlags.MANUAL_ANCHOR */) {
            leftAnchors.push(i);
        }
    }
    if (leftAnchors.length > 0) {
        for (let i = 0; i < rhsTokens.length; i++) {
            if (rhsTokens[i].flags & 32768 /* TokenFlags.MANUAL_ANCHOR */) {
                rightAnchors.push(i);
            }
        }
    }
    const matches = [];
    if (rightAnchors.length > 0) {
        let rightPos = 0;
        for (let l = 0; l < leftAnchors.length; l++) {
            const leftTokenIndex = leftAnchors[l];
            for (let r = rightPos; r < rightAnchors.length; r++) {
                const rightTokenIndex = rightAnchors[r];
                if (lhsTokens[leftTokenIndex].text === rhsTokens[rightTokenIndex].text) {
                    matches.push({ lhsIndex: leftTokenIndex, rhsIndex: rightTokenIndex });
                    rightPos = r + 1;
                    break;
                }
            }
        }
    }
    let prevLhs = 0;
    let prevRhs = 0;
    for (const match of matches) {
        const lhsAnchor = match.lhsIndex;
        const rhsAnchor = match.rhsIndex;
        if (prevLhs < lhsAnchor || prevRhs < rhsAnchor) {
            // console.log("diffCore", {
            // 	lhsTokens,
            // 	lhsLower: prevLhs,
            // 	lhsUpper: lhsAnchor,
            // 	rhsTokens,
            // 	rhsLower: prevRhs,
            // 	rhsUpper: rhsAnchor,
            // });
            await diffCore(ctx, lhsTokens, prevLhs, lhsAnchor, rhsTokens, prevRhs, rhsAnchor, findBestHistogramAnchor);
        }
        ctx.entries.push({
            type: 0,
            left: {
                pos: lhsAnchor,
                len: 1,
            },
            right: {
                pos: rhsAnchor,
                len: 1,
            },
        });
        prevLhs = lhsAnchor + 1;
        prevRhs = rhsAnchor + 1;
    }
    if (prevLhs < lhsTokens.length || prevRhs < rhsTokens.length) {
        // console.log("diffCore", {
        // 	lhsTokens,
        // 	lhsLower: prevLhs,
        // 	lhsUpper: lhsTokens.length,
        // 	rhsTokens,
        // 	rhsLower: prevRhs,
        // 	rhsUpper: rhsTokens.length,
        // });
        await diffCore(ctx, lhsTokens, prevLhs, lhsTokens.length, rhsTokens, prevRhs, rhsTokens.length, findBestHistogramAnchor);
    }
    // const rawEntries = await diffCore(ctx, lhsTokens, 0, lhsTokens.length, rhsTokens, 0, rhsTokens.length, findBestHistogramAnchor);
    // return postProcess(ctx, rawEntries, lhsTokens, rhsTokens);
    return ctx.entries;
}
// histogram diffì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ í•¨ìˆ˜
// ì–¼ë§ˆë‚˜ ê°’ì–´ì¹˜ ìˆëŠ” ê³µí†µ ì•µì»¤ë¥¼ ì°¾ëŠëƒê°€ ë§¤ìš° ì¤‘ìš”í•˜ê³  ê³ ë¡œ ê·¸ ê°’ì–´ì¹˜ë¥¼ ë§¤ê¸°ëŠ” ê¸°ì¤€ê³¼ ë°©ë²•ì´ ë˜ ë§¤ìš° ì¤‘ìš”í•¨
// ì—¬ëŸ¬ê°€ì§€ ìƒê°í•´ë³¼ ê²ƒë“¤ì´ ë§ì§€ë§Œ...
const findBestHistogramAnchor = function (lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper, ctx) {
    const diffOptions = ctx.options;
    const LENGTH_BIAS_FACTOR = diffOptions.lengthBiasFactor || 0.7; // ê¸¸ì´ê°€ ë„ˆë¬´ í¬ê²Œ ì˜í–¥ì„ ì£¼ëŠ” ê²½í–¥ì´ ìˆì–´ì„œ ì´ê±¸ë¡œ ì¡°ì ˆ
    const UNIQUE_BONUS = 1 / (diffOptions.uniqueMultiplier || 1 / 0.5);
    const CONTAINER_START_BONUS = 1 / (diffOptions.containerStartMultiplier || 1 / 0.85);
    const CONTAINER_END_BONUS = 1 / (diffOptions.containerEndMultiplier || 1 / 0.8);
    const LINE_START_BONUS = 1 / (diffOptions.lineStartMultiplier || 1 / 0.85);
    const LINE_END_BONUS = 1 / (diffOptions.lineEndMultiplier || 1 / 0.9);
    const SECTION_HEADING_BONUS = 1 / (diffOptions.sectionHeadingMultiplier || 1 / 0.75);
    //const FULL_LINE_BONUS = 0.85; nê·¸ë¨ì„ ì‚¬ìš©ì‹œ ì—¬ëŸ¬ë‹¨ì–´ê°€ ë§¤ì¹˜ë˜ëŠ” ê²½ìš° ì˜¤íˆë ¤ ë§ˆì§€ë§‰ ë‹¨ì–´ê°€ ë‹¤ìŒ ì¤„ë¡œ ë„˜ì–´ê°€ì„œ ë³´ë„ˆìŠ¤ë¥¼ ëª» ë°›ì„ ìˆ˜ê°€ ìˆë‹¤
    const useLengthBias = !!ctx.options.useLengthBias;
    const maxGram = ctx.options.maxGram || 1;
    const useMatchPrefix = ctx.options.whitespace === "ignore";
    const maxLen = useMatchPrefix ? Math.floor(maxGram * 1.5) : maxGram; //1=>1, 2=>3, 3=>4, 4=>6, 5=>7, 6=>9, 7=>10, 8=>12, 9=>13, 10=>15,...
    const delimiter = ctx.options.whitespace === "ignore" ? "" : "\u0000";
    const freq = {};
    for (let n = 1; n <= maxLen; n++) {
        for (let i = lhsLower; i <= lhsUpper - n; i++) {
            let key = lhsTokens[i].text;
            let failed = false;
            // if (!(lhsTokens[i].flags & NO_JOIN)) {
            for (let k = 1; k < n; k++) {
                // if (lhsTokens[i + k].flags & NO_JOIN) {
                // 	failed = true;
                // 	break;
                // }
                key += delimiter + lhsTokens[i + k].text;
            }
            // } else {
            // 	failed = n > 1;
            // }
            // if (!failed) {
            freq[key] = (freq[key] || 0) + 1;
            // }
        }
        for (let i = rhsLower; i <= rhsUpper - n; i++) {
            let key = rhsTokens[i].text;
            let failed = false;
            // if (!(rhsTokens[i].flags & NO_JOIN)) {
            for (let k = 1; k < n; k++) {
                // if (rhsTokens[i + k].flags & NO_JOIN) {
                // 	failed = true;
                // 	break;
                // }
                key += delimiter + rhsTokens[i + k].text;
            }
            // } else {
            // 	failed = n > 1;
            // }
            // if (!failed) {
            freq[key] = (freq[key] || 0) + 1;
            // }
        }
    }
    let best = null;
    for (let i = lhsLower; i < lhsUpper; i++) {
        const ltext1 = lhsTokens[i].text;
        // íŠ¹ìˆ˜ ì¼€ì´ìŠ¤
        // ê°•ì œë¡œ ë¬¸ì„œì˜ íŠ¹ì • ì§€ì ë¼ë¦¬ ë§¤ì¹­ì‹œí‚´. ë¬¸ì„œ êµ¬ì¡°ê°€ í•­ìƒ ë‚´ ë§˜ ê°™ì€ ê²ƒì´ ì•„ë‹ˆì•¼. ã… 
        // if (lhsTokens[i].flags & MANUAL_ANCHOR) {
        // 	for (let j = rhsLower; j < rhsUpper; j++) {
        // 		if (rhsTokens[j].text === ltext1) {
        // 			console.log("manual anchor", ltext1, i, j);
        // 			return {
        // 				lhsIndex: i,
        // 				lhsLength: 1,
        // 				rhsIndex: j,
        // 				rhsLength: 1,
        // 			};
        // 		}
        // 	}
        // }
        for (let j = rhsLower; j < rhsUpper; j++) {
            let li = i, ri = j;
            let lhsLen = 0, rhsLen = 0;
            let nGrams = 0;
            while (li < lhsUpper && ri < rhsUpper && lhsLen < maxLen && rhsLen < maxLen && nGrams < maxGram) {
                const ltext = lhsTokens[li].text;
                const rtext = rhsTokens[ri].text;
                if (ltext === rtext) {
                    // if (lhsTokens[li].flags & rhsTokens[ri].flags & MANUAL_ANCHOR) {
                    // 	return {
                    // 		lhsIndex: li,
                    // 		lhsLength: 1,
                    // 		rhsIndex: ri,
                    // 		rhsLength: 1,
                    // 	};
                    // }
                    li++;
                    ri++;
                    lhsLen++;
                    rhsLen++;
                    nGrams++;
                    continue;
                }
                if (useMatchPrefix && ltext.length !== rtext.length && ltext[0] === rtext[0]) {
                    const match = matchPrefixTokens(lhsTokens, li, lhsUpper, rhsTokens, ri, rhsUpper);
                    if (match) {
                        const matchedGrams = Math.min(match[0], match[1]);
                        if (lhsLen + match[0] <= maxLen && rhsLen + match[1] <= maxLen && nGrams + matchedGrams <= maxGram) {
                            li += match[0];
                            ri += match[1];
                            lhsLen += match[0];
                            rhsLen += match[1];
                            nGrams += matchedGrams;
                            continue;
                        }
                    }
                }
                break;
            }
            if (lhsLen > 0 && rhsLen > 0) {
                let frequency;
                let len;
                // let anchorText: string;
                if (lhsLen === 1) {
                    // anchorText = ltext1;
                    frequency = freq[ltext1] || 1;
                    len = ltext1.length;
                    // score = freq[ltext1] || 1;
                    // if (useLengthBias) {
                    // 	score += 1 / (ltext1.length + 1);
                    // }
                }
                else {
                    let key = lhsTokens[i].text;
                    len = key.length;
                    for (let k = 1; k < lhsLen; k++) {
                        const text = lhsTokens[i + k].text;
                        key += delimiter + text;
                        len += text.length;
                    }
                    // anchorText = key;
                    frequency = freq[key] || 1;
                    // score = (freq[key] || 1) / ((lhsLen + 1) * (len + 1));
                    // score = (freq[key] || 1) / (lhsLen * len + 1);
                    // score = (freq[key] || 1) / (len + 1);
                }
                let score = 0;
                score = useLengthBias ? frequency / (1 + Math.log(len + 1) * LENGTH_BIAS_FACTOR) : frequency;
                if (frequency === 1) {
                    score *= UNIQUE_BONUS;
                }
                let boundaryBonus = 1;
                // if (boundaryBonus > CONTAINER_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & CONTAINER_START) {
                // 	boundaryBonus = CONTAINER_START_BONUS;
                // }
                // if (boundaryBonus > CONTAINER_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & CONTAINER_END) {
                // 	boundaryBonus = CONTAINER_END_BONUS;
                // }
                // if (boundaryBonus > LINE_START_BONUS && lhsTokens[i].flags & rhsTokens[j].flags & LINE_START) {
                // 	boundaryBonus = LINE_START_BONUS;
                // }
                // if (boundaryBonus > LINE_END_BONUS && lhsTokens[i + lhsLen - 1].flags & rhsTokens[j + rhsLen - 1].flags & LINE_END) {
                // 	boundaryBonus = LINE_END_BONUS;
                // }
                score *= boundaryBonus;
                // if (lhsTokens[i].flags & rhsTokens[j].flags & SECTION_HEADING_MASK) {
                // 	// if ((lhsTokens[i].flags & SECTION_HEADING_MASK) !== 0) {
                // 	// 	// LEVEL1ì€ ë¬´ì‹œ. ë¬¸ì„œ êµ¬ì¡°ê°€ ì˜êµ¬ê°™ì€ ê²½ìš°ê°€ ë§ìŒ.
                // 	// } else {
                // 	// }
                // 	score *= SECTION_HEADING_BONUS;
                // }
                if (!best || score < best.score) {
                    best = {
                        lhsIndex: i,
                        lhsLength: lhsLen,
                        rhsIndex: j,
                        rhsLength: rhsLen,
                        score,
                        // anchorText,
                    };
                }
            }
        }
    }
    return best ?? null;
};
// ============================================================
// Helper functions
// ============================================================
// Divide and conquer!
// myers, histogram, patience ì•Œê³ ë¦¬ì¦˜ì— ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì¬ê·€í•¨ìˆ˜
// 1. ì–‘ í…ìŠ¤íŠ¸ë¥¼ ê³µí†µë˜ëŠ” ë¶€ë¶„(ì•µì»¤)ìœ¼ë¡œ ë¶„í• 
// 2. ë¶„í• ëœ ì˜ì—­ì— ëŒ€í•´ì„œ ì¬ê·€í˜¸ì¶œ
async function diffCore(ctx, leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, findAnchor, consumeDirections = 3) {
    if (lhsLower > lhsUpper || rhsLower > rhsUpper) {
        throw new Error("Invalid range");
    }
    // ì‚¬ì‹¤ ì´ê±¸ ì“°ë©´ ë¦¬í„´ê°’ì´ í•„ìš” ì—†ëŠ”ë°...
    // í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê³ ì¹˜ê¸° ê·€ì°®ì•„ì„œ ì¼ë‹¨ ë‚´ë¹„ë‘ .
    const entries = ctx.entries;
    const now = performance.now();
    if (now - ctx.lastYield > 100) {
        ctx.lastYield = now;
        await new Promise((resolve) => setTimeout(resolve, 0));
        if (ctx.cancel)
            throw new Error("cancelled");
    }
    // TODO
    // ê³µí†µ ë¶€ë¶„ì„ ìŠ¤í‚µí•˜ëŠ”ê±´ë° ë¬¸ì œëŠ” ì—¬ê¸°ì—ì„œ HEAD, TAILì„ ìŠ¤í‚µí•˜ê³ 
    // ì´í›„ì— diffCoreë¥¼ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•  ë•Œ ì•ìª½ ì ˆë°˜ì— ëŒ€í•´ì„œ HEADë¶€ë¶„, ë’¤ìª½ ì ˆë°˜ì— ëŒ€í•´ì„œ TAILë¶€ë¶„ì„ ë‹¤ì‹œ í•œë²ˆ ìŠ¤í‚µì„ ì‹œë„í•˜ê²Œ ëœë‹¤.
    // ë” ì´ìƒ ìŠ¤í‚µí•  ê²Œ ì—†ìœ¼ë‹ˆ ê²°ê³¼ì—ëŠ” ì°¨ì´ê°€ ì—†ê² ì§€ë§Œ ë¶ˆí•„ìš”í•œ ì‹œë„ë¥¼ ì•ˆí•˜ëŠ” ìª½ìœ¼ë¡œ ê°œì„ í•´ ë³¼ í•„ìš”ê°€ ìˆìŒ!
    // ìƒê°í•´ë³¼ ê²ƒ: ê³µí†µ prefix,suffixë¥¼ ìŠ¤í‚µí•˜ì§€ ì•Šì•˜ì„ ê²½ìš° ìŠ¤í‚µë˜ì§€ ì•Šì€ ë¶€ë¶„ì—ì„œ ë” ë‚˜ì€ ì•µì»¤ê°€ ë‚˜ì˜¬ í™•ë¥ ì´ ìˆë‹¤.
    // ê·¸ë ‡ì§€ë§Œ ìŠ¤í‚µí•˜ì§€ ì•Šìœ¼ë©´ ì„±ëŠ¥ ìƒ ì•„ì£¼ í° ë¬¸ì œê°€ ìƒê¹€!
    let skippedHead;
    let skippedTail;
    [lhsLower, lhsUpper, rhsLower, rhsUpper, skippedHead, skippedTail] = consumeCommonEdges(leftTokens, rightTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, ctx.options.tokenization === "word" ? ctx.options.whitespace : "normalize", consumeDirections);
    // 	entries.push(...skippedHead); ì´ë ‡ê²Œ ë„£ìœ¼ë©´ í­ë°œí•¨.
    for (const item of skippedHead) {
        entries.push(item);
    }
    // ì–‘ìª½ ëª¨ë‘ ë‚¨ì•„ìˆëŠ” ì˜ì—­ì´ ìˆëŠ” ê²½ìš° ê³µí†µ ì•µì»¤ë¥¼ ì°¾ì•„ë³¸ë‹¤!
    let anchor = null;
    if (lhsLower < lhsUpper &&
        rhsLower < rhsUpper &&
        (anchor = findAnchor(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper, ctx)) &&
        (anchor.lhsLength > 0 || anchor.rhsLength > 0) && // for safety! ì ì–´ë„ í•œìª½ì´ë¼ë„ ì˜ì—­ì„ ì¤„ì—¬ì•¼ ë¬´í•œë£¨í”„ ì•ˆ ìƒê¸¸ ë“¯?
        anchor.lhsIndex >= lhsLower &&
        anchor.lhsIndex + anchor.lhsLength <= lhsUpper &&
        anchor.rhsIndex >= rhsLower &&
        anchor.rhsIndex + anchor.rhsLength <= rhsUpper) {
        // console.debug("anchor:", anchor, lhsLower, lhsUpper, rhsLower, rhsUpper);
        await diffCore(ctx, leftTokens, lhsLower, anchor.lhsIndex, rightTokens, rhsLower, anchor.rhsIndex, findAnchor, 2);
        // ì˜ë„ì ìœ¼ë¡œ ì•µì»¤ ì˜ì—­ê¹Œì§€ í¬í•¨í•´ì„œ í˜¸ì¶œí•¨
        await diffCore(ctx, leftTokens, anchor.lhsIndex, lhsUpper, rightTokens, anchor.rhsIndex, rhsUpper, findAnchor, 1);
        // await diffCore(ctx, leftTokens, anchor.lhsIndex + anchor.lhsLength, lhsUpper, rightTokens, anchor.rhsIndex + anchor.rhsLength, rhsUpper, findAnchor, 1);
    }
    else {
        // ìœ íš¨í•œ ì•µì»¤ëŠ” ëª»ì°¾ì•˜ì§€ë§Œ ë‚¨ì•„ìˆëŠ” í† í°ë“¤ì´ ìˆë‹¤ë©´ diffë¡œ ì²˜ë¦¬
        if (lhsLower < lhsUpper || rhsLower < rhsUpper) {
            let type = 0;
            if (lhsLower < lhsUpper)
                type |= 1;
            if (rhsLower < rhsUpper)
                type |= 2;
            entries.push({
                type: type,
                left: {
                    pos: lhsLower,
                    len: lhsUpper - lhsLower,
                },
                right: {
                    pos: rhsLower,
                    len: rhsUpper - rhsLower,
                },
            });
        }
    }
    for (const item of skippedTail) {
        entries.push(item);
    }
    return entries;
}
// ê³µë°±ì„ ì™„ì „íˆ ë¬´ì‹œí•˜ëŠ” ê²½ìš° "ì•ˆë…• í•˜ì„¸ìš”" vs "ì•ˆë…•í•˜ì„¸ìš”"ëŠ” ê°™ë‹¤ê³  ì²˜ë¦¬í•´ì•¼í•˜ì§€ë§Œ
// ë‹¨ì–´ë‹¨ìœ„ í† í°ì¸ ê²½ìš° í† í° ëŒ€ í† í° ë¹„êµëŠ” ì‹¤íŒ¨í•  ìˆ˜ ë°–ì— ì—†ë‹¤.
// ë”°ë¼ì„œ ê° í† í°ì˜ ê¸€ìë¥¼ í•œë•€í•œë•€ ë§¤ì¹˜ì‹œì¼œë´ì•¼í•˜ê³  ì–‘ìª½ì—ì„œ í† í°ì´ ëë‚˜ëŠ” ì‹œì ê¹Œì§€ ëª¨ë“  ê¸€ìê°€ ë§¤ì¹˜ë˜ì—ˆë‹¤ë©´
// ê·¸ ëë‚˜ëŠ” ì‹œì ê¹Œì§€ì˜ í† í° ìˆ˜ë§Œí¼ consumeì„ í•¨.
function consumeCommonEdges(lhsTokens, rhsTokens, lhsLower, lhsUpper, rhsLower, rhsUpper, whitespace = "ignore", consumeDirections = 3) {
    const head = [];
    const tail = [];
    let matchedCount;
    // Prefix
    if (consumeDirections & 1) {
        while (lhsLower < lhsUpper && rhsLower < rhsUpper) {
            if (lhsTokens[lhsLower].text === rhsTokens[rhsLower].text) {
                head.push({
                    type: 0,
                    left: { pos: lhsLower, len: 1 },
                    right: { pos: rhsLower, len: 1 },
                });
                lhsLower++;
                rhsLower++;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsLower].text.length !== rhsTokens[rhsLower].text.length &&
                lhsTokens[lhsLower].text[0] === rhsTokens[rhsLower].text[0] &&
                (matchedCount = matchPrefixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                head.push({
                    type: 0,
                    left: {
                        pos: lhsLower,
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsLower,
                        len: matchedCount[1],
                    },
                });
                lhsLower += matchedCount[0];
                rhsLower += matchedCount[1];
            }
            else {
                break;
            }
        }
    }
    // Suffix
    if (consumeDirections & 2) {
        while (lhsUpper > lhsLower && rhsUpper > rhsLower) {
            if (lhsTokens[lhsUpper - 1].text === rhsTokens[rhsUpper - 1].text) {
                tail.push({
                    type: 0,
                    left: { pos: lhsUpper - 1, len: 1 },
                    right: { pos: rhsUpper - 1, len: 1 },
                });
                lhsUpper--;
                rhsUpper--;
            }
            else if (whitespace === "ignore" &&
                lhsTokens[lhsUpper - 1].text.length !== rhsTokens[rhsUpper - 1].text.length &&
                lhsTokens[lhsUpper - 1].text.at(-1) === rhsTokens[rhsUpper - 1].text.at(-1) &&
                (matchedCount = matchSuffixTokens(lhsTokens, lhsLower, lhsUpper, rhsTokens, rhsLower, rhsUpper))) {
                tail.push({
                    type: 0,
                    left: {
                        pos: lhsUpper - matchedCount[0],
                        len: matchedCount[0],
                    },
                    right: {
                        pos: rhsUpper - matchedCount[1],
                        len: matchedCount[1],
                    },
                });
                lhsUpper -= matchedCount[0];
                rhsUpper -= matchedCount[1];
            }
            else {
                break;
            }
        }
        tail.reverse();
    }
    return [lhsLower, lhsUpper, rhsLower, rhsUpper, head, tail];
}
function matchPrefixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsLower, j = rhsLower;
    let ci = 0, cj = 0;
    let lhsToken = leftTokens[i++], ltext = lhsToken.text, lhsLen = ltext.length;
    let rhsToken = rightTokens[j++], rtext = rhsToken.text, rhsLen = rtext.length;
    // if (lhsToken.flags & NO_JOIN_NEXT || rhsToken.flags & NO_JOIN_NEXT) {
    // 	// return false;
    // }
    while (true) {
        while (ci < lhsLen && cj < rhsLen) {
            if (ltext[ci++] !== rtext[cj++]) {
                return false;
            }
        }
        // ë¬¸ì ë¶ˆì¼ì¹˜ ì—†ì´ ì–‘ìª½ í† í°ì´ ë™ì‹œì— ëë‚œ ê²½ìš°
        if (ci === lhsLen && cj === rhsLen)
            return [i - lhsLower, j - rhsLower];
        if (ci === lhsLen) {
            if (i === lhsUpper)
                return false;
            if (lhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            lhsToken = leftTokens[i++];
            if (!lhsToken)
                return false;
            if (lhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            ltext = lhsToken.text;
            lhsLen = ltext.length;
            ci = 0;
        }
        if (cj === rhsLen) {
            if (j === rhsUpper)
                return false;
            if (rhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            rhsToken = rightTokens[j++];
            if (!rhsToken)
                return false;
            if (rhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            rtext = rhsToken.text;
            rhsLen = rtext.length;
            cj = 0;
        }
    }
}
function matchSuffixTokens(leftTokens, lhsLower, lhsUpper, rightTokens, rhsLower, rhsUpper) {
    if (lhsLower >= lhsUpper || rhsLower >= rhsUpper)
        return false;
    let i = lhsUpper - 1, j = rhsUpper - 1;
    let lhsToken = leftTokens[i--], ltext = lhsToken.text, rhsToken = rightTokens[j--], rtext = rhsToken.text;
    let ci = ltext.length - 1, cj = rtext.length - 1;
    // if (lhsToken.flags & NO_JOIN_PREV || rhsToken.flags & NO_JOIN_PREV) {
    // 	return false;
    // }
    while (true) {
        while (ci >= 0 && cj >= 0) {
            if (ltext[ci--] !== rtext[cj--]) {
                return false;
            }
        }
        if (ci < 0 && cj < 0)
            return [lhsUpper - i - 1, rhsUpper - j - 1];
        if (ci < 0) {
            if (i < lhsLower)
                return false;
            if (lhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            lhsToken = leftTokens[i--];
            if (!lhsToken)
                return false;
            if (lhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            ltext = lhsToken.text;
            ci = lhsToken.text.length - 1;
        }
        if (cj < 0) {
            if (j < rhsLower)
                return false;
            if (rhsToken.flags & 4096 /* TokenFlags.NO_JOIN_PREV */)
                return false;
            rhsToken = rightTokens[j--];
            if (!rhsToken)
                return false;
            if (rhsToken.flags & 8192 /* TokenFlags.NO_JOIN_NEXT */)
                return false;
            rtext = rhsToken.text;
            cj = rhsToken.text.length - 1;
        }
    }
}
//# sourceMappingURL=worker.js.map
</script>
    <style id="highlightStyle">
    </style>
<style>
:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--status-bar-height: 22px;
	font-size: 16px;
	--container-gap: 8px;
	--sidebar-width: 200px;
	--text-container-padding-block: 4px;
	--text-container-padding-inline: 4px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
	/* font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; */
}

.container {
	display: grid;
	/* grid-template-rows: var(--topbar-height) 1fr; */
	grid-template-columns: 1fr var(--sidebar-width);
	height: calc(100vh - var(--status-bar-height, 0px));
	overflow: hidden;
	gap: 0 var(--container-gap, 0px);
	position: relative;
}

#scrollSyncIndicator {
	position: absolute;
	left: calc(50% - 10px);
	z-index: 1000;
	top: calc(50% - 10px);
	width: 20px;
	height: 20px;
	pointer-events: none;
	display: none;
}

#progress {
	display: none;
	position: fixed;
	bottom: calc(20px + var(--status-bar-height, 0px));
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
	outline: 1px solid #ccc;
	outline-offset: 0px;
}

.mirror,
.editor {
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	/* font-family: "ë‹ì›€ì²´", monospace; */
	font-size: 14px;
	margin: 0;
	overflow-y: visible;
	/* white-space: pre-wrap; */
	word-break: break-all;
	overflow-wrap: anywhere;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
	/* scroll-margin: var(--scroll-margin); */
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
	color: #333;
}

#main > canvas {
	position: fixed;
	top: 0;
	left: 0;
	bottom: var(--status-bar-height, 0px);
	width: calc(100vw - var(--sidebar-width) - var(--container-gap, 0px));
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -1;
	will-change: transform; /* ì •í™•íˆ ë­˜í•˜ëŠ” ë†ˆì¸ì§€ ì•Œì•„ë´ì•¼í•¨ */
}

.editor-wrapper canvas {
	position: fixed;
	bottom: var(--status-bar-height, 0px);
	width: calc((100vw - var(--sidebar-width) - var(--container-gap, 0px)) / 2);
	height: calc(100vh - var(--status-bar-height, 0px));
	pointer-events: none;
	z-index: -2;
	will-change: transform; /* ì •í™•íˆ ë­˜í•˜ëŠ” ë†ˆì¸ì§€ ì•Œì•„ë´ì•¼í•¨ */
}

.editor-wrapper canvas.highlight {
	z-index: -1;
	opacity: 0.3;
}

.editor-wrapper:focus-within .editor {
	color: #000;
}

.mirror {
	background: hsl(0 0% 80% / 0.3);
	transition: background 0.3s ease, color 0.3s ease;
	z-index: -99;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: transparent;
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.edit .editor-wrapper:focus-within .mirror {
	background: transparent;
}

.aligned .editor {
	display: none;
}

.aligned .mirror {
	background: transparent;
	position: static;
	color: #ccc;
	background-color: #000;
	cursor: text;
	pointer-events: auto;
	caret-color: white;
}

.edit .mirror {
	height: unset !important;
}

.edit .mirror * {
	height: unset !important;
	color: unset !important;
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
	display: contents;
}

mark {
	background-color: inherit;
	color: inherit;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
}

mark:not(:empty) {
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-blockìœ¼ë¡œ ì•ˆí•´ë‘ë©´ ë†’ì´ 1pxì´ ëª¨ìë¥´ê²Œ ëœë‹¤. ë¬»ì§€ë§ˆ... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	left: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80% / 0.75);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
ê³µê°„ì„ ì „í˜€ ì°¨ì§€í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ visualì´ ìˆì–´ì•¼í•¨
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black
		repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror > div:has(mark) {
	background-color: hsl(0 75% 25% / 0.75);
}

/*
ì¤„(div)ì•ˆì— ë¸”ëŸ­ ì—˜ëŸ¬ë¨¼íŠ¸ë¥¼ ë„£ì–´ì„œ ê°•ì œë¡œ ì¤„ë°”ê¿ˆ íš¨ê³¼ë¥¼ ì£¼ì—ˆì„ ë•Œ
diffê°€ ì—†ëŠ” ê°€ìƒì˜ ì¤„ë„ diffê°€ ìˆëŠ” ì¤„ì²˜ëŸ¼ í‘œì‹œë˜ëŠ” ë¬¸ì œ.
ë‹¹ì—°í•œê±°ê¸´ í•œë°... ì‰¬ìš´ í•´ê²°ë°©ë²•ì´ ë– ì˜¤ë¥´ì§ˆ ì•ŠëŠ”ë‹¤!
ê³ ë¯¼ í•„ìš”
*/
.aligned hr[data-type="after"] + span {
	display: block;
	background: black;
}

.edit .mirror > div:has(mark) {
	background-color: hsl(0 100% 90%);
}

.aligned span {
	z-index: 1;
	background: transparent;
}
/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

#diffList .heading {
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	display: block;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

.identical #diffList:empty::after {
	content: "ğŸ‘¬";
	font-size: 128px;
	font-weight: bold;
	font-family: monospace;
	text-align: center;
	display: block;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList span:empty::after {
	content: "ğŸ’­";
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: monospace;
	content: "L";
	margin-right: 4px;
	opacity: 0.2;
	/* content: "â—€ï¸"; */
}

#diffList .left-visible .left::before,
#diffList .right-visible .right::before {
	opacity: 1;
}

#diffList .right::before {
	content: "R" !important;
	/* content: "â–¶ï¸" !important; */
}

.edit hr {
	height: 0 !important;
}

/* ì˜ë¯¸ì—†ë‹¤
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}

sup,
.sup {
	vertical-align: super;
	font-size: smaller;
}

sub,
.sub {
	vertical-align: sub;
	font-size: smaller;
}

.red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

.aligned .red {
	color: hsl(0 100% 40%) !important;
}

:root {
	--statusbar-bg: #f0f0f0;
	--statusbar-fg: #333;
	--statusbar-hover: rgba(0, 0, 0, 0.05);
}

body.aligned {
	--statusbar-bg: #1e1e1e;
	--statusbar-fg: #ccc;
	--statusbar-hover: rgba(255, 255, 255, 0.08);
}

#statusbar {
	height: 22px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	font-size: 12px;
	background: var(--statusbar-bg);
	color: var(--statusbar-fg);
	border-top: 1px solid rgba(0, 0, 0, 0.1);
	user-select: none;
	transition: background 0.3s ease, color 0.3s ease;
}

.status-left,
.status-right {
	display: flex;
	gap: 16px;
	align-items: center;
}

.status-item {
	display: flex;
	align-items: center;
	gap: 4px;
	white-space: nowrap;
}

.status-item.clickable {
	cursor: pointer;
	padding: 2px 6px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

.status-item.clickable:hover {
	background: var(--statusbar-hover);
}

.value {
	font-weight: 500;
}

#statusbar {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	height: var(--status-bar-height);
	background: #1e1e1e;
	color: #ccc;
}

.status-bar-left,
.status-bar-right,
.status-bar-center {
	display: flex;
	align-items: center;
}

.status-bar-left {
	justify-content: flex-start;
}

.status-bar-right {
	justify-content: flex-end;
}

.status-bar-center {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-grow: 1;
	text-align: center;
}

.status-item {
	margin: 0 10px;
}
.status-item.status-item.clickable {
	cursor: pointer;
}

.status-item.disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.status-item span {
	font-weight: bold;
}

#settingsPopup {
	position: absolute;
	background: #2d2d2d;
	color: #ccc;
	font-size: 12px;
	border: 1px solid #444;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
	min-width: 150px;
	z-index: -98;
	display: none;
}

.popup div {
	padding: 6px 12px;
	cursor: pointer;
}

.edit .mirror {
	display: none !important;
}

.aligned canvas {
	display: none !important;
}

.popup div:hover {
	background: #3a3a3a;
}

.hidden {
	display: none;
}

.popup .selected {
	background: #3a3a3a;
	color: #fff;
	font-weight: bold;
}

.editor-wrapper h6 {
	all: unset;
}

.edit .editor-wrapper h6 {
	all: unset;
	text-decoration-color: #000;
}

.aligned .editor-wrapper h6 {
	color: #fff;
	font-weight: bold;
}

/* .edit .mirror br {
	display: none;
}

.aligned .mirror {
	white-space: normal;
}

.aligned .mirror div {
	display: contents;;
} */

.editor table {
	border-collapse: collapse;
	border-spacing: 0;
}

.editor th,
.editor td {
	vertical-align: top;
	border: 1px solid #000;
	padding: var(--text-container-padding-block, 0px) var(--text-container-padding-inline, 0px);
	user-select: none;
}

.editor p:empty::before {
	content: "\00a0";
}

.color-red {
	color: hsl(0 100% 40%);
	font-weight: bold;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-size: inherit;
}

.bottom-padding {
	display: block;
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.editor {
	min-height: max(100%, var(--min-height, 100%));
}

.editor::after {
	content: "";
	display: block;
	height: var(--bottom-padding, 0px);

	background: red repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
}

.editor a {
	pointer-events: none;
	user-select: none;
}

.padtop::before {
	content: "";
	display: block;
	background: #fff repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.85) 0px, hsl(0 0% 88% / 0.85) 4px, hsl(0 0% 100% / 0.8) 4px, hsl(0 0% 100% / 0.8) 8px);
	height: var(--padding, 0px);
}

.diff-anchor:not(p .diff-anchor)::before {
	/* content: "";
	display: block;
	min-height: calc(1em * var(--line-height, 1.5));
	*/
}

.diff-anchor-block {
}

.diff-anchor-block::before {
	/* content: "";
	display: block;
	min-height: calc(1em * var(--line-height, 1.5)); */
}

@keyframes fadein {
	from {
		opacity: 0;
	}
	to {
		opacity: 1;
	}
}

@keyframes fadeout {
	from {
		opacity: 1;
	}
	to {
		opacity: 0;
	}
}

.fade-in {
	animation: fadein 0.5s forwards;
}

.fade-out {
	animation: fadeout 0.1s forwards;
}

canvas {
	transition: opacity 0.3s ease;
	opacity: 1;
}

.dimmed {
	opacity: 0.5;
}

.restored {
	transition: none !important; /* ë³µì› ì‹œ ì¦‰ì‹œ ë°˜ì˜ */
	opacity: 1;
}

</style>
</head>

<body>
    <div class="container">
        <main id="main">
            <div id="scrollSyncIndicator">ğŸ”—</div>
            <!--leftEditor will be here -->
            <!-- rightEditor will be here -->
        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>
    <div id="settingsPopup" class="popup hidden"></div>
    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        cssText += ` --line-height: ${LINE_HEIGHT};\n`;
        cssText += ` --topbar-height: ${TOPBAR_HEIGHT}px;\n`;
        cssText += ` --scroll-margin: ${SCROLL_MARGIN}px;\n`;
        cssText += ` --editor-padding: ${EDITOR_PADDING}px;\n`;
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script>"use strict";
const DiffSeek = (function () {
    let _activeEditor = null;
    let _lastFocusedEditor = null;
    let _lastScrolledEditor = null;
    let _currentlyScrollingEditor = null;
    let _preventScrollSync = false;
    let _currentDiffIndex = -1;
    let _syncEditor = false;
    let _resetCurrentlyScrollingEditorId = null;
    // let _diffResult: DiffResponse | null = null;
    let _diffContext = { done: false, reqId: 0 };
    let _outputOptions = {
        // ì–´ì°¨í”¼ ë‚˜ë§Œ ì“°ëŠ” ê¸°ëŠ¥ì¼í…Œë‹ˆ
        leftLabel: "ëŒ€ë¹„í‘œ",
        rightLabel: "ì „ë¬¸",
        htmlFormat: "div",
        textFormat: 0,
    };
    let _copyMode = "raw";
    let _lastNonRawCopyMode = "compare";
    let _diffListItemElements = [];
    let _aligned = true;
    let _renderPending = false;
    const _anchors = [];
    const _leftBottomPadding = document.createElement("A");
    _leftBottomPadding.contentEditable = "false";
    _leftBottomPadding.className = "bottom-padding";
    const _rightBottomPadding = document.createElement("A");
    _rightBottomPadding.contentEditable = "false";
    _rightBottomPadding.className = "bottom-padding";
    // ì •ë§ ì§€ì €ë¶„í•œ ì½”ë“œ ì‹œì‘
    const _diffOptions = (function (defaultValues) {
        let _diffOptions = { ...defaultValues };
        function setValue(key, value) {
            if (_diffOptions[key] !== value) {
                _diffOptions[key] = value;
                computeDiff();
            }
        }
        return {
            get algorithm() {
                return _diffOptions.algorithm;
            },
            set algorithm(value) {
                if (value !== "histogram" && value !== "lcs") {
                    throw new Error("Invalid algorithm: " + value);
                }
                setValue("algorithm", value);
            },
            get tokenization() {
                return _diffOptions.tokenization;
            },
            set tokenization(value) {
                if (value !== "char" && value !== "word" && value !== "line") {
                    throw new Error("Invalid tokenization: " + value);
                }
                setValue("tokenization", value);
            },
            get whitespace() {
                return _diffOptions.whitespace;
            },
            set whitespace(value) {
                if (value !== "ignore" && value !== "normalize") {
                    throw new Error("Invalid whitespace handling: " + value);
                }
                setValue("whitespace", value);
            },
            get greedyMatch() {
                return !!_diffOptions.greedyMatch;
            },
            set greedyMatch(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid greedyMatch: " + value);
                }
                setValue("greedyMatch", !!value);
            },
            get useLengthBias() {
                return !!_diffOptions.useLengthBias;
            },
            set useLengthBias(value) {
                if (value !== true && value !== false) {
                    throw new Error("Invalid useLengthBias: " + value);
                }
                setValue("useLengthBias", !!value);
            },
            get maxGram() {
                return _diffOptions.maxGram;
            },
            set maxGram(value) {
                if (value < 1) {
                    throw new Error("Invalid maxGram: " + value);
                }
                setValue("maxGram", value);
            },
            get lengthBiasFactor() {
                return _diffOptions.lengthBiasFactor;
            },
            set lengthBiasFactor(value) {
                if (value <= 0) {
                    throw new Error("Invalid lengthBiasFactor: " + value);
                }
                setValue("lengthBiasFactor", value);
            },
            get sectionHeadingMultiplier() {
                return _diffOptions.sectionHeadingMultiplier;
            },
            set sectionHeadingMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid sectionHeadingMultiplier: " + value);
                }
                setValue("sectionHeadingMultiplier", value);
            },
            get lineStartMultiplier() {
                return _diffOptions.lineStartMultiplier;
            },
            set lineStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineStartMultiplier: " + value);
                }
                setValue("lineStartMultiplier", value);
            },
            get lineEndMultiplier() {
                return _diffOptions.lineEndMultiplier;
            },
            set lineEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid lineEndMultiplier: " + value);
                }
                setValue("lineEndMultiplier", value);
            },
            get uniqueMultiplier() {
                return _diffOptions.uniqueMultiplier;
            },
            set uniqueMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid uniqueMultiplier: " + value);
                }
                setValue("uniqueMultiplier", value);
            },
            get containerStartMultiplier() {
                return _diffOptions.containerStartMultiplier;
            },
            set containerStartMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid containerStartMultiplier: " + value);
                }
                setValue("containerStartMultiplier", value);
            },
            get containerEndMultiplier() {
                return _diffOptions.containerEndMultiplier;
            },
            set containerEndMultiplier(value) {
                if (value <= 0) {
                    throw new Error("Invalid containerEndMultiplier: " + value);
                }
                setValue("containerEndMultiplier", value);
            },
        };
    })({
        algorithm: "histogram",
        tokenization: "word",
        whitespace: "ignore",
        greedyMatch: false,
        useLengthBias: true,
        maxGram: 4,
        lengthBiasFactor: 0.7,
        containerStartMultiplier: 1 / 0.85,
        containerEndMultiplier: 1 / 0.9,
        sectionHeadingMultiplier: 1 / 0.75,
        lineStartMultiplier: 1 / 0.9,
        lineEndMultiplier: 1 / 0.95,
        uniqueMultiplier: 1 / 0.6667,
    });
    const mainContainer = document.getElementById("main");
    // const leftEditor = createEditor(mainContainer, "left", getEditorCallbacks("left"));
    // const rightEditor = createEditor(mainContainer, "right", getEditorCallbacks("right"));
    const leftEditor = new Editor2(mainContainer, "left", getEditorCallbacks("left"));
    const rightEditor = new Editor2(mainContainer, "right", getEditorCallbacks("right"));
    const diffCanvas = document.createElement("canvas");
    diffCanvas.id = "diffCanvas";
    mainContainer.appendChild(diffCanvas);
    const diffCanvasCtx = diffCanvas.getContext("2d");
    const highlightCanvas = document.createElement("canvas");
    highlightCanvas.id = "highlightCanvas";
    mainContainer.appendChild(highlightCanvas);
    const body = document.querySelector("body");
    const diffList = document.getElementById("diffList");
    const highlightStyle = document.getElementById("highlightStyle");
    const progress = document.getElementById("progress");
    const scrollSyncIndicator = document.getElementById("scrollSyncIndicator");
    const alignmentStyleElement = document.createElement("style");
    document.head.appendChild(alignmentStyleElement);
    const editorContentsChanged = {
        left: true,
        right: true,
    };
    const renderer = createRenderer(mainContainer, leftEditor, rightEditor, {
        onDiffVisibilityChanged,
    });
    function onDiffVisibilityChanged(editorName, shown, hidden) { }
    function onSelectionChanged() {
        if (true)
            return;
        // const selection = window.getSelection();
        // if (selection && selection.rangeCount > 0) {
        // 	const range = selection.getRangeAt(0);
        // 	let editor: Editor2 | null = null;
        // 	if (leftEditor.wrapper.contains(range.commonAncestorContainer)) {
        // 		editor = leftEditor;
        // 	} else if (rightEditor.wrapper.contains(range.commonAncestorContainer)) {
        // 		editor = rightEditor;
        // 	} else {
        // 		console.log("Selection changed outside editors:", range, range.toString());
        // 	}
        // 	if (editor) {
        // 		const [startTokenIndex, endTokenIndex] = editor.findTokenOverlapIndices(range);
        // 		if (startTokenIndex >= 0 && endTokenIndex > startTokenIndex) {
        // 			const [otherStartTokenIndex, otherEndTokenIndex] = mapTokenRangeToOtherSide(
        // 				_diffContext.rawEntries!,
        // 				editor === leftEditor ? "left" : "right",
        // 				startTokenIndex,
        // 				endTokenIndex
        // 			);
        // 			console.debug("Selection changed:", startTokenIndex, endTokenIndex, " >>>", otherStartTokenIndex, otherEndTokenIndex);
        // 			if (otherStartTokenIndex >= 0) {
        // 				const otherEditor = editor === leftEditor ? rightEditor : leftEditor;
        // 				const otherStartToken = otherEditor.tokens[otherStartTokenIndex];
        // 				const otherEndToken = otherEditor.tokens[otherEndTokenIndex - 1];
        // 				if (otherStartToken && otherEndToken) {
        // 					const otherRange = document.createRange();
        // 					otherRange.setStart(otherStartToken.range.startContainer, otherStartToken.range.startOffset);
        // 					otherRange.setEnd(otherEndToken.range.endContainer, otherEndToken.range.endOffset);
        // 					renderer.setSelectionHighlight(otherRange);
        // 					return;
        // 				}
        // 			}
        // 		}
        // 	}
        // }
        // renderer.setSelectionHighlight(null);
    }
    function getEditorCallbacks(editorName) {
        const pendingDiffVisibilities = new Map();
        let updateDiffVisilitiesPending = false;
        //const editor = editorName === "left" ? leftEditor : rightEditor;
        return {
            onContentChanged: function () {
                editorContentsChanged[editorName] = true;
                onSelectionChanged();
                computeDiff();
            },
            onRender() {
                //alignAnchors();
            },
            onScroll(scrollTop, _) {
                // updateCanvas();
                if (_preventScrollSync) {
                    return;
                }
                const editor = editorName === "left" ? leftEditor : rightEditor;
                const otherEditor = editor === leftEditor ? rightEditor : leftEditor;
                otherEditor.scrollTop = scrollTop;
                let flags = 1 /* RenderFlags.Scroll */;
                if (editorName === "left") {
                    flags |= 8 /* RenderFlags.LEFT_EDITOR */;
                }
                else {
                    flags |= 16 /* RenderFlags.RIGHT_EDITOR */;
                }
                renderer.markDirty(flags);
                render();
            },
            // í˜„ì¬ í™”ë©´ ìƒì— ë³´ì´ëŠ” diff ì•„ì´í…œë“¤.
            onDiffVisibilityChanged: (entries) => {
                for (const entry of entries) {
                    const diffIndex = entry.item;
                    pendingDiffVisibilities.set(diffIndex, entry.isVisible);
                }
                if (!updateDiffVisilitiesPending) {
                    updateDiffVisilitiesPending = true;
                    requestAnimationFrame(() => {
                        updateDiffVisilitiesPending = false;
                        for (const [diffIndex, visible] of pendingDiffVisibilities) {
                            const listItem = _diffListItemElements[diffIndex];
                            if (listItem) {
                                const button = listItem.firstElementChild;
                                button.classList.toggle(editorName + "-visible", visible);
                            }
                        }
                        pendingDiffVisibilities.clear();
                    });
                }
            },
        };
    }
    const resizeObserver = new ResizeObserver(() => {
        renderer.updateLayout();
    });
    resizeObserver.observe(mainContainer);
    function createWorker() {
        // ë³´ì•ˆ ìƒ new Worker("worker.js")ëŠ” ì‹¤í–‰ ì•ˆë¨.
        let workerURL;
        const scriptElement = document.getElementById("worker.js");
        const workerCode = scriptElement.textContent;
        if (workerCode.length < 10) {
            workerURL = scriptElement.src; // "./dist/worker.js";
        }
        else {
            const blob = new Blob([workerCode], { type: "application/javascript" });
            workerURL = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerURL);
        return worker;
    }
    const { computeDiff } = (function () {
        const worker = createWorker();
        let _reqId = 0;
        let computeDiffTimeoutId = null;
        function* computeDiffGenerator(ctx) {
            let idleDeadline = yield ctx;
            const request = {
                type: "diff",
                reqId: ctx.reqId,
                options: ctx.diffOptions,
                leftTokens: null,
                rightTokens: null,
            };
            const leftRichTokens = leftEditor.tokens;
            const rightRichTokens = rightEditor.tokens;
            if (editorContentsChanged.left) {
                const leftTokens = new Array(leftEditor.tokens.length);
                for (let i = 0; i < leftEditor.tokens.length; i++) {
                    const richToken = leftRichTokens[i];
                    leftTokens[i] = {
                        text: richToken.text,
                        flags: richToken.flags,
                    };
                }
                request.leftTokens = leftTokens;
                if (idleDeadline.timeRemaining() <= 1) {
                    idleDeadline = yield;
                }
            }
            if (editorContentsChanged.right) {
                const rightTokens = new Array(rightEditor.tokens.length);
                for (let i = 0; i < rightEditor.tokens.length; i++) {
                    const richToken = rightRichTokens[i];
                    rightTokens[i] = {
                        text: richToken.text,
                        flags: richToken.flags,
                    };
                }
                request.rightTokens = rightTokens;
                if (idleDeadline.timeRemaining() <= 1) {
                    idleDeadline = yield;
                }
            }
            console.debug("diff request:", request);
            worker.postMessage(request);
        }
        function computeDiff() {
            if (computeDiffTimeoutId) {
                cancelIdleCallback(computeDiffTimeoutId);
                //clearTimeout(computeDiffTimeoutId);
            }
            _currentDiffIndex = -1;
            body.classList.add("computing");
            progress.textContent = "...";
            const ctx = (_diffContext = {
                reqId: ++_reqId, //overflow ë˜ëŠ” ìˆœê°„ ì§€êµ¬ ë©¸ë§
                // leftText: leftText,
                // rightText: rightText,
                diffOptions: { ..._diffOptions },
                done: false,
                processTime: 0,
                leftTokens: leftEditor.tokens,
                rightTokens: rightEditor.tokens,
            });
            const generator = computeDiffGenerator(ctx);
            const step = (idleDeadline) => {
                computeDiffTimeoutId = null;
                const { done } = generator.next(idleDeadline);
                if (!done && ctx === _diffContext) {
                    computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
                }
            };
            computeDiffTimeoutId = requestIdleCallback(step, { timeout: COMPUTE_DEBOUNCE_TIME });
        }
        worker.onmessage = function (e) {
            const data = e.data;
            console.debug("message received:", e);
            if (data.type === "diff") {
                if (data.reqId === _reqId) {
                    body.classList.remove("computing");
                    _diffContext.rawEntries = data.diffs;
                    update(_diffContext);
                    _diffContext.done = true;
                    _diffContext.processTime = data.processTime;
                    onDiffComputed(_diffContext);
                }
            }
            else if (data.type === "start") {
                progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
            }
        };
        function onDiffComputed(diffContext) {
            // leftEditor.update(diffContext);
            // rightEditor.update(diffContext);
            // calculateDiffRects();
            // leftEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            // rightEditor.update({ diffs: diffContext.diffs!, anchors: diffContext.anchors!, headings: diffContext.headings! });
            // updateDiffList();
        }
        return { computeDiff };
    })();
    // function restoreSelectionRange({ editor, startOffset, endOffset }: { editor: Editor; startOffset: number; endOffset: number }) {
    // 	if (editor) {
    // 		editor.selectTextRange(startOffset, endOffset);
    // 	}
    // }
    let resetHighlightId = null;
    function highlightDiff(diffIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `mark[data-diff="${diffIndex}"], mark[data-diff="${diffIndex}"]::after { 
	box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
	animation: highlightAnimation 0.3s linear 3; 
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 3000);
    }
    function highlightHeading(headingIndex) {
        if (resetHighlightId !== null) {
            clearTimeout(resetHighlightId);
        }
        highlightStyle.textContent = `[data-heading="${headingIndex}"] { 
	text-decoration-line: underline !important;
	}`;
        resetHighlightId = setTimeout(() => {
            highlightStyle.textContent = "";
        }, 2000);
    }
    document.addEventListener("mouseover", (e) => {
        if (e.target.dataset.diff !== undefined) {
            const diff = Number(e.target.dataset.diff);
            // highlightDiff(diff);
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            const heading = Number(e.target.dataset.heading);
            highlightHeading(heading);
        }
    });
    document.addEventListener("mouseout", (e) => {
        if (e.target.dataset.diff !== undefined) {
            // const diff = Number((e.target as HTMLElement).dataset.diff);
            // highlightStyle.textContent = "";
            return;
        }
        if (e.target.dataset.heading !== undefined) {
            highlightStyle.textContent = "";
            if (resetHighlightId !== null) {
                clearTimeout(resetHighlightId);
            }
        }
    });
    document.addEventListener("selectionchange", (e) => {
        onSelectionChanged();
    });
    // syncScrollToggle.addEventListener("click", () => {
    // 	toggleSyncScroll();
    // });
    // alignedModeToggle.addEventListener("click", () => {
    // 	if (_alignedMode) {
    // 		disableAlignedMode();
    // 	} else {
    // 		enableAlignedMode();
    // 	}
    // });
    function toggleSyncScroll() {
        _syncEditor = !_syncEditor;
    }
    document.addEventListener("copy", (e) => {
        if (_diffContext.done === false) {
            return;
        }
        if (true) {
            return;
        }
        // const selection = window.getSelection();
        // if (!selection || selection.isCollapsed) return;
        // const range = selection.getRangeAt(0);
        // const editor = leftEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? leftEditor
        // 	: rightEditor.wrapper.contains(range.commonAncestorContainer)
        // 	? rightEditor
        // 	: null;
        // if (editor === null) {
        // 	return;
        // }
        // const [startOffset, endOffset] = editor.getTextSelectionRange();
        // if (startOffset === null || endOffset === null) return;
        // if (_copyMode === "raw" && !_alignedMode) {
        // 	return;
        // }
        // e.preventDefault();
        // const text = editor.text;
        // const tokens = editor === leftEditor ? _diffContext.leftTokens! : _diffContext.rightTokens!;
        // const otherTokens = editor === leftEditor ? _diffContext.rightTokens! : _diffContext.leftTokens!;
        // const rawEntries = _diffContext.rawEntries!;
        // const sideKey = editor === leftEditor ? "left" : "right";
        // const otherSideKey = sideKey === "left" ? "right" : "left";
        // const diffs = _diffContext.diffs!;
        // if (_copyMode === "raw") {
        // 	const plain = editor.text.slice(startOffset, endOffset);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else if (_copyMode === "compare") {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const [mappedStartIndex, mappedEndIndex] = mapTokenRangeToOtherSide(rawEntries, sideKey, startIndex, endIndex);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const otherStartToken = otherTokens[mappedStartIndex];
        // 	const otherEndToken = otherTokens[mappedEndIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const otherStartPos = otherStartToken?.pos ?? 0;
        // 	const otherEndPos = otherEndToken ? otherEndToken.pos + otherEndToken.len : otherStartPos;
        // 	const leftRuns = getTextRuns(
        // 		"left",
        // 		leftEditor.text,
        // 		{ diffs },
        // 		sideKey === "left" ? startPos : otherStartPos,
        // 		sideKey === "left" ? endPos : otherEndPos
        // 	);
        // 	const rightRuns = getTextRuns(
        // 		"right",
        // 		rightEditor.text,
        // 		{ diffs },
        // 		sideKey === "right" ? startPos : otherStartPos,
        // 		sideKey === "right" ? endPos : otherEndPos
        // 	);
        // 	const html = buildOutputHTML(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	const plain = buildOutputPlainText(leftEditor.text, leftRuns, rightEditor.text, rightRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // } else {
        // 	const [startIndex, endIndex] = getSelectedTokenRange(tokens, startOffset, endOffset);
        // 	const startToken = tokens[startIndex];
        // 	const endToken = tokens[endIndex - 1];
        // 	const startPos = startToken?.pos ?? 0;
        // 	const endPos = endToken ? endToken.pos + endToken.len : startPos;
        // 	const textRuns = getTextRuns(sideKey, leftEditor.text, { diffs }, startPos, endPos);
        // 	const html = buildOutputHTMLFromRuns(text, textRuns, _outputOptions);
        // 	const plain = buildOutputPlainTextFromRuns(text, textRuns, _outputOptions);
        // 	e.clipboardData?.setData("text/html", html);
        // 	e.clipboardData?.setData("text/plain", plain);
        // }
    });
    document.addEventListener("keydown", (e) => {
        // ì–´ëŠ ë‹¨ì¶•í‚¤ë¥¼ ì¨ì•¼ ì˜ì¼ë‹¤ê³  ì†Œë¬¸ë‚˜ëƒ?
        if (e.key === "F2") {
            e.preventDefault();
            if (e.shiftKey) {
                toggleSyncScroll();
                return;
            }
            return;
        }
        if (e.key === "F4") {
            e.preventDefault();
            if (_copyMode === "raw") {
                _copyMode = _lastNonRawCopyMode;
            }
            else {
                _lastNonRawCopyMode = _copyMode;
                _copyMode = "raw";
            }
            return;
        }
        if (e.key === "F8") {
            _diffOptions.whitespace = _diffOptions.whitespace === "ignore" ? "normalize" : "ignore";
        }
        // ê¸°ë³¸ì ìœ¼ë¡œ ë¸Œë¼ìš°ì €ì˜ ì²«ë²ˆì§¸ íƒ­, ë‘ë²ˆì§¸ íƒ­ì„ ì„ íƒí•˜ëŠ” ë‹¨ì¶•í‚¤ì¸ë°...
        // ë¸Œë¼ìš°ì €ì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë‹¨ì¶•í‚¤ë¥¼ ë®ì–´ì“°ëŠ” ê±´ ì •ë§ ëª»ëœ ì§“ì´ê¸´ í•œë°...
        // ì‚¬ìš©ìì˜ ì˜ë„ë¥¼ ë¬´ì‹œí•´ë²„ë¦´ ìˆ˜ ìˆëŠ” ì•„ì£¼ ë‚˜ìœ ë‹¨ì¶•í‚¤ì§€ë§Œ... ì¸í„°ë„·ë„ ì•ˆë˜ëŠ” ì»´ì—ì„œ ëˆ„ê°€ ì—£ì§€ì— íƒ­ì„ ì—¬ëŸ¬ê°œ ì—´ì–´ë†“ê³  ì“¸ê¹Œ ì‹¶ë‹¤.
        if (e.ctrlKey && (e.key === "1" || e.key === "2")) {
            e.preventDefault();
            const editor = e.key === "1" ? leftEditor : rightEditor;
            editor.editor.focus();
            return;
        }
        // diff cycling
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
            e.preventDefault();
            if (_diffContext.done) {
                const diffs = _diffContext.diffs;
                if (!diffs || diffs.length === 0) {
                    return;
                }
                _currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
                if (_currentDiffIndex < 0) {
                    _currentDiffIndex = diffs.length - 1;
                }
                if (_currentDiffIndex >= diffs.length) {
                    _currentDiffIndex = 0;
                }
                scrollToDiff(_currentDiffIndex);
                highlightDiff(_currentDiffIndex);
            }
        }
    });
    diffList.addEventListener("click", (e) => {
        const diffIndex = Number(e.target.dataset.diff);
        if (!isNaN(diffIndex)) {
            _currentDiffIndex = diffIndex;
            scrollToDiff(diffIndex);
            return;
        }
        const headingIndex = Number(e.target.dataset.heading);
        if (!isNaN(headingIndex)) {
            scrollToHeading(headingIndex);
            return;
        }
    });
    function scrollToDiff(diffIndex) {
        _preventScrollSync = true;
        // leftEditor.scrollToDiff(diffIndex);
        // rightEditor.scrollToDiff(diffIndex);
        requestAnimationFrame(() => {
            _preventScrollSync = false;
        });
    }
    function scrollToHeading(headingIndex) { }
    for (const editor of [leftEditor, rightEditor]) {
        function onFocus() {
            _activeEditor = _lastFocusedEditor = editor;
        }
        function onBlur() {
            _activeEditor = null;
        }
        editor.editor.addEventListener("focus", onFocus);
        editor.editor.addEventListener("blur", onBlur);
        editor.editor.addEventListener("keydown", (e) => {
            if (e.key === " " && e.ctrlKey) {
                // ì—ë””í„°ì—ì„œ í¸ì§‘ ì¤‘ ë°˜ëŒ€ìª½ ì—ë””í„°ì˜ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¥¼ í˜„ì¬ ì—ë””í„°ì˜ ë‚´ìš©ì— ë§ì¶”...ë ¤ê³  ì‹œë„ë§Œ í•´ ë´„.
                return;
            }
            if (e.ctrlKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
                // ì´ì •ë„ ìŠ¤í¬ë¡¤ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë˜ì–´ë˜ëŠ”ê±° ì•„ë‹ˆì•¼?? ì´ ê¸°ëŠ¥ ë‚˜ë§Œ ì“°ë‚˜?
                // ìŠ¤í¬ë¡¤ ì˜ì—­ ë°–ì˜ ë”± í•œë‘ì¤„! ë”± ê·¸ì •ë„ë§Œ ë³´ë©´ ëœë‹¤ ì‹¶ì„ ë•Œ?
                // í…ìŠ¤íŠ¸ì»¤ì„œê°€ ì¤‘ì•™ ë¶€ë¶„ì— ìœ„ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë§ˆìŒì´ ë†“ì´ì§€ ì•Šì•„ì„œ ì§€ê¸ˆ ë‹¹ì¥ ìœ„ì•„ë˜ë¡œ ì¡°ê¸ˆ ìŠ¤í¬ë¡¤ í•´ì•¼ë§Œ í•  ë•Œ!!!!
                e.preventDefault();
                const fontSize = parseFloat(getComputedStyle(editor.editor).fontSize);
                const delta = (e.key === "ArrowUp" ? -LINE_HEIGHT : LINE_HEIGHT) * 2 * fontSize;
                console.log("delta:", delta);
                editor.scrollByOffset(delta);
            }
            if (e.key === "Escape") {
                const sel = window.getSelection();
                if (sel)
                    sel.removeAllRanges(); // ì„ íƒ í•´ì œ
            }
        });
        // editor.editor.addEventListener("click", (e) => {
        // 	if (e.ctrlKey) {
        // 		enableAlignedMode(true);
        // 	}
        // });
        function onClick(e) {
            if (e.altKey) {
                // const [start, end] = editor.getTextSelectionRange();
                // if (start !== null && end !== null && start === end) {
                // 	_activeEditor = editor;
                // 	disableAlignedMode();
                // 	setTimeout(() => {
                // 		//syncScrollPosition(editor);
                // 		document.execCommand("insertText", false, " " + MANUAL_ANCHOR1 + " ");
                // 		requestAnimationFrame(() => {
                // 			editor.updateText();
                // 		});
                // 	}, 0);
                // 	return;
                // }
            }
        }
        editor.editor.addEventListener("click", onClick);
    }
    let _resizeCancelId = null;
    function alignAnchors(callingEditor) {
        if (_resizeCancelId !== null) {
            cancelIdleCallback(_resizeCancelId);
            //clearTimeout(_resizeCancelId);
        }
        // _leftBottomPadding.remove();
        // _rightBottomPadding.remove();
        _preventScrollSync = true;
        let changed = false;
        const MAX_ITERATIONS = 10;
        let iteration = 0;
        do {
            changed = false;
            for (let i = 0; i < _anchors.length; i++) {
                const leftScrollTop = leftEditor.wrapper.scrollTop;
                const rightScrollTop = rightEditor.wrapper.scrollTop;
                const entry = _anchors[i];
                const { leftEl, rightEl } = entry;
                let leftY;
                let rightY;
                let delta;
                // leftY = leftEl.getBoundingClientRect().y + leftEditor.wrapper.scrollTop;
                // rightY = rightEl.getBoundingClientRect().y + rightEditor.wrapper.scrollTop;
                // delta = Math.round(leftY - rightY);
                // reset current padding. ì´ê±¸ í•˜ì§€ ì•Šìœ¼ë©´ íŒ¨ë”©ì´ ì¤„ì–´ë“¤ì§€ ì•Šê³  ê³„ì† ìŒ“ì—¬ë‚˜ê°€ê¸°ë§Œ í•¨.
                leftEl.classList.remove("padtop");
                rightEl.classList.remove("padtop");
                // padtop í´ë˜ìŠ¤ê°€ ìˆì–´ì•¼ --padding ê°’ì´ ì ìš©ì´ ë˜ë¯€ë¡œ --padding ê°’ì„ ì§€ìš¸ í•„ìš”ëŠ” ì—†ì„ ê²ƒ ê°™ì§€ë§Œ
                // ì§€ìš°ì§€ ì•Šê³  ëƒ…ë‘ë©´ ë‹¹ìµœ ì´í•´ê°€ ì•ˆë˜ëŠ” ê´´ìƒí•œ rectê°€ íŠ€ì–´ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
                leftEl.style.removeProperty("--padding");
                rightEl.style.removeProperty("--padding");
                void leftEl.offsetHeight; // force reflow
                void rightEl.offsetHeight; // force reflow
                leftY = leftEl.getBoundingClientRect().y + leftEditor.wrapper.scrollTop;
                rightY = rightEl.getBoundingClientRect().y + rightEditor.wrapper.scrollTop;
                // console.log("[CURRENT] Left Y:", leftY, "Right Y:", rightY);
                delta = Math.round(leftY - rightY);
                if (delta !== 0) {
                    delta = Math.round(leftY - rightY);
                    if (delta > 0) {
                        rightEl.classList.add("padtop");
                        leftEl.classList.remove("padtop");
                        rightEl.style.setProperty("--padding", `${delta}px`);
                        changed = true;
                    }
                    else if (delta < 0) {
                        // pad left
                        leftEl.classList.add("padtop");
                        rightEl.classList.remove("padtop");
                        leftEl.style.setProperty("--padding", `${-delta}px`);
                        changed = true;
                    }
                }
                if (entry.delta !== delta) {
                    entry.delta = delta;
                    changed = true;
                }
            }
            changed = false;
        } while (changed && ++iteration < MAX_ITERATIONS);
        console.log("sync height:", {
            leftWrapperScrollHeight: leftEditor.wrapper.scrollHeight,
            rightWrapperScrollHeight: rightEditor.wrapper.scrollHeight,
            leftWrapperHeight: leftEditor.wrapper.clientHeight,
            rightWrapperHeight: rightEditor.wrapper.clientHeight,
            leftEditorHeight: leftEditor.editor.clientHeight,
            rightEditorHeight: rightEditor.editor.clientHeight,
            leftEditorScrollHeight: leftEditor.editor.scrollHeight,
            rightEditorScrollHeight: rightEditor.editor.scrollHeight,
            leftScrollTop: leftEditor.wrapper.scrollTop,
            rightScrollTop: rightEditor.wrapper.scrollTop,
            leftEditorWrapperRect: leftEditor.wrapper.getBoundingClientRect(),
            rightEditorWrapperRect: rightEditor.wrapper.getBoundingClientRect(),
            leftEditorRect: leftEditor.editor.getBoundingClientRect(),
            rightEditorRect: rightEditor.editor.getBoundingClientRect(),
        });
        // ì´ê²ƒë„ --padding ê°’ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì§€ìš°ì§€ ì•Šê³  ëƒ…ë‘ë©´ ì–´ëŠìˆœê°„ ë‚©ë“ì´ ì•ˆë˜ëŠ” ë†’ì´ê°€ ë‚˜ì˜¨ë‹¤.
        leftEditor.editor.style.removeProperty("--min-height");
        rightEditor.editor.style.removeProperty("--min-height");
        _resizeCancelId = requestAnimationFrame(() => {
            // leftEditor.markDirty(RenderFlags.ALL);
            // rightEditor.markDirty(RenderFlags.ALL);
            const leftHeight = leftEditor.editor.scrollHeight;
            const rightHeight = rightEditor.editor.scrollHeight;
            const maxHeight = Math.max(leftHeight, rightHeight);
            // leftEditor.wrapper.style.setProperty("--bottom-padding", `${maxHeight - leftHeight}px`);
            // rightEditor.wrapper.style.setProperty("--bottom-padding", `${maxHeight - rightHeight}px`);
            leftEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
            rightEditor.editor.style.setProperty("--min-height", `${maxHeight}px`);
            void rightEditor.editor.offsetHeight;
            if (document.activeElement === leftEditor.editor) {
                rightEditor.scrollTop = leftEditor.scrollTop;
            }
            else {
                leftEditor.scrollTop = rightEditor.scrollTop;
            }
            renderer.markDirty(24 /* RenderFlags.EDITOR_MASK */ | 4 /* RenderFlags.DIFF_GEOMETRY */);
            renderer.render();
            _preventScrollSync = false;
        });
        console.log("alignAnchors done:");
    }
    // ë¬´ì‹í•˜ê²Œ í° í•¨ìˆ˜
    // ì°ì°í•œë°... ì¬ë¯¸ ì—†ëŠ” ë¶€ë¶„ì´ë¼...
    function update(diffContext) {
        const leftTokens = diffContext.leftTokens;
        const rightTokens = diffContext.rightTokens;
        const rawEntries = diffContext.rawEntries;
        const unusedAnchors = new Set();
        for (const anchor of _anchors) {
            unusedAnchors.add(anchor.leftEl);
            unusedAnchors.add(anchor.rightEl);
        }
        const diffs = [];
        const leftDiffs = [];
        const rightDiffs = [];
        let currentDiff = null;
        for (let i = 0; i < rawEntries.length; i++) {
            const entry = rawEntries[i];
            const left = entry.left;
            const right = entry.right;
            if (entry.type) {
                if (currentDiff) {
                    console.assert(currentDiff.left.pos + currentDiff.left.len === entry.left.pos, currentDiff, entry);
                    console.assert(currentDiff.right.pos + currentDiff.right.len === entry.right.pos, currentDiff, entry);
                    currentDiff.type |= entry.type;
                    currentDiff.left.len += entry.left.len;
                    currentDiff.right.len += entry.right.len;
                }
                else {
                    currentDiff = { left: { ...entry.left }, right: { ...entry.right }, type: entry.type };
                }
            }
            else {
                // common entry
                if (currentDiff) {
                    finalizeDiff();
                }
                currentDiff = null;
                const leftToken = leftTokens[left.pos];
                const rightToken = rightTokens[right.pos];
                if (leftToken.flags & rightToken.flags & 4 /* TokenFlags.BLOCK_START */) {
                    const leftAnchorEl = leftEditor.getOrInsertStartAnchor(left.pos);
                    const rightAnchorEl = rightEditor.getOrInsertStartAnchor(right.pos);
                    if (leftAnchorEl && rightAnchorEl) {
                        _anchors.push({
                            leftEl: leftAnchorEl,
                            rightEl: rightAnchorEl,
                            delta: 0,
                        });
                        unusedAnchors.delete(leftAnchorEl);
                        unusedAnchors.delete(rightAnchorEl);
                    }
                }
            }
        }
        if (currentDiff) {
            finalizeDiff();
        }
        function finalizeDiff() {
            const diffIndex = diffs.length;
            const leftIndex = currentDiff.left.pos;
            const rightIndex = currentDiff.right.pos;
            const leftTokenCount = currentDiff.left.len;
            const rightTokenCount = currentDiff.right.len;
            const leftDiffItem = {
                diffIndex,
                tokenIndex: leftIndex,
                tokenCount: leftTokenCount,
                preferBlockStart: false,
                preferBlockEnd: false,
                flags: 0,
            };
            const rightDiffItem = {
                diffIndex,
                tokenIndex: rightIndex,
                tokenCount: rightTokenCount,
                preferBlockStart: false,
                preferBlockEnd: false,
                flags: 0,
            };
            if (leftTokenCount > 0 && rightTokenCount > 0) {
                const leftToken = leftTokens[leftIndex];
                const leftEndToken = leftTokens[leftIndex + leftTokenCount - 1];
                const rightToken = rightTokens[rightIndex];
                const rightEndToken = rightTokens[rightIndex + rightTokenCount - 1];
                if (leftToken.flags & rightToken.flags & 4 /* TokenFlags.BLOCK_START */) {
                    leftDiffItem.preferBlockStart = true;
                    rightDiffItem.preferBlockStart = true;
                    if (leftEndToken.flags & rightEndToken.flags & 8 /* TokenFlags.BLOCK_END */) {
                        leftDiffItem.preferBlockEnd = true;
                        rightDiffItem.preferBlockEnd = true;
                    }
                    const leftAnchorEl = leftEditor.getOrInsertStartAnchor(leftIndex);
                    const rightAnchorEl = rightEditor.getOrInsertStartAnchor(rightIndex);
                    if (leftAnchorEl && rightAnchorEl) {
                        _anchors.push({
                            leftEl: leftAnchorEl,
                            rightEl: rightAnchorEl,
                            delta: 0,
                        });
                        unusedAnchors.delete(leftAnchorEl);
                        unusedAnchors.delete(rightAnchorEl);
                    }
                }
            }
            else {
                let filledItem, emptyItem;
                let filledTokens, emptyTokens;
                let filledTokenIndex, emptyTokenIndex;
                let filledTokenCount;
                if (leftTokenCount > 0) {
                    filledItem = leftDiffItem;
                    filledTokens = leftTokens;
                    filledTokenIndex = leftIndex;
                    filledTokenCount = leftTokenCount;
                    emptyItem = rightDiffItem;
                    emptyTokenIndex = rightIndex;
                    emptyTokens = rightTokens;
                }
                else {
                    filledItem = rightDiffItem;
                    filledTokens = rightTokens;
                    filledTokenIndex = rightIndex;
                    filledTokenCount = rightTokenCount;
                    emptyItem = leftDiffItem;
                    emptyTokens = leftTokens;
                    emptyTokenIndex = leftIndex;
                }
                const filledToken = filledTokens[filledTokenIndex];
                const filledEndToken = filledTokens[filledTokenIndex + filledTokenCount - 1];
                const emptyBeforeToken = emptyTokens[emptyTokenIndex - 1];
                const emptyAfterToken = emptyTokens[emptyTokenIndex];
                if (filledToken.flags & 1 /* TokenFlags.LINE_START */) {
                    filledItem.preferBlockStart = true;
                    if (emptyBeforeToken && emptyBeforeToken.flags & 2 /* TokenFlags.LINE_END */) {
                        // empty item starts with a line end token, so it should be considered as a block start
                        emptyItem.preferBlockStart = true;
                    }
                }
                if (filledEndToken.flags & 2 /* TokenFlags.LINE_END */) {
                    filledItem.preferBlockEnd = true;
                    if (emptyAfterToken && emptyAfterToken.flags & 1 /* TokenFlags.LINE_START */) {
                        // empty item ends with a line start token, so it should be considered as a block end
                        emptyItem.preferBlockEnd = true;
                    }
                }
            }
            leftDiffs.push(leftDiffItem);
            rightDiffs.push(rightDiffItem);
        }
        // leftEditor.update({ diffs: leftDiffs, anchors: leftAnchors });
        // rightEditor.update({ diffs: rightDiffs, anchors: rightAnchors });
        const finalDiffsLeft = [];
        const finalDiffsRight = [];
        for (let diffIndex = 0; diffIndex < leftDiffs.length; diffIndex++) {
            const hue = DIFF_COLOR_HUES[diffIndex % NUM_DIFF_COLORS];
            const leftDiff = leftDiffs[diffIndex];
            const rightDiff = rightDiffs[diffIndex];
            const [leftRange, leftAnchorEl] = getDiffRange(leftEditor, leftDiff);
            const [rightRange, rightAnchorEl] = getDiffRange(rightEditor, rightDiff);
            finalDiffsLeft.push({
                diffIndex,
                range: leftRange,
                fill: `hsl(${hue} 100% 80%)`,
                stroke: `hsl(${hue} 100% 40% / 0.5)`,
                geometry: null,
            });
            finalDiffsRight.push({
                diffIndex,
                range: rightRange,
                fill: `hsl(${hue} 100% 80%)`,
                stroke: `hsl(${hue} 100% 40% / 0.5)`,
                geometry: null,
            });
            if (leftAnchorEl) {
                unusedAnchors.delete(leftAnchorEl);
            }
            if (rightAnchorEl) {
                unusedAnchors.delete(rightAnchorEl);
            }
        }
        renderer.setDiffs("left", finalDiffsLeft);
        renderer.setDiffs("right", finalDiffsRight);
        console.log("final diffs:", finalDiffsLeft, finalDiffsRight);
        for (const anchor of unusedAnchors) {
            anchor.remove();
        }
        render();
    }
    function render() {
        if (_renderPending) {
            return;
        }
        _renderPending = true;
        renderer.markDirty(24 /* RenderFlags.EDITOR_MASK */ | 7 /* RenderFlags.ALL */);
        requestAnimationFrame(() => {
            renderer.render();
            console.log("render done");
            requestAnimationFrame(() => { });
            _renderPending = false;
        });
    }
    _diffContext = {
        reqId: 0,
        // leftText: leftEditor.text,
        // rightText: rightEditor.text,
        diffOptions: { ..._diffOptions },
        done: false,
        leftTokens: null,
        rightTokens: null,
    };
    computeDiff();
    return {
        get dump() {
            // ë””ë²„ê¹… í•  ë•Œ...
            return {
                _diffContext: _diffContext,
                // diffs: _diffResult?.diffs,
                // anchors: _diffResult?.anchors,
                diffOptions: _diffOptions,
                leftEditor,
                rightEditor,
                activeEditor: _activeEditor,
            };
        },
        compute: computeDiff,
        diffOptions: _diffOptions,
        get outputOptions() {
            return _outputOptions;
        },
    };
    function getDiffRange(editor, diff) {
        let range = null;
        let anchorEl = null;
        if (diff.tokenCount === 0) {
            let bestInsertionPoint = null;
            let bestScore = -1;
            for (const point of editor.yieldAnchorPointsInRange(diff.tokenIndex)) {
                let score = 0;
                if (diff.preferBlockStart && point.flags & 64 /* InsertionPointFlags.BlockStart */) {
                    score += 1;
                }
                if (diff.preferBlockEnd && point.flags & 128 /* InsertionPointFlags.BlockEnd */) {
                    score += 1;
                }
                if (score > bestScore || (score === bestScore && bestInsertionPoint === null)) {
                    bestInsertionPoint = point;
                    bestScore = score;
                }
            }
            if (bestInsertionPoint) {
                [range, anchorEl] = getOrCreateDiffAnchorOrRangeFromInsertionPoint(bestInsertionPoint);
            }
        }
        if (!range) {
            range = editor.createTokenRange(diff.tokenIndex, diff.tokenCount);
        }
        return [range, anchorEl];
    }
    function getOrCreateDiffAnchorOrRangeFromInsertionPoint(point) {
        const range = document.createRange();
        let anchorEl = null;
        if (point.existingAnchor) {
            range.selectNode(point.existingAnchor);
            anchorEl = point.existingAnchor;
        }
        else {
            range.setStart(point.container, point.offset);
            range.collapse(true);
            if (point.container.nodeType === 1) {
                anchorEl = document.createElement("A");
                anchorEl.classList.add("anchor", "diff-anchor");
                range.insertNode(anchorEl);
                range.selectNode(anchorEl);
            }
        }
        return [range, anchorEl];
    }
})();
//# sourceMappingURL=main.js.map
</script>
</body>

</html>
