<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiffSeek</title>
<style>:root {
	--diff-hue-removed: 0;
	--diff-hue-added: 120;
	--diff-hue: 0;
	--editor-padding: 8px;
	--line-height: 20px;
	--scroll-margin: 1rem;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body,
html {
	height: 100vh;
	width: 100vw;
	overflow: hidden;
	scroll-padding-top: 1rem;
	font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

#progress {
	display: none;
	position: fixed;
	bottom: 20px;
	right: 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	padding: 10px 20px;
	border-radius: 5px;
	font-size: 14px;
	z-index: 1000;
}

.computing #progress {
	display: block;
}

/* layout */
.container {
	display: grid;
	grid-template-columns: 1fr 300px;
	height: 100vh;
	overflow: hidden;
	gap: 8px;
	position: relative;
}

#main {
	height: 100%;
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0rem;
	padding: 0;
	overflow-x: hidden;
	position: relative;
}

#sidebar {
	overflow-y: auto;
	background: #eee;
	padding: 8px;
}

/* .line-break {
	display: block;
}
.line-break::before {
	content: " ";
	display: block;
	height: 1rem;
} */

.editor-wrapper {
	width: 100%;
	height: 100%;
	overflow-x: hidden;
	position: relative;
}

.mirror,
.editor {
	white-space-collapse: preserve;
	text-wrap-mode: wrap;
	text-wrap: stable;
	max-height: 100%;
	z-index: -1;
	border: 0;
	min-height: 100%;
	max-width: 100%;
	overflow-y: visible;
	line-height: var(--line-height);
	scroll-padding-top: var(--scroll-margin);
	font-family: monospace;
	font-size: 1rem;
	margin: 0;
	overflow-y: visible;
	height: 100%;
	white-space: pre-wrap;
	/* 
	contenteditable과 아닌 것에서 일관적으로 줄바꿈이 되지 않음!
	*/
	word-break: break-all;
	overflow-wrap: anywhere;
	border: 1px solid #ccc;
	border-radius: 4px;
	z-index: 0;
	max-width: 100%;
	width: 100%;
	outline: none;
	padding: var(--editor-padding);
}

.mirror div,
.editor div {
	min-height: var(--line-height);
}

.editor {
	z-index: 2;
}

.mirror {
	z-index: -1;
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	color: rgba(0, 0, 0, 0.1);
	/* color: rgba(0, 0, 0, 0.1);
	background-color: #f8f8f8; */
}

.aligned .editor {
	display: none;
}
.aligned .mirror {
	pointer-events: auto;
	position: static;
	color: inherit;
	background-color: transparent;
	/* cursor: default; */
}

.mirror div {
	line-height: var(--line-height);
	min-height: var(--line-height);
}

.aligned [data-pad-top]::before {
	content: "";
	display: block;
	height: var(--pad-top);
	background: #efefef
		repeating-linear-gradient(
			135deg,
			rgba(200, 200, 200, 0.15) 0px,
			rgba(200, 200, 200, 0.15) 3px,
			rgba(255, 255, 255, 0.05) 3px,
			rgba(255, 255, 255, 0.05) 6px
		);
}

.aligned [data-pad-diff]::after {
	content: "";
	display: block;
	height: var(--pad-diff);
	background-color: #f7d4d4;
}

mark {
	line-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);

	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), -1px 1px hsl(var(--diff-hue) 100% 40%); */
	/* outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	outline-offset: 0px 3px; */
	color: inherit;
}
mark:not(:empty) {
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
}

mark:empty {
	position: relative;
	outline: none;
	background-color: unset;
	vertical-align: top;
	min-height: 20px;
	display: inline-block; /* inline-block으로 안해두면 높이 1px이 모자르게 된다. 묻지마... */
}

mark:empty::after {
	position: absolute;
	content: "";
	top: 0px;
	right: 0px;
	height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
	/* border: 1px solid hsl(var(--diff-hue) 100% 40%); */
	/* box-shadow: 1px -1px hsl(var(--diff-hue) 100% 40%), 1px 1px hsl(var(--diff-hue) 100% 40%); */
	outline: 1px solid hsl(var(--diff-hue) 100% 40% / 0.5);
	outline-offset: 0px;
	width: 3px;
	display: inline-block;
}

.aligned mark {
	color: #000;
}
/* .diff:empty {
	position: relative;
	min-height: var(--line-height);
	background-color: hsl(var(--diff-hue) 100% 80%);
} */

/* mark:empty::after {
	position: absolute;
	content: "";
	min-height: var(--line-height);
	top: 0;
	left: 0;
	width: 2px;
	display: inline-block;
	background-color: hsl(var(--diff-hue), 100%, 80%);
	outline: 1px solid hsl(var(--diff-hue), 100%, 40%);
} */

/* non empty diff */

/*
empty diff
공간을 전혀 차지하지 않으면서도 visual이 있어야함
*/
/* .diff:empty {
	display: inline-block;
	position: relative;
	vertical-align: bottom;
} */

/* .diff:empty::after {
	content: "";
	display: inline-block;
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	position: absolute;
	top: 0;
	width: 2px;
	height: var(--line-height);
} */

/* .mirror > div:has(mark:not(.block)),
hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 95%);
} */

/*
줄맞춤 용 marker element
*/

hr {
	border: 0;
	height: 0;
	display: inline;
	pointer-events: none;
}

.aligned hr.expanded {
	display: block;
}

.aligned hr {
	background: black repeating-linear-gradient(135deg, hsl(0 0% 88% / 0.15) 0px, hsl(0 0% 88% / 0.15) 4px, hsl(0 0% 100% / 0.05) 4px, hsl(0 0% 100% / 0.05) 8px);
}

.aligned hr[data-diff][data-type="after"] {
	background: hsl(0 75% 25% / 0.25)
		repeating-linear-gradient(135deg, hsl(0 100% 88% / 0.15) 0px, hsl(0 100% 88% / 0.15) 4px, hsl(0 100% 100% / 0.05) 4px, hsl(0 100% 100% / 0.05) 8px);
}

.aligned .mirror {
	color: #fff;
	background-color: #000;
}

.aligned .mirror > div:has(mark),
.aligned hr[data-type="diffEnd"] {
	background-color: hsl(0 75% 25%);
}

.edit .mirror > div:has(mark),
.edit hr[data-type="diffEnd"] {
	background-color: hsl(0 100% 90%);
}

/*
scrolling
*/
#main {
	overflow: hidden;
	overflow-y: hidden;
}

.editor-wrapper {
	overflow-y: scroll;
}

.aligned #main {
	overflow-y: scroll;
}

.aligned .editor-wrapper {
	overflow: visible;
	padding-right: 7px;
}

.aligned .editor-wrapper:last-child {
	margin-left: 8px;
}

@keyframes highlightAnimation {
	0% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
	50% {
		background-color: white;
	}
	100% {
		background-color: hsl(var(--diff-hue) 100% 80%);
	}
}

#diffList {
	list-style-type: none;
}

.computing #diffList {
	opacity: 0.5;
}

#diffList li:not(:last-child) {
	margin-bottom: 6px;
}

#diffList mark {
	position: relative;
	display: block;
	color: hsl(var(--diff-hue) 100% 20%);
	background-color: hsl(var(--diff-hue) 100% 80%);
	outline: 1px solid hsl(var(--diff-hue) 100% 40%);
	border-radius: 4px;
	padding: 4px;
	display: flex;
	flex-direction: column;
}

#diffList span {
	pointer-events: none;
	font-size: 12px;
	margin-bottom: 1px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding: 4px 2px;
	text-decoration: none;
	padding-inline: 4px;
	font-weight: bold;
}

#diffList .left::before,
#diffList .right::before {
	display: inline-block;
	justify-content: center;
	padding-inline: 3px;
	align-items: center;
	border-radius: 25%;
	background-color: hsl(var(--diff-hue) 100% 40%);
	border: 1px solid hsl(var(--diff-hue) 100% 20%);
	color: white;
	font-weight: bold;

	font-family: "Consolas", "Courier New", monospace;
	content: "L";
	margin-right: 4px;
	/* content: "◀️"; */
}

#diffList .right::before {
	content: "R" !important;
	/* content: "▶️" !important; */
}

.edit hr {
	height: 0 !important;
}

/* 의미없다
.aligned .mirror > div:hover {
	background-color: hsl(0 30% 30% / 0.3);
	
} */

#rightAnchor12-after {
	display: inline;
}
</style>
<script id='constants.js'>// 인접한 색과 60이상 차이나게
const DIFF_COLOR_HUES = [30, 180, 300, 120, 240, 60, 270]; //[60, 240, 120, 300, 180];//[60, 120, 180, 240, 300];
const NUM_DIFF_COLORS = DIFF_COLOR_HUES.length;

const LINE_TAG = "DIV";
const ANCHOR_TAG = "HR";
const DIFF_ELEMENT_NAME = "MARK";
const LINE_HEIGHT = 20;

const PROCESSING_MESSAGES = [
	"한땀한땀 비교 중...",
	"인내심 테스트 중...",
	"생각 중...",
	"COME ON, TARS!",
	"재부팅 준비 중...",
	"무한 루프 중...",
	"머리 긁는 중...",
	"흰머리 뽑는 중...",
    "DIFFSEEKING...",
    "시스템 침투 중...",
    "ANALYZING...",
    "3... 2... 1...",
    "SYSTEM MALFUNCTION...",
];
</script>
<script id='editor.js'>const ANCHOR = "ANCHOR";
const CHARS = "CHARS";
const DIFF = "DIFF";
const DIFF_END = "DIFF_END";
const LINEBREAK = "LINEBREAK";
const END_OF_STRING = "END_OF_STRING";

function createEditor(container, name, callbacks) {
	const { onTextChanged, onMirrorUpdated } = callbacks;
	const _lineElements = [];
	const _diffElements = [];
	const _anchorElements = [];
	const _visibleAnchors = new Set();
	let _text = "";
	let _savedCaret = null;
	let _observingAnchors = false;

	const wrapper = document.createElement("div");
	wrapper.id = name + "EditorWrapper";
	wrapper.classList.add("editor-wrapper");

	const mirror = document.createElement("div");
	mirror.id = name + "Mirror";
	mirror.classList.add("mirror");

	const editor = document.createElement("div");
	editor.id = name + "Editor";
	editor.classList.add("editor");
	editor.contentEditable = "plaintext-only";
	editor.spellcheck = false;

	wrapper.appendChild(mirror);
	wrapper.appendChild(editor);
	container.appendChild(wrapper);

	function updateText() {
		_text = editor.textContent;
		onTextChanged(_text);
	}

	editor.addEventListener("input", updateText);
	editor.addEventListener("focus", callbacks.onFocus);
	editor.addEventListener("blur", callbacks.onBlur);
	wrapper.addEventListener("scroll", callbacks.onScroll);
	wrapper.addEventListener("mouseenter", callbacks.onEnter);
	wrapper.addEventListener("mouseleave", callbacks.onLeave);

	const anchorIntersectionObserver = new IntersectionObserver(
		(entries) => {
			for (const entry of entries) {
				if (entry.isIntersecting) {
					_visibleAnchors.add(entry.target);
				} else {
					_visibleAnchors.delete(entry.target);
				}
			}
		},

		{ threshold: 1, root: document.getElementById("main") }
	);

	function saveCaret() {
		const sel = window.getSelection();
		if (sel.rangeCount > 0) {
			const range = sel.getRangeAt(0);
			if (editor.contains(range.commonAncestorContainer)) {
				_savedCaret = range.cloneRange();
			}
		}
	}

	function restoreCaret() {
		if (_savedCaret && editor.contains(_savedCaret.commonAncestorContainer)) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(_savedCaret);
		}
		_savedCaret = null;
	}

	function getVisibleAnchors() {
		return Array.from(_visibleAnchors).sort((a, b) => Number(a.dataset.pos) - Number(b.dataset.pos));
	}

	function getFirstVisibleLineElementInEditor() {
		const lineEls = _lineElements;
		// 이진 검색으로 현재 화면에 보이는 줄 엘러먼트 중 첫번째 찾기
		// 모든 픽셀이 화면에 다 보이는 경우만! 윗부분 1px만 짤려도 가차 없다.
		let low = 0;
		let high = lineEls.length - 1;
		let mid;
		let lineEl = null;
		let lineTop = null;
		while (low <= high) {
			mid = (low + high) >>> 1;
			const top = lineEls[mid].getBoundingClientRect().top;
			if (top >= 0) {
				lineEl = lineEls[mid];
				if (top <= 10) {
					// 이정도면 안전하게 "찾았다"라고 말할 수 있지 않을까?
					// 변태같이 화면 스케일을 1/2로 줄이지 않는 이상...
					break;
				}
				lineTop = top;
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return [lineEl, lineTop];
	}

	// 현재 화면에 보이는 editor의 문자 인덱스를 찾음.
	function getFirstVisiblePosInEditor() {
		const rect = editor.getBoundingClientRect();
		let x = rect.left + 10;
		let y = rect.top + 10;
		let parentEl = editor.parentElement;
		while (parentEl) {
			x += parentEl.scrollLeft;
			y += parentEl.scrollTop;
			parentEl = parentEl.parentElement;
		}

		const caretPos = document.caretPositionFromPoint(x, y);
		if (caretPos !== null) {
			const offsetNode = caretPos.offsetNode;
			let offset = caretPos.offset;
			if (offsetNode.nodeType === 3 && editor.contains(offsetNode)) {
				// 찾았다. 그대로 리턴... 하면 인생 참 편하지?
				// editor 안에 여러개의 text node가 있을 수 있기 때문에 offsetNode보다 앞에 위치한 text node들의 text length를 모두 더해야함.
				// previous sibling으로 찾으면 훨씬 간단하고 빠를테지만 나중에 editor를 구조를 바꿀지도 모르니 일단 안정빵으로
				const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
				let node;
				while ((node = walker.nextNode())) {
					if (node === offsetNode) {
						return offset;
					}
					offset += node.nodeValue.length;
				}
			}
		}

		return null;
	}

	function scrollToDiff(diffIndex) {
		_diffElements[diffIndex][0].scrollIntoView({});
	}

	function scrollToLine(lineNum, offset = 0) {
		const lineEl = _lineElements[lineNum - 1];
		if (lineEl) {
			// 아! 1px이 왜 어긋나는지 몰겠는데... 나 바쁜 사람이야
			wrapper.scrollTop = lineEl.offsetTop;
		}
	}

	function scrollToTextPosition(pos) {
		if (window.getComputedStyle(editor).display === "none") {
			for (let i = 0; i < _lineElements.length; i++) {
				const linePos = Number(_lineElements[i].dataset.pos);
				if (linePos > pos) {
					if (i > 0) {
						_lineElements[i - 1].scrollIntoView();
					} else {
						mirror.scrollHeight = 0;
					}
					break;
				}
			}
		} else {
			const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
			let node;
			while ((node = walker.nextNode())) {
				const nodeLen = node.nodeValue.length;
				if (pos < nodeLen) {
					// TODO
					// const range = document.createRange();
					// const sel = window.getSelection();
					// range.setStart(node, pos);
					// range.setEnd(node, pos);
					// sel.removeAllRanges();
					// sel.addRange(range);
					break;
				}
				pos -= nodeLen;
			}
		}
	}

	function update({ diffs, anchors }) {
		if (!diffs) {
			return;
		}

		_lineElements.length = 0;
		_diffElements.length = 0;
		_anchorElements.length = 0;
		untrackVisibleAnchors();

		editor.style.removeProperty("min-height");
		mirror.style.removeProperty("min-height");

		const text = _text;
		const view = mirror;
		const textruns = textrunGenerator(name, text, diffs, anchors);
		let lineEl = null;
		let inlineNode = null;
		let currentDiffIndex = null;
		let lineNum = 1;
		let unwrittenDiff = false;
		let lineHasNonSpaceChar = false;
		let lineHasNonSpaceNonDiffChar = false;
		let diffAnchorIndex = null;
		let _pos = 0;

		function appendAnchor(pos, anchorIndex, diffIndex = null) {
			const anchor = anchors[anchorIndex];
			if (inlineNode === null || inlineNode.nodeName !== ANCHOR_TAG) {
				const el = document.createElement(ANCHOR_TAG);
				lineEl.insertBefore(el, inlineNode);
				inlineNode = el;
			}
			inlineNode.id = `${name}Anchor${anchorIndex}-${anchor.type}`;
			inlineNode.dataset.anchor = anchorIndex;
			inlineNode.dataset.type = anchor.type; 
			inlineNode.dataset.pos = pos;
			if (diffIndex !== null) {
				inlineNode.dataset.diff = diffIndex;
			} else {
				delete inlineNode.dataset.diff;
			}
			_anchorElements.push(inlineNode);
			inlineNode = inlineNode.nextSibling;
		}

		function appendChars(chars, hasNonSpaceChar) {
			if (currentDiffIndex !== null) {
				const diff = diffs[currentDiffIndex];
				if (inlineNode === null || inlineNode.nodeName !== DIFF_ELEMENT_NAME) {
					const el = document.createElement(DIFF_ELEMENT_NAME);
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
				inlineNode.dataset.diff = currentDiffIndex;
				inlineNode.className = "diff-color" + ((currentDiffIndex % NUM_DIFF_COLORS) + 1);
				inlineNode.classList.toggle("block", diff.align && diff[name].empty);
				_diffElements[currentDiffIndex] = _diffElements[currentDiffIndex] || [];
				_diffElements[currentDiffIndex].push(inlineNode);
				unwrittenDiff = false;
			} else {
				if (inlineNode === null || inlineNode.nodeName !== "SPAN") {
					//console.log("new text node");
					const el = document.createElement("SPAN");
					el.textContent = chars;
					lineEl.insertBefore(el, inlineNode);
					inlineNode = el;
				} else {
					if (inlineNode.textContent !== chars) {
						inlineNode.textContent = chars;
					}
				}
			}
			inlineNode = inlineNode.nextSibling;
		}

		let textRunResult;

		lineEl = view.firstElementChild;

		do {
			lineHasNonSpaceChar = false;
			lineHasNonSpaceNonDiffChar = false;
			if (currentDiffIndex !== null) {
				unwrittenDiff = true;
			}
			if (lineEl === null) {
				lineEl = document.createElement(LINE_TAG);
				view.appendChild(lineEl);
				lineEl.dataset.lineNum = lineNum;
				lineEl.dataset.pos = _pos;
			}
			_lineElements[lineNum - 1] = lineEl;
			inlineNode = lineEl.firstChild;

			while (!(textRunResult = textruns.next()).done) {
				const { type, pos, len, diffIndex, anchorIndex, hasNonSpaceChar } = textRunResult.value;
				_pos = pos;
				if (type === DIFF) {
					currentDiffIndex = diffIndex;
					unwrittenDiff = true;
				} else if (type === DIFF_END) {
					if (unwrittenDiff) {
						appendChars("", hasNonSpaceChar);
					}
					currentDiffIndex = null;
				} else if (type === CHARS) {
					lineHasNonSpaceChar = lineHasNonSpaceChar || hasNonSpaceChar;
					if (currentDiffIndex === null) {
						lineHasNonSpaceNonDiffChar = lineHasNonSpaceNonDiffChar || hasNonSpaceChar;
					}
					appendChars(text.substring(pos, pos + len), hasNonSpaceChar);
				} else if (type === LINEBREAK || type === END_OF_STRING) {
					//console.log("linebreak", { type, pos, len });
					break;
				} else if (type === ANCHOR) {
					appendAnchor(pos, anchorIndex, diffIndex);
				}
			}

			if (unwrittenDiff) {
				appendChars("", false);
			}

			while (inlineNode) {
				const nextInlineNode = inlineNode.nextSibling;
				inlineNode.remove();
				inlineNode = nextInlineNode;
			}

			lineEl = lineEl.nextElementSibling;
			if (textRunResult.value.type === END_OF_STRING) {
				break;
			}
			lineNum++;
		} while (!textRunResult.done);

		_lineElements.length = lineNum;

		while (lineEl) {
			const nextLineEl = lineEl.nextElementSibling;
			lineEl.remove();
			lineEl = nextLineEl;
		}

		requestAnimationFrame(() => {
			const height = view.scrollHeight;
			editor.style.minHeight = height + "px";
			mirror.style.minHeight = height + "px";
		});
		trackVisibleAnchors();
		onMirrorUpdated();
	}

	function trackVisibleAnchors() {
		if (!_observingAnchors) {
			for (const anchor of _anchorElements) {
				//if (!anchor.id.endsWith("-after")) {
					anchorIntersectionObserver.observe(anchor);
				//}
			}
			_observingAnchors = true;
		}
	}

	function untrackVisibleAnchors() {
		_observingAnchors = false;
		_visibleAnchors.clear();
		anchorIntersectionObserver.disconnect();
	}

	function getFirstVisibleAnchor() {
		let firstAnchor = null;
		let firstPos = null;
		for (const anchor of _visibleAnchors) {
			if (firstAnchor === null) {
				firstAnchor = anchor;
				firstPos = Number(anchor.dataset.pos);
			} else {
				const pos = Number(anchor.dataset.pos);
				if (pos < firstPos) {
					firstAnchor = anchor;
					firstPos = pos;
				}
			}
		}
		return firstAnchor;
	}

	updateText();

	return {
		name: name,
		wrapper,
		editor,
		mirror,
		update,
		getFirstVisiblePosInEditor,
		scrollToDiff,
		scrollToTextPosition,
		saveCaret,
		restoreCaret,
		getVisibleAnchors,
		trackVisibleAnchors,
		untrackVisibleAnchors,
		getFirstVisibleAnchor,
		scrollToLine,
		getFirstVisibleLineElementInEditor,
		get text() {
			return _text;
		},
		get lineElements() {
			return _lineElements;
		},
		get diffElements() {
			return _diffElements;
		},
		get visibleAnchors() {
			return _visibleAnchors;
		},
		get anchorElements() {
			return _anchorElements;
		}
	};
}

function* textrunGenerator(textKey, text, diffs, anchors) {
	const _textLen = text.length;
	let _pos = 0;
	let _textPos = 0;
	let _diffIndex = -1;
	let _anchorIndex = -1;
	let _anchorPos;
	let _diffPos;
	let _inDiff = false;
	let _diffEnd;
	let _hasNonSpaceChar = false;
	let _lineNum = 1;

	const current = {
		pos: 0,
		len: 0,
		diffIndex: null,
		anchorIndex: null,
		hasNonSpaceChar: false,
	};

	// anchor위치는 diff의 시작위치
	// diff 범위 밖일때는 어디에서든 올 수 있다

	function nextAnchor() {
		_anchorIndex++;
		if (_anchorIndex < anchors.length) {
			const data = anchors[_anchorIndex];
			_anchorPos = data[textKey];
			if (_anchorPos < _pos) {
				//console.warn("Anchor skipped", { anchor: data, anchorIndex: _anchorIndex, pos: _pos, anchorPos: _anchorPos });
				nextAnchor();
			}
		} else {
			_anchorIndex = anchors.length;
			_anchorPos = Number.MAX_SAFE_INTEGER;
		}
	}

	function nextDiff() {
		_diffIndex++;
		if (_diffIndex < diffs.length) {
			const data = diffs[_diffIndex][textKey];
			_diffPos = data.pos;
			_diffEnd = data.pos + data.len;
		} else {
			_diffIndex = diffs.length;
			_diffPos = Number.MAX_SAFE_INTEGER;
			_diffEnd = Number.MAX_SAFE_INTEGER;
		}
	}

	// 일단 줄번호++
	// 해당 줄번호에 해당하는 ling mapping를 찾아서 그 index를 _lineMapIndex로 저장.
	// 못찾으면 그 이후 maping index에 ~를 씌운 값
	//
	nextDiff();
	nextAnchor();

	function chars() {
		current.type = CHARS;
		current.pos = _textPos;
		current.len = _pos - _textPos;
		current.diffIndex = _inDiff ? _diffIndex : null;
		current.hasNonSpaceChar = _hasNonSpaceChar;
		_hasNonSpaceChar = false;
		_textPos = _pos;
		return current;
	}

	// 주의:
	// 같은 pos를 가진 anchor가 두개가 있을 수 있다. 길이가 0인 diff에 대한 anchor와 그 위치에 시작되는 common anchor
	// 반대의 순서는 없음.

	while (true) {
		if (_pos === _diffPos) {
			// 현재 위치 이전까지의 문자열들.
			if (_textPos < _pos) {
				yield chars();
			}
			
			if (_pos === _anchorPos) {
				let anchor = anchors[_anchorIndex];
				if (anchor.diffIndex === _diffIndex && anchor.type === "before") {
					current.type = ANCHOR;
					current.pos = _pos;
					current.len = 0;
					current.diffIndex = _diffIndex;
					current.anchorIndex = _anchorIndex;
					yield current;
					nextAnchor();
				}
			}

			_inDiff = true;
			_diffPos = Number.MAX_SAFE_INTEGER;
			current.type = DIFF;
			current.pos = _pos;
			current.len = 0;
			current.diffIndex = _diffIndex;
			yield current;
		}

		if (_pos === _diffEnd) {
			if (_textPos < _pos) {
				yield chars();
			}
			current.type = DIFF_END;
			current.pos = _pos;
			current.len = 0;
			current.diffIndex = _diffIndex;
			yield current;
			_inDiff = false;
			// 현재 diff::after 앵커가 존재하면 그것 먼저 반환한 후에 nextDiff() 해야함!
			if (_pos === _anchorPos) {
				let anchor = anchors[_anchorIndex];
				if (anchor.diffIndex === _diffIndex && anchor.type === "after") {
					current.type = ANCHOR;
					current.pos = _pos;
					current.len = 0;
					current.diffIndex = _diffIndex;
					current.anchorIndex = _anchorIndex;
					yield current;
					nextAnchor();
				} else {
					//console.warn("Anchor skipped", { anchor, pos: _pos, anchorPos: _anchorPos, diffIndex: _diffIndex });
					nextAnchor();
				}
			}
			nextDiff();
		}

		if (_pos === _anchorPos) {
			let anchor = anchors[_anchorIndex];
			if (anchor.diffIndex === null && anchor.type === "before") {
				current.type = ANCHOR;
				current.pos = _pos;
				current.len = 0;
				current.diffIndex = null;
				current.anchorIndex = _anchorIndex;
				yield current;
				nextAnchor();
			} else {
				//console.warn("Anchor skipped", { anchor, pos: _pos, anchorPos: _anchorPos });
				nextAnchor();
			}
		}
		
		while (_pos < _textLen && _pos !== _diffPos && _pos !== _diffEnd && _pos !== _anchorPos && text[_pos] !== "\n") {
			_hasNonSpaceChar = _hasNonSpaceChar || (text[_pos] !== " " && text[_pos] !== "\t");
			_pos++;
		}

		if (_pos === _diffPos || _pos === _diffEnd || _pos === _anchorPos) {
			// 다음 루프에서 처리
			continue;
		}

		if (_textPos < _pos) {
			yield chars();
		}

		if (text[_pos] === "\n") {
			current.type = LINEBREAK;
			current.pos = _pos;
			current.len = 1;
			current.diffIndex = _inDiff ? _diffIndex : null;
			yield current;
			_lineNum++;
			_textPos = ++_pos;
			continue;
		}

		break;
	}

	current.type = END_OF_STRING;
	current.pos = _textLen;
	current.len = 0;
	current.diffIndex = null;
	yield current;
	//yield [END_OF_STRING, _textLen, 0, null];
}
</script>
<script id='worker.js'>const DIFF_BY_CHAR = 1;
const DIFF_BY_WORD = 2;
const DIFF_BY_LINE = 3;
const DIFF_BY_PARAGRAPH = 4;

const TOKEN_CACHE_SIZE = 4;
const MIN_PARAGRAPH_GAP = 1;

const FIRST_OF_LINE = 1; // PRECEDED_BY_NEWLINE ?
const LAST_OF_LINE = 2; // FOLLOWED_BY_NEWLINE ?
const WILD_CARD = 16;

const decoder = new TextDecoder();
let _nextWork = null;
let _currentWork = null;

const tokenCache = {
	[DIFF_BY_CHAR]: [],
	[DIFF_BY_WORD]: [],
	[DIFF_BY_LINE]: [],
	[DIFF_BY_PARAGRAPH]: [],
};

// #region trie
function createTrieNode() {
	const children = {};
	function next(char) {
		return char === " " ? this : children[char] || null;
	}

	function addChild(char) {
		if (!children[char]) {
			children[char] = createTrieNode();
		}
		return children[char];
	}
	return { next, addChild, word: null, flags: null };
}

function createTrie() {
	const root = createTrieNode();

	function insert(word, flags = 0) {
		let node = root;
		for (const char of word) {
			node = node.addChild(char);
		}
		node.word = word;
		node.flags = flags;
	}

	return { insert, root };
}
// #endregion

const SPACE_CHARS = {
	" ": true, // 공백
	"\t": true, // 탭
	"\n": true, // 줄 바꿈
	"\r": true, // 캐리지 리턴
	"\f": true, // 폼 피드
	"\v": true, // 수평 탭
};

const Trie = createTrie();
Trie.insert("(추가)", WILD_CARD);
Trie.insert("(삭제)", WILD_CARD);
Trie.insert("(신설)", WILD_CARD);
Trie.insert("(생략)", WILD_CARD);
Trie.insert("(현행과같음)", WILD_CARD);

const TrieRoot = Trie.root;
const WildcardNode = Trie.root.next("(");

self.onmessage = (e) => {
	if (e.data.type === "diff") {
		const work = {
			reqId: e.data.reqId,
			left: e.data.left,
			right: e.data.right,
			method: e.data.method,
			cancel: false,
		};
		if (_currentWork) {
			_currentWork.cancel = true;
			_nextWork = work;
			return;
		}
		runDiff(work);
	}
};

async function runDiff(work) {
	_currentWork = work;
	const leftText = decoder.decode(work.left);
	const rightText = decoder.decode(work.right);
	try {
		work.lastYield = work.start = performance.now();
		const results = await computeDiff({ leftText, rightText, method: work.method || DIFF_BY_WORD, ctx: work });
		work.finish = performance.now();
		//console.log("Elapsed time:", work.finish - work.start);
		_currentWork = null;
		if (results) {
			self.postMessage({
				reqId: work.reqId,
				type: "diffs",
				diffs: results.diffs,
				anchors: results.anchors,
			});
		} else {
			console.debug("Diff canceled");
		}
	} catch (e) {
		if (e.message === "cancelled") {
			console.debug("Diff canceled");
		} else {
			console.error(e);
		}
	}
	[work, _nextWork] = [_nextWork, null];
	if (work) {
		return await runDiff(work);
	}
}

function normalizeText(input) {
	return input.replace(/\s{2,}/g, " ").trim();
}

function checkIfFirstOfLine(input, pos) {
	pos--;
	while (pos >= 0) {
		if (input[pos] === "\n") {
			break;
		} else if (!SPACE_CHARS[input[pos]]) {
			return false;
		}
		pos--;
	}
	return true;
}

function tokenizeByChar(input, inputPos = null, inputEnd = null, baseLineNum = null) {
	const tokens = [];
	let lineCount = 0;
	let flags = 0;
	if (inputPos === null) {
		inputPos = 0;
	}
	if (inputEnd === null) {
		inputEnd = input.length;
	}
	if (baseLineNum === null) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (!SPACE_CHARS[char]) {
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}
			flags |= tokens.length === 0 && checkIfFirstOfLine(input, i) ? FIRST_OF_LINE : 0;
			tokens.push({
				text: char,
				pos: i,
				len: 1,
				lineNum: baseLineNum + lineCount,
				flags,
			});
			flags = 0;
		}
		if (char === "\n") {
			lineCount++;
			flags = FIRST_OF_LINE;
			if (tokens.length > 0) {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
			}
		}
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByChar", tokens);
	return tokens;
}

function tokenizeByWord(input, inputPos = null, inputEnd = null, baseLineNum = null) {
	const tokens = [];
	let currentStart = -1;
	let lineCount = 0;
	let flags = 0;
	if (inputPos === null) {
		inputPos = 0;
	}
	if (inputEnd === null) {
		inputEnd = input.length;
	}
	if (baseLineNum === null) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		//if (/[\w\u3131-\uD79D]+/.test(char)) {
		// 문장부호를 별개로 단어로 분리하는 방법도 생각해볼 필요가 있음.
		// but!! "(현행과 같음)"의 여는 괄호가 별개로 매치되는 건 원하지 않음.

		if (SPACE_CHARS[char]) {
			if (currentStart !== -1) {
				flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
				tokens.push({
					text: input.substring(currentStart, i),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags,
				});
				flags = 0;
				currentStart = -1;
			}
			if (char === "\n") {
				lineCount++;
				flags = FIRST_OF_LINE;
				if (tokens.length > 0) {
					tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				}
			}
		} else {
			if (char === "(") {
				let p = i + 1;
				let found = null;
				for (let node = WildcardNode; p < inputEnd && (node = node.next(input[p++])) !== null; ) {
					if (node.word !== null) {
						found = node;
						break;
					}
				}
				if (found) {
					if (currentStart !== -1) {
						flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
						tokens.push({
							text: input.substring(currentStart, i),
							pos: currentStart,
							len: i - currentStart,
							lineNum: baseLineNum + lineCount,
							flags,
						});
						flags = 0;
						currentStart = -1;
					}

					flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
					tokens.push({
						text: found.word,
						pos: i,
						len: p - i,
						lineNum: baseLineNum + lineCount,
						flags: flags | found.flags,
					});
					flags = 0;
					i = p - 1;
					continue;
				}
			}

			if (currentStart === -1) {
				currentStart = i;
			}
		}
	}

	if (currentStart !== -1) {
		flags |= tokens.length === 0 && checkIfFirstOfLine(input, currentStart) ? FIRST_OF_LINE : 0;
		tokens.push({
			text: input.substring(currentStart),
			pos: currentStart,
			len: inputEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: flags,
		});
	}

	if (tokens.length > 0) {
		let p = inputEnd;
		while (p <= input.length) {
			if (p === input.length || input[p] === "\n") {
				tokens[tokens.length - 1].flags |= LAST_OF_LINE;
				break;
			} else if (!SPACE_CHARS[input[p]]) {
				break;
			}
			p++;
		}
	}

	//console.log("tokenizeByWord", tokens);
	return tokens;
}

function tokenizeByLine(input, inputPos = null, inputEnd = null, baseLineNum = null) {
	const tokens = [];
	let currentStart = -1;
	let currentEnd = -1;
	let lineCount = 0;
	if (inputPos === null) {
		inputPos = 0;
	}
	if (inputEnd === null) {
		inputEnd = input.length;
	}
	if (baseLineNum === null) {
		baseLineNum = 1;
	}

	for (let i = inputPos; i < inputEnd; i++) {
		const char = input[i];
		if (char !== "\n") {
			if (!SPACE_CHARS[char]) {
				if (currentStart === -1) {
					currentStart = i;
				}
				currentEnd = i + 1;
			}
		} else {
			if (currentStart !== -1) {
				tokens.push({
					text: input.substring(currentStart, currentEnd),
					pos: currentStart,
					len: i - currentStart,
					lineNum: baseLineNum + lineCount,
					flags: FIRST_OF_LINE | LAST_OF_LINE,
				});
				currentStart = currentEnd = -1;
			}
			lineCount++;
		}
	}

	if (currentStart !== -1) {
		tokens.push({
			text: input.substring(currentStart, currentEnd),
			pos: currentStart,
			len: currentEnd - currentStart,
			lineNum: baseLineNum + lineCount,
			flags: FIRST_OF_LINE | LAST_OF_LINE,
		});
	}

	return tokens;
}

function tokenize(input, method, inputPos = null, inputEnd = null, baseLineNum = null) {
	const cacheArr = tokenCache[method];
	if (cacheArr) {
		// for (let i = 0; i < cacheArr.length; i++) {
		// 	const token = cacheArr[i];
		// 	if (token.text === input) {
		// 		if (i !== cacheArr.length - 1) {
		// 			cacheArr.splice(i, 1);
		// 			cacheArr.push(token);
		// 		}
		// 		return token.tokens;
		// 	}
		// }
	}

	const tokens =
		method === DIFF_BY_CHAR
			? tokenizeByChar(input, inputPos, inputEnd, baseLineNum)
			: method === DIFF_BY_LINE
			? tokenizeByLine(input, inputPos, inputEnd, baseLineNum)
			: tokenizeByWord(input, inputPos, inputEnd, baseLineNum);

	tokens.push({
		text: "",
		pos: input.length,
		len: 0,
		lineNum: tokens.length > 0 ? tokens[tokens.length - 1].lineNum : 1,
		flags: FIRST_OF_LINE | LAST_OF_LINE,
	});

	if (cacheArr) {
		if (cacheArr.length >= TOKEN_CACHE_SIZE) {
			cacheArr.shift();
		}
		cacheArr.push({ text: input, tokens });
	}
	return tokens;
}

// function computeLCS(leftTokens, rightTokens) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;
// 	const dp = new Array(m + 1);
// 	const blockLength = new Array(m + 1);
// 	const lcsIndices = [];

// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 		blockLength[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		for (let j = 1; j <= n; j++) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				let weight = 1;
// 				// 연속된 매치 토큰에 가중치 부여
// 				if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 					weight += dp[i - 1][j - 1];
// 				}
// 				// dp 테이블 갱신
// 				dp[i][j] = dp[i - 1][j - 1] + weight;
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 			}
// 		}
// 	}

// 	// for (let i = 1; i <= m; i++) {
// 	// 	for (let j = 1; j <= n; j++) {
// 	// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 	// 			let weight = 1;
// 	// 			if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 	// 				weight += blockLength[i - 1][j - 1];
// 	// 			}
// 	// 			dp[i][j] = dp[i - 1][j - 1] + weight;
// 	// 			blockLength[i][j] = blockLength[i - 1][j - 1] + 1;
// 	// 		} else {
// 	// 			dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 	// 			blockLength[i][j] = 0;
// 	// 		}
// 	// 	}
// 	// }

// 	let i = m;
// 	let j = n;
// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			}
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}
// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

// function backtrackLCS(dp, leftTokens, rightTokens) {
// 	let i = leftTokens.length;
// 	let j = rightTokens.length;
// 	const lcsIndices = [];

// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			if (dp[i][j] === dp[i - 1][j - 1] + 1) {
// 				lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 				i--;
// 				j--;
// 			} else {
// 				if (dp[i - 1][j] > dp[i][j - 1]) {
// 					i--;
// 				} else if (dp[i - 1][j] < dp[i][j - 1]) {
// 					j--;
// 				} else {
// 					i--;
// 				}
// 			}
// 		} else {
// 			if (dp[i - 1][j] > dp[i][j - 1]) {
// 				i--;
// 			} else {
// 				j--;
// 			}
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

//
// WEIGHTED LCS! meticulous하게 테스트 해볼 필요 있음.
//
// function computeLCS(leftTokens, rightTokens) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;
// 	const dp = new Array(m + 1);
// 	const lcsIndices = [];

// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		for (let j = 1; j <= n; j++) {
// 			if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 				let weight = 1;
// 				if (i > 1 && j > 1 && leftTokens[i - 2].text === rightTokens[j - 2].text) {
// 					weight += dp[i - 1][j - 1];
// 				}
// 				dp[i][j] = dp[i - 1][j - 1] + weight;
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 			}
// 		}
// 	}

// 	let i = m;
// 	let j = n;
// 	while (i > 0 && j > 0) {
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

async function computeLCS(leftTokens, rightTokens, ctx) {
	const m = leftTokens.length;
	const n = rightTokens.length;

	const dp = new Array(m + 1);
	//const consecutive = new Array(m + 1);
	for (let i = 0; i <= m; i++) {
		dp[i] = new Array(n + 1).fill(0);
		//consecutive[i] = new Array(n + 1).fill(0);
	}
	for (let i = 1; i <= m; i++) {
		const leftText = leftTokens[i - 1].text;
		for (let j = 1; j <= n; j++) {
			if (ctx && ((i + j) & 16383) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}

			const rightText = rightTokens[j - 1].text;
			if (leftText === rightText) {
				//consecutive[i][j] = consecutive[i - 1][j - 1] + 1;
				dp[i][j] = dp[i - 1][j - 1] + 1; // + consecutive[i][j];
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				//consecutive[i][j] = 0;
			}
		}
	}

	let i = m;
	let j = n;
	const lcsIndices = [];
	while (i > 0 && j > 0) {
		// if (ctx && ((i + j) & 511) === 0) {
		// 	const now = performance.now();
		// 	if (now - ctx.lastYield > 100) {
		// 		ctx.lastYield = now;
		// 		await new Promise((resolve) => setTimeout(resolve, 0));
		// 		if (ctx.cancel) {
		// 			throw new Error("cancelled");
		// 		}
		// 	}
		// }
		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
			lcsIndices.push({
				leftIndex: i - 1,
				rightIndex: j - 1,
				//text: leftTokens[i - 1].text, // 필요하면 leftTokens[leftIndex]로 얻을 수 있음!
			});
			i--;
			j--;
		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
			i--;
		} else {
			j--;
		}
	}
	lcsIndices.reverse();
	return lcsIndices;
}

// async function computeLCS(leftTokens, rightTokens, ctx) {
// 	const m = leftTokens.length;
// 	const n = rightTokens.length;

// 	const dp = new Array(m + 1);
// 	const consecutive = new Array(m + 1);
// 	for (let i = 0; i <= m; i++) {
// 		dp[i] = new Array(n + 1).fill(0);
// 		consecutive[i] = new Array(n + 1).fill(0);
// 	}

// 	for (let i = 1; i <= m; i++) {
// 		const leftText = leftTokens[i - 1].text;
// 		for (let j = 1; j <= n; j++) {
// 			if (j % 1023 === 0) {
// 				if (ctx && performance.now() - ctx.lastYield > 100) {
// 					ctx.lastYield = performance.now();
// 					await new Promise((resolve) => setTimeout(resolve, 0));
// 					if (ctx.cancel) {
// 						return null;
// 					}
// 				}
// 			}

// 			const rightText = rightTokens[j - 1].text;

// 			if (leftText === rightText) {
// 				consecutive[i][j] = consecutive[i - 1][j - 1] + 1; // 연속 매치 횟수 증가
// 				dp[i][j] = dp[i - 1][j - 1] + 1 + consecutive[i][j]; // 연속 매치에 가중치 부여
// 			} else {
// 				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// 				consecutive[i][j] = 0;
// 			}
// 		}
// 	}

// 	let i = m;
// 	let j = n;
// 	const lcsIndices = [];
// 	while (i > 0 && j > 0) {
// 		if ((i + j) % 1023 === 0 && ctx && performance.now() - ctx.lastYield > 100) {
// 			ctx.lastYield = performance.now();
// 			await new Promise((resolve) => setTimeout(resolve, 0));
// 			if (ctx.cancel) {
// 				return null;
// 			}
// 		}
// 		if (leftTokens[i - 1].text === rightTokens[j - 1].text) {
// 			lcsIndices.push({ leftIndex: i - 1, rightIndex: j - 1, text: leftTokens[i - 1].text });
// 			i--;
// 			j--;
// 		} else if (dp[i - 1][j] >= dp[i][j - 1]) {
// 			i--;
// 		} else {
// 			j--;
// 		}
// 	}

// 	lcsIndices.reverse();
// 	return lcsIndices;
// }

function findLineStartPos(text, pos) {
	while (pos > 0 && text[pos - 1] !== "\n") {
		pos--;
	}
	return pos;
}

// function findLineEndPos(text, pos, maxPos, numLines = 1){
// 	while (pos < maxPos && numLines > 0) {
// 		if (text[pos] === "\n") {
// 			numLines--;
// 			if (numLines === 0) {
// 				break;
// 			}
// 		}
// 		pos++;
// 	}
// 	return pos;
// }

async function computeDiff({ leftText, rightText, leftTokens = undefined, rightTokens = undefined, method = DIFF_BY_WORD, ctx, skipFallback = false }) {
	const diffs = [],
		anchors = [];

	let now = performance.now();
	if (!leftTokens) {
		leftTokens = tokenize(leftText, method);
	}
	if (!rightTokens) {
		rightTokens = tokenize(rightText, method);
	}
	let elapsed = performance.now() - now;
	console.debug("Tokenize elapsed time:", elapsed);

	now = performance.now();
	const lcs = await computeLCS(leftTokens, rightTokens, ctx);
	elapsed = performance.now() - now;
	console.debug("LCS elapsed time:", elapsed);

	if (ctx && ctx.cancel) {
		throw new Error("cancelled");
	}
	const lcsLength = lcs.length;
	const leftTokensLength = leftTokens.length - 1;
	const rightTokensLength = rightTokens.length - 1;

	// LCS에 비해 나머지 부분은 성능에 큰 영향을 미치지 않음.

	if (leftTokensLength === 0 && rightTokensLength === 0) {
		//
	} else if (leftTokensLength === 0) {
		diffs.push({
			type: "diff",
			align: true,
			left: {
				pos: 0,
				len: 0,
				line: 1,
				lineEnd: 1,
				entireLines: true,
				empty: true,
			},
			right: {
				pos: rightTokens[0].pos,
				len: rightTokens[rightTokensLength - 1].pos + rightTokens[rightTokensLength - 1].len - rightTokens[0].pos,
				line: rightTokens[0].lineNum,
				lineEnd: rightTokens[rightTokensLength - 1].lineNum,
				entireLines: true,
			},
		});
	} else if (rightTokensLength === 0) {
		diffs.push({
			type: "diff",
			align: true,
			left: {
				pos: leftTokens[0].pos,
				len: leftTokens[leftTokensLength - 1].pos + leftTokens[leftTokensLength - 1].len - leftTokens[0].pos,
				line: leftTokens[0].lineNum,
				lineEnd: leftTokens[leftTokensLength - 1].lineNum,
				entireLines: true,
			},
			right: {
				pos: 0,
				len: 0,
				line: 1,
				lineEnd: 1,
				entireLines: true,
				empty: true,
			},
		});
	} else {
		let i = 0;
		let j = 0;
		let lcsIndex = 0;
		let lastYield = 0;
		let iteration = 0;

		while (lcsIndex < lcsLength || i < leftTokensLength || j < rightTokensLength) {
			if (ctx && (iteration & 1023) === 0) {
				const now = performance.now();
				if (now - ctx.lastYield > 100) {
					ctx.lastYield = now;
					await new Promise((resolve) => setTimeout(resolve, 0));
					if (ctx.cancel) {
						throw new Error("cancelled");
					}
				}
			}
			if (lcsIndex < lcsLength && i === lcs[lcsIndex].leftIndex && j === lcs[lcsIndex].rightIndex) {
				const leftToken = leftTokens[i];
				const rightToken = rightTokens[j];
				if ((leftToken.flags & rightToken.flags & FIRST_OF_LINE) === FIRST_OF_LINE) {
					anchors.push({
						type: "before",
						diffIndex: null,
						left: leftToken.pos,
						right: rightToken.pos,
					});
				}
				i++;
				j++;
				lcsIndex++;
				continue; // 다음 순회로 건너뜀
			}

			let leftIndex = i;
			let leftCount = 0;
			let rightIndex = j;
			let rightCount = 0;

			while (i < leftTokensLength && (lcsIndex >= lcsLength || i < lcs[lcsIndex].leftIndex)) {
				leftCount++;
				i++;
			}

			while (j < rightTokensLength && (lcsIndex >= lcsLength || j < lcs[lcsIndex].rightIndex)) {
				rightCount++;
				j++;
			}

			let align = false;
			let leftPos, leftLen, leftLine, leftLineEnd, rightPos, rightLen, rightLine, rightLineEnd;
			let leftEmpty = leftCount === 0;
			let rightEmpty = rightCount === 0;
			let leftEntireLines = false;
			let rightEntireLines = false;
			let leftIsFirstWord, leftIsLastWord, rightIsBeforeFirstWord, rightIsAfterLastWord;

			if (leftCount > 0 && rightCount > 0) {
				leftPos = leftTokens[leftIndex].pos;
				leftLen = leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len - leftPos;
				leftLine = leftTokens[leftIndex].lineNum;
				leftLineEnd = leftTokens[leftIndex + leftCount - 1].lineNum;
				leftEntireLines =
					leftIndex === 0 || (leftTokens[leftIndex].flags & FIRST_OF_LINE && leftTokens[leftIndex + leftCount - 1].flags & LAST_OF_LINE);
				rightPos = rightTokens[rightIndex].pos;
				rightLen = rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len - rightPos;
				rightLine = rightTokens[rightIndex].lineNum;
				rightLineEnd = rightTokens[rightIndex + rightCount - 1].lineNum;
				rightEntireLines = rightTokens[rightIndex].flags & FIRST_OF_LINE && rightTokens[rightIndex + rightCount - 1].flags & LAST_OF_LINE;
				align = !!(leftTokens[leftIndex].flags && rightTokens[rightIndex].flags && FIRST_OF_LINE);

				if (method > DIFF_BY_CHAR) {
					const leftTokens2 = tokenize(
						leftText,
						method - 1,
						leftPos,
						leftTokens[leftIndex + leftCount - 1].pos + leftTokens[leftIndex + leftCount - 1].len,
						leftLine
					);
					const rightTokens2 = tokenize(
						rightText,
						method - 1,
						rightPos,
						rightTokens[rightIndex + rightCount - 1].pos + rightTokens[rightIndex + rightCount - 1].len,
						rightLine
					);
					const result = await computeDiff({
						leftText,
						rightText,
						leftTokens: leftTokens2,
						rightTokens: rightTokens2,
						method: method - 1,
						ctx,
						skipFallback: true,
					});
					if (result.diffs.length === 0) {
						for (const anchor of result.anchors) {
							if (anchor.diffIndex !== null) {
								anchor.diffIndex += diffs.length;
							}
							anchors.push(anchor);
						}
						continue;
					}

					// for (const diff of result.diffs) {
					// 	diffs.push(diff);
					// }

					// console.log("fallback done");
					// continue;
				}
				// if (method !== DIFF_BY_CHAR) {
				// 	if (leftLen <= 40 && rightLen <= 40) {
				// 		let leftFragment = leftText.substring(leftPos, leftPos + leftLen).replace(/\s/g, "");
				// 		let rightFragment = rightText.substring(rightPos, rightPos + rightLen).replace(/\s/g, "");
				// 		if (leftFragment === rightFragment) {
				// 			leftIndex = rightIndex = 0;
				// 			leftCount = rightCount = 0;
				// 			continue;
				// 		}
				// 	}
				// }
			} else if (leftCount > 0 || rightCount > 0) {
				//
				// 추가 또는 삭제 한쪽만 있는 경우
				//

				let longSideText, shortSideText;
				let longSideIndex, longSideCount, longSideTokens;
				let shortSideIndex, shortSideCount, shortSideTokens;
				let longSidePos, longSideLen;
				let shortSidePos, shortSideLen;
				let longSideLine, longSideLineEnd, shortSideLine, shortSideLineEnd;
				let longSideEntireLines = false,
					shortSideEntireLines = false;
				let longSideIsFirstWord, longSideIsLastWord, shortSideIsBeforeFirstWord, shortSideIsAfterLastWord;

				if (leftCount > 0) {
					longSideText = leftText;
					longSideTokens = leftTokens;
					longSideIndex = leftIndex;
					longSideCount = leftCount;
					shortSideText = rightText;
					shortSideTokens = rightTokens;
					shortSideIndex = rightIndex;
					shortSideCount = rightCount;
				} else {
					longSideText = rightText;
					longSideTokens = rightTokens;
					longSideIndex = rightIndex;
					longSideCount = rightCount;
					shortSideText = leftText;
					shortSideTokens = leftTokens;
					shortSideIndex = leftIndex;
					shortSideCount = leftCount;
				}

				longSidePos = longSideTokens[longSideIndex].pos; //longSideIndex > 0 ? longSideTokens[longSideIndex - 1].pos + longSideTokens[longSideIndex - 1].len : 0;
				longSideLen = longSideTokens[longSideIndex + longSideCount - 1].pos + longSideTokens[longSideIndex + longSideCount - 1].len - longSidePos;
				longSideLine = longSideTokens[longSideIndex].lineNum;
				longSideLineEnd = longSideTokens[longSideIndex + longSideCount - 1].lineNum;
				longSideIsFirstWord = longSideTokens[longSideIndex].flags & FIRST_OF_LINE;
				longSideIsLastWord = longSideTokens[longSideIndex + longSideCount - 1].flags & LAST_OF_LINE;
				longSideEntireLines = longSideIsFirstWord && longSideIsLastWord;

				shortSideIsBeforeFirstWord =
					shortSideIndex === 0 || (shortSideIndex < shortSideTokens.length && shortSideTokens[shortSideIndex].flags & FIRST_OF_LINE);
				shortSideIsAfterLastWord =
					shortSideIndex === shortSideTokens.length || (shortSideIndex > 0 && shortSideTokens[shortSideIndex - 1].flags & LAST_OF_LINE);
				shortSidePos = shortSideTokens[shortSideIndex].pos; //shortSideIndex > 0 ? shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len : 0;
				shortSideIsBeforeFirstWord = checkIfFirstOfLine(shortSideText, shortSidePos)
				shortSideIsAfterLastWord = shortSideIndex === 0 || shortSideTokens[shortSideIndex - 1].flags & LAST_OF_LINE;

				shortSideLen = 0;
				align = longSideEntireLines && (shortSideIsBeforeFirstWord || shortSideIsAfterLastWord);

				if (shortSideIsBeforeFirstWord || shortSideIsAfterLastWord) {
					if (longSideIsFirstWord) {
						// short side 위치를 가능하면 줄의 시작 위치로.
						if (shortSideIndex === 0) {
							shortSidePos = 0;
							shortSideLine = 1;
						} else {
							// 다음줄의 시작pos
							shortSidePos = shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len;
							shortSideLine = shortSideTokens[shortSideIndex - 1].lineNum;
							const end = shortSideIndex < shortSideTokens.length ? shortSideTokens[shortSideIndex].pos : shortSideText.length;
							let p = shortSidePos;
							while (p < end) {
								if (shortSideText[p] === "\n") {
									shortSidePos = p + 1;
									shortSideLine++;
									break;
								}
								p++;
							}
						}
					} else if (longSideIsLastWord) {
						if (shortSideIndex > 0) {
							shortSidePos = shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len;
							shortSideLine = shortSideTokens[shortSideIndex - 1].lineNum;
						} else {
							shortSidePos = 0;
							shortSideLine = 1;
						}
					}
				} else {
					// middle of line

					if (shortSideIndex < shortSideTokens.length) {
						shortSidePos = shortSideTokens[shortSideIndex].pos;
						shortSideLine = shortSideTokens[shortSideIndex].lineNum;
					} else {
						// 이전 토큰의 마지막에
						shortSidePos = shortSideTokens[shortSideIndex - 1].pos + shortSideTokens[shortSideIndex - 1].len;
						shortSideLine = shortSideTokens[shortSideIndex - 1].lineNum;
					}
				}

				shortSideLineEnd = shortSideLine;
				shortSideEntireLines = longSideEntireLines && shortSideIsBeforeFirstWord && shortSideIsAfterLastWord;
				if (leftCount > 0) {
					leftPos = longSidePos;
					leftLen = longSideLen;
					leftLine = longSideLine;
					leftLineEnd = longSideLineEnd;
					leftEntireLines = longSideEntireLines;
					leftIsFirstWord = longSideIsFirstWord;
					leftIsLastWord = longSideIsLastWord;
					rightPos = shortSidePos;
					rightLen = shortSideLen;
					rightLine = shortSideLine;
					rightLineEnd = shortSideLineEnd;
					rightEntireLines = shortSideEntireLines;
					rightIsBeforeFirstWord = shortSideIsBeforeFirstWord;
					rightIsAfterLastWord = shortSideIsAfterLastWord;
				} else {
					leftPos = shortSidePos;
					leftLen = shortSideLen;
					leftLine = shortSideLine;
					leftLineEnd = shortSideLineEnd;
					leftEntireLines = shortSideEntireLines;
					leftIsFirstWord = shortSideIsBeforeFirstWord;
					leftIsLastWord = shortSideIsAfterLastWord;
					rightPos = longSidePos;
					rightLen = longSideLen;
					rightLine = longSideLine;
					rightLineEnd = longSideLineEnd;
					rightEntireLines = longSideEntireLines;
					rightIsBeforeFirstWord = longSideIsFirstWord;
					rightIsAfterLastWord = longSideIsLastWord;
				}
			} else {
				throw new Error("WTF?");
			}

			if (leftIsFirstWord && rightIsBeforeFirstWord) {
				anchors.push({
					type: "before",
					diffIndex: diffs.length,
					left: leftPos,
					right: rightPos,
				});
			}

			diffs.push({
				align,
				left: {
					pos: leftPos,
					len: leftLen,
					empty: leftEmpty,
				},
				right: {
					pos: rightPos,
					len: rightLen,
					empty: rightEmpty,
				},
			});

			if (leftIsLastWord && rightIsAfterLastWord) {
				anchors.push({
					type: "after",
					diffIndex: diffs.length - 1,
					left: leftPos + leftLen,
					right: rightPos + rightLen,
				});
			}
		}
	}

	return { diffs, anchors };
}
</script>
    <style id="highlightStyle">
    </style>
</head>

<body>
    <div class="container">
        <main id="main">
            <!-- <div id="left"></div>
            <div id="right"></div> -->

        </main>
        <div id="sidebar">
            <ol id="diffList"></ol>
        </div>
    </div>
    <div id="progress"></div>

    <!-- <div class="drawer" id="drawer">
        <div class="drawer-header">
            <h2></h2>

            <button class="close-btn" onclick="closeDrawer()">Close</button>
        </div>
        <div class="drawer-content">
            <h4>Diff Mode</h4>
            <radio-group>
                <ul class="drawer-menu">
                    <li><label><input type="radio" name="tokenizeMethod" value="char" checked /> Char</label></li>
                    <li><label><input type="radio" name="tokenizeMethod" value="word" /> Word</label></li>
                    <li><label><input type="radio" name="tokenizeMethod" value="word" /> Line</label></li>
                </ul>
            </radio-group>
        </div>
    </div> -->

    <script>
        const style = document.createElement("style");
        let cssText = ":root {\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += ` --diff-hue${idx + 1}: ${color};\n`;
        });
        cssText += "}\n";
        DIFF_COLOR_HUES.forEach((color, idx) => {
            cssText += `.diff-color${idx + 1} { --diff-hue: var(--diff-hue${idx + 1}); }\n`;
        });
        style.textContent = cssText;
        document.head.appendChild(style);
    </script>
<script id='main.js'>const COMPUTE_DEBOUNCE_TIME = 200;

const DiffSeek = (function () {
	let _diffs = [];
	let _anchors = [];
	let _alignedMode = false;
	let _alignedDirty = false;
	let _updateTimeoutId = null;
	let _activeEditor = null;
	let _lastFocusedEditor = null;
	let _lastScrolledEditor = null;
	let _syncingScroll = false;
	let _syncingScrollTimeoutId = null;
	let _mousedOverEditor = null;
	let _currentDiffIndex = -1;

	const container = document.getElementById("main");
	const leftEditor = createEditor(container, "left", getEditorCallbacks("left"));
	const rightEditor = createEditor(container, "right", getEditorCallbacks("right"));
	const diffList = document.getElementById("diffList");

	function getEditorCallbacks(key) {
		return {
			onEnter: () => {
				_mousedOverEditor = key === "left" ? leftEditor : rightEditor;
			},
			onLeave: () => {
				_mousedOverEditor = null;
			},
			onFocus: () => {
				if (key === "left") {
					_activeEditor = _lastFocusedEditor = leftEditor;
				} else {
					_activeEditor = _lastFocusedEditor = rightEditor;
				}
			},
			onBlur: () => {
				_activeEditor = null;
			},
			onScroll: function () {
				_lastScrolledEditor = key === "left" ? leftEditor : rightEditor;
			},
			onTextChanged: function () {
				if (_updateTimeoutId) {
					clearTimeout(_updateTimeoutId);
				}
				_diffs = null;
				_anchors = null;
				_currentDiffIndex = -1;
				_alignedDirty = true;
				_updateTimeoutId = setTimeout(() => {
					_updateTimeoutId = null;
					computeDiff();
				}, COMPUTE_DEBOUNCE_TIME);
			},
			onMirrorUpdated: function () {
				_alignedDirty = true;
				if (_alignedMode) {
					recalculateAlignmentPaddingAndPositions();
				}
			},
			onFirstVisibleAnchorChanged: function (anchor) {
				if (_syncingScroll) {
					// console.log("syncing scroll, ignoring first visible anchor change", anchor);
					return;
				}
				if (_alignedMode || !anchor || _syncingScroll) {
					return;
				}
				_syncingScroll = true;
				// console.log("first visible anchor changed", anchor, anchor.scrollTop, anchor.offsetTop);
				const anchorIndex = Number(anchor.dataset.anchor);
				const thisMirror = key === "left" ? leftEditor.wrapper : rightEditor.wrapper;

				const theOtherAnchorId = key === "left" ? `rightAnchor${anchorIndex}` : `leftAnchor${anchorIndex}`;
				const theOtherAnchor = document.getElementById(theOtherAnchorId);
				if (theOtherAnchor) {
					const theOtherMirror = key === "left" ? rightEditor.wrapper : leftEditor.wrapper;
					const theOtherOffsetTop = theOtherAnchor.offsetTop;
					theOtherMirror.scrollTop = thisMirror.scrollTop - anchor.offsetTop + theOtherOffsetTop;
				}
				if (_syncingScrollTimeoutId) {
					clearTimeout(_syncingScrollTimeoutId);
				}
				_syncingScrollTimeoutId = setTimeout(() => {
					_syncingScroll = false;
				}, 50);
				// requestAnimationFrame(() => {
				// 	_syncingScroll = false;
				// });
			},
		};
	}

	// #region WORKER STUFF
	let workerURL;
	const workerCode = document.getElementById("worker.js").textContent;
	if (workerCode.trim().length === 0) {
		workerURL = "worker.js";
	} else {
		const blob = new Blob([workerCode], { type: "application/javascript" });
		workerURL = URL.createObjectURL(blob);
	}
	const worker = new Worker(workerURL);
	const encoder = new TextEncoder();
	let reqId = 0;
	function computeDiff() {
		progress.textContent = PROCESSING_MESSAGES[Math.floor(Math.random() * PROCESSING_MESSAGES.length)];
		document.querySelector("body").classList.add("computing");
		if (reqId === Number.MAX_SAFE_INTEGER) {
			reqId = 1;
		} else {
			reqId++;
		}
		worker.postMessage({
			type: "diff",
			reqId: reqId,
			left: encoder.encode(leftEditor.text),
			right: encoder.encode(rightEditor.text),
			method: 2,
		});
	}

	worker.onmessage = function (e) {
		const data = e.data;
		if (data.type === "diffs") {
			if (data.reqId === reqId) {
				//console.log("diffs computed", data);
				document.querySelector("body").classList.remove("computing");
				onDiffComputed(data);
			}
		}
	};

	function onDiffComputed({ diffs, anchors }) {
		console.debug("diffs computed", diffs, anchors);
		_diffs = diffs;
		_anchors = anchors;
		_alignedDirty = true;
		leftEditor.update({ diffs, anchors });
		rightEditor.update({ diffs, anchors });
		updateDiffList();
	}
	// #endregion

	function enableAlignedMode() {
		if (!_alignedMode) {
			const currentEditor = _mousedOverEditor || _activeEditor || _lastScrolledEditor;
			let firstVisibleLine, firstVisibleLineTop;
			let caretPos;

			if (_activeEditor) {
				_activeEditor.saveCaret();
			}

			if (currentEditor) {
				[firstVisibleLine, firstVisibleLineTop] = currentEditor.getFirstVisibleLineElementInEditor();
			}

			_alignedMode = true;
			const body = document.querySelector("body");
			body.classList.remove("edit");
			body.classList.add("aligned");
			recalculateAlignmentPaddingAndPositions();

			if (caretPos) {
				currentEditor.scrollToTextPosition(caretPos);
			}

			if (firstVisibleLine) {
				const top = firstVisibleLine.offsetTop;
				requestAnimationFrame(() => {
					container.scrollTop = top;
				});
			}
		}
	}

	function resolveSelectionRange(range) {
		let startLine = range.startContainer;
		while (startLine && startLine.tagName !== "DIV") {
			startLine = startLine.parentElement;
		}
		let endLine = range.endContainer;
		while (endLine && endLine.tagName !== "DIV") {
			endLine = endLine.parentElement;
		}
		let startOffset = range.startOffset;
		let prevSibling = range.startContainer.previousSibling;
		while (prevSibling) {
			startOffset += prevSibling.textContent.length;
			prevSibling = prevSibling.previousSibling;
		}

		let endOffset = range.endOffset;
		prevSibling = range.endContainer.previousSibling;
		while (prevSibling) {
			endOffset += prevSibling.textContent.length;
			prevSibling = prevSibling.previousSibling;
		}
	}

	rightEditor.editor.addEventListener("contextmenu", (e) => {
		e.preventDefault();
		if (_alignedMode) {
			disableAlignedMode(true);
		} else {
			enableAlignedMode();
		}
	});

	rightEditor.mirror.addEventListener("contextmenu", (e) => {
		e.preventDefault();

		disableAlignedMode(true);
	});
	2;
	rightEditor.mirror.addEventListener("click", (e) => {
		if (e.ctrlKey) {
			disableAlignedMode(true);
		}
	});

	rightEditor.mirror.addEventListener("dblclick", (e) => {
		if (e.ctrlKey) {
			disableAlignedMode(true);
		}
	});

	function selectText(range, editor, startLineNumber, startOffset, endLineNumber, endOffset) {
		const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
		let currentNode;
		let lineNum = 1;
		let startSet = false;

		while ((currentNode = walker.nextNode())) {
			const text = currentNode.textContent;
			let linePos = 0;
			if (!startSet) {
				if (lineNum < startLineNumber) {
					for (let i = linePos; i < text.length; i++) {
						if (text[i] === "\n") {
							lineNum++;
							if (lineNum === startLineNumber) {
								linePos = i + 1;
								break;
							}
						}
					}
				}
				if (lineNum !== startLineNumber) {
					continue;
				}
				range.setStart(currentNode, Math.min(linePos + startOffset, text.length));
				startSet = true;
			}

			if (lineNum !== endLineNumber) {
				for (let i = linePos; i < text.length; i++) {
					if (text[i] === "\n") {
						lineNum++;
						if (lineNum === endLineNumber) {
							linePos = i + 1;
							break;
						}
					}
				}
				if (lineNum !== endLineNumber) {
					continue;
				}
			}
			if (lineNum === endLineNumber) {
				range.setEnd(currentNode, Math.min(linePos + endOffset, text.length));
				return true;
			}
		}
		return false;
	}

	function getSelectionRange() {
		const selection = window.getSelection();
		const range = selection.rangeCount ? selection.getRangeAt(0) : null;
		if (range) {
			if (leftEditor.mirror.contains(range.commonAncestorContainer)) {
				editor = leftEditor.editor;
			} else if (rightEditor.mirror.contains(range.commonAncestorContainer)) {
				editor = rightEditor.editor;
			} else {
				return;
			}
			let startLineEl = range.startContainer;
			while (startLineEl && startLineEl.tagName !== "DIV") {
				startLineEl = startLineEl.parentElement;
			}
			let endLineEl = range.endContainer;
			while (endLineEl && endLineEl.tagName !== "DIV") {
				endLineEl = endLineEl.parentElement;
			}

			const startLineNumber = Number(startLineEl.dataset.lineNum);
			const endLineNumber = Number(endLineEl.dataset.lineNum);

			let currentNode;
			let startOffset = 0;
			walker = document.createTreeWalker(startLineEl, NodeFilter.SHOW_TEXT, null, false);
			while ((currentNode = walker.nextNode())) {
				if (currentNode === range.startContainer) {
					startOffset += range.startOffset;
					break;
				} else {
					startOffset += currentNode.textContent.length;
				}
			}

			let endOffset = 0;
			walker = document.createTreeWalker(endLineEl, NodeFilter.SHOW_TEXT, null, false);
			while ((currentNode = walker.nextNode())) {
				if (currentNode === range.endContainer) {
					endOffset += range.endOffset;
					break;
				} else {
					endOffset += currentNode.textContent.length;
				}
			}

			return {
				editor,
				startLineNumber,
				startOffset,
				endLineNumber,
				endOffset,
			};
		}
		return null;
	}

	function disableAlignedMode(retainSelection = true) {
		const selectionRange = getSelectionRange();
		const [leftFirstLine, leftFirstLineDistance] = leftEditor.getFirstVisibleLineElementInEditor();
		const [rightFirstLine, rightFirstLineDistance] = rightEditor.getFirstVisibleLineElementInEditor();

		if (_lastFocusedEditor) {
			_lastFocusedEditor.saveCaret();
		}

		_alignedMode = false;
		const body = document.querySelector("body");
		body.classList.remove("aligned");
		body.classList.add("edit");

		requestAnimationFrame(() => {
			if (leftFirstLine) {
				leftEditor.scrollToLine(Number(leftFirstLine.dataset.lineNum), leftFirstLineDistance);
			}
			if (rightFirstLine) {
				rightEditor.scrollToLine(Number(rightFirstLine.dataset.lineNum), rightFirstLineDistance);
			}
		});

		if (_lastFocusedEditor) {
			_lastFocusedEditor.editor.focus();
			_lastFocusedEditor.restoreCaret();
		}

		// if (_lastFocusedEditor) {
		// 	console.log("restoring caret", _lastFocusedEditor.name);
		// 	_lastFocusedEditor.restoreCaret();
		// 	_lastFocusedEditor.editor.focus();
		// }

		if (selectionRange && retainSelection) {
			const range = document.createRange();
			if (
				selectText(
					range,
					selectionRange.editor,
					selectionRange.startLineNumber,
					selectionRange.startOffset,
					selectionRange.endLineNumber,
					selectionRange.endOffset
				)
			) {
				const selection = window.getSelection();
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}
	}

	function alignAnchor(anchorIndex, leftAnchor, rightAnchor, type) {
		if (type === "before") {
			const leftTop = leftAnchor.offsetTop;
			const rightTop = rightAnchor.offsetTop;
			let topDiff = leftTop - rightTop;
			let shortSide, longSide;
			if (topDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				topDiff = -topDiff;
			} else if (topDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${topDiff}px`;
				shortSide.className = "expanded";
			}
		} else {
			const leftBottom = leftAnchor.offsetTop + leftAnchor.offsetHeight;
			const rightBottom = rightAnchor.offsetTop + rightAnchor.offsetHeight;
			let bottomDiff = leftBottom - rightBottom;
			let shortSide, longSide;
			if (bottomDiff < 0) {
				shortSide = leftAnchor;
				longSide = rightAnchor;
				bottomDiff = -bottomDiff;
			} else if (bottomDiff > 0) {
				shortSide = rightAnchor;
				longSide = leftAnchor;
			}

			if (shortSide) {
				shortSide.style.height = `${bottomDiff}px`;
				shortSide.className = "expanded";
			}
		}
	}

	function recalculateAlignmentPaddingAndPositions() {
		const anchors = _anchors;
		if (!anchors) {
			return;
		}

		for (let i = 0; i < leftEditor.anchorElements.length; i++) {
			const anchor = leftEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}
		for (let i = 0; i < rightEditor.anchorElements.length; i++) {
			const anchor = rightEditor.anchorElements[i];
			anchor.style.height = 0;
			anchor.className = "";
		}

		for (let anchorIndex = 0; anchorIndex < anchors.length; anchorIndex++) {
			const anchor = anchors[anchorIndex];
			const leftAnchor = document.getElementById(`leftAnchor${anchorIndex}-${anchor.type}`);
			const rightAnchor = document.getElementById(`rightAnchor${anchorIndex}-${anchor.type}`);
			if (!leftAnchor || !rightAnchor) {
				console.warn("anchor not found", anchorIndex, leftAnchor, rightAnchor);
			}

			if (leftAnchor && rightAnchor) {
				alignAnchor(anchorIndex, leftAnchor, rightAnchor, anchor.type);
			}
		}
	}

	function updateDiffList() {
		if (!_diffs) {
			return;
		}

		const leftWholeText = leftEditor.text;
		const rightWholeText = rightEditor.text;
		const fragment = document.createDocumentFragment();

		for (let i = 0; i < _diffs.length; i++) {
			const diff = _diffs[i];
			const li = document.createElement("LI");
			const button = document.createElement("MARK");
			button.dataset.diff = i;
			button.className = "diff-color" + ((i % NUM_DIFF_COLORS) + 1);
			li.appendChild(button);

			const leftText = leftWholeText.substring(diff.left.pos, diff.left.pos + diff.left.len);
			const leftSpan = document.createElement("SPAN");
			leftSpan.textContent = leftText;
			leftSpan.classList.add("left");
			button.appendChild(leftSpan);

			const rightText = rightWholeText.substring(diff.right.pos, diff.right.pos + diff.right.len);
			const rightSpan = document.createElement("SPAN");
			rightSpan.textContent = rightText;
			rightSpan.classList.add("right");
			button.appendChild(rightSpan);

			fragment.appendChild(li);
		}

		diffList.innerHTML = "";
		diffList.appendChild(fragment);
	}

	window.addEventListener("keydown", (e) => {
		if (e.key === "F2") {
			e.preventDefault();
			// toggle!
			if (_alignedMode) {
				disableAlignedMode();
			} else {
				enableAlignedMode();
			}
			return;
		}

		if (e.ctrlKey && (e.key === "q" || e.key === "Q")) {
			e.preventDefault();
			let source = _mousedOverEditor || _activeEditor;

			// if (!source) {
			// 	let elementAtCursor = document.elementFromPoint(cursorX, cursorY);
			// 	if (elementAtCursor) {
			// 		if (leftEditor.wrapper.contains(elementAtCursor)) {
			// 			source = leftEditor;
			// 		} else if (rightEditor.wrapper.contains(elementAtCursor)) {
			// 			source = rightEditor;
			// 		}
			// 	}
			// 	console.log("elementAtCursor", source);
			// }

			if (source) {
				const target = source === leftEditor ? rightEditor : leftEditor;
				syncScrollPosition(source, target, e.shiftKey);
			}
			return;
		}

		if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
			e.preventDefault();
			if (!_diffs) {
				return;
			}

			_currentDiffIndex += e.key === "ArrowUp" ? -1 : 1;
			if (_currentDiffIndex < 0) {
				_currentDiffIndex = _diffs.length - 1;
			}
			if (_currentDiffIndex >= _diffs.length) {
				_currentDiffIndex = 0;
			}
			leftEditor.scrollToDiff(_currentDiffIndex);
			rightEditor.scrollToDiff(_currentDiffIndex);
			highlightDiff(_currentDiffIndex);
			return;
		}
	});

	diffList.addEventListener("click", (e) => {
		const diffIndex = Number(e.target.dataset.diff);
		if (!isNaN(diffIndex)) {
			leftEditor.scrollToDiff(diffIndex);
			rightEditor.scrollToDiff(diffIndex);
		}
	});

	disableAlignedMode();

	function syncScrollPosition(sourceEditor, targetEditor, backward = false) {
		const sourceAnchors = sourceEditor.getVisibleAnchors();
		if (sourceAnchors.length === 0) {
			return;
		}

		let sourceAnchor = null;
		let targetAnchor = null;

		const start = backward ? sourceAnchors.length - 1 : 0;
		const end = backward ? -1 : sourceAnchors.length;
		const step = backward ? -1 : 1;

		for (let i = start; i !== end; i += step) {
			const anchor = sourceAnchors[i];
			if (anchor.dataset.diff !== undefined) {
				const theOtherAnchorId =
					sourceEditor.name === "left"
						? `rightAnchor${anchor.dataset.anchor}-${anchor.dataset.type}`
						: `leftAnchor${anchor.dataset.anchor}-${anchor.dataset.type}`;
				targetAnchor = document.getElementById(theOtherAnchorId);
				if (targetAnchor) {
					sourceAnchor = anchor;
					break;
				} else {
					console.warn("target anchor not found", theOtherAnchorId);
				}
			}
		}

		if (!sourceAnchor) {
			for (let i = start; i !== end; i += step) {
				const anchor = sourceAnchors[i];
				if (anchor.dataset.diff === undefined) {
					const theOtherAnchorId =
						sourceEditor.name === "left"
							? `rightAnchor${anchor.dataset.anchor}-${anchor.dataset.type}`
							: `leftAnchor${anchor.dataset.anchor}-${anchor.dataset.type}`;
					targetAnchor = document.getElementById(theOtherAnchorId);
					if (targetAnchor) {
						sourceAnchor = anchor;
						break;
					} else {
						console.warn("target anchor not found2", theOtherAnchorId);
					}
				}
			}
		}

		if (!sourceAnchor) {
			return;
		}

		// const theOtherAnchorId = sourceEditor.name === "left" ? `rightAnchor${anchor.dataset.anchor}` : `leftAnchor${anchor.dataset.anchor}`;
		// const theOtherAnchor = document.getElementById(theOtherAnchorId);
		// if (!theOtherAnchor) {
		// 	return;
		// }

		const prevLastScrolledEditor = _lastScrolledEditor;
		const sourceWrapper = sourceEditor.wrapper;
		const targetWrapper = targetEditor.wrapper;
		targetWrapper.scrollTop = sourceWrapper.scrollTop - sourceAnchor.offsetTop + targetAnchor.offsetTop;
		_lastScrolledEditor = prevLastScrolledEditor;
	}

	function highlightDiff(diff) {
		highlightStyle.textContent = `mark[data-diff="${diff}"], mark[data-diff="${diff}"]::after { 
box-shadow: 0px 0px 15px 3px hsl(var(--diff-hue) 100% 80% / 0.8);
animation: highlightAnimation 0.3s linear 3; 
}`;
	}

	document.addEventListener("mouseover", (e) => {
		if (e.target.dataset.diff !== undefined) {
			const diff = Number(e.target.dataset.diff);
			highlightDiff(diff);
		}
	});

	document.addEventListener("mouseout", (e) => {
		if (e.target.dataset.diff !== undefined) {
			highlightStyle.textContent = "";
		}
	});

	return {
		get alignedMode() {
			return _alignedMode;
		},

		set alignedMode(value) {
			if (!!value) {
				enableAlignedMode();
			} else {
				disableAlignedMode();
			}
		},
		get dump() {
			return {
				diffs: _diffs,
				anchors: _anchors,
				leftEditor,
				rightEditor,
			};
		},
	};
})();
</script>
</body>

</html>

