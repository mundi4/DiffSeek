# DiffSeek 
#### 개요
- 정말 센스만점 이름. 중국산 DeepSeek 아님.
- 업무매뉴얼 비교의 압박 때문에 개발...이라고 하면 너무 거창하고 그냥 한번 짜봤음.
- 기본적으로 Histogram 알고리즘 사용. 브라우저 개발툴 콘솔에서 `DiffSeek.diffOptions.algorithm = "histogram|lcs|myers"` 뭐 이렇게 다른 알고리즘도 사용 가능하지만... `myers` 알고리즘은 아직 제대로 완성 못시켰고(살짝 어려움) `lcs`는 조금 느림.
- 공백 무시. 공백을 완전히 무시하는건 완전히 의도된 것임. **업무매뉴얼의 줄바꿈 위치는 절대로 문장의 끝 혹은 단락의 끝과 일치하지 않음!**(`DiffSeek.diffOptions.whitespace = "ignore|normalize"`). 참고로 공백을 전혀 무시하지 않거나 정규화(여러개의 연속된 공백을 하나로 인식)해서 비교하는 코드를 짜는게 100만배 쉬움.
- 단어 단위 diff. 글자 단위 diff는 성능도 성능이지만 사람의 눈에 오히려 더 피곤하기만 함. 줄 단위의 경우도 문서마다 줄바꿈의 위치가 지멋대로라 비효율적임(`DiffSeek.diffOptions.tokenization = "char|word|line"`).
- [GitHub](https://github.com/mundi4/DiffSeek)

#### 구현 의도? 참고사항?
- 양쪽에 텍스트 붙여넣고 실행버튼 딱~ 누르면 diff들이 표시되.... *왜???? 버튼을 뭐하러 눌러?* **diff는 텍스트 변경시 실시간으로, 입력한 텍스트 바로 그 자리에서 보여줘야 함!!**(사실 입력과 결과view를 분리하면 결과view는 더 자유롭게 기능도 빵빵하게 그리고 더 쉽게 만들 수는 있음).
- 실시간으로 업데이트가 일어나는 도중에도 편집을 방해하면 안됨. 미세한 딜레이라든지 의도하지 않은 커서위치 변경, 한글입력상태 복원 등등(한글입력상태 복원 방법은 없다 보면 됨. 우회하는 방법은 업데이트를 안하는것, 최소한 커서가 있는 노드에 대해서는 업데이트를 안하고 미루는 방법이 거의 유일함).
- 업데이트마다 DOM을 완전히 싹 갈아엎지 말고 가능한 경우 기존 노드들을 재사용 할 것.
- 편집기(사실 그냥 텍스트 입력창ㅋ)의 기본적인 기능(복붙,undo/redo,...)들은 되도록 브라우저에게 넘길 것. 이런 기능들은 숨쉬기와 같아서 예상대로 작동 안하는 순간 짜증 솟구침. 또한 나처럼 깐깐한 사람에게 어색함이 안느껴질만큼 제대로 구현하기는 쉽지 않음(커서위치, 텍스트선택범위, 스크롤 위치, 얼마나 많은 편집을 하나의 히스토리 엔트리로 묶을 것인가, 양쪽 편집기를 왔다갔다 했을 때, ...).
- 위와 같은 이유로 편집기와 실제로 diff가 하이라이트되는 영역(mirror)을 분리시킴.
- 크기가 큰 텍스트(5만글자 이상)를 비교할 때에도 편집기가 충분히(아주 충분히) 반응적일 것. 딜레이 최소화! 단순 debouncing이 아니라 그 이상이 필요.
- 다른 문자(문자code가 다른 경우)지만 같다고 여겨질 수 있는 경우도 처리하였지만 이건 이러한 문자들을 직접 추가해줘야함(`constants.ts/NORMALIZE_CHARS`).
- (추가),(신설),(현행과 같음),(삭제) 등은 wildcard로 처리. 이 토큰들은 괄호 안 공백을 무시하고 절대로 중간에서 안잘리게('(현행과','같음)'이 되지 않게) 만들어놨지만 아직은 딱 거기까지임.
- diff 하이라이트 색들은 정말 세심하게 고른 것들임. 절대 불만을 가져서는 안됨. 빨간색 계통은 배경과 확실히 대비되지 않을 수 있기 때문에 의도적으로 제외(`constants.ts/DIFF_COLOR_HUES`).
- 큰 워드문서에서 복붙을 할 때에 복사가 바로 되지 않는 문제가 있는데 절대적으로 MS워드의 문제임. 될때까지 붙여넣기 하면 언젠가는 된다(기다리는 동안 워드는 먹통됨).
- 개정대비표vs전문, 전문vs전문 **전체를 한번**에 복/붙해서 비교할 수 있어야함(수십번씩 드래그,복/붙을 하는 것보다는 무조건 편함!!). 그래서 만든게  Aligned Mode
- 엣지(혹은 크롬) 전용. 인간적으로 2025년에 ie를 왜 써야하지?

#### Aligned Mode
- 이름은 맘에 안들지만 암튼 양쪽 텍스트에서 서로 대비되는 줄들의 위치를 같게 맞춰주는 기능. `F2`로 토글.
- 양쪽 스크롤 동기화됨.
- readonly 모드임(텍스트를 선택하고 간단한 수정을 시도하면 기본 모드로 전환되면서 수정이 되게는 해놨음).
- Aligned Mode는 까만 배경임(기본 모드와 확실히 대비되는 느낌이 있어야 했음).
- 두 모드를 전환할때 선택된 텍스트의 범위를 유지하려고 노력한 부분은 칭찬 받아야 함(수고했어~).
- 컨트롤 키를 누른채로 텍스트를 클릭하면 기본 모드로 전환되면서 클릭한 위치로 커서를 옮김(수고했어~).
- 양쪽 diff부분을 블럭단위로 표시할 수 있는 경우는 그러려고 노력(!)했음.
- 양쪽 대비(매치)되는 부분의 위치의 차이는 padding요소를 넣어서 메꿈. TODO: 여러개의 빈줄로 인해 발생하는 위치 차이는 padding이 아니라 빈줄들을 collapse하는 쪽으로 해야 더 보기 좋을 것 같음.

#### 인터넷도 안되고 아무것도 없는... 있는 거라곤 브라우저, 메모장 밖에 없는 회사 pc에서 돌려야함.
- html + css + js는 어쩔 수 없는 선택. 리액트 같은건 상상도 못함. html css js로 구현
- 섬세하고 이쁜 UI요소가 부족한 것은 절대적으로 이 때문임. 요새 누가 UI요소를 하나하나 손수 만드나...
- 타입스크립트로 작성하고 컴파일된 js를 옮기는 건 가능.
- 닷넷, java 런타임은 깔려있는 것 같지만 그 뿐임. sdk가 없음.
- 인간적으로 vscode정도는 깔아주면 안되나...

#### 집에서 만든 코드를 회사로 옮기는 방법?
- 워크비 쪽지/내부메일로 보내고 회사에서 열어서 메모장에 붙여넣기. 고로 코드가 너무 커지면 안됨. 외부 라이브러리? 어림도 없음.
- 다행히도 휴대폰 워크비 앱에서 복사/붙여넣기를 사용할 방법이 있더라(비밀 유지 필요..ㅋ 이거 막히면 더이상의 업데이트는 불가능함).
- 옮기기 전에 하나의 파일(diffseek.html)로 합친 후에 그 파일의 내용을 옮겨야함. 지금쯤 빌드된 파일이 4000줄이 넘을지도 모르니 두어번에 걸쳐 나눠서 복붙 필요.
- build, dist폴더를 모두 git에 포함한 것은 이러한 이유임(나눠서 복붙하다가 한줄 빼먹은 경우에 휴대폰으로 github의 코드와 비교해봐야함).
- 컴파일된 .js파일에 주석을 남기는 것도 회사에서 디버깅을 해야되는 경우가 있기 때문. 회사에서 수정한 걸 집으로 가져가는건 쉽지 않음. 어느 부분을 어떻게 수정했는지 기억해야함. 오늘 먹은 반찬도 기억 안남.

#### 브라우저에서 웹 주소가 아닌 파일을 여는 것이기 때문에 보안상 제약이 많음.
- 쿠키? localStorage? ... 그게 되겠니? 상태/옵션 저장하는건 불가능.
- new Worker(url) - 파일 url을 열 수 없음(그래서 worker를 쓰려면 약간의 트릭 필요)
- 그 외 '이게 될까?' 싶은 것들은 안된다고 보면 됨
- 스크립트로 복사/붙여넣기를 실행할 때의 경고는 엣지 설정-whitelist에 등록해서 피할 수 있기는 함. 지금은 관련 기능들을 다 지워버렸으니까 필요 없지만 다시 넣을까함(단축키로 왼쪽창/오른쪽창 선택없이 바로 붙여넣기 등)

#### 단축키?
- F2 - aligned mode 토글(양쪽 줄맞춤, 스크롤 동기화, 편집 불가)
- SHIFT-F2 - scroll sync 토글(약간의 줄맞춤, 약간의 스크롤 동기화, 편집 가능)
- ctrl-1/ctrl-2 편집기에 포커스
- 편집 중에 ctrl-space - 반대쪽 편집기의 스크롤 위치를 현재 편집기에 맞춤(가능한 경우)

#### histogram 알고리즘
- 가장 많이 쓰이는 알고리즘 중 하나인 것 같음.
- 이 알고리즘에서 가장 중요한건 공통 앵커를 그것도 아주 좋은놈으로 찾는 부분인 것 같은데 생각할 것이 많음. 각 섹션의 제목(1. 개요, 2. 업무처리 순서, ...)에 가중치를 주려했지만 해당 제목들은 업무매뉴얼 워드파일에서 맨 앞에 쏠려있는 경우(제목을 왼쪽 컬럼에 넣고 엔터키 수십번 눌러서 섹션을 나눈 경우)가 많아서 의미 없음. (1), (가), 1), 가)에는 적용했지만 얼마나 정확하고 효율적일지 감이 안와서 가중치를 높게 주지 않았음.
- 최우선순위 앵커 `@@@`, `###` (발견시 무조건 양쪽 텍스트에 나오는 이 앵커들을 순서대로 매치시킴). 감이 안오면 양쪽에 같은 텍스트를 복붙해놓고 왼쪽에는 맨윗줄에 `@@@`, 오른쪽은 맨아랫줄에 `@@@`를 입력해보기. 당연히 공백이나 줄바꿈으로 다른 글자와 분리가 되어야함.
- 그외  줄의 시작/끝 부분에 가중치, 희귀도에 가중치, 문자열 길이에 가중치.
- 단순히 단어vs단어 뿐만 아니라 n그램(복수개의 단어 매치), n개의 단어와 m개의 단어(단어 수가 다르지만 공백을 무시하고 비교할 경우 같은 단어들)도 매치되는 경우에도 앵커로 사용하려고 노력...은 함.
- 내 생각에 공통prefix/suffix를 스킵하는 부분 때문에 최고로 좋은 앵커를 찾을 기회를 놓치는 경우도 생길 수 있을 것 같지만 스킵 안하면 성능 개판 됨. 절대적으로 필요.
